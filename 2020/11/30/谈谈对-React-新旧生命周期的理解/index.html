<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><meta name="google-site-verification" content="Qo9CuYma6lcb220mfCfgnBGOVfDoC_mvlz110GFlrAM"><meta name="baidu-site-verification" content="code-CWnLQXg7Zn"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"jacky-summer.github.io",root:"/",scheme:"Gemini",version:"7.7.2",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0,b2t:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="前言在写这篇文章的时候，React 已经出了 17.0.1 版本了，虽说还来讨论目前 React 新旧生命周期有点晚了，React 两个新生命周期虽然出了很久，但实际开发我却没有用过，因为 React 16 版本后我们直接 React Hook 起飞开发项目。但对新旧生命周期的探索，还是有助于我们更好理解 React 团队一些思想和做法，于是今天就要回顾下这个问题和理解总结，虽然还是 React"><meta property="og:type" content="article"><meta property="og:title" content="谈谈对 React 新旧生命周期的理解"><meta property="og:url" content="https://jacky-summer.github.io/2020/11/30/%E8%B0%88%E8%B0%88%E5%AF%B9-React-%E6%96%B0%E6%97%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/index.html"><meta property="og:site_name" content="JackySummer"><meta property="og:description" content="前言在写这篇文章的时候，React 已经出了 17.0.1 版本了，虽说还来讨论目前 React 新旧生命周期有点晚了，React 两个新生命周期虽然出了很久，但实际开发我却没有用过，因为 React 16 版本后我们直接 React Hook 起飞开发项目。但对新旧生命周期的探索，还是有助于我们更好理解 React 团队一些思想和做法，于是今天就要回顾下这个问题和理解总结，虽然还是 React"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8eb7f64f3f94a9f8038949001284385~tplv-k3u1fbpfcp-watermark.image"><meta property="article:published_time" content="2020-11-30T00:22:19.000Z"><meta property="article:modified_time" content="2020-11-30T00:23:10.115Z"><meta property="article:author" content="Jacky Lin"><meta property="article:tag" content="React"><meta property="article:tag" content="生命周期"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8eb7f64f3f94a9f8038949001284385~tplv-k3u1fbpfcp-watermark.image"><link rel="canonical" href="https://jacky-summer.github.io/2020/11/30/%E8%B0%88%E8%B0%88%E5%AF%B9-React-%E6%96%B0%E6%97%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>谈谈对 React 新旧生命周期的理解 | JackySummer</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">JackySummer</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="site-search"><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://jacky-summer.github.io/2020/11/30/%E8%B0%88%E8%B0%88%E5%AF%B9-React-%E6%96%B0%E6%97%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Jacky Lin"><meta itemprop="description" content="一个热爱技术，乐于分享的前端er"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="JackySummer"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">谈谈对 React 新旧生命周期的理解</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-11-30 08:22:19" itemprop="dateCreated datePublished" datetime="2020-11-30T08:22:19+08:00">2020-11-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/React%E7%B3%BB%E5%88%97/" itemprop="url" rel="index"><span itemprop="name">React系列</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>5.9k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>5 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在写这篇文章的时候，React 已经出了 17.0.1 版本了，虽说还来讨论目前 React 新旧生命周期有点晚了，React 两个新生命周期虽然出了很久，但实际开发我却没有用过，因为 React 16 版本后我们直接 React Hook 起飞开发项目。</p><p>但对新旧生命周期的探索，还是有助于我们更好理解 React 团队一些思想和做法，于是今天就要回顾下这个问题和理解总结，虽然还是 React Hook 写法香，但是依然要深究学习类组件的东西，了解 React 团队的一些思想与做法。</p><p>本文只讨论 React17 版本前的。</p><h2 id="React-16-版本后做了什么"><a href="#React-16-版本后做了什么" class="headerlink" title="React 16 版本后做了什么"></a>React 16 版本后做了什么</h2><p>首先是给三个生命周期函数加上了 UNSAFE：</p><ul><li>UNSAFE_componentWillMount</li><li>UNSAFE_componentWillReceiveProps</li><li>UNSAFE_componentWillUpdate</li></ul><p>这里并不是表示不安全的意思，它只是不建议继续使用，并表示使用这些生命周期的代码可能在未来的 React 版本（目前 React17 还没有完全废除）存在缺陷，如 React Fiber 异步渲染的出现。</p><p>同时新增了两个生命周期函数：</p><ul><li>getDerivedStateFromProps</li><li>getSnapshotBeforeUpdate</li></ul><h2 id="UNSAFE-componentWillReceiveProps"><a href="#UNSAFE-componentWillReceiveProps" class="headerlink" title="UNSAFE_componentWillReceiveProps"></a>UNSAFE_componentWillReceiveProps</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_componentWillReceiveProps(nextProps)</span><br></pre></td></tr></table></figure><p>先来说说这个函数，<code>componentWillReceiveProps</code></p><p>该子组件方法并不是父组件 props 改变才触发，官方回答是：</p><blockquote><p>如果父组件导致组件重新渲染，即使 props 没有更改，也会调用此方法。如果只想处理更改，请确保进行当前值与变更值的比较。</p></blockquote><p>先来说说 React 为什么废除该函数，废除肯定有它不好的地方。</p><p><code>componentWillReceiveProps</code>函数的一般使用场景是：</p><ul><li>如果组件自身的某个 state 跟父组件传入的 props 密切相关的话，那么可以在该方法中判断前后两个 props 是否相同，如果不同就根据 props 来更新组件自身的 state。<br>类似的业务需求比如：一个可以横向滑动的列表，当前高亮的 Tab 显然隶属于列表自身的状态，但很多情况下，业务需求会要求从外部跳转至列表时，根据传入的某个值，直接定位到某个 Tab。</li></ul><p>但该方法缺点是会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。</p><p>而在新版本中，官方将更新 state 与触发回调重新分配到了 <code>getDerivedStateFromProps</code> 与 <code>componentDidUpdate</code> 中，使得组件整体的更新逻辑更为清晰。</p><p>新生命周期方法<code>static getDerivedStateFromProps(props, state)</code>怎么用呢？</p><blockquote><p>getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</p></blockquote><p>从函数名字就可以看出大概意思：使用 props 来派生/更新 state。这就是重点了，但凡你想使用该函数，都必须出于该目的，使用它才是正确且符合规范的。</p><p>跟<code>getDerivedStateFromProps</code>不同的是，它在挂载和更新阶段都会执行（<code>componentWillReceiveProps</code>挂载阶段不会执行），因为更新 state 这种需求不仅在 props 更新时存在，在 props 初始化时也是存在的。</p><p>而且<code>getDerivedStateFromProps</code>在组件自身 state 更新也会执行而<code>componentWillReceiveProps</code>方法执行则取决于父组件的是否触发重新渲染，也可以看出<code>getDerivedStateFromProps</code>并不是 <code>componentWillReceiveProps</code>方法的替代品.</p><p>引起我们注意的是，这个生命周期方法是一个静态方法，静态方法不依赖组件实例而存在，故在该方法内部是无法访问 this 的。新版本生命周期方法能做的事情反而更少了，限制我们只能根据 props 来派生 state，官方是基于什么考量呢？</p><p>因为无法拿到组件实例的 this，这也导致我们无法在函数内部做 this.fetch()请求，或者不合理的 this.setState()操作导致可能的死循环或其他副作用。有没有发现，这都是不合理不规范的操作，但开发者们都有机会这样用。可如果加了个静态 static，间接强制我们都无法做了，也从而避免对生命周期的滥用。</p><p>React 官方也是通过该限制，尽量保持生命周期行为的可控可预测，根源上帮助了我们避免不合理的编程方式，即一个 API 要保持单一性，做一件事的理念。</p><p>如下例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.isLogin !== <span class="keyword">this</span>.props.isLogin) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      isLogin: nextProps.isLogin,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.isLogin) &#123;</span><br><span class="line">    <span class="keyword">this</span>.handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.isLogin !== prevState.isLogin) &#123; <span class="comment">// 被对比的props会被保存一份在state里</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      isLogin: nextProps.isLogin, <span class="comment">// getDerivedStateFromProps 的返回值会自动 setState</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!prevState.isLogin &amp;&amp; <span class="keyword">this</span>.props.isLogin) &#123;</span><br><span class="line">    <span class="keyword">this</span>.handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UNSAVE-componentWillMount"><a href="#UNSAVE-componentWillMount" class="headerlink" title="UNSAVE_componentWillMount"></a>UNSAVE_componentWillMount</h2><blockquote><p>UNSAFE_componentWillMount() 在挂载之前被调用。它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染。</p></blockquote><p>我们应该避免在此方法中引入任何副作用或事件订阅，而是选用<code>componentDidMount()</code>。</p><p>在 React 初学者刚接触的时候，可能有这样一个疑问：一般都是数据请求放在<code>componentDidMount</code>里面，但放在<code>componentWillMount</code>不是会更快获取数据吗？</p><p>因为理解是<code>componentWillMount</code>在 render 之前执行，早一点执行就早拿到请求结果；但是其实不管你请求多快，都赶不上首次 render，页面首次渲染依旧处于没有获取异步数据的状态。</p><p>还有一个原因，<code>componentWillMount</code>是服务端渲染唯一会调用的生命周期函数，如果你在此方法中请求数据，那么服务端渲染的时候，在服务端和客户端都会分别请求两次相同的数据，这显然也我们想看到的结果。</p><p>特别是有了 React Fiber，更有机会被调用多次，故请求不应该放在<code>componentWillMount</code>中。</p><p>还有一个错误的使用是在<code>componentWillMount</code>中订阅事件，并在<code>componentWillUnmount</code>中取消掉相应的事件订阅。事实上只有调用<code>componentDidMount</code>后，React 才能保证稍后调用<code>componentWillUnmount</code>进行清理。而且服务端渲染时不会调用<code>componentWillUnmount</code>，可能导致内存泄露。</p><p>还有人会将事件监听器（或订阅）添加到 <code>componentWillMount</code> 中，但这可能导致服务器渲染（永远不会调用 <code>componentWillUnmount</code>）和异步渲染（在渲染完成之前可能被中断，导致不调用 <code>componentWillUnmount</code>）的内存泄漏。</p><p>对于该函数，一般情况，如果项目有使用，则是通常把现有 <code>componentWillMount</code> 中的代码迁移至 <code>componentDidMount</code> 即可。</p><h2 id="UNSAFE-componentWillUpdate"><a href="#UNSAFE-componentWillUpdate" class="headerlink" title="UNSAFE_componentWillUpdate"></a>UNSAFE_componentWillUpdate</h2><blockquote><p>当组件收到新的 props 或 state 时，会在渲染之前调用 <code>UNSAFE_componentWillUpdate()</code>。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。</p></blockquote><p>注意，不能在该方法中调用 this.setState()；在 <code>componentWillUpdate</code> 返回之前，你也不应该执行任何其他操作（例如，dispatch Redux 的 action）触发对 React 组件的更新。</p><p>首先跟上面两个函数一样，该函数也发生在 render 之前，也存在一次更新被调用多次的可能，从这一点上看就依然不可取了。</p><p>其次，该方法常见的用法是在组件更新前，读取当前某个 DOM 元素的状态，并在 <code>componentDidUpdate</code> 中进行相应的处理。但 React 16 版本后有 suspense、异步渲染机制等等，render 过程可以被分割成多次完成，还可以被暂停甚至回溯，这导致 <code>componentWillUpdate</code> 和 <code>componentDidUpdate</code> 执行前后可能会间隔很长时间，这导致 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。而且足够使用户进行交互操作更改当前组件的状态，这样可能会导致难以追踪的 BUG。</p><p>为了解决这个问题，于是就有了新的生命周期函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState)</span><br></pre></td></tr></table></figure><blockquote><p><code>getSnapshotBeforeUpdate</code> 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为第三个参数传入<code>componentDidUpdate(prevProps, prevState, snapshot)</code></p></blockquote><p>与 <code>componentWillUpdate</code> 不同，<code>getSnapshotBeforeUpdate</code> 会在最终的 render 之前被调用，也就是说在 <code>getSnapshotBeforeUpdate</code> 中读取到的 DOM 元素状态是可以保证与 <code>componentDidUpdate</code> 中一致的。</p><p>虽然 <code>getSnapshotBeforeUpdate</code> 不是一个静态方法，但我们也应该尽量使用它去返回一个值。这个值会随后被传入到 <code>componentDidUpdate</code> 中，然后我们就可以在 <code>componentDidUpdate</code> 中去更新组件的状态，而不是在 <code>getSnapshotBeforeUpdate</code> 中直接更新组件状态。避免了 <code>componentWillUpdate</code> 和 <code>componentDidUpdate</code> 配合使用时将组件临时的状态数据存在组件实例上浪费内存，<code>getSnapshotBeforeUpdate</code> 返回的数据在 <code>componentDidUpdate</code> 中用完即被销毁，效率更高。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8eb7f64f3f94a9f8038949001284385~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>来看官方的一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class ScrollingList extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.listRef &#x3D; React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    &#x2F;&#x2F; 我们是否在 list 中添加新的 items？</span><br><span class="line">    &#x2F;&#x2F; 捕获滚动位置以便我们稍后调整滚动位置。</span><br><span class="line">    if (prevProps.list.length &lt; this.props.list.length) &#123;</span><br><span class="line">      const list &#x3D; this.listRef.current;</span><br><span class="line">      return list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span><br><span class="line">    &#x2F;&#x2F; 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span><br><span class="line">    &#x2F;&#x2F;（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span><br><span class="line">    if (snapshot !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      const list &#x3D; this.listRef.current;</span><br><span class="line">      list.scrollTop &#x3D; list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div ref&#x3D;&#123;this.listRef&#125;&gt;&#123;&#x2F;* ...contents... *&#x2F;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果项目中有用到<code>componentWillUpdate</code>的话，升级方案就是将现有的 <code>componentWillUpdate</code> 中的回调函数迁移至 <code>componentDidUpdate</code>。如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 <code>getSnapshotBeforeUpdate</code>，然后在 <code>componentDidUpdate</code> 中统一触发回调或更新状态。</p><p>除了这些，React 16 版本的依然还有大改动，其中引人注目的就是 Fiber，之后我还会抽空写一篇关于 React Fiber 的文章，可以关注我的<a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</p><p>参考：</p><ul><li><a href="https://www.html.cn/qa/react/14367.html" target="_blank" rel="noopener">为什么废弃 react 生命周期函数</a></li><li><a href="https://juejin.cn/post/6844903600309665799" target="_blank" rel="noopener">React v16.3 版本新生命周期函数浅析及升级方案</a></li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:24px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/React/" rel="tag"><i class="fa fa-tag"></i> React</a> <a href="/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" rel="tag"><i class="fa fa-tag"></i> 生命周期</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2020/11/23/HTTP-%E5%92%8C-HTTPS-%E5%8D%8F%E8%AE%AE/" rel="prev" title="HTTP 和 HTTPS 协议"><i class="fa fa-chevron-left"></i> HTTP 和 HTTPS 协议</a></div><div class="post-nav-item"></div></div></footer></article></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#React-16-版本后做了什么"><span class="nav-number">2.</span> <span class="nav-text">React 16 版本后做了什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UNSAFE-componentWillReceiveProps"><span class="nav-number">3.</span> <span class="nav-text">UNSAFE_componentWillReceiveProps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UNSAVE-componentWillMount"><span class="nav-number">4.</span> <span class="nav-text">UNSAVE_componentWillMount</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UNSAFE-componentWillUpdate"><span class="nav-number">5.</span> <span class="nav-text">UNSAFE_componentWillUpdate</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Jacky Lin" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">Jacky Lin</p><div class="site-description" itemprop="description">一个热爱技术，乐于分享的前端er</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">68</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">58</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/Jacky-Summer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Jacky-Summer" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://juejin.im/user/5d77c17bf265da03c61e7c24" title="掘金 → https:&#x2F;&#x2F;juejin.im&#x2F;user&#x2F;5d77c17bf265da03c61e7c24" rel="noopener" target="_blank"><i class="fa fa-fw fa-drupal"></i>掘金</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Jacky Lin</span></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">博客全站共124k字</span></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="https://cdn.bootcss.com/canvas-nest.js/1.0.1/canvas-nest.min.js"></script><script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script type="text/javascript" src="/js/clicklove.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>