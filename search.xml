<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>手把手带你入门 NextJS</title>
    <url>/2020/08/21/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-NextJS/</url>
    <content><![CDATA[<p>Next.js 之前用过一次，这次是重新做个小回顾，现在最新版本已经到了 9.5.3，有些 API 也同以前有点不同了，网上大部分教程也都是旧版本 v7 的比较多，故打算写下简单的教程，绝对详细的带你入个小门。</p>
<a id="more"></a>

<h2 id="库版本"><a href="#库版本" class="headerlink" title="库版本"></a>库版本</h2><p>本文案例用的关键库版本如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;next&quot;: &quot;^9.5.2&quot;,</span><br><span class="line">&quot;react&quot;: &quot;^16.13.1&quot;,</span><br></pre></td></tr></table></figure>

<p>node 版本为 12.18.1（nodejs 版本 &gt;= 10.13 即可）</p>
<h2 id="初始化-Next-js-项目"><a href="#初始化-Next-js-项目" class="headerlink" title="初始化 Next.js 项目"></a>初始化 Next.js 项目</h2><ol>
<li>新建一个文件夹</li>
</ol>
<p>如<code>learn-nextjs-example</code>，先进行初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -y</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装所需要的依赖包</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i react react-dom next --save</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>添加 script 命令</li>
</ol>
<p>为了是开发输入 npm 命令更快捷，所以把常用的命令作为快捷命令设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;next&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;next start&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>创建 pages 文件夹，运行第一个页面</li>
</ol>
<blockquote>
<p>pages 文件夹是放置页面的，这里边的文件会自动生成相应路由。</p>
</blockquote>
<ul>
<li>比如创建 <code>pages/about.js</code>，那么访问该页面地址就是 <code>http://localhost:3000/about</code>；</li>
<li>比如创建 <code>pages/about/about.js</code>，那么访问地址为<code>http://localhost:3000/about/about</code>。</li>
</ul>
<p>现在我们创建 <code>pages/index.js</code>，index.js 就是默认代表根路径了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello Next.js!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure>

<p>此时运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm rum dev</span><br></pre></td></tr></table></figure>

<p>打开<code>http://localhost:3000/</code>，可以看到页面成功运行了，也可以知道 Next.js 内置 React，因此不用我们再引入<br><code>import React from &#39;react&#39;</code>，就可以直接使用 React 的语法，当然你写了也不会报错，不过没必要。</p>
<h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>页面跳转有两种形式，一种是利用标签<code>Link</code>，一种是编程式路由跳转<code>router.push(&#39;/&#39;)</code>。路由跳转方式还是跟 React 很像的，只不过用的是 <code>next</code> 的包</p>
<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><ol>
<li>先创建两个页面</li>
</ol>
<p><code>pages/about.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>About Page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> About</span><br></pre></td></tr></table></figure>

<p><code>pages/news.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> News = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>News Page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> News</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在首页<code>pages/index.js</code>编写路由跳转链接</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;Hello Next.js!&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Link href='/</span>about<span class="string">'&gt;</span></span><br><span class="line"><span class="string">          &lt;a&gt;关于&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;Link href='</span>/news<span class="string">'&gt;</span></span><br><span class="line"><span class="string">          &lt;a&gt;新闻&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">export default Home</span></span><br></pre></td></tr></table></figure>

<p>在这里要注意的是 a 标签不用添加 href 元素，添加了也不起作用。<br>如果<code>Link</code>里面换成其他标签如<code>span</code>，也依然能成功跳转到对应页面，可以知道<code>Link</code>是给里面的元素添加了点击绑定事件，而不是只会给 a 标签添加 href 而已。</p>
<p>此时 DOM 结构：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de05d989ca674288856386d286ad3052~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>还有要注意的是：<code>Link</code> 里面只能有一个根元素，要不然它不知要绑定谁会报错。</p>
<h3 id="编程式路由跳转"><a href="#编程式路由跳转" class="headerlink" title="编程式路由跳转"></a>编程式路由跳转</h3><p>这里主要用<code>useRouter</code>钩子进行跳转</p>
<p>修改<code>pages/index.js</code>，修改其中一个路由</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter()</span><br><span class="line">  <span class="keyword">const</span> gotoAbout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    router.push(<span class="string">'/news'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;Hello Next.js!&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Link href='/</span>about<span class="string">'&gt;</span></span><br><span class="line"><span class="string">          &lt;a&gt;关于&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;button onClick=&#123;gotoAbout&#125;&gt;新闻&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">export default Home</span></span><br></pre></td></tr></table></figure>

<h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><h3 id="query-形式传参"><a href="#query-形式传参" class="headerlink" title="query 形式传参"></a>query 形式传参</h3><p>在 Next.js 中只能通过 query（?name=jackylin）来传递参数，不能通过(path:name)的形式传递参数。<br>修改<code>pages/index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter()</span><br><span class="line">  <span class="keyword">const</span> gotoAbout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    router.push(<span class="string">'/news'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;Hello Next.js!&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Link href='/</span>about?name=jackylin<span class="string">'&gt;</span></span><br><span class="line"><span class="string">          &lt;a&gt;关于&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;button onClick=&#123;gotoAbout&#125;&gt;新闻&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">export default Home</span></span><br></pre></td></tr></table></figure>

<p>也可以变换成这种方式传</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Link href&#x3D;&#123;&#123; pathname: &#39;&#x2F;about&#39;, query: &#123; name: &#39;jackylin&#39; &#125; &#125;&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>传递了参数<code>name</code>后，接下来是接收参数。</p>
<p>打开<code>pages/about.js</code>添加代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = <span class="function">(<span class="params">&#123; router &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;About Page&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;接收到参数为：&#123;router.query.name&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(About)</span></span><br></pre></td></tr></table></figure>

<p>点击<code>关于</code>，跳转到 about 页面，页面内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">About Page</span><br><span class="line">接收到参数为：jackylin</span><br></pre></td></tr></table></figure>

<p>同时也可看到地址栏带有参数：<code>http://localhost:3000/about?name=jackylin</code></p>
<h3 id="编程式路由跳转传递参数"><a href="#编程式路由跳转传递参数" class="headerlink" title="编程式路由跳转传递参数"></a>编程式路由跳转传递参数</h3><p>修改<code>pages/index.js</code>中的 <code>gotoAbout</code>方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gotoAbout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  router.push(&#123;</span><br><span class="line">    pathname: <span class="string">'/news'</span>,</span><br><span class="line">    query: &#123;</span><br><span class="line">      info: <span class="string">'学习Next.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pages/news.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> News = <span class="function">(<span class="params">&#123; router &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;News Page&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;接收到参数为：&#123;router.query.info&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(News)</span></span><br></pre></td></tr></table></figure>

<h2 id="路由变化的钩子"><a href="#路由变化的钩子" class="headerlink" title="路由变化的钩子"></a>路由变化的钩子</h2><p>这里就不一个个细细展开了，直接代码说话：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter()</span><br><span class="line">  <span class="keyword">const</span> gotoAbout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    router.push(&#123;</span><br><span class="line">      pathname: <span class="string">'/news'</span>,</span><br><span class="line">      query: &#123;</span><br><span class="line">        info: <span class="string">'学习Next.js'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleRouteChangeStart = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'routeChangeStart 路由开始变化，url:'</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRouteChangeComplete = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'routeChangeComplete 路由结束变化，url:'</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleBeforeHistoryChange = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'beforeHistoryChange 在改变浏览器 history之前触发，url:'</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRouteChangeError = <span class="function">(<span class="params">err, url</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`routeChangeError 跳转发生错误: <span class="subst">$&#123;err&#125;</span>, url:<span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleHashChangeStart = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hashChangeStart hash路由模式跳转开始时执行，url:'</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleHashChangeComplete = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hashChangeComplete hash路由模式跳转完成时，url:'</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    router.events.on(<span class="string">'routeChangeStart'</span>, handleRouteChangeStart)</span><br><span class="line">    router.events.on(<span class="string">'routeChangeComplete'</span>, handleRouteChangeComplete)</span><br><span class="line">    router.events.on(<span class="string">'beforeHistoryChange'</span>, handleBeforeHistoryChange)</span><br><span class="line">    router.events.on(<span class="string">'routeChangeError'</span>, handleRouteChangeError)</span><br><span class="line">    router.events.on(<span class="string">'hashChangeStart'</span>, handleHashChangeStart)</span><br><span class="line">    router.events.on(<span class="string">'hashChangeComplete'</span>, handleHashChangeComplete)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      router.events.off(<span class="string">'routeChangeStart'</span>, handleRouteChangeStart)</span><br><span class="line">      router.events.off(<span class="string">'routeChangeComplete'</span>, handleRouteChangeComplete)</span><br><span class="line">      router.events.off(<span class="string">'beforeHistoryChange'</span>, handleBeforeHistoryChange)</span><br><span class="line">      router.events.off(<span class="string">'routeChangeError'</span>, handleRouteChangeError)</span><br><span class="line">      router.events.off(<span class="string">'hashChangeStart'</span>, handleHashChangeStart)</span><br><span class="line">      router.events.off(<span class="string">'hashChangeComplete'</span>, handleHashChangeComplete)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;Hello Next.js!&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Link href='/</span>about?name=jackylin<span class="string">'&gt;</span></span><br><span class="line"><span class="string">          &lt;a&gt;关于&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;button onClick=&#123;gotoAbout&#125;&gt;新闻&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">export default Home</span></span><br></pre></td></tr></table></figure>

<h2 id="style-jsx-编写页面-CSS-样式"><a href="#style-jsx-编写页面-CSS-样式" class="headerlink" title="style-jsx 编写页面 CSS 样式"></a>style-jsx 编写页面 CSS 样式</h2><p>我们建立一个头部组件再引入<code>pages/index.js</code>，在根目录下新建<code>components/header.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Header = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div className=<span class="string">'header-bar'</span>&gt;Header&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header</span><br></pre></td></tr></table></figure>

<p><code>pages/index.js</code>引入 Header 组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'../components/header'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>接着给 Header 写样式，Next.js 内置支持 style jsx 语法，这是其中一种 CSS-in-JS 的解决方案</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Header = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div className=<span class="string">'header-bar'</span>&gt;Header&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;style jsx&gt;</span></span><br><span class="line"><span class="regexp">        &#123;`</span></span><br><span class="line"><span class="regexp">          .header-bar &#123;</span></span><br><span class="line"><span class="regexp">            width: 100%;</span></span><br><span class="line"><span class="regexp">            height: 50px;</span></span><br><span class="line"><span class="regexp">            line-height: 50px;</span></span><br><span class="line"><span class="regexp">            background: lightblue;</span></span><br><span class="line"><span class="regexp">            text-align: center;</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        `&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Header</span></span><br></pre></td></tr></table></figure>

<p>运行样式生效<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27bcc345b1bf4fdcb50e582310abc0d7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>查看 DOM 结构，会发现 Next.js 会自动加入一个随机类名（jsx-xxxxxxx），这样就能防止 CSS 的全局污染。<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2de14d7f46694782a151d440ecb2626f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="添加全局-CSS-文件"><a href="#添加全局-CSS-文件" class="headerlink" title="添加全局 CSS 文件"></a>添加全局 CSS 文件</h2><p>新建文件夹 public，用于放置静态文件如图片和 css 文件等，注意只有名为<code>public</code>的目录能够存放静态资源并对外提供访问。新建文件<code>public/static/styles/common.css</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义 App</li>
</ul>
<p>Next.js 使用<code>App</code>组件来初始化页面，我们可以覆盖<code>App</code>组件来控制页面的初始化。该<code>App</code>作用一般如下：</p>
<ul>
<li>在页面切换之间保持布局的持久化</li>
<li>切换页面时保持状态</li>
<li>使用 componentDidCatch 自定义错误处理</li>
<li>向页面注入额外的数据</li>
<li>添加全局 CSS</li>
</ul>
<p>我们要做的就是添加全局 CSS 样式，所以需要覆盖原来默认的<code>App</code>，首先要创建<code>pages/_app.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'../public/static/styles/common.css'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Component 指当前页面，每次路由切换时，Component 都会更新</span></span><br><span class="line"><span class="comment"> * pageProps 是带有初始属性的对象，该初始属性由我们的某个数据获取方法预先加载到你的页面中，否则它将是一个空对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params">&#123; Component, pageProps &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务，运行，全局样式添加成功。</p>
<h2 id="集成-style-components"><a href="#集成-style-components" class="headerlink" title="集成 style-components"></a>集成 style-components</h2><p>如果想要项目支持 style-components 的话，需要我们自己去配置。我们通过自定义 Document 的方式来改写代码，即是指<code>_document.js</code>文件，它只有在服务器端渲染的时候才会被调用，主要用来修改服务器端渲染的文档内容，一般用来配合第三方 css-in-js 方案使用。</p>
<ul>
<li>安装所需库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i styled-components --save</span><br></pre></td></tr></table></figure>

<p>编译 styled-components</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i babel-plugin-styled-components --save-dev</span><br></pre></td></tr></table></figure>

<p>新建文件<code>.babelrc</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;next&#x2F;babel&quot;],</span><br><span class="line">  &quot;plugins&quot;: [[&quot;styled-components&quot;, &#123; &quot;ssr&quot;: true &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建 <code>_document.js</code>，改写覆盖它原来的写法。这里要注意的是，要一定要继承 <code>Document</code>，才来改写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Document <span class="keyword">from</span> <span class="string">'next/document'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ServerStyleSheet &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDocument</span> <span class="keyword">extends</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(ctx) &#123;</span><br><span class="line">    <span class="keyword">const</span> sheet = <span class="keyword">new</span> ServerStyleSheet()</span><br><span class="line">    <span class="keyword">const</span> originalRenderPage = ctx.renderPage</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ctx.renderPage = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">        originalRenderPage(&#123;</span><br><span class="line">          enhanceApp: <span class="function"><span class="params">App</span> =&gt;</span> <span class="function"><span class="params">props</span> =&gt;</span> sheet.collectStyles(<span class="xml"><span class="tag">&lt;<span class="name">App</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>),</span><br><span class="line">        &#125;)</span><br><span class="line">      <span class="keyword">const</span> initialProps = <span class="keyword">await</span> Document.getInitialProps(ctx)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...initialProps,</span><br><span class="line">        styles: (</span><br><span class="line">          &lt;&gt;</span><br><span class="line">            &#123;initialProps.styles&#125;</span><br><span class="line">            &#123;sheet.getStyleElement()&#125;</span><br><span class="line">          &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">        ),</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125; finally &#123;</span></span><br><span class="line"><span class="regexp">      sheet.seal()</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这其中详细配置意思可以去官方文档找点线索了解：<a href="https://nextjs.org/docs/advanced-features/custom-document" target="_blank" rel="noopener">Next.js</a></p>
<p>接下来我们使用 styled-components 的方式添加样式，打开<code>pages/about.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Title = styled.h1<span class="string">`</span></span><br><span class="line"><span class="string">  color: green;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = <span class="function">(<span class="params">&#123; router &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Title&gt;About Page&lt;<span class="regexp">/Title&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;接收到参数为：&#123;router.query.name&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(About)</span></span><br></pre></td></tr></table></figure>

<p>运行，如下图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e914adfd47af4564a3c06b641f514b8e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="获取数据的方式"><a href="#获取数据的方式" class="headerlink" title="获取数据的方式"></a>获取数据的方式</h2><p>四个 api 都只能在 pages 文件夹内的文件中使用</p>
<h3 id="getStaticProps"><a href="#getStaticProps" class="headerlink" title="getStaticProps"></a>getStaticProps</h3><p><strong>当页面内容取决于外部数据</strong></p>
<p>Next.js 推荐我们尽可能使用静态生成的方式，因为所有页面都可以只构建一次并托管到 CDN 上，这比让服务器根据每个页面请求来渲染页面快得多。</p>
<p>比如下列一些类型的页面：</p>
<ul>
<li>营销页面</li>
<li>个人博客</li>
<li>产品列表</li>
<li>静态文档</li>
</ul>
<p>如果一个页面使用了 静态生成（SSG），在构建时将生成此页面对应的 HTML 文件 。HTML 文件将在每个页面请求时被重用，还可以被 CDN 缓存。这个跟 hexo，Gatsby 类似的，生成静态文件还有 json 文件。</p>
<p>关于 Gatsby，它是基于 React 的上层框架，具体可以看我这篇博客了解：<a href="https://juejin.im/post/6850418110885789704" target="_blank" rel="noopener">手把手带你入门 Gatsby</a></p>
<p>Next.js 会尽可能地自动优化应用并输出静态 HTML，如果你在你的页面组件添加了<code>getInitialProps</code>方法才会禁用自动静态优化，<code>getInitialProps</code>方法下面会说到。</p>
<p>比如我们可以执行命令查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>打包默认是 SSG 模式：</p>
<p><code>● (SSG) automatically generated as static HTML + JSON (uses getStaticProps)</code></p>
<p>会发现<code>.next/server/pages/</code>下多出了几个 HTML 文件，这些就是静态构建出的 HTML 文件。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06f57ad8a7c046efbcbbbb90032f0396~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>新建文件<code>pages/blog.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Blog = <span class="function">(<span class="params">&#123; posts &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>title: &#123;posts.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数在构建时被调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStaticProps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用外部 API 获取内容</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">'https://jsonplaceholder.typicode.com/todos/1'</span>)</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> res.json()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在构建时将接收到 `posts` 参数</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      posts,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Blog</span><br></pre></td></tr></table></figure>

<p>进入<code>http://localhost:3000/blog</code>，发现页面能正常获取到请求结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: delectus aut autem</span><br></pre></td></tr></table></figure>

<h3 id="getStaticPaths"><a href="#getStaticPaths" class="headerlink" title="getStaticPaths"></a>getStaticPaths</h3><p><strong>当页面的路径取决于外部数据</strong></p>
<p>这种方式和上面就有些不同了，上面<code>http://localhost:3000/blog</code>访问路径时我们已经写了一个 js 页面文件，但如果我们想要根据获取的数据动态生成多篇文章路径的话，那就需要用到这个 API，通常用这个 API 会同时配合<code>getStaticProps</code>一起用。</p>
<p>新建文件<code>pages/posts/[id].js</code>，你没有看错，文件名就是<code>[id].js</code></p>
<p>用<code>id</code>标识单篇博文，比如你访问<code>http://localhost:3000/posts/1</code>就展示<code>id</code>为 1 的文章。</p>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Post = <span class="function">(<span class="params">&#123; post &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;文章id: &#123;post.id&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;博客标题: &#123;post.title&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 构建路由</span></span><br><span class="line"><span class="regexp">export async function getStaticPaths() &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 调用外部 API 获取博文列表</span></span><br><span class="line"><span class="regexp">  const res = await fetch('https:/</span><span class="regexp">/jsonplaceholder.typicode.com/</span>todos<span class="string">')</span></span><br><span class="line"><span class="string">  const posts = await res.json()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 根据博文列表生成所有需要预渲染的路径</span></span><br><span class="line"><span class="string">  const paths = posts.map(post =&gt; `/posts/$&#123;post.id&#125;`)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // fallback为false，表示任何不在 getStaticPaths 的路径的结果将是 404 页面。</span></span><br><span class="line"><span class="string">  return &#123; paths, fallback: false &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 获取单个页面博文数据</span></span><br><span class="line"><span class="string">export async function getStaticProps(&#123; params &#125;) &#123;</span></span><br><span class="line"><span class="string">  // 如果路由是 /posts/1，那么 params.id 就是 1</span></span><br><span class="line"><span class="string">  const res = await fetch(`https://jsonplaceholder.typicode.com/todos/$&#123;params.id&#125;`)</span></span><br><span class="line"><span class="string">  const post = await res.json()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 通过 props 参数向页面传递博文的数据</span></span><br><span class="line"><span class="string">  return &#123; props: &#123; post &#125; &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default Post</span></span><br></pre></td></tr></table></figure>

<p>拉取下来的数据全部有 200 条，也就是说动态构建了 200 个路由，现在我们访问第 50 篇博文的话，直接输入<code>http://localhost:3000/posts/50</code></p>
<p>页面显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文章id: 50</span><br><span class="line">博文标题: cupiditate necessitatibus ullam aut quis dolor voluptate</span><br></pre></td></tr></table></figure>

<p>接下来让我们再次打包，执行<code>npm run build</code>（如果打包发生错误很可能是网络差和请求链接有关，因为要请求很多页面，如果是网络问题多试几次就行），你会发现这次打包时间变长了，因为要构建的静态页面多了，我们请求返回来的数据有 200 条，所以应该生成 200 个静态 HTML 文件和相应的 json 数据文件。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/088770a941f1479fa15fc96d348f85a4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>我们来看 <code>1.json</code> 文件，就是请求后的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;pageProps&quot;:&#123;&quot;post&quot;:&#123;&quot;userId&quot;:1,&quot;id&quot;:1,&quot;title&quot;:&quot;delectus aut autem&quot;,&quot;completed&quot;:false&#125;&#125;,&quot;__N_SSG&quot;:true&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getServerSideProps"><a href="#getServerSideProps" class="headerlink" title="getServerSideProps"></a>getServerSideProps</h3><p><strong>每次页面请求时重新生成页面的 HTML</strong></p>
<p>如果无法在用户请求之前预渲染页面，那上面的”静态生成”就不太适用了，或者是页面数据需要频繁的更新，并且页面内容会随着每个请求而变化。这个时候，有两种方案：</p>
<ul>
<li>将“静态生成”与 客户端渲染 一起使用：你可以跳过页面某些部分的预渲染，然后使用客户端 JavaScript 来填充它们</li>
<li>使用 服务器端渲染： Next.js 针对每个页面的请求进行预渲染。由于 CDN 无法缓存该页面，因此速度会较慢，但是预渲染的页面将始终是最新的。</li>
</ul>
<p>由于服务器端渲染会导致性能比“静态生成”慢，因此仅在绝对必要时才使用此功能。</p>
<p>新建文件<code>pages/server-blog.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Blog = <span class="function">(<span class="params">&#123; posts &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>title: &#123;posts.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每次页面请求时都会运行，而在构建时不运行。</span></span><br><span class="line"><span class="comment">// 要设置某个页面使用服务器端渲染，就需要导出 getServerSideProps 函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getServerSideProps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用外部 API 获取内容</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">'https://jsonplaceholder.typicode.com/todos/1'</span>)</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> res.json()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在构建时将接收到 `posts` 参数</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      posts,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Blog</span><br></pre></td></tr></table></figure>

<p>运行<code>npm run build</code>，发现这次并没有生成对应的 html 文件——<code>server-blog.html</code>，因为我们指定了服务端渲染，请求构建时不会执行，不是静态生成。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2717dff8c6a0485d836091e87f9093c0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h3 id="getInitialProps"><a href="#getInitialProps" class="headerlink" title="getInitialProps"></a>getInitialProps</h3><p>getInitialProps 是在渲染页面之前就会运行的 API。 如果该路径下包含该请求，则执行该请求，并将所需的数据作为 props 传递给页面。当第一次访问直接页面，getInitialProps 就在服务器端运行，加载完毕后页面给客户端托管，使用客户端的路由跳转，之后页面的 getInitialProps 就在客户端执行了。</p>
<blockquote>
<p>推荐： getStaticProps 或 getServerSideProps。如果你使用的是 Next.js 9.3 或更高版本，我们建议你使用 getStaticProps 或 getServerSideProps 来替代 getInitialProps。这些新的获取数据的方法使你可以在静态生成（static generation）和服务器端渲染（server-side rendering）之间进行精细控制。</p>
</blockquote>
<p>新建文件<code>pages/initial-blog.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> InitialBlog = <span class="function">(<span class="params">&#123; post &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;getInitialProps Demo Page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;获取到的title: &#123;post.title&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;Link href=<span class="string">'/'</span>&gt;</span><br><span class="line">        &lt;a&gt;返回首页&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Link&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">InitialBlog.getInitialProps = async ctx =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const res = await fetch('https:/</span><span class="regexp">/jsonplaceholder.typicode.com/</span>todos/<span class="number">1</span><span class="string">')</span></span><br><span class="line"><span class="string">  const post = await res.json()</span></span><br><span class="line"><span class="string">  return &#123; post &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default InitialBlog</span></span><br></pre></td></tr></table></figure>

<p>再修改<code>pages/index.js</code>代码，增加一个<code>Link</code>标签可以跳转回该页面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Link href=<span class="string">'/initial-blog'</span>&gt;</span><br><span class="line">    &lt;a&gt;进入Initial Blog&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Link&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>

<p>接着直接地址栏输入<code>http://localhost:3000/initial-blog</code>，在渲染该页面内容前，先会执行<code>getInitialProps</code>方法，执行完的结果再传到页面组件，开始渲染页面。由于我们是第一次访问页面，首屏则为服务端渲染。</p>
<p>页面内容显示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getInitialProps Demo Page</span><br><span class="line">获取到的title: delectus aut autem</span><br></pre></td></tr></table></figure>

<p>打开浏览器的 Network 面板，找到 Name 值为<code>initial-blog</code>的请求，会看到请求响应内容的正是该页面的 HTML。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4171887a1ccc44e88da72bd43266b35b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>点击<code>返回首页</code>，再从首页点击<code>进入Initial Blog</code>，重新进入该页面，注意的是此时已经不是我们浏览器通过地址栏访问该页面，而是通过前端路由进入该页面。</p>
<p>查看 Network 面板的请求，会看到此时返回的是<code>getInitialProps</code>请求回来的数据，而不是 HTML 页面内容，由此可知此时页面已经交由客户端渲染。这就是所谓 SSR 渲染，首屏交给服务端渲染返回，返回后页面跳转就是客户端渲染了。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2da317e74c0482ab58d19ee7bdc51a1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="自定义-Head"><a href="#自定义-Head" class="headerlink" title="自定义 Head"></a>自定义 Head</h2><p>之所以会选择 Next.js，相信一个非常重要的原因就是有利用 SEO，那么利于爬虫检索的方式，一种就是在页面写好 TDK（title、description、keyword），Next.js 可以自定义<code>Head</code>标签</p>
<p>修改<code>components/header.js</code>，在最外层 div 根元素里内添加代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Head&gt;</span><br><span class="line">  &lt;title&gt;Next.js 教程 -- JackyLin&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;meta name='viewport' content='initial-scale=1.0, width=device-width' /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/Head&gt;</span></span><br></pre></td></tr></table></figure>

<p>打开<code>http://localhost:3000/</code>，就会看到页面的头部标签 title 已经被我们改了。</p>
<h2 id="LazyLoding-实现模块-组件懒加载"><a href="#LazyLoding-实现模块-组件懒加载" class="headerlink" title="LazyLoding 实现模块/组件懒加载"></a>LazyLoding 实现模块/组件懒加载</h2><p>懒加载是指需要用到或该加载到某个组件/模块的时候，才加载那个组件/模块的 js 文件，也叫异步加载。</p>
<p>如果页面文件内容多过大，那么可能出现首次打开速度慢，这时就需要进行优化了，懒加载就是其中一种方式。</p>
<h3 id="懒加载模块"><a href="#懒加载模块" class="headerlink" title="懒加载模块"></a>懒加载模块</h3><p>先安装一个处理日期时间的库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i moment --save</span><br></pre></td></tr></table></figure>

<p>新建<code>pages/time.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Time = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> getTime = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setNowTime(moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [nowTime, setNowTime] = useState(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;getTime&#125;&gt;获取当前时间&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;当前时间：&#123;nowTime&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Time</span></span><br></pre></td></tr></table></figure>

<p>假设我们这个页面内容很多，然后你进入该页面可能不需要点击获取时间，但<code>moment</code>模块依然加载了，这就有点资源浪费。<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b24abdbe08d64eb7ae5585dcede06dee~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>于是，我们想当我们点击按钮的时候，再来加载<code>moment</code>模块，即是实现异步加载，而不是页面一进入就加载。</p>
<p>此时点击按钮获取时间，可看到 Network 面板看到<code>moment</code>的代码被打包成了一个<code>1.js</code>文件，这样就实现了懒加载了，这样可以减少了主要 JavaScript 包的大小,带来了更快的加载速度。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94d858ae0d074bd4939864f6105d4f3b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Time = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> getTime = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> moment = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'moment'</span>)</span><br><span class="line">    setNowTime(moment.default().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>)) <span class="comment">// 注意这里使用 default，不能直接用 moment()</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> getTime = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setNowTime(moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [nowTime, setNowTime] = useState(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;getTime&#125;&gt;获取当前时间&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;当前时间：&#123;nowTime&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Time</span></span><br></pre></td></tr></table></figure>

<h3 id="懒加载组件"><a href="#懒加载组件" class="headerlink" title="懒加载组件"></a>懒加载组件</h3><p>懒加载组件需要引入 <code>next/dynamic</code>模块</p>
<p>新建组件<code>components/content.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Content = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Content</span><br></pre></td></tr></table></figure>

<p>引入<code>pages/time.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">'next/dynamic'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载自定义组件</span></span><br><span class="line"><span class="keyword">const</span> Content = dynamic(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/content'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Time = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> getTime = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> moment = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'moment'</span>)</span><br><span class="line">    setNowTime(moment.default().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>)) <span class="comment">// 注意这里使用 default，不能直接用 moment()</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [nowTime, setNowTime] = useState(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;getTime&#125;&gt;获取当前时间&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;当前时间：&#123;nowTime&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;Content /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Time</span></span><br></pre></td></tr></table></figure>

<p>观察 Network 可以看到 Content 组件被新单独打包成一个 js 文件</p>
<h2 id="打包生产环境"><a href="#打包生产环境" class="headerlink" title="打包生产环境"></a>打包生产环境</h2><p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>打包完成后，运行服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure>

<p>然后查看页面，打包成功！</p>
<p>参考：</p>
<ul>
<li><a href="https://medium.com/swlh/server-side-rendering-styled-components-with-nextjs-1db1353e915e" target="_blank" rel="noopener">Server side rendering Styled-Components with NextJS</a></li>
</ul>
]]></content>
      <categories>
        <category>NextJS</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>NextJS</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title>前端跨域解决方案归纳整理</title>
    <url>/2020/08/16/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%BD%92%E7%BA%B3%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>前端跨域的各种文章其实已经很多了，但大部分还是不太符合我胃口的介绍跨域。看来看去，如果要让自己理解印象深刻，果然还是得自己敲一敲，并总结归纳整理一篇博客出来，以此记录。</p>
<a id="more"></a>

<h2 id="跨域的限制"><a href="#跨域的限制" class="headerlink" title="跨域的限制"></a>跨域的限制</h2><p>跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。</p>
<h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><p>除非特别说明，否则下方标记的 html 文件默认都运行在 <a href="http://127.0.0.1:5500" target="_blank" rel="noopener">http://127.0.0.1:5500</a> 服务下</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS 即是指跨域资源共享。它允许浏览器向非同源服务器，发出 Ajax 请求，从而克服了 Ajax 只能同源使用的限制。这种方式的跨域主要是在后端进行设置。</p>
<p>这种方式的关键是后端进行设置，即是后端开启 Access-Control-Allow-Origin 为<code>*</code>或对应的 <code>origin</code>就可以实现跨域。</p>
<p>浏览器将 CORS 请求分成两类：简单请求和非简单请求。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<ol>
<li>请求方法是以下是三种方法之一：</li>
</ol>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<ol start="2">
<li>HTTP 的头信息不超出以下几种字段：</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p><strong>简单请求</strong></p>
<p>cors.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest() xhr.open(<span class="string">'GET'</span>, <span class="string">'http://localhost:8002/request'</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p>server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://127.0.0.1:5500'</span>) <span class="comment">// 设置允许哪个域访问</span></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">'server ok'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8002</span>)</span><br></pre></td></tr></table></figure>

<p><strong>非简单请求</strong></p>
<p>上面的是简单请求，如果我们用非简单请求的方式，比如请求方法是 PUT，也可以通过设置实现跨域。</p>
<p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求。</p>
<p>浏览器先询问服务器，服务器收到”预检”请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, <span class="string">'http://localhost:8002/request'</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p>server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> whileList = [<span class="string">'http://127.0.0.1:5500'</span>] <span class="comment">// 设置白名单</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> origin = req.headers.origin</span><br><span class="line">  <span class="built_in">console</span>.log(whitList.includes(origin))</span><br><span class="line">  <span class="keyword">if</span> (whitList.includes(origin)) &#123;</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, origin) <span class="comment">// 设置允许哪个域访问</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT'</span>) <span class="comment">// 设置允许哪种请求方法访问</span></span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.put(<span class="string">'/request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">'server ok'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8002</span>)</span><br></pre></td></tr></table></figure>

<p>整个过程发送了两次请求，跨域成功。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/414b7733753342dc84384053835ad883~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>当然，还可以设置其他参数：</p>
<ul>
<li><strong>Access-Control-Request-Headers</strong></li>
</ul>
<p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段</p>
<ul>
<li><strong>Access-Control-Allow-Credentials</strong></li>
</ul>
<p>表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。</p>
<ul>
<li><strong>Access-Control-Expose-Headers</strong></li>
</ul>
<p>CORS 请求时，XMLHttpRequest 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers 里面指定。</p>
<ul>
<li><strong>Access-Control-Max-Age</strong></li>
</ul>
<p>用来指定本次预检请求的有效期，单位为秒。有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。</p>
<h3 id="Node-中间件代理"><a href="#Node-中间件代理" class="headerlink" title="Node 中间件代理"></a>Node 中间件代理</h3><p>实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就没有跨域一说。</p>
<p>代理服务器，需要做以下几个步骤：</p>
<ol>
<li>接受客户端请求 。</li>
<li>将请求转发给服务器。</li>
<li>拿到服务器响应数据。</li>
<li>将响应转发给客户端。</li>
</ol>
<p>这次我们使用 express 中间件 http-proxy-middleware 来代理跨域, 转发请求和响应</p>
<p>案例三个文件都在同一级目录下：</p>
<p>index.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'/api/request'</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请求成功，结果是：'</span>, xhr.responseText) <span class="comment">// request success</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p>nodeMdServer.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置静态资源</span></span><br><span class="line">app.use(express.static(__dirname))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代理</span></span><br><span class="line">app.use(</span><br><span class="line">  <span class="string">'/api'</span>,</span><br><span class="line">  createProxyMiddleware(&#123;</span><br><span class="line">    target: <span class="string">'http://localhost:8002'</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">'^/api'</span>: <span class="string">''</span>, <span class="comment">// 重写路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8001</span>)</span><br></pre></td></tr></table></figure>

<p>nodeServer.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">'request success'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8002</span>)</span><br></pre></td></tr></table></figure>

<p>运行<code>http://localhost:8001/index.html</code>，跨域成功</p>
<p>平常 vue/react 项目配置 webpack-dev-server 的时候也是通过 Node proxy 代理的方式来解决的。</p>
<h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p>实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。</p>
<p>这种方式只需修改 Nginx 的配置即可解决跨域问题，前端除了接口换成对应形式，然后前后端不需要修改作其他修改。</p>
<p>实现思路：通过 nginx 配置一个代理服务器（同域不同端口）做跳板机，反向代理要跨域的域名，这样可以修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。</p>
<p>nginx 目录下的 nginx.conf 修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass   http:&#x2F;&#x2F;www.domain2.com:8080;  # 反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; # 修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http:&#x2F;&#x2F;www.domain1.com;  # 当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动 Nginx</p>
<p>index.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:81/?user=admin'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>

<p>server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>))</span><br><span class="line">  <span class="comment">// 向前台写cookie</span></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Set-Cookie'</span>: <span class="string">'l=123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>, <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.write(<span class="built_in">JSON</span>.stringify(params))</span><br><span class="line">  res.end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p>原理：利用了 script 标签可跨域的特性，在客户端定义一个回调函数（<strong>全局函数</strong>），请求服务端返回该回调函数的调用，并将服务端的数据以该回调函数参数的形式传递过来，然后该函数就被执行了。该方法需要服务端配合完成。</p>
<p>实现步骤：</p>
<ol>
<li>声明一个全局回调函数，参数为服务端返回的 data。</li>
<li>创建一个 script 标签，拼接整个请求 api 的地址（要传入回调函数名称如 ?callback=getInfo ），赋值给 script 的 src 属性</li>
<li>服务端接受到请求后处理数据，然后将函数名和需要返回的数据拼接成字符串，拼装完成是执行函数的形式。（getInfo(‘server data’)）</li>
<li>浏览器接收到服务端的返回结果，调用了声明的回调函数。</li>
</ol>
<p>jsonp.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">// 告诉你一声， jsonp跨域成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">script.src = <span class="string">'http://localhost:3000?callback=getInfo'</span> <span class="comment">//</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br></pre></td></tr></table></figure>

<p>server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; callback &#125; = req.query</span><br><span class="line">  res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>('告诉你一声， jsonp跨域成功')`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>jQuery 的 $.ajax() 方法当中集成了 JSONP 的实现，在此就不写出来了。</p>
<p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，而且这种方式用起来也麻烦，故我们自己封装一个 jsonp 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">    <span class="comment">// 定义全局回调函数</span></span><br><span class="line">    <span class="built_in">window</span>[callback] = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(script) <span class="comment">// 调用完毕即删除</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    params = &#123; callback, ...params &#125; <span class="comment">// &#123;callback: "getInfo", name: "jacky"&#125;</span></span><br><span class="line">    <span class="keyword">let</span> paramsArr = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      paramsArr.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;paramsArr.join(<span class="string">'&amp;'</span>)&#125;</span>`</span> <span class="comment">// http://localhost:3000/?callback=getInfo&amp;name=jacky</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    name: <span class="string">'jacky'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  callback: <span class="string">'getInfo'</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// 告诉你一声， jsonp跨域成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>服务端解构的时候可以取出参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; callback, name &#125; = req.query</span><br><span class="line">  res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>('告诉你一声， jsonp跨域成功')`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>优点：兼容性好</p>
<p>缺点：由于 script 本身的限制，该跨域方式仅支持 get 请求，且不安全可能遭受 XSS 攻击</p>
<h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><p>postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：</p>
<ol>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的 iframe 消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ol>
<p>总之，它可以允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p>
<blockquote>
<p>otherWindow.postMessage(message, targetOrigin, [transfer]);</p>
</blockquote>
<ul>
<li>otherWindow：其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象、或者是命名过或数值索引的 window.frames。</li>
<li>message: 将要发送到其他 window 的数据。</li>
<li>targetOrigin:通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*“（表示无限制）或者一个 URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配 targetOrigin 提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li>
<li>transfer(可选)：是一串和 message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li>
</ul>
<p>这次我们把两个 html 文件挂到两个 server 下，采取 fs 读取的方式引入，运行两个 js 文件</p>
<p>postMessage1.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:8002"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">id</span>=<span class="string">"frame"</span> <span class="attr">onLoad</span>=<span class="string">"load()"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>)</span></span><br><span class="line"><span class="actionscript">      frame.contentWindow.postMessage(<span class="string">'你好，我是postMessage1'</span>, <span class="string">'http://localhost:8002'</span>) <span class="comment">//发送数据</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//接受返回数据</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.data) <span class="comment">// 你好，我是postMessage2</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>postMsgServer1.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> html = fs.readFileSync(<span class="string">'./postMessage1.html'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">  res.end(html)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8001</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server listening on 8001'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>postMessage2.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.data) <span class="comment">// 你好，我是postMessage1</span></span></span><br><span class="line"><span class="actionscript">      e.source.postMessage(<span class="string">'你好，我是postMessage2'</span>, e.origin)</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>postMsgServer2.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> html = fs.readFileSync(<span class="string">'./postMessage2.html'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">  res.end(html)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8002</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server listening on 8002'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p>WebSocket 是一种网络通信协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，长连接方式不受跨域影响。由于原生 WebSocket API 使用起来不太方便，我们一般都会使用第三方库如 ws。</p>
<p>Web 浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的 HTTP 连接不同，对服务器有重要的影响。</p>
<p>socket.html（<code>http://127.0.0.1:5500/socket.html</code>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8001'</span>)</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  socket.send(<span class="string">'向服务端发送数据'</span>)</span><br><span class="line">&#125;</span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data) <span class="comment">// 服务端传给你的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行<code>nodeServer.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wsServer = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8001</span> &#125;)</span><br><span class="line">wsServer.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 向服务端发送数据</span></span><br><span class="line">    ws.send(<span class="string">'服务端传给你的数据'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain + iframe"></a>document.domain + iframe</h3><p>这种方式只能用于二级域名相同的情况下。</p>
<p>比如 a.test.com 和 b.test.com 就属于二级域名，它们都是 test.com 的子域</p>
<p>只需要给页面添加 document.domain =’test.com’ 表示二级域名都相同就可以实现跨域。</p>
<p>比如：页面 a.test.com:3000/test1.html 获取页面 b.test.com:3000/test2.html 中 a 的值</p>
<p>test1.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"http://b.test.com:3000/test2.html"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">frameborder</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onload</span>=<span class="string">"load()"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"iframe"</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'test.com'</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(iframe.contentWindow.a)</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>test2.html</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">'test.com'</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="window-name-iframe"><a href="#window-name-iframe" class="headerlink" title="window.name + iframe"></a>window.name + iframe</h3><p>浏览器具有这样一个特性：同一个标签页或者同一个 iframe 框架加载过的页面共享相同的 window.name 属性值。在同个标签页里，name 值在不同的页面加载后也依旧存在，这些页面上 window.name 属性值都是相同的。利用这些特性，就可以将这个属性作为在不同页面之间传递数据的介质。</p>
<blockquote>
<p>由于安全原因，浏览器始终会保持 window.name 是 string 类型。</p>
</blockquote>
<p>打开<code>http://localhost:8001/a.html</code></p>
<ul>
<li><a href="http://localhost:8001/a.html" target="_blank" rel="noopener">http://localhost:8001/a.html</a></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"http://localhost:8002/c.html"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">frameborder</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onload</span>=<span class="string">"load()"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"iframe"</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> first = <span class="literal">true</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      if (first) &#123;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>)</span></span><br><span class="line"><span class="actionscript">        iframe.src = <span class="string">'http://localhost:8001/b.html'</span></span></span><br><span class="line"><span class="actionscript">        first = <span class="literal">false</span></span></span><br><span class="line"><span class="actionscript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(iframe.contentWindow.name) <span class="comment">// 我是c.html里的数据</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><a href="http://localhost:8001/b.html（不需要往html加内容，默认html结构模板即可）" target="_blank" rel="noopener">http://localhost:8001/b.html（不需要往html加内容，默认html结构模板即可）</a></p>
</li>
<li><p><a href="http://localhost:8002/c.html" target="_blank" rel="noopener">http://localhost:8002/c.html</a></p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name = <span class="string">'我是c.html里的数据'</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>c 页面给 window.name 设置了值, 即便 c 页面销毁，但 name 值不会被销毁；a 页面依旧能够得到 window.name。</p>
<h3 id="location-hash-iframe"><a href="#location-hash-iframe" class="headerlink" title="location.hash + iframe"></a>location.hash + iframe</h3><p>实现原理： a.html 欲与 c.html 跨域相互通信，通过中间页 b.html 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。</p>
<p>具体实现步骤：一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。</p>
<p>同样的，a.html 和 b.html 是同域的，都是<a href="http://localhost:8001，也就是说">http://localhost:8001，也就是说</a> b 的 hash 值可以直接复制给 a 的 hash。c.html 为<a href="http://localhost:8002下的">http://localhost:8002下的</a></p>
<p>a.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:8002/c.html#jackylin"</span> <span class="attr">style</span>=<span class="string">"display: none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 检测hash的变化</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="number">456</span>, location.hash) <span class="comment">// #monkey</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.parent.parent.location.hash = location.hash</span><br><span class="line"><span class="comment">// b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span></span><br></pre></td></tr></table></figure>

<p>c.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(location.hash) <span class="comment">//  #jackylin</span></span><br><span class="line"><span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">iframe.src = <span class="string">'http://localhost:8001/b.html#monkey'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>CORS 支持所有的 HTTP 请求，是跨域最主流的方案</li>
<li>日常工作中，用得比较多的跨域方案是 CORS 和 Node 中间件及 Nginx 反向代理</li>
<li>不管是 Node 中间件代理还是 Nginx 反向代理，主要是通过同源策略对服务器不加限制。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></li>
<li><a href="https://github.com/ljianshu/Blog/issues/55" target="_blank" rel="noopener">九种跨域方式实现原理（完整版）</a></li>
<li><a href="https://juejin.im/post/6844903992057659400" target="_blank" rel="noopener">可能是最好的跨域解决方案了</a></li>
</ul>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>解决使用输入法输入在 React input 框中的问题</title>
    <url>/2020/08/14/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8%E8%BE%93%E5%85%A5%E6%B3%95%E8%BE%93%E5%85%A5%E5%9C%A8-React-input-%E6%A1%86%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在使用 React 绑定 input 输入框的 onChange 方法时，如果使用中文输入法（或者其他输入法），会出现一个问题：还在输入拼音的时候，onChange 方法已经触发了，如下，即输入过程就已经触发了多次 onChange 方法。如果 onChange 方法有较为复杂的逻辑，就可能会带来一些用户体验或者逻辑的问题。</p>
<p>本文以此问题开始，逐步探索解决方案。</p>
<a id="more"></a>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26ab509fe10d46bc97f80ee6f8728336~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>只要有按下键盘的动作，就会触发 onChange 方法，如果输入英文就没什么问题，但使用中/日/韩等输入法的话，比如输入中文拼音已经开始在触发 onChange 事件了。</p>
<h2 id="需求及解决方案"><a href="#需求及解决方案" class="headerlink" title="需求及解决方案"></a>需求及解决方案</h2><ul>
<li><p>需求：等到选择确认输入中文后，才让它触发 onChange 方法的后续操作，如改变 value 的值。</p>
</li>
<li><p>解决方案：使用 compositionEvent 事件来解决。</p>
</li>
</ul>
<blockquote>
<p>DOM 接口 CompositionEvent 表示用户间接输入文本（如使用输入法）时发生的事件。此接口的常用事件有 compositionstart, compositionupdate 和 compositionend</p>
</blockquote>
<h2 id="CompositionEvent-事件介绍"><a href="#CompositionEvent-事件介绍" class="headerlink" title="CompositionEvent 事件介绍"></a>CompositionEvent 事件介绍</h2><ul>
<li>compositionstart</li>
</ul>
<p>当用户使用输入法如拼音输入汉字时，这个事件就会被触发，即是在用户开始非直接输入的时候触发，在非直接输入的时候结束，整个过程只触发了一次。</p>
<ul>
<li>compositionupdate</li>
</ul>
<p>事件触发于字符被输入到一段文字的时候，如在用户开始输入拼音到确定结束的过程都会触发该事件。</p>
<ul>
<li>compositionend</li>
</ul>
<p>当文本段落的组成完成或取消时, compositionend 事件将被触发 。如用户点击拼音输入法选词确定后，则触发了该事件，此时是直接输入了，整个过程只触发了一次。</p>
<p>可以知道这三个事件就把我们输入中文拼音的三个过程进行了拆分。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们通过监听输入法开始输入到结束的事件，即是去监听<code>compositionstart</code>和<code>compositionend</code>方法，通过设置一个变量，在两个方法里面设置 true/false，来判断是否处在中文输入拼音这个过程当中，如果是，则不触发 onChange 后续事件。</p>
<p>这个未必是优化。搜索框提示的一个很重要用处，不是帮助省出来那么一点打字的时间，而是为了提示打字人应该写什么。很多时候打字者只有一个模糊的需求，全靠搜索框提示才能明白自己真正想搜什么。而这时候对拼音进行搜索提示，不说提醒用户该拼音词也可以搜到结果，单说在某种可能的用况下会避免用户搜索整个输入法却找不到对应汉字（因为输入错误拼音）这点就非常好用了。</p>
<p>如下代码，我们通过设置个对照：value1 对应的为正常 onChange 操作，value2 对应的则是做了输入法处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isComposition = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestComposition</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value1: <span class="string">''</span>,</span><br><span class="line">      value2: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.handleChange1 = <span class="keyword">this</span>.handleChange1.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.handleChange2 = <span class="keyword">this</span>.handleChange2.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.handleComposition = <span class="keyword">this</span>.handleComposition.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange1 = <span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      value1: ev.target.value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange2 = <span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 未使用输入法或使用输入法完毕才能触发</span></span><br><span class="line">    <span class="keyword">if</span> (!isComposition) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value2: ev.target.value,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleComposition(ev) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.type === <span class="string">'compositionend'</span>) &#123;</span><br><span class="line">      isComposition = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      isComposition = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">'text'</span> onChange=&#123;<span class="keyword">this</span>.handleChange1&#125; /&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.value1&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type='text'</span></span><br><span class="line"><span class="regexp">          onChange=&#123;this.handleChange2&#125;</span></span><br><span class="line"><span class="regexp">          onCompositionStart=&#123;this.handleComposition&#125;</span></span><br><span class="line"><span class="regexp">          onCompositionEnd=&#123;this.handleComposition&#125;</span></span><br><span class="line"><span class="regexp">          placeholder='使用了composition的input框'</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.value2&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TestComposition</span><br></pre></td></tr></table></figure>

<p>那么这样就能解决了吗？还不行。</p>
<p>其他浏览器不会有问题，但谷歌浏览器却不行。这里要注意的是谷歌浏览器跟其他浏览器的执行顺序不同：</p>
<blockquote>
<p>谷歌浏览器： compositionstart -&gt; onChange -&gt; compositionend</p>
</blockquote>
<blockquote>
<p>其他浏览器： compositionstart -&gt; compositionend -&gt; onChange</p>
</blockquote>
<p>所以上述代码运行在谷歌浏览器的话，一开始中文输入我们就将 isComposition 设置为 true，最后一步 compositionend 方法我们才将 isComposition 恢复为 true,而 onChange 已经执行完了， 按这个逻辑中文输入法打字都改不了 input 的 value 值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isComposition) &#123;</span><br><span class="line">  <span class="comment">// isComposition为false 才可以执行onChange后续逻辑</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    value2: ev.target.value,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们需要对谷歌浏览器做一次特别处理：</p>
<ol>
<li>判断是否为谷歌浏览器</li>
<li>如果是，则在 compositionend 方法最后再执行一次 onChange 方法</li>
</ol>
<p>最后附上完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isComposition = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> isChrome = navigator.userAgent.indexOf(<span class="string">'Chrome'</span>) &gt; <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestComposition</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value1: <span class="string">''</span>,</span><br><span class="line">      value2: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.handleChange1 = <span class="keyword">this</span>.handleChange1.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.handleChange2 = <span class="keyword">this</span>.handleChange2.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.handleComposition = <span class="keyword">this</span>.handleComposition.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange1 = <span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      value1: ev.target.value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange2 = <span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 未使用输入法或使用输入法完毕才能触发</span></span><br><span class="line">    <span class="keyword">if</span> (!isComposition) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value2: ev.target.value,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleComposition(ev) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.type === <span class="string">'compositionend'</span>) &#123;</span><br><span class="line">      isComposition = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">if</span> (!isComposition &amp;&amp; isChrome) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleChange2(ev)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      isComposition = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">'text'</span> onChange=&#123;<span class="keyword">this</span>.handleChange1&#125; /&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.value1&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type='text'</span></span><br><span class="line"><span class="regexp">          onChange=&#123;this.handleChange2&#125;</span></span><br><span class="line"><span class="regexp">          onCompositionStart=&#123;this.handleComposition&#125;</span></span><br><span class="line"><span class="regexp">          onCompositionEnd=&#123;this.handleComposition&#125;</span></span><br><span class="line"><span class="regexp">          placeholder='使用了composition的input框'</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.value2&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TestComposition</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ac3e7f8896b4d608c1ae46ee22f0866~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>注：</p>
<ul>
<li>Vue 自带解决了上述问题，v-model 有用到 compositionEvent 事件</li>
<li>该做法视乎项目需求场景，因为如果有需要进行搜索中文拼音过程也要提示英文单词的来说，那就没必要了</li>
<li>也可以使用 ref 的方式进行绑定，上述只是其中一种解决方式</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent" target="_blank" rel="noopener">MDN：CompositionEvent</a></li>
<li><a href="https://www.yukapril.com/2019/11/11/react-input-composition.html" target="_blank" rel="noopener">中文输入法在 React 文本输入框的特殊处理</a></li>
</ul>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，鼓励我继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>compositionEvent</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS水平垂直居中回顾总结</title>
    <url>/2020/08/09/CSS%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>用了一段时间的 material-ui，都很少自己动手写原生的样式了。但 html, css, js 始终是前端的三大基础，这周突然想到 CSS 水平居中方案，因为用多了 <code>flex</code> 和 <code>margin: auto</code>等这类方案解决，在回顾还有还有几种方案可以解决，于是打算温故知新，重新打下代码，写下该文作为笔记。</p>
<a id="more"></a>

<p>html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面代码基于上述代码增加，不会再重复写。要实现的效果是让子元素在父元素中水平垂直居中<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d9ccfcd90a64bd58de3cf3e972c5981~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="一、flex-布局"><a href="#一、flex-布局" class="headerlink" title="一、flex 布局"></a>一、flex 布局</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是最经典的用法了，不过，也可以有另一种写法实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    align-self: center;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、absolute-负-margin"><a href="#二、absolute-负-margin" class="headerlink" title="二、absolute + 负 margin"></a>二、absolute + 负 margin</h2><p>该方法适用于知道固定宽高的情况。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、absolute-transform"><a href="#三、absolute-transform" class="headerlink" title="三、absolute + transform"></a>三、absolute + transform</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、absolute-margin-auto"><a href="#四、absolute-margin-auto" class="headerlink" title="四、absolute + margin auto"></a>四、absolute + margin auto</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、absolute-calc"><a href="#五、absolute-calc" class="headerlink" title="五、absolute + calc"></a>五、absolute + calc</h2><p>该方法适用于知道固定宽高的情况。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、text-align-vertical-align"><a href="#六、text-align-vertical-align" class="headerlink" title="六、text-align + vertical-align"></a>六、text-align + vertical-align</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">300px</span>; <span class="comment">/* 等于 parent 的 height */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">line-height</span>: initial; <span class="comment">/* 这样 child 内的文字就不会超出跑到下面 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、table-cell"><a href="#七、table-cell" class="headerlink" title="七、table-cell"></a>七、table-cell</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、Grid"><a href="#八、Grid" class="headerlink" title="八、Grid"></a>八、Grid</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: center;</span><br><span class="line">  <span class="attribute">justify-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、writing-mode"><a href="#九、writing-mode" class="headerlink" title="九、writing-mode"></a>九、writing-mode</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">writing-mode</span>: vertical-lr;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">writing-mode</span>: horizontal-tb;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励吧~</li>
</ul>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>封装 axios 拦截器实现用户无感刷新 access_token</title>
    <url>/2020/07/26/%E5%B0%81%E8%A3%85-axios-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0-access-token/</url>
    <content><![CDATA[<p>最近做项目的时候，涉及到一个单点登录，即是项目的登录页面，用的是公司共用的一个登录页面，在该页面统一处理逻辑。最终实现用户只需登录一次，就可以以登录状态访问公司旗下的所有网站。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>单点登录( Single Sign On ，简称 SSO），是目前比较流行的企业业务整合的解决方案之一，用于多个应用系统间，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
</blockquote>
<p>其中本文讲的是在登录后如何管理<code>access_token</code>和<code>refresh_token</code>，主要就是封装 axios拦截器，在此记录。</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul>
<li>前置场景</li>
</ul>
<ol>
<li><p>进入该项目某个页面<code>http://xxxx.project.com/profile</code>需要登录，未登录就跳转至SSO登录平台，此时的登录网址 url为<code>http://xxxxx.com/login?app_id=project_name_id&amp;redirect_url=http://xxxx.project.com/profile</code>，其中<code>app_id</code>是后台那边约定定义好的，<code>redirect_url</code>是成功授权后指定的回调地址。</p>
</li>
<li><p>输入账号密码且正确后，就会重定向回刚开始进入的页面，并在地址栏带一个参数 <code>?code=XXXXX</code>，即是<code>http://xxxx.project.com/profile?code=XXXXXX</code>，code的值是使用一次后即无效，且10分钟内过期</p>
</li>
<li><p>立马获取这个code值再去请求一个api <code>/access_token/authenticate</code>，携带参数<code>{ verify_code: code }</code>，并且该api已经自带<code>app_id</code>和<code>app_secret</code>两个固定值参数，通过它去请求授权的api，请求成功后得到返回值<code>{ access_token: &quot;xxxxxxx&quot;, refresh_token: &quot;xxxxxxxx&quot;, expires_in: xxxxxxxx }</code>，存下<code>access_token</code>和<code>refresh_token</code>到cookie中（localStorage也可以），此时用户就算登录成功了。</p>
</li>
<li><p><code>access_token</code>为标准JWT格式，是授权令牌，可以理解就是验证用户身份的，是应用在调用api访问和修改用户数据必须传入的参数（放在请求头headers里），2小时后过期。也就是说，做完前三步后，你可以调用需要用户登录才能使用的api；但是假如你什么都不操作，静静过去两个小时后，再去请求这些api，就会报<code>access_token</code>过期，调用失败。</p>
</li>
<li><p>那么总不能2小时后就让用户退出登录吧，解决方法就是两小时后拿着过期的<code>access_token</code>和<code>refresh_token</code>（<code>refresh_token</code>过期时间一般长一些，比如一个月或更长）去请求<code>/refresh</code> api，返回结果为<code>{ access_token: &quot;xxxxx&quot;, expires_in: xxxxx }</code>，换取新的<code>access_token</code>，新的<code>access_token</code>过期时间也是2小时，并重新存到cookie，循环往复继续保持登录调用用户api了。<code>refresh_token</code>在限定过期时间内（比如一周或一个月等），下次就可以继续换取新的<code>access_token</code>，但过了限定时间，就算真正意义过期了，也就要重新输入账号密码来登录了。</p>
</li>
</ol>
<p>公司网站登录过期时间都只有两小时（token过期时间），但又想让一个月内经常活跃的用户不再次登录，于是才有这样需求，避免了用户再次输入账号密码登录。</p>
<p>为什么要专门用一个 <code>refresh_token</code> 去更新 <code>access_token</code> 呢？首先<code>access_token</code>会关联一定的用户权限，如果用户授权更改了，这个<code>access_token</code>也是需要被刷新以关联新的权限的，如果没有 <code>refresh_token</code>，也可以刷新 <code>access_token</code>，但每次刷新都要用户输入登录用户名与密码，多麻烦。有了 <code>refresh_ token</code>，可以减少这个麻烦，客户端直接用 <code>refresh_token</code> 去更新 <code>access_token</code>，无需用户进行额外的操作。</p>
<p>说了这么多，或许有人会吐槽，一个登录用<code>access_token</code>就行了还要加个<code>refresh_token</code>搞得这么麻烦，或者有的公司<code>refresh_token</code>是后台包办的并不需要前端处理。但是，前置场景在那了，需求都是基于该场景下的。</p>
<ul>
<li>需求</li>
</ul>
<ol>
<li><p>当<code>access_token</code>过期的时候，要用<code>refresh_token</code>去请求获取新的<code>access_token</code>，前端需要做到用户无感知的刷新<code>access_token</code>。比如用户发起一个请求时，如果判断<code>access_token</code>已经过期，那么就先要去调用刷新token接口拿到新的<code>access_token</code>，再重新发起用户请求。</p>
</li>
<li><p>如果同时发起多个用户请求，第一个用户请求去调用刷新token接口，当接口还没返回时，其余的用户请求也依旧发起了刷新token接口请求，就会导致多个请求，这些请求如何处理，就是我们本文的内容了。</p>
</li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>写在请求拦截器里，在请求前，先利用最初请求返回的字段<code>expires_in</code>字段来判断<code>access_token</code>是否已经过期，若已过期，则将请求挂起，先刷新<code>access_token</code>后再继续请求。</p>
<ul>
<li>优点： 能节省http请求</li>
<li>缺点： 因为使用了本地时间判断，若本地时间被篡改，有校验失败的风险</li>
</ul>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>写在响应拦截器里，拦截返回后的数据。先发起用户请求，如果接口返回<code>access_token</code>过期，先刷新<code>access_token</code>，再进行一次重试。</p>
<ul>
<li>优点：无需判断时间</li>
<li>缺点： 会消耗多一次http请求</li>
</ul>
<p>在此我选择的是方案二。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里使用axios，其中做的是请求后拦截，所以用到的是axios的响应拦截器<code>axios.interceptors.response.use()</code>方法</p>
<h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><ul>
<li><p>@utils/auth.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Cookies <span class="keyword">from</span> <span class="string">'js-cookie'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TOKEN_KEY = <span class="string">'access_token'</span></span><br><span class="line"><span class="keyword">const</span> REGRESH_TOKEN_KEY = <span class="string">'refresh_token'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getToken = <span class="function"><span class="params">()</span> =&gt;</span> Cookies.get(TOKEN_KEY)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setToken = <span class="function">(<span class="params">token, params = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  Cookies.set(TOKEN_KEY, token, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setRefreshToken = <span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</span><br><span class="line">  Cookies.set(REGRESH_TOKEN_KEY, token)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>request.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken, setToken, getRefreshToken &#125; <span class="keyword">from</span> <span class="string">'@utils/auth'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新 access_token 的接口</span></span><br><span class="line"><span class="keyword">const</span> refreshToken = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> instance.post(<span class="string">'/auth/refresh'</span>, &#123; <span class="attr">refresh_token</span>: getRefreshToken() &#125;, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 axios 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL:  process.env.GATSBY_API_URL,</span><br><span class="line">  timeout: <span class="number">30000</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error.response) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// token 过期或无效，返回 401 状态码，在此处理逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给请求头添加 access_token</span></span><br><span class="line"><span class="keyword">const</span> setHeaderToken = <span class="function">(<span class="params">isNeedToken</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> accessToken = isNeedToken ? getToken() : <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (isNeedToken) &#123; <span class="comment">// api 请求需要携带 access_token </span></span><br><span class="line">    <span class="keyword">if</span> (!accessToken) &#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'不存在 access_token 则跳转回登录页'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    instance.defaults.headers.common.Authorization = <span class="string">`Bearer <span class="subst">$&#123;accessToken&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有些 api 并不需要用户授权使用，则不携带 access_token；默认不携带，需要传则设置第三个参数为 true</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="keyword">get</span> = (url, params = &#123;&#125;, isNeedToken = <span class="literal">false</span>) =&gt; &#123;</span><br><span class="line">  setHeaderToken(isNeedToken)</span><br><span class="line">  <span class="keyword">return</span> instance(&#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    url,</span><br><span class="line">    params,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> post = <span class="function">(<span class="params">url, params = &#123;&#125;, isNeedToken = <span class="literal">false</span></span>) =&gt;</span> &#123;</span><br><span class="line">  setHeaderToken(isNeedToken)</span><br><span class="line">  <span class="keyword">return</span> instance(&#123;</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    url,</span><br><span class="line">    data: params,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>接下来改造 request.js中axios的响应拦截器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error.response) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error.response.status === <span class="number">401</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; config &#125; = error</span><br><span class="line">        <span class="keyword">return</span> refreshToken().then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; access_token &#125; = res.data</span><br><span class="line">            setToken(access_token)</span><br><span class="line">            config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;access_token&#125;</span>`</span></span><br><span class="line">            <span class="keyword">return</span> instance(config)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'抱歉，您的登录状态已失效，请重新登录！'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>约定返回401状态码表示<code>access_token</code>过期或者无效，如果用户发起一个请求后返回结果是<code>access_token</code>过期，则请求刷新<code>access_token</code>的接口。请求成功则进入<code>then</code>里面，重置配置，并刷新<code>access_token</code>并重新发起原来的请求。</p>
<p>但如果<code>refresh_token</code>也过期了，则请求也是返回401。此时调试会发现函数进不到<code>refreshToken()</code>的<code>catch</code>里面，那是因为<code>refreshToken()</code>方法内部是也是用了同个<code>instance</code>实例，重复响应拦截器401的处理逻辑，但该函数本身就是刷新<code>access_token</code>，故需要把该接口排除掉，即：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (error.response.status === <span class="number">401</span> &amp;&amp; !error.config.url.includes(<span class="string">'/auth/refresh'</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就已经实现了无感刷新<code>access_token</code>了，当<code>access_token</code>没过期，正常返回；过期时，则axios内部进行了一次刷新token的操作，再重新发起原来的请求。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="防止多次刷新-token"><a href="#防止多次刷新-token" class="headerlink" title="防止多次刷新 token"></a>防止多次刷新 token</h3><p>如果token是过期的，那请求刷新<code>access_token</code>的接口返回也是有一定时间间隔，如果此时还有其他请求发过来，就会再执行一次刷新<code>access_token</code>的接口，就会导致多次刷新<code>access_token</code>。因此，我们需要做一个判断，定义一个标记判断当前是否处于刷新<code>access_token</code>的状态，如果处在刷新状态则不再允许其他请求调用该接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isRefreshing = <span class="literal">false</span> <span class="comment">// 标记是否正在刷新 token</span></span><br><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error.response) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error.response.status === <span class="number">401</span> &amp;&amp; !error.config.url.includes(<span class="string">'/auth/refresh'</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; config &#125; = error</span><br><span class="line">        <span class="keyword">if</span> (!isRefreshing) &#123;</span><br><span class="line">            isRefreshing = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> refreshToken().then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; access_token &#125; = res.data</span><br><span class="line">                setToken(access_token)</span><br><span class="line">                config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;access_token&#125;</span>`</span></span><br><span class="line">                <span class="keyword">return</span> instance(config)</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'抱歉，您的登录状态已失效，请重新登录！'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">            &#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                isRefreshing = <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="同时发起多个请求的处理"><a href="#同时发起多个请求的处理" class="headerlink" title="同时发起多个请求的处理"></a>同时发起多个请求的处理</h3><p>上面做法还不够，因为如果同时发起多个请求，在token过期的情况，第一个请求进入刷新token方法，则其他请求进去没有做任何逻辑处理，单纯返回失败，最终只执行了第一个请求，这显然不合理。</p>
<p>比如同时发起三个请求，第一个请求进入刷新token的流程，第二个和第三个请求需要存起来，等到token更新后再重新发起请求。</p>
<p>在此，我们定义一个数组<code>requests</code>，用来保存处于等待的请求，之后返回一个<code>Promise</code>，只要不调用<code>resolve</code>方法，该请求就会处于等待状态，则可以知道其实数组存的是函数；等到token更新完毕，则通过数组循环执行函数，即逐个执行resolve重发请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isRefreshing = <span class="literal">false</span> <span class="comment">// 标记是否正在刷新 token</span></span><br><span class="line"><span class="keyword">let</span> requests = [] <span class="comment">// 存储待重发请求的数组</span></span><br><span class="line"></span><br><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error.response) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error.response.status === <span class="number">401</span> &amp;&amp; !error.config.url.includes(<span class="string">'/auth/refresh'</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; config &#125; = error</span><br><span class="line">        <span class="keyword">if</span> (!isRefreshing) &#123;</span><br><span class="line">            isRefreshing = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> refreshToken().then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; access_token &#125; = res.data</span><br><span class="line">                setToken(access_token)</span><br><span class="line">                config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;access_token&#125;</span>`</span></span><br><span class="line">                <span class="comment">// token 刷新后将数组的方法重新执行</span></span><br><span class="line">                requests.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(access_token))</span><br><span class="line">                requests = [] <span class="comment">// 重新请求完清空</span></span><br><span class="line">                <span class="keyword">return</span> instance(config)</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'抱歉，您的登录状态已失效，请重新登录！'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">            &#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                isRefreshing = <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回未执行 resolve 的 Promise</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 用函数形式将 resolve 存入，等待刷新后再执行</span></span><br><span class="line">                requests.push(<span class="function"><span class="params">token</span> =&gt;</span> &#123;</span><br><span class="line">                    config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">                    resolve(instance(config))</span><br><span class="line">                &#125;)  </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最终 request.js 代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken, setToken, getRefreshToken &#125; <span class="keyword">from</span> <span class="string">'@utils/auth'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新 access_token 的接口</span></span><br><span class="line"><span class="keyword">const</span> refreshToken = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> instance.post(<span class="string">'/auth/refresh'</span>, &#123; <span class="attr">refresh_token</span>: getRefreshToken() &#125;, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 axios 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL:  process.env.GATSBY_API_URL,</span><br><span class="line">  timeout: <span class="number">30000</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isRefreshing = <span class="literal">false</span> <span class="comment">// 标记是否正在刷新 token</span></span><br><span class="line"><span class="keyword">let</span> requests = [] <span class="comment">// 存储待重发请求的数组</span></span><br><span class="line"></span><br><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error.response) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error.response.status === <span class="number">401</span> &amp;&amp; !error.config.url.includes(<span class="string">'/auth/refresh'</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; config &#125; = error</span><br><span class="line">        <span class="keyword">if</span> (!isRefreshing) &#123;</span><br><span class="line">            isRefreshing = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> refreshToken().then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; access_token &#125; = res.data</span><br><span class="line">                setToken(access_token)</span><br><span class="line">                config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;access_token&#125;</span>`</span></span><br><span class="line">                <span class="comment">// token 刷新后将数组的方法重新执行</span></span><br><span class="line">                requests.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(access_token))</span><br><span class="line">                requests = [] <span class="comment">// 重新请求完清空</span></span><br><span class="line">                <span class="keyword">return</span> instance(config)</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'抱歉，您的登录状态已失效，请重新登录！'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">            &#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                isRefreshing = <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回未执行 resolve 的 Promise</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 用函数形式将 resolve 存入，等待刷新后再执行</span></span><br><span class="line">                requests.push(<span class="function"><span class="params">token</span> =&gt;</span> &#123;</span><br><span class="line">                    config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">                    resolve(instance(config))</span><br><span class="line">                &#125;)  </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给请求头添加 access_token</span></span><br><span class="line"><span class="keyword">const</span> setHeaderToken = <span class="function">(<span class="params">isNeedToken</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> accessToken = isNeedToken ? getToken() : <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (isNeedToken) &#123; <span class="comment">// api 请求需要携带 access_token </span></span><br><span class="line">    <span class="keyword">if</span> (!accessToken) &#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'不存在 access_token 则跳转回登录页'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    instance.defaults.headers.common.Authorization = <span class="string">`Bearer <span class="subst">$&#123;accessToken&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有些 api 并不需要用户授权使用，则无需携带 access_token；默认不携带，需要传则设置第三个参数为 true</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="keyword">get</span> = (url, params = &#123;&#125;, isNeedToken = <span class="literal">false</span>) =&gt; &#123;</span><br><span class="line">  setHeaderToken(isNeedToken)</span><br><span class="line">  <span class="keyword">return</span> instance(&#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    url,</span><br><span class="line">    params,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> post = <span class="function">(<span class="params">url, params = &#123;&#125;, isNeedToken = <span class="literal">false</span></span>) =&gt;</span> &#123;</span><br><span class="line">  setHeaderToken(isNeedToken)</span><br><span class="line">  <span class="keyword">return</span> instance(&#123;</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    url,</span><br><span class="line">    data: params,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>參考文章</li>
</ul>
<p><a href="https://juejin.im/post/5d5ccdd75188255625591357" target="_blank" rel="noopener">https://juejin.im/post/5d5ccdd75188255625591357</a></p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手带你入门Gatsby</title>
    <url>/2020/07/12/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8Gatsby/</url>
    <content><![CDATA[<p>最近在学习 Gatsby，它主要有 SEO 好，而且首页渲染快等优点，在国外很流行的一个框架，这篇长文带你入个门。Gatsby 是一个静态站点生成器，Gatsby 主要的应用的技术是 React 和 GraphQL…</p>
<a id="more"></a>

<h2 id="Gatsby-介绍"><a href="#Gatsby-介绍" class="headerlink" title="Gatsby 介绍"></a>Gatsby 介绍</h2><h3 id="什么是-Gatsby"><a href="#什么是-Gatsby" class="headerlink" title="什么是 Gatsby"></a>什么是 Gatsby</h3><p>Gatsby 是一个基于 React ，用于搭建静态站点的开源框架，用于帮助开发者构建运行速度极快的网站。可以说它是一个静态站点生成器，Gatsby 主要的应用的技术是 React 和 GraphQL。</p>
<p>官网：<a href="https://www.gatsbyjs.org/" target="_blank" rel="noopener">https://www.gatsbyjs.org/</a></p>
<h3 id="为什么选-Gatsby"><a href="#为什么选-Gatsby" class="headerlink" title="为什么选 Gatsby"></a>为什么选 Gatsby</h3><p>Gatsby 能快速使用 React 生态系统来生成静态网站，它具备更高的性能，而且 Gatsby 的生态也很强大。</p>
<p>当你想自己动手搭建个人博客时，考虑的是 SEO 要好，而且你不用理会数据库和服务器等复杂的部署设置，Gatsby 构建的网站为静态站点，你可以很轻松的将网站部署在很多服务上。Gatsby 不需要等待请求时生成页面，而是预先生成页面，因此网站的速度会很快。</p>
<p>Gatsby 中运用了 React, react-router, Webpack 以及 GraphQL 等新技术，也跟随了技术潮流。</p>
<h2 id="GraphQL-介绍"><a href="#GraphQL-介绍" class="headerlink" title="GraphQL 介绍"></a>GraphQL 介绍</h2><p>上面我们说到了 GraphQL，没了解的同学可能不太清楚。</p>
<blockquote>
<p>GraphQL 是一种用于 API 的查询语言，是 Restful API 的替代品。</p>
</blockquote>
<p>至于替代 Restful API 一说，个人觉得现在 Restful API 占据绝对的主导地位，当前还是很难被撼动的。因为目前来看，GraphQL 也有它的缺点。</p>
<p>看到这里没学过 GraphQL 也不用怕，因为用到的不多而且 Gatsby 内置一个界面方便我们操作。GraphQL 目前国外比较火，它作为一门新技术，即使不深入我们也可以了解一下。</p>
<p>这里我们当然要吹捧它的优点，上面的定义你可能会疑惑，API 不就是后端写好的接口吗，怎么还能查询？</p>
<p>GraphQL 我们把这个单词拆开的话是： Graph(图形或图表) + QL（Query Language），它是一种图形化的查询语言，描述客户端如何像服务端请求数据的语法规范。听起来模模糊糊，那它相对 Restful API 又解决了什么痛点呢？</p>
<ol>
<li>请求你所要的数据不多不少</li>
</ol>
<p>相信多数人肯定遇到过的场景，比如项目管理系统，进入某页面展示一个列表，列表上只需展示标题，但你请求返回的数据却多了其他信息，比如创建者、创建时间等。这些信息在这里是多余的，但它可能有它自己存在的理由，或许是其他场景需要返回这些信息，因此该接口就直接包含了所有数据。</p>
<p>这一点，GraphQL 能准确获取你想要的数据，不多不少，想要返回指定的什么数据，就返回什么数据。数据由应用来控制，而不是服务器。</p>
<ol start="2">
<li>获取多个资源只需要一个请求</li>
</ol>
<p>GraphQL 查询不仅能够获得资源的属性，还能沿着资源间引用进一步查询。典型的 REST API 请求多个资源时得载入多个 URL，而 GraphQL 可以通过一次请求就获取你应用所需的所有数据。这样一来，即使是比较慢的移动网络连接下，使用 GraphQL 的应用也能表现得足够迅速。</p>
<ol start="3">
<li>描述所有的可能类型系统</li>
</ol>
<p>GraphQL API 基于类型和字段的方式进行组织，而非入口端点。你可以通过一个单一入口端点得到你所有的数据能力。GraphQL 使用类型来保证应用只请求可能的数据，还提供了清晰的辅助性错误信息。应用可以使用类型，而避免编写手动解析代码。</p>
<p>Gatsby 使用了 GraphQL，作为在本地管理资源的一种方式。</p>
<h2 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul>
<li>安装 Gatsby 脚手架</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g gatsby-cli</span><br></pre></td></tr></table></figure>

<ul>
<li>新建项目</li>
</ul>
<blockquote>
<p>gatsby new [projectName][starter]：根据 starter 创建一个新项目</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gatsby new gatsby-blog-demo https:&#x2F;&#x2F;github.com&#x2F;gatsbyjs&#x2F;gatsby-starter-hello-world</span><br></pre></td></tr></table></figure>

<p>我们这里使用官方最简单版本的 hello-world 模板进行开发，如果你直接使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gatsby new gatsby-blog-demo</span><br></pre></td></tr></table></figure>

<p>默认会使用 <a href="https://github.com/gatsbyjs/gatsby-starter-default" target="_blank" rel="noopener">gatsby-starter-default</a> 来新建项目</p>
<ul>
<li>运行项目</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd gatsby-blog-demo</span><br><span class="line">gatsby develop</span><br></pre></td></tr></table></figure>

<p>打开 <code>localhost:8000</code>，就可以看到输出了一句<code>Hello world!</code></p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>这里介绍 Gatsby 的几个常用命令：</p>
<ul>
<li>gastby develop：开启热加载开发环境</li>
<li>gastby build：打包到 public 下，构建生产环境用的优化过的静态网站所需的一切静态资源、静态页面与 js 代码</li>
<li>gatsby serve：在打包之后，启动一个本地的服务，供你测试刚才”gatsby build”生成的静态网页</li>
</ul>
<h3 id="GraphiQL"><a href="#GraphiQL" class="headerlink" title="GraphiQL"></a>GraphiQL</h3><p>打开<code>http://localhost:8000/__graphql</code>，就会看到 GraphQL 的调试界面，这里可以查看所有的数据、以及调试 query 语句是否返回相应的数据。可以直接在左侧点击选中，就可以自动生成 query 语句。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d4b8f913506df?w=1922&h=538&f=png&s=78717" alt=""></p>
<h3 id="可能出现的警告"><a href="#可能出现的警告" class="headerlink" title="可能出现的警告"></a>可能出现的警告</h3><p>如果运行后你的控制台出现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">React-Hot-Loader: react-🔥-dom patch is not detected. React 16.6+ features may not work.</span><br></pre></td></tr></table></figure>

<p>可以这样解决:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @hot-loader&#x2F;react-dom</span><br></pre></td></tr></table></figure>

<p>在根目录下新建<code>gatsby-node.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.onCreateWebpackConfig &#x3D; (&#123; getConfig, stage &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  const config &#x3D; getConfig()</span><br><span class="line">  if (stage.startsWith(&#39;develop&#39;) &amp;&amp; config.resolve) &#123;</span><br><span class="line">    config.resolve.alias &#x3D; &#123;</span><br><span class="line">      ...config.resolve.alias,</span><br><span class="line">      &#39;react-dom&#39;: &#39;@hot-loader&#x2F;react-dom&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再重新启动项目，就可以消除这个警告</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── .cache</span><br><span class="line">├── public</span><br><span class="line">├── src</span><br><span class="line">|  └── pages            &#x2F;&#x2F; 该文件夹下的文件会被映射为路由</span><br><span class="line">|     └── index.js</span><br><span class="line">├── static              &#x2F;&#x2F; 静态资源</span><br><span class="line">├── .prettierignore</span><br><span class="line">├── .prettierrc</span><br><span class="line">├── gatsby-config.js    &#x2F;&#x2F; 基本配置文件</span><br><span class="line">├── LICENSE</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure>

<h2 id="Gatsby-配置文件"><a href="#Gatsby-配置文件" class="headerlink" title="Gatsby 配置文件"></a>Gatsby 配置文件</h2><p>这里最初始的模板只有一个配置文件，一般项目中都会有 4 个配置文件</p>
<h3 id="gatsby-config-js"><a href="#gatsby-config-js" class="headerlink" title="gatsby-config.js"></a>gatsby-config.js</h3><p>基本配置文件。整个 Gatsby 站点的配置文件。可以在里面配置网站的相关基本信息。</p>
<h3 id="gatsby-node-js"><a href="#gatsby-node-js" class="headerlink" title="gatsby-node.js"></a>gatsby-node.js</h3><p>node 相关配置文件。这个文件只会在 build 期间运行一次，比如动态创建一些页面。</p>
<h3 id="gatsby-browser-js"><a href="#gatsby-browser-js" class="headerlink" title="gatsby-browser.js"></a>gatsby-browser.js</h3><p>客户端相关配置。一些浏览器相关的 API 通过在这个文件里去实现，比如一些监听路由变化，注册 serviceWorker 等等。</p>
<h3 id="gatsby-ssr-js"><a href="#gatsby-ssr-js" class="headerlink" title="gatsby-ssr.js"></a>gatsby-ssr.js</h3><p>服务端渲染相关配置文件。使用 Gatsby 的服务端渲染 API 自定义影响服务端渲染的默认设置。</p>
<h2 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h2><h3 id="路由页"><a href="#路由页" class="headerlink" title="路由页"></a>路由页</h3><p>我们在 <code>pages</code>目录下创建一个文件<code>about.js</code>，则对应的路由路径为<code>/about</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>about me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> About</span><br></pre></td></tr></table></figure>

<p>打开<code>http://localhost:8000/about</code>，显示的是我们刚刚创建的页面</p>
<h3 id="404-页面"><a href="#404-页面" class="headerlink" title="404 页面"></a>404 页面</h3><p><code>pages</code>目录下的文件名即是路由路径，但有一个比较特殊，当匹配不到路径时，Gatsby 会跳转到 404 页面，如果我们在 pages 下创建文件名<code>404.js</code>，会使用我们自定义的 404 页面。当前我们随便输入一个不存在的页面路径：<code>http://localhost:8000/test</code>，页面就会报错。</p>
<p>我们新建一个文件 404.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>404 页面不存在<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> About</span><br></pre></td></tr></table></figure>

<p>再随便输入一个路径，显示出该页面：<br><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d52ba499ad501?w=1223&h=404&f=png&s=37041" alt=""></p>
<p>Gatsby 会确保将 404 页面构建为 404.html，默认情况下会为我们创建此页面，在该页面也列出了网站上的所有页面路由链接,我们可以通过单击<code>Preview custom 404 page</code>看我们刚才创建的 404 页面。</p>
<p>那我们想直接跳转到我们自定义的 404 页面啊，还要我们点击才跳转。原因是处于开发环境，即当使用 <code>gatsby develop</code>时，Gatsby 使用默认的 404 页面覆盖我们自定义的 404 页面，但实际上是已经生效了。</p>
<p>我们可以打包，启动一个本地的服务，模拟处于线上环境来看，这个时候才是直接显示我们自定义的 404 页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gatsby build</span><br><span class="line">gatsby serve</span><br></pre></td></tr></table></figure>

<p>然后打开<code>http://localhost:9000/test</code>（任意路径），就能跳转到我们自定义的 404 页面了</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d5e52ae8fcd52?w=334&h=102&f=png&s=3896" alt=""></p>
<h3 id="创建布局组件"><a href="#创建布局组件" class="headerlink" title="创建布局组件"></a>创建布局组件</h3><ol>
<li><p>创建一个新目录 <code>src/components</code>。</p>
</li>
<li><p>在上面的目录中创建一个布局组件文件 src/components/layout.js：</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; children &#125;) =&gt; (</span><br><span class="line">  &lt;div style=&#123;&#123; <span class="attr">margin</span>: <span class="string">`3rem auto`</span>, <span class="attr">maxWidth</span>: <span class="number">650</span>, <span class="attr">padding</span>: <span class="string">`0 1rem`</span> &#125;&#125;&gt;&#123;children&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在<code>src/pages/index.js</code>中，加入 Layout 组件，</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../components/layout'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Layout</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就让整体页面居中了，这里都是 React 的基本操作</p>
<h2 id="设置-CSS-样式"><a href="#设置-CSS-样式" class="headerlink" title="设置 CSS 样式"></a>设置 CSS 样式</h2><p>Gatsby 中样式可以使用多种形式，普通的 <code>import &#39;./xxx.css</code>我们就不说了。</p>
<h3 id="使用全局样式"><a href="#使用全局样式" class="headerlink" title="使用全局样式"></a>使用全局样式</h3><p>我们向网站添加全局样式的最直接的方法之一就是使用全局 .css 样式表。</p>
<p>在 src 目录下新建文件夹<code>styles</code>，添加一个 global.css 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  background-color: #f5f5f5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在目录下创建 gatsby-browser.js 中，将样式文件导入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;.&#x2F;src&#x2F;styles&#x2F;global.css&quot;</span><br></pre></td></tr></table></figure>

<p>重启本地服务，就发现页面背景变为浅灰色了。</p>
<h3 id="使用-CSS-Module-为组件设置样式"><a href="#使用-CSS-Module-为组件设置样式" class="headerlink" title="使用 CSS Module 为组件设置样式"></a>使用 CSS Module 为组件设置样式</h3><p>CSS Module 可以减少全局污染、防止命名冲突和样式的覆盖。</p>
<blockquote>
<p>CSS Module 实现原理是：将所有模块化的类名，修改为成唯一的名称，即添加一些不重复的前缀或后缀。这样使得项目中，不同人员编写的样式不会出现覆盖和冲突。</p>
</blockquote>
<ol>
<li>创建 CSS 文件 <code>src/styles/index.module.css</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">.text &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用法如下：<code>src/pages/index.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;</span><br><span class="line">import Layout from &quot;..&#x2F;components&#x2F;layout&quot;</span><br><span class="line">import styles from &quot;..&#x2F;styles&#x2F;index.module.css&quot;</span><br><span class="line"></span><br><span class="line">export default function Home() &#123;</span><br><span class="line">  console.log(styles)</span><br><span class="line">  return (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;h1 className&#x3D;&#123;styles.title&#125;&gt;Hello World&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;div className&#x3D;&#123;styles.text&#125;&gt;Test&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;Layout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d61d3f95cadf0?w=718&h=174&f=png&s=5935" alt=""></p>
<p>输出 <code>styles</code>,可以看到被导入处理的结果:</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d61cc37846a59?w=514&h=68&f=png&s=6441" alt=""><br>如果将其与 CSS 文件进行比较，你会发现每个格式现在都是导入对象中指向长字符串的键（key），例如 <code>title</code> 指向 <code>index-module--title--1i-Wh</code>。 这些样式名称是 CSS 模块生成的。 保证它们在你的网站上是唯一的。 而且由于必须导入它们才能使用这些类，所以对于在任何地方使用这些 CSS 样式都没问题。</p>
<h3 id="其他处理-CSS-的方式"><a href="#其他处理-CSS-的方式" class="headerlink" title="其他处理 CSS 的方式"></a>其他处理 CSS 的方式</h3><p>使用 css 样式就点到为止了，其他的比如 Sass 等；还有 CSS in JS 的方式，比如 Emotion, Styled Component。可以去官网查看相应支持的 Gatsby 插件，就可以使用了。</p>
<h2 id="获取-Gatsby-中的数据"><a href="#获取-Gatsby-中的数据" class="headerlink" title="获取 Gatsby 中的数据"></a>获取 Gatsby 中的数据</h2><p>建立网站时，您可能需要重用一些常用的数据——比如公用的网站标题、作者信息等，我们不可能在每个页面都加，所以我们把标题存储在一个位置，然后从其他文件引用该位置就行了，更改的时候也只能更改这一处地方。</p>
<p>这些常用数据的存放位置就是 <code>gatsby-config.js</code> 文件中的 <code>siteMetadata</code> 对象。打开这个文件，写入代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;* Your site config here *&#x2F;</span><br><span class="line">  siteMetadata: &#123;</span><br><span class="line">    title: &#96;Title from siteMetadata&#96;,</span><br><span class="line">    author: &#39;jacky&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<h3 id="使用页面查询"><a href="#使用页面查询" class="headerlink" title="使用页面查询"></a>使用页面查询</h3><p>编辑 <code>src/pages/about.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">'gatsby'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GraphQL 获取的数据，会当做参数传递到页面组件中</span></span><br><span class="line"><span class="comment">// 数据的形式是 &#123; errors, data &#125;，没有错误则不会有 errors</span></span><br><span class="line"><span class="keyword">const</span> About = <span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.site.siteMetadata.title)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Title: &#123;data.site.siteMetadata.title&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;author: &#123;data.site.siteMetadata.author&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;div&gt;about me&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> About</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> query = graphql<span class="string">`</span></span><br><span class="line"><span class="string">  query &#123;</span></span><br><span class="line"><span class="string">    site &#123;</span></span><br><span class="line"><span class="string">      siteMetadata &#123;</span></span><br><span class="line"><span class="string">        title</span></span><br><span class="line"><span class="string">        author</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>然后就拉出数据了</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d63bec7bccdeb?w=576&h=188&f=png&s=10256" alt=""></p>
<p>其中，GraphQL 查询语句是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  site &#123;</span><br><span class="line">    siteMetadata &#123;</span><br><span class="line">      title,</span><br><span class="line">      author</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会懵逼， site 是哪里来的，这数据格式怎么是这样，这就是 GraphQL 查询语句了，我们可以打开 Gatsby 内置的 GraphQL 调试界面 <code>http://localhost:8000/__graphql</code>。</p>
<p>这里的<code>site</code>即为我们<code>gatsby-config.js</code>写的站点配置。</p>
<p>依次点击左边的<code>site</code>、<code>siteMetadata</code>，然后有我们刚才写的<code>title</code>,<code>author</code>字段 供我们选择，在点击的同时，中间的框会生成查询语句，最后点击运行按钮，会输出查询结果。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d660d32ae1825?w=1442&h=642&f=png&s=61514" alt=""></p>
<p>当你后面需要获取更多复杂嵌套数据的时候，可以直接在这个界面找和点击，自动生成查询语句就行了。</p>
<p>由我们自己写的查询语句也知道，上面我们介绍 GraphQL 的时候说的一个特点，获取数据不多不少，即我们可以选择想要的数据，比如我就想获取标题不想获取作者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const query &#x3D; graphql&#96;</span><br><span class="line">  query &#123;</span><br><span class="line">    site &#123;</span><br><span class="line">      siteMetadata &#123;</span><br><span class="line">        title</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>

<h3 id="使用非页面组件查询（静态查询）"><a href="#使用非页面组件查询（静态查询）" class="headerlink" title="使用非页面组件查询（静态查询）"></a>使用非页面组件查询（静态查询）</h3><p>这里注意，我们需要区分两种方式的查询，上面的例子的查询方式，只适用于页面查询，即是在<code>src/pages</code>下的路由界面，如果在非页面组件下进行 GraphQL 查询，则不能用上面的方式，应该使用 <code>StaticQuery</code> 组件或者 <code>useStaticQuery hook</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 页面查询</span><br><span class="line">export const query &#x3D; graphql&#96;</span><br><span class="line">    query&#123; ... &#125;</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>

<p>比如我们创建一个组件<code>src/components/header.js</code></p>
<ul>
<li>StaticQuery</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; graphql, StaticQuery &#125; <span class="keyword">from</span> <span class="string">'gatsby'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Header = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;StaticQuery</span><br><span class="line">    query=&#123;graphql<span class="string">`</span></span><br><span class="line"><span class="string">      query &#123;</span></span><br><span class="line"><span class="string">        site &#123;</span></span><br><span class="line"><span class="string">          siteMetadata &#123;</span></span><br><span class="line"><span class="string">            author</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    `</span>&#125;</span><br><span class="line">    render=&#123;data =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;</span><br><span class="line">        site: &#123; siteMetadata &#125;,</span><br><span class="line">      &#125; = data</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是Header组件，作者是：&#123;siteMetadata.author&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header</span><br></pre></td></tr></table></figure>

<p>或者使用 useStaticQuery 方式</p>
<ul>
<li>useStaticQuery</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;</span><br><span class="line">import &#123; useStaticQuery, graphql &#125; from &quot;gatsby&quot;</span><br><span class="line"></span><br><span class="line">const Header &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const data &#x3D; useStaticQuery(</span><br><span class="line">    graphql&#96;</span><br><span class="line">      query &#123;</span><br><span class="line">        site &#123;</span><br><span class="line">          siteMetadata &#123;</span><br><span class="line">            author</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#96;</span><br><span class="line">  )</span><br><span class="line">  return &lt;div&gt;这是Header组件，作者是：&#123;data.site.siteMetadata.author&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Header</span><br></pre></td></tr></table></figure>

<p>然后在<code>src/pages/index.js</code>中引入 Header 组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../components/layout'</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'../components/header'</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'../styles/index.module.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;h1 className=&#123;styles.title&#125;&gt;Hello World&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className=&#123;styles.text&#125;&gt;Test&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/Layout&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d6d9b2afff80c?w=705&h=203&f=png&s=8464" alt=""></p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="gatsby-source-filesystem"><a href="#gatsby-source-filesystem" class="headerlink" title="gatsby-source-filesystem"></a>gatsby-source-filesystem</h3><p>这个是 Gatsby 的数据源插件，即通过该插件将各方面的数据转换为本地能够通过 GraphQL 提取的内容，用于设置项目的文件系统。</p>
<ul>
<li>安装插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save gatsby-source-filesystem</span><br></pre></td></tr></table></figure>

<ul>
<li>在 gatsby-config.js 文件配置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  siteMetadata: &#123;</span><br><span class="line">    title: <span class="string">`Title from siteMetadata`</span>,</span><br><span class="line">    author: <span class="string">'jacky'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    &#123;</span><br><span class="line">      resolve: <span class="string">`gatsby-source-filesystem`</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        name: <span class="string">`src`</span>, <span class="comment">// 名称，可以用来过滤</span></span><br><span class="line">        path: <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/src/`</span>, <span class="comment">// 文件路径</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<p>打开<code>http://localhost:8000/__graphql</code>，关注<code>allFile</code>和<code>file</code>两个可选项。</p>
<p>我们点击 <code>allFile</code>这个可选项，依次选择如下图</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d74ca7b60229d?w=1542&h=928&f=png&s=113095" alt=""></p>
<p>这里我们要知道，我们要查询的数据基本在<code>edges.node</code>下，节点 <code>node</code>是图（graph）中一个对象的特殊称呼，每个 File 节点都包含了你要查询的字段。</p>
<p>我们选择的<code>id</code>,<code>relativePath</code>,<code>name</code>字段都对应我们 <code>src</code>目录下创建的文件, 还有很多其他字段可选择，由此可知我们创建的 7 个文件的各种信息。</p>
<p>既然这里能查询出来，说明我们组件里面也能查出来然后使用数据，比如你可以从组件中查询出来做个文件列表。</p>
<p>这个相比传统的 React 项目就挺厉害了，不用做什么复杂的工作，就能轻松拿下这些数据。Gatsby 比较强大的就是它的生态了，很多插件都配好了，更多插件可以看官网的插件库介绍：<a href="https://www.gatsbyjs.org/plugins/" target="_blank" rel="noopener">https://www.gatsbyjs.org/plugins/</a></p>
<h3 id="gatsby-transformer-remark"><a href="#gatsby-transformer-remark" class="headerlink" title="gatsby-transformer-remark"></a>gatsby-transformer-remark</h3><p>这个是数据转换插件，我们用 Gatsby 做个人博客的话，它可必不可少。现在我们程序员写博客基本是用 markdown 语法了，做一个博客的话，不可缺少的就是对 markdown 语法的解析。</p>
<ul>
<li>安装插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save gatsby-transformer-remark</span><br></pre></td></tr></table></figure>

<ul>
<li>在 gatsby-config.js 文件配置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">/* Your site config here */</span></span><br><span class="line">  siteMetadata: &#123;</span><br><span class="line">    title: <span class="string">`Title from siteMetadata`</span>,</span><br><span class="line">    author: <span class="string">'jacky'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    &#123;</span><br><span class="line">      resolve: <span class="string">`gatsby-source-filesystem`</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        name: <span class="string">`src`</span>, <span class="comment">// 名称，可以用来过滤</span></span><br><span class="line">        path: <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/src/`</span>, <span class="comment">// 文件路径</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">`gatsby-transformer-remark`</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务</p>
<p>这个插件添加了 allMarkdownRemark 和 markdownRemark 两个数据字段</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d7761605cba2b?w=205&h=243&f=png&s=7538" alt=""></p>
<ul>
<li>新建 md 文件</li>
</ul>
<p>在<code>src</code>下创建<code>_posts</code>目录，添加一个<code>first-blog.md</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;我的第一篇博客&quot;</span><br><span class="line">date: &quot;2020-06-21&quot;</span><br><span class="line">tags: &quot;React&quot;</span><br><span class="line">categories: &quot;React系列&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 这是第一篇博客的标题</span><br><span class="line"></span><br><span class="line">first blog 的内容 1</span><br></pre></td></tr></table></figure>

<p>如果博客不是自己搭建的，而是直接上某平台写的话，对上面这段语法就可能不太了解，在 md 文件开头的 <code>---</code> 包裹的是 frontmatter（前言），然后在里面可以添加文章的各种关键词信息。</p>
<p>然后我们就可以在<code>http://localhost:8000/__graphql</code>查询到我们写的 md 文件的详情信息了</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d7823d4e7db7f?w=1703&h=499&f=png&s=61510" alt=""></p>
<p>我们稍微再改动，创建多两个 md 文件</p>
<p><code>second-blog.md</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;我的第二篇博客&quot;</span><br><span class="line">date: &quot;2020-06-22&quot;</span><br><span class="line">tags: &quot;Vue&quot;</span><br><span class="line">categories: &quot;Vue系列&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 这是第二篇博客的标题</span><br><span class="line"></span><br><span class="line">second blog 的内容 2</span><br></pre></td></tr></table></figure>

<p><code>third-blog.md</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;我的第三篇博客&quot;</span><br><span class="line">date: &quot;2020-06-23&quot;</span><br><span class="line">tags: &quot;React&quot;</span><br><span class="line">categories: &quot;React系列&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 这是第三篇博客的标题</span><br><span class="line"></span><br><span class="line">third blog 的内容 3</span><br></pre></td></tr></table></figure>

<p>再次查询数据，把我们刚刚添加的文章数据都拿下来了</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d78dc41c94349?w=599&h=687&f=png&s=41548" alt=""></p>
<p>既然 GraphQL 能拿到数据，说明我们也能把它放到页面展示出来。</p>
<p>新建文件<code>src/pages/blog.js</code>,我们做一个博客目录汇总：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../components/layout'</span></span><br><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">'gatsby'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Blog = <span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;h1&gt;博客目录&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;data.allMarkdownRemark.edges.map((&#123; node &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          return (</span></span><br><span class="line"><span class="regexp">            &lt;div</span></span><br><span class="line"><span class="regexp">              key=&#123;node.id&#125;</span></span><br><span class="line"><span class="regexp">              style=&#123;&#123;</span></span><br><span class="line"><span class="regexp">                border: '1px solid #000',</span></span><br><span class="line"><span class="regexp">                margin: '10px',</span></span><br><span class="line"><span class="regexp">                padding: '10px',</span></span><br><span class="line"><span class="regexp">              &#125;&#125;</span></span><br><span class="line"><span class="regexp">            &gt;</span></span><br><span class="line"><span class="regexp">              &lt;h2&gt;&#123;node.frontmatter.title&#125;&lt;/</span>h2&gt;</span><br><span class="line">              &lt;div&gt;分类&#123;node.frontmatter.categories&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">              &lt;div&gt;标签：&#123;node.frontmatter.tags&#125;&lt;/</span>div&gt;</span><br><span class="line">              &lt;div&gt;发布时间：&#123;node.frontmatter.date&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Layout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Blog</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> query = graphql<span class="string">`</span></span><br><span class="line"><span class="string">  query &#123;</span></span><br><span class="line"><span class="string">    allMarkdownRemark &#123;</span></span><br><span class="line"><span class="string">      edges &#123;</span></span><br><span class="line"><span class="string">        node &#123;</span></span><br><span class="line"><span class="string">          id</span></span><br><span class="line"><span class="string">          frontmatter &#123;</span></span><br><span class="line"><span class="string">            tags</span></span><br><span class="line"><span class="string">            title</span></span><br><span class="line"><span class="string">            date</span></span><br><span class="line"><span class="string">            categories</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>打开<code>http://localhost:8000/blog</code>，博客目录就展示出来了：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172e1b12d01e3ba3?w=722&h=601&f=png&s=36586" alt=""></p>
<p>但有个问题，每篇博客的信息确实能拿出来，但是我们要链接啊，即是点击博客标题，进入博客详情页面，即是文章路径，所以接下来我们将创建页面。</p>
<h2 id="利用数据创建页面"><a href="#利用数据创建页面" class="headerlink" title="利用数据创建页面"></a>利用数据创建页面</h2><h3 id="gatsby-node-js-1"><a href="#gatsby-node-js-1" class="headerlink" title="gatsby-node.js"></a>gatsby-node.js</h3><p>这个时候我们就要建立<code>gatsby-node.js</code>文件了，这个配置文件里面的代码是 node 层相关的。</p>
<p>前面我们说过 <code>src/pages</code>目录下的文件会全部渲染成路由，但如果我们博客文章一篇篇的详情页要我们自己创建一个 js 文件，这肯定不合理了。</p>
<p>我们会用到两个 API：</p>
<h4 id="onCreateNode"><a href="#onCreateNode" class="headerlink" title="onCreateNode"></a>onCreateNode</h4><p>每当创建新节点（或更新）时，Gatsby 都会调用 onCreateNode 函数。</p>
<p>向<code>gatsby-node.js</code>写入代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.onCreateNode = <span class="function">(<span class="params">&#123; node &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(node.internal.type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务，查看终端，你会发现打印出很多创建的节点：<code>SitePage</code>, <code>SitePlugin</code>, <code>Site</code>, <code>SiteBuildMetadata</code>, <code>Directory</code>, <code>File</code>, <code>MarkdownRemark</code>,我们关注的只有<code>MarkdownRemark</code>，于是修改函数使其仅仅记录 MarkdownRemark 节点；我们使用每一个 md 文件的名称来作为路径，如要获取文件名称，你需要遍历一遍它的父节点 <code>File</code>，<code>File</code>节点包含了我们需要的文件数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.onCreateNode = <span class="function">(<span class="params">&#123; node, getNode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.internal.type === <span class="string">`MarkdownRemark`</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fileNode = getNode(node.parent)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`\n`</span>, fileNode.relativePath)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务，查看终端，打印如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_posts&#x2F;first-blog.md</span><br><span class="line"></span><br><span class="line">_posts&#x2F;second-blog.md</span><br><span class="line"></span><br><span class="line">_posts&#x2F;third-blog.md</span><br></pre></td></tr></table></figure>

<p>相对路径出来，接下来我们要创建路径，可以使用<code>gatsby-source-filesystem</code>插件带的创建路径的函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createFilePath &#125; = <span class="built_in">require</span>(<span class="string">`gatsby-source-filesystem`</span>)</span><br><span class="line"></span><br><span class="line">exports.onCreateNode = <span class="function">(<span class="params">&#123; node, getNode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.internal.type === <span class="string">`MarkdownRemark`</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(createFilePath(&#123; node, getNode, <span class="attr">basePath</span>: <span class="string">`pages`</span> &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务，打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;_posts&#x2F;first-blog&#x2F;</span><br><span class="line">&#x2F;_posts&#x2F;second-blog&#x2F;</span><br><span class="line">&#x2F;_posts&#x2F;third-blog&#x2F;</span><br></pre></td></tr></table></figure>

<p>接下来，向 API 传递一个函数<code>createNodeField</code>，该函数允许我们在其他插件创建的节点里创建其他字段。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.onCreateNode = <span class="function">(<span class="params">&#123; node, getNode, actions &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; createNodeField &#125; = actions</span><br><span class="line">  <span class="keyword">if</span> (node.internal.type === <span class="string">`MarkdownRemark`</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> slug = createFilePath(&#123; node, getNode, <span class="attr">basePath</span>: <span class="string">`pages`</span> &#125;)</span><br><span class="line">    createNodeField(&#123;</span><br><span class="line">      node,</span><br><span class="line">      name: <span class="string">`slug`</span>,</span><br><span class="line">      value: slug, <span class="comment">// 通常用 slug 一词代表路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务，打开<code>http://localhost:8000/__graphql</code>，就能查询到路径了</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172e1ce4c0a61cae?w=1097&h=448&f=png&s=28484" alt=""></p>
<h4 id="createPages"><a href="#createPages" class="headerlink" title="createPages"></a>createPages</h4><p>createPages 这个 API 用于添加页面。在创建页面之前，首先要有页面模板，这样创建页面就能指定所使用的模板了。</p>
<p>新建文件<code>src/templates/blog-post.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../components/layout'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;div&gt;Hello blog post&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Layout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后更改 <code>gatsby-node.js</code>的<code>createPages</code>函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">`path`</span>)</span><br><span class="line"></span><br><span class="line">exports.createPages = <span class="keyword">async</span> (&#123; graphql, actions &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> graphql(<span class="string">`</span></span><br><span class="line"><span class="string">    query &#123;</span></span><br><span class="line"><span class="string">      allMarkdownRemark &#123;</span></span><br><span class="line"><span class="string">        edges &#123;</span></span><br><span class="line"><span class="string">          node &#123;</span></span><br><span class="line"><span class="string">            fields &#123;</span></span><br><span class="line"><span class="string">              slug</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span>)</span><br><span class="line">  result.data.allMarkdownRemark.edges.forEach(<span class="function">(<span class="params">&#123; node &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    createPage(&#123;</span><br><span class="line">      path: node.fields.slug,</span><br><span class="line">      component: path.resolve(<span class="string">`./src/templates/blog-post.js`</span>),</span><br><span class="line">      context: &#123;</span><br><span class="line">        slug: node.fields.slug,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重启服务，随便输入一个路径，跳转到默认的 404 页面，就会看到自动生成三篇博客的路径了，点击任一篇，跳转的是我们刚创建的 <code>blog-post.js</code>组件。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/24/172e3bb13a244d4c?w=1230&h=548&f=png&s=51476" alt=""></p>
<p>我们要的是显示博客内容，所以我们需要对模板文件再进行改造：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">'gatsby'</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../components/layout'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; data &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> post = data.markdownRemark</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;post.frontmatter.title&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div dangerouslySetInnerHTML=&#123;&#123; __html: post.html &#125;&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Layout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> query = graphql<span class="string">`</span></span><br><span class="line"><span class="string">  query($slug: String!) &#123;</span></span><br><span class="line"><span class="string">    markdownRemark(fields: &#123; slug: &#123; eq: $slug &#125; &#125;) &#123;</span></span><br><span class="line"><span class="string">      html</span></span><br><span class="line"><span class="string">      frontmatter &#123;</span></span><br><span class="line"><span class="string">        title</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<p>上面是动态变量查询的写法，GraphQL 的语法，可以看看 (<a href="https://graphql.org/learn/queries/#variables" target="_blank" rel="noopener">https://graphql.org/learn/queries/#variables</a>)</p>
<p>完成之后，比如我点击第二篇博客，就可以正确进入页面并显示内容了</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/24/172e3c8f759609dd?w=757&h=255&f=png&s=18207" alt=""></p>
<p>为了更完善，我们给 blog 目录页面添加可跳转的链接，加入 <code>slug</code>查询字段, 增加 <code>Link</code>跳转，这个用法与 React 路由的 <code>Link</code>差不多一致，涉及不深的情况下暂且当成相同用法。</p>
<p><code>src/pages/blog.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../components/layout'</span></span><br><span class="line"><span class="keyword">import</span> &#123; graphql, Link &#125; <span class="keyword">from</span> <span class="string">'gatsby'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Blog = <span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;h1&gt;博客目录&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;data.allMarkdownRemark.edges.map((&#123; node &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          return (</span></span><br><span class="line"><span class="regexp">            &lt;Link to=&#123;node.fields.slug&#125; key=&#123;node.id&#125;&gt;</span></span><br><span class="line"><span class="regexp">              &lt;div</span></span><br><span class="line"><span class="regexp">                style=&#123;&#123;</span></span><br><span class="line"><span class="regexp">                  border: '1px solid #000',</span></span><br><span class="line"><span class="regexp">                  margin: '10px',</span></span><br><span class="line"><span class="regexp">                  padding: '10px',</span></span><br><span class="line"><span class="regexp">                &#125;&#125;</span></span><br><span class="line"><span class="regexp">              &gt;</span></span><br><span class="line"><span class="regexp">                &lt;h2&gt;&#123;node.frontmatter.title&#125;&lt;/</span>h2&gt;</span><br><span class="line">                &lt;div&gt;分类&#123;node.frontmatter.categories&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;div&gt;标签：&#123;node.frontmatter.tags&#125;&lt;/</span>div&gt;</span><br><span class="line">                &lt;div&gt;发布时间：&#123;node.frontmatter.date&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>div&gt;</span><br><span class="line">            &lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">          )</span></span><br><span class="line"><span class="regexp">        &#125;)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/Layout&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Blog</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export const query = graphql`</span></span><br><span class="line"><span class="regexp">  query &#123;</span></span><br><span class="line"><span class="regexp">    allMarkdownRemark &#123;</span></span><br><span class="line"><span class="regexp">      edges &#123;</span></span><br><span class="line"><span class="regexp">        node &#123;</span></span><br><span class="line"><span class="regexp">          id</span></span><br><span class="line"><span class="regexp">          frontmatter &#123;</span></span><br><span class="line"><span class="regexp">            tags</span></span><br><span class="line"><span class="regexp">            title</span></span><br><span class="line"><span class="regexp">            date</span></span><br><span class="line"><span class="regexp">            categories</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">          fields &#123;</span></span><br><span class="line"><span class="regexp">            slug</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">`</span></span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/6/24/172e3ce7be50852c?w=722&h=596&f=png&s=36793" alt=""></p>
<p>现在点击博客，就能跳转到对应页面了，虽然没做样式页面比较丑，但只要在<code>src/_posts</code>目录新建 md 文件，然后这里就能跟着自动刷新，算是一个超简易的博客了。</p>
<h2 id="打包上线"><a href="#打包上线" class="headerlink" title="打包上线"></a>打包上线</h2><p>停止开发服务，构建生产版本，把静态文件输出到 public 目录中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gatsby build</span><br></pre></td></tr></table></figure>

<p>在本地查看生产环境版本，运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gatsby serve</span><br></pre></td></tr></table></figure>

<p>接下来，就可以在<code>localhost:9000</code>访问我们刚才做的网站了</p>
<p>本项目的 <a href="https://github.com/Jacky-Summer/gatsby-blog-demo" target="_blank" rel="noopener">github 地址</a></p>
<p>至此，我们教程就介绍到这里了。</p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>Gatsby</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Gatsby</tag>
        <tag>GraphQL</tag>
        <tag>SSR</tag>
      </tags>
  </entry>
  <entry>
    <title>完全搞懂 BFC</title>
    <url>/2020/07/05/%E5%AE%8C%E5%85%A8%E6%90%9E%E6%87%82-BFC/</url>
    <content><![CDATA[<p>BFC 是 CSS 中一个比较重要的概念，也是面试经常考查的点…</p>
<a id="more"></a>

<h2 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC"></a>什么是 BFC</h2><p>BFC 全称是 Block Formatting Context，即块格式化上下文。</p>
<p>除了 BFC，还有：</p>
<ul>
<li>IFC（行级格式化上下文）- inline 内联</li>
<li>GFC（网格布局格式化上下文）- <code>display: grid</code></li>
<li>FFC（自适应格式化上下文）- <code>display: flex</code>或<code>display: inline-flex</code></li>
</ul>
<blockquote>
<p>注意：同一个元素不能同时存在于两个 BFC 中</p>
</blockquote>
<p>它是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。怎么理解呢？实际就是说 BFC 是一个渲染区域，并且有自己的一套渲染规则，使其内部布局的元素具有一些特性。</p>
<p><strong>BFC 提供一个独立的布局环境，BFC 内部的元素布局与外部互不影响。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/17318faf333483aa?w=798&h=317&f=png&s=23237" alt=""></p>
<h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p>CSS 属性值 display 为 block，list-item，table 的元素。</p>
<p>块级盒具有以下特性：</p>
<ul>
<li>CSS 属性值 display 为 block，list-item，table 时，它就是块级元素</li>
<li>布局上，块级盒呈现为竖直排列的块</li>
<li>每个块级盒都会参与 BFC 的创建</li>
<li>每个块级元素都会至少生成一个块级盒，称为主块级盒；一些元素可能会生成额外的块级盒，比如 <code>&lt;li&gt;</code>，用来存放项目符号</li>
</ul>
<h2 id="创建-BFC"><a href="#创建-BFC" class="headerlink" title="创建 BFC"></a>创建 BFC</h2><p>以下元素会创建 BFC</p>
<ul>
<li>根元素（<code>&lt;html&gt;</code>）</li>
<li>浮动元素（<code>float</code>不为<code>none</code>）</li>
<li>绝对定位元素（<code>position</code>为<code>absolute</code>或<code>fixed</code>）</li>
<li>表格的标题和单元格（<code>display</code> 为 <code>table-caption</code>，<code>table-cell</code>）</li>
<li>匿名表格单元格元素（<code>display</code> 为 <code>table</code> 或 <code>inline-table</code>）</li>
<li>行内块元素（<code>display</code> 为 <code>inline-block</code>）</li>
<li><code>overflow</code> 的值不为 <code>visible</code> 的元素</li>
<li>弹性元素（<code>display</code> 为 <code>flex</code> 或 <code>inline-flex</code> 的元素的直接子元素）</li>
<li>网格元素（<code>display</code> 为 <code>grid</code> 或 <code>inline-grid</code> 的元素的直接子元素）</li>
</ul>
<p>以上是 CSS2.1 规范定义的 BFC 触发方式，在最新的 CSS3 规范中，弹性元素和网格元素会创建 F(Flex)FC 和 G(Grid)FC。</p>
<h2 id="BFC-的特性"><a href="#BFC-的特性" class="headerlink" title="BFC 的特性"></a>BFC 的特性</h2><ul>
<li>BFC 是页面上的一个独立容器，容器里面的子元素不会影响外面的元素。</li>
<li>BFC 内部的块级盒会在垂直方向上一个接一个排列</li>
<li>同一 BFC 下的相邻块级元素可能发生外边距折叠，创建新的 BFC 可以避免外边距折叠</li>
<li>每个元素的外边距盒（margin box）的左边与包含块边框盒（border box）的左边相接触（从右向左的格式的话，则相反），即使存在浮动</li>
<li>浮动盒的区域不会和 BFC 重叠</li>
<li>计算 BFC 的高度时，浮动元素也会参与计算</li>
</ul>
<p>如果不太理解的，在下面 BFC 的应用我会提及。</p>
<h2 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h2><h3 id="自适应两列布局"><a href="#自适应两列布局" class="headerlink" title="自适应两列布局"></a>自适应两列布局</h3><p>左列浮动（定宽或不定宽都可以），给右列开启 BFC。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* html 代码 *&#x2F;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;浮动元素，无固定宽度&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;自适应&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* css 代码 *&#x2F;</span><br><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a0544fd4461f?w=1919&h=234&f=png&s=13127" alt=""></p>
<ol>
<li>将左列设为左浮动，将自身高度塌陷，使得其它块级元素可以和它占据同一行的位置。</li>
<li>右列为 div 块级元素，利用其自身的流特性占满整行。</li>
<li>右列设置<code>overflow: hidden</code>,触发 BFC 特性，使其自身与左列的浮动元素隔离开，不占满整行。</li>
</ol>
<p>这即是上面说的 BFC 的特性之一：<strong>浮动盒的区域不会和 BFC 重叠</strong></p>
<h3 id="防止外边距（margin）重叠"><a href="#防止外边距（margin）重叠" class="headerlink" title="防止外边距（margin）重叠"></a>防止外边距（margin）重叠</h3><h4 id="兄弟元素之间的外边距重叠"><a href="#兄弟元素之间的外边距重叠" class="headerlink" title="兄弟元素之间的外边距重叠"></a>兄弟元素之间的外边距重叠</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* html 代码 *&#x2F;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* css 代码 *&#x2F;</span><br><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.child1 &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-bottom: 10px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.child2 &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-top: 20px;</span><br><span class="line">    background-color: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/17318cb5761f328e?w=183&h=220&f=png&s=2328" alt=""></p>
<p>两个块级元素，红色 div 距离底部 10px，绿色 div 距离顶部 20px，按道理应该两个块级元素相距 30px 才对，但实际却是取距离较大的一个，即 20px。</p>
<blockquote>
<p>块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的较大者，这种行为称为外边距折叠（重叠），注意这个是发生在属于同一 BFC 下的块级元素之间</p>
</blockquote>
<p>根据 BFC 特性，创建一个新的 BFC 就不会发生 margin 折叠了。比如我们在他们两个 div 外层再包裹一层容器，加属性<code>overflow: hidden</code>，触发 BFC，那么两个 div 就不属于同个 BFC 了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* html 代码 *&#x2F;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;child1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;child2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* css 代码 *&#x2F;</span><br><span class="line">.parent &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* ... *&#x2F;</span><br></pre></td></tr></table></figure>

<p>这个关于兄弟元素外边距叠加的问题，除了触发 BFC 也有其他方案，比如你统一只用上边距或下边距，就不会有上面的问题。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/17318dc6636f418f?w=209&h=231&f=png&s=2376" alt=""></p>
<h4 id="父子元素的外边距重叠"><a href="#父子元素的外边距重叠" class="headerlink" title="父子元素的外边距重叠"></a>父子元素的外边距重叠</h4><p>这种情况存在父元素与其第一个或最后一个子元素之间（嵌套元素）。<br>如果在父元素与其第一个/最后一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的外边距 分开，此时子元素的外边距会“溢出”到父元素的外面。</p>
<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* HTML 代码 *&#x2F;</span><br><span class="line">&lt;div id&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* CSS 代码 *&#x2F;</span><br><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">#parent &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: green;</span><br><span class="line">    margin-top: 20px;</span><br><span class="line">&#125;</span><br><span class="line">#child &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: red;</span><br><span class="line">    margin-top: 30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a48a81bc27d9?w=376&h=236&f=png&s=6696" alt=""></p>
<p>如上图，红色的 div 在绿色的 div 内部，且设置了<code>margin-top</code>为 30px，但我们发现红色 div 的顶部与绿色 div 顶部重合，并没有距离顶部 30px，而是溢出到父元素的外面计算。即本来父元素距离顶部只有 20px，被子元素溢出影响，外边距重叠，取较大的值，则距离顶部 30px。</p>
<p>解决办法：</p>
<ol>
<li>给父元素触发 BFC（如添加<code>overflow: hidden</code>）</li>
<li>给父元素添加 border</li>
<li>给父元素添加 padding</li>
</ol>
<p>这样就能实现我们期望的效果了：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a50faed50d4d?w=249&h=221&f=png&s=2040" alt=""></p>
<h3 id="清除浮动解决令父元素高度坍塌的问题"><a href="#清除浮动解决令父元素高度坍塌的问题" class="headerlink" title="清除浮动解决令父元素高度坍塌的问题"></a>清除浮动解决令父元素高度坍塌的问题</h3><p>当容器内子元素设置浮动时，脱离了文档流，容器中总父元素高度只有边框部分高度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* html 代码 *&#x2F;</span><br><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* css 代码 *&#x2F;</span><br><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.parent &#123;</span><br><span class="line">    border: 4px solid red;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a132272ea410?w=1927&h=209&f=png&s=16771" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a249e4c9c33f?w=338&h=679&f=png&s=38121" alt=""></p>
<p>解决办法：给父元素触发 BFC，使其有 BFC 特性：<strong>计算 BFC 的高度时，浮动元素也会参与计算</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    border: 4px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a1fd01267b9d?w=1920&h=237&f=png&s=10195" alt=""></p>
<p>上面我们都是用的<code>overflow: hidden</code>触发 BFC，因为确实常用嘛，但是触发 BFC 也不止是只有这一种方法，如上面写的所示。</p>
<p>比如可以设置<code>float: left</code>; <code>float: right</code>; <code>display: inline-block</code>; <code>overflow: auto</code>; <code>display: flex</code>; <code>display:&quot; table</code>; <code>position</code>为<code>absolute</code>或<code>fixed</code>等等，这些都可以触发，不过父元素宽度表现不一定相同，但父元素高度都被撑出来了。当然实际运用可不是随便挑一个走，还是根据场景选择。</p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，鼓励我继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
  </entry>
  <entry>
    <title>一文汇总 CSS 两列布局和三列布局</title>
    <url>/2020/06/27/%E4%B8%80%E6%96%87%E6%B1%87%E6%80%BB-CSS-%E4%B8%A4%E5%88%97%E5%B8%83%E5%B1%80%E5%92%8C%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>随着大前端的发展，UI 框架层出不穷，让我们前端开发对 CSS 的能力要求变得没那么高或者没那么严苛，起码重要性是比不上 JS 编程的。但是，基础的 CSS 依然需要我们熟练掌握，今天就来总结写下 CSS 布局的方式。</p>
<a id="more"></a>

<h2 id="两列布局"><a href="#两列布局" class="headerlink" title="两列布局"></a>两列布局</h2><h3 id="左列定宽，右列自适应"><a href="#左列定宽，右列自适应" class="headerlink" title="左列定宽，右列自适应"></a>左列定宽，右列自适应</h3><p><img src="https://user-gold-cdn.xitu.io/2020/6/25/172ebffbad247324?w=1918&h=427&f=png&s=21351" alt=""></p>
<h4 id="float-margin-布局"><a href="#float-margin-布局" class="headerlink" title="float + margin 布局"></a>float + margin 布局</h4><p>html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>; <span class="comment">/* 大于或等于左列的宽度 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="float-overflow-布局"><a href="#float-overflow-布局" class="headerlink" title="float + overflow 布局"></a>float + overflow 布局</h4><p>html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="绝对定位布局"><a href="#绝对定位布局" class="headerlink" title="绝对定位布局"></a>绝对定位布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="table-布局"><a href="#table-布局" class="headerlink" title="table 布局"></a>table 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>,</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grid-网格布局"><a href="#grid-网格布局" class="headerlink" title="grid 网格布局"></a>grid 网格布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="左列不定宽，右列自适应"><a href="#左列不定宽，右列自适应" class="headerlink" title="左列不定宽，右列自适应"></a>左列不定宽，右列自适应</h3><p>左列盒子宽度随着内容增加或减少发生变化，右列盒子自适应</p>
<h4 id="float-overflow-布局-1"><a href="#float-overflow-布局-1" class="headerlink" title="float + overflow 布局"></a>float + overflow 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列不定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex-布局-1"><a href="#flex-布局-1" class="headerlink" title="flex 布局"></a>flex 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列不定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a>grid 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列不定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: auto <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三列布局"><a href="#三列布局" class="headerlink" title="三列布局"></a>三列布局</h2><h3 id="两列定宽，一列自适应"><a href="#两列定宽，一列自适应" class="headerlink" title="两列定宽，一列自适应"></a>两列定宽，一列自适应</h3><p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ee126919a5ecb?w=1916&h=408&f=png&s=21184" alt=""></p>
<h4 id="float-margin-布局-1"><a href="#float-margin-布局-1" class="headerlink" title="float + margin 布局"></a>float + margin 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">300px</span>; <span class="comment">/* 左列的宽度 + 中间列的宽度 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="float-overflow-布局-2"><a href="#float-overflow-布局-2" class="headerlink" title="float + overflow 布局"></a>float + overflow 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="table-布局-1"><a href="#table-布局-1" class="headerlink" title="table 布局"></a>table 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex-布局-2"><a href="#flex-布局-2" class="headerlink" title="flex 布局"></a>flex 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grid-布局-1"><a href="#grid-布局-1" class="headerlink" title="grid 布局"></a>grid 布局</h4><p>html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">200px</span> auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="左右定宽，中间自适应"><a href="#左右定宽，中间自适应" class="headerlink" title="左右定宽，中间自适应"></a>左右定宽，中间自适应</h3><p><img src="https://user-gold-cdn.xitu.io/2020/6/27/172f36b76f3065b5?w=1914&h=409&f=png&s=21663" alt=""></p>
<p>圣杯布局和双飞翼布局目的都是希望先加载的是中间的部分，然后再开始加载 left 和 right 两部分相对来说不是很重要的东西。</p>
<h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><p>圣杯布局：为了让中间的内容不被遮挡，将中间 div（或最外层父 div）设置 padding-left 和 padding-right （值等于 left 和 right 的宽度），将左右两个 div 用相对布局 position: relative 并分别配合 left 和 right 属性，以便左右两栏 div 移动后不遮挡中间 div。</p>
<p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>,</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="comment">/* 使 #left 上去一行 */</span></span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>; <span class="comment">/* 使 #right 上去一行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>双飞翼布局，为了中间 div 内容不被遮挡，直接在中间 div 内部创建子 div 用于放置内容，在该子 div 里用 margin-left 和 margin-right 为左右两栏 div 留出位置。</p>
<p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center-inside"</span>&gt;</span>中间列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span>,</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="comment">/* 使 #left 上去一行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>; <span class="comment">/* 使 #right 上去一行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center-inside</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flex-实现"><a href="#flex-实现" class="headerlink" title="flex 实现"></a>flex 实现</h3><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>,</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: -<span class="number">1</span>; <span class="comment">/* 让 #left 居于左侧 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS伪元素实现中间文字，两边横线的效果</title>
    <url>/2020/06/16/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E5%AE%9E%E7%8E%B0%E4%B8%AD%E9%97%B4%E6%96%87%E5%AD%97%EF%BC%8C%E4%B8%A4%E8%BE%B9%E6%A8%AA%E7%BA%BF%E7%9A%84%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>今天做项目的时候，要实现效果：中间是文字，两边是横线围着，其中有间距。了解了几种做法。伪元素这个刚开始没想到，回来又自己敲了一遍，以做记录…</p>
<a id="more"></a>

<p>效果：</p>
<p><img src="/images/css-pseudo.png" alt="image.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS伪元素实现中间文字, 两边横线效果<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line">        width: 640px;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">        text-align: center;</span><br><span class="line">        width: 100%;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> <span class="selector-class">.word</span><span class="selector-pseudo">:before</span>,</span></span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> <span class="selector-class">.word</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 50%;</span><br><span class="line">        width: 40%;</span><br><span class="line">        height: 1px;</span><br><span class="line">        background: blue;</span><br><span class="line">        content: '';</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="comment">/* 调整背景横线的左右距离 */</span></span></span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> <span class="selector-class">.word</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line">        left: 0;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> <span class="selector-class">.word</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">        right: 0;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"word"</span>&gt;</span>中间的字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Formik +Yup 处理 React 表单验证</title>
    <url>/2020/06/13/%E4%BD%BF%E7%94%A8-Formik-Yup-%E5%A4%84%E7%90%86-React-%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>React 操作表单一直都是比较繁琐的操作，在以前用的是 redux-form， 但现在 formik 这个库设计得更加优雅，Github 的 star 数目已经远远超过 redux-form 了。做表单就是为了收集一些数据，然后进行提交。而 redux-form 理念是把这些数据存放到 reducer 中去，当我们表单多的时候，显然对整个 store 的数据管理不太友好，因为多了很多表单数据。而 formik 解决的其中一个痛点就是这个，它可以在组件内部处理这些表单项而简单易用。</p>
<p>Formik 旨在轻松管理具有复杂验证的表单, Formik 支持同步和异步表单级和字段级验证。</p>
<a id="more"></a>

<p><code>例子的 Formik 为 2.1.4 版</code></p>
<p>先来看个基本的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useFormik &#125; <span class="keyword">from</span> <span class="string">'formik'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./FormDemo.css'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查表单字段</span></span><br><span class="line"><span class="keyword">const</span> validate = <span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> errors = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!values.name) &#123;</span><br><span class="line">    errors.name = <span class="string">'不能为空'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (values.name.length &gt; <span class="number">20</span>) &#123;</span><br><span class="line">    errors.name = <span class="string">'名字太长，输入有误'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!values.email) &#123;</span><br><span class="line">    errors.email = <span class="string">'不能为空'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="regexp">/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]&#123;2,4&#125;$/i</span>.test(values.email)) &#123;</span><br><span class="line">    errors.email = <span class="string">'邮箱格式错误'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> errors</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FormDemo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> formik = useFormik(&#123;</span><br><span class="line">    initialValues: &#123;</span><br><span class="line">      name: <span class="string">''</span>,</span><br><span class="line">      email: <span class="string">''</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    validate,</span><br><span class="line">    onSubmit: <span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="built_in">JSON</span>.stringify(values, <span class="literal">null</span>, <span class="number">2</span>))</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;formik.handleSubmit&#125; className=<span class="string">'form-wrap'</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">'form-group'</span>&gt;</span><br><span class="line">        &lt;label&gt;名字&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          name='name'</span></span><br><span class="line"><span class="regexp">          onChange=&#123;formik.handleChange&#125;</span></span><br><span class="line"><span class="regexp">          onBlur=&#123;formik.handleBlur&#125;</span></span><br><span class="line"><span class="regexp">          value=&#123;formik.values.name&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &#123;formik.touched.name &amp;&amp; formik.errors.name ? (</span><br><span class="line">          &lt;div className=<span class="string">'error-tip'</span>&gt;&#123;formik.errors.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        ) : null&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">'form-group'</span>&gt;</span><br><span class="line">        &lt;label&gt;邮箱&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          name='email'</span></span><br><span class="line"><span class="regexp">          onChange=&#123;formik.handleChange&#125;</span></span><br><span class="line"><span class="regexp">          onBlur=&#123;formik.handleBlur&#125;</span></span><br><span class="line"><span class="regexp">          value=&#123;formik.values.email&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &#123;formik.touched.email &amp;&amp; formik.errors.email ? (</span><br><span class="line">          &lt;div className=<span class="string">'error-tip'</span>&gt;&#123;formik.errors.email&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        ) : null&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> FormDemo</span><br></pre></td></tr></table></figure>

<p>以上是一个很简单的表单，输入名字与邮箱。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/13/172acf9ec35b272f?w=433&h=232&f=gif&s=31469" alt=""></p>
<p>上面例子中我们使用的是 useFormik 这种用法，还有使用 <code>&lt;Formik /&gt;</code> 和 <code>withFormik</code> 的用法。</p>
<p>但我们发现一个问题，当正在输入名字的时候，邮箱已经立马显示不能为空了，我们需要的是当点击的时候才做其他表单元素的判断而不是一次性判断完。对这一问题，我们需要再加一个判断<code>touched</code>, 这个代表表单中的某个字段是否被点击过，直译的话就是”触碰过”或”动过”，这样就不会出现上面的问题了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  formik.touched.name &amp;&amp; formik.errors.name ? (</span><br><span class="line">    &lt;div className=<span class="string">'error-tip'</span>&gt;&#123;formik.errors.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  ) : null</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>但发现上面的代码还是挺多, onChange, onBlur, value 等属性还是挺重复的，每个表单元素写一段，其实我们可以更精简，使用 formik 里面的<code>getFieldProps</code>方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">"&#123;formik.handleSubmit&#125;"</span> <span class="attr">className</span>=<span class="string">"form-wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">'name'</span> &#123;<span class="attr">...formik.getFieldProps</span>('<span class="attr">name</span>')&#125; /&gt;</span> &#123;formik.touched.name &amp;&amp;</span><br><span class="line">    formik.errors.name ? (</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"error-tip"</span>&gt;</span>&#123;formik.errors.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ) : null&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">'email'</span> &#123;<span class="attr">...formik.getFieldProps</span>('<span class="attr">email</span>')&#125; /&gt;</span> &#123;formik.touched.email &amp;&amp;</span><br><span class="line">    formik.errors.email ? (</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"error-tip"</span>&gt;</span>&#123;formik.errors.email&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ) : null&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么表单字段的验证能不能简化呢？formik 表单验证大多数我们会选择和 yup 库进行搭配，yup 的专长就是作规则校验的。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> formik = useFormik(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  validationSchema: Yup.object(&#123;</span><br><span class="line">    name: Yup.string().max(<span class="number">20</span>, <span class="string">'名字太长，输入有误'</span>).required(<span class="string">'不能为空'</span>),</span><br><span class="line">    email: Yup.string().email(<span class="string">'邮箱格式错误'</span>).required(<span class="string">'不能为空'</span>),</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>上面 validationSchema 为 Formik 专门为 yup 留出的接口，所以 formik 是很好支持 yup 搭配使用的。</p>
<p>最后附上官网：<a href="https://jaredpalmer.com/formik/" target="_blank" rel="noopener">https://jaredpalmer.com/formik/</a><br><br></p>
<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>Formik</tag>
        <tag>Yup</tag>
      </tags>
  </entry>
  <entry>
    <title>【React 原理（一）】实现 createElement 和 render 方法</title>
    <url>/2020/06/06/%E3%80%90React-%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%91%E5%AE%9E%E7%8E%B0-createElement-%E5%92%8C-render-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在 React 中，我们都知道可以写 jsx 代码会被编译成真正的 DOM 插入到要显示的页面上。这具体是怎么实现的，今天我们就自己动手做一下。</p>
<a id="more"></a>

<h2 id="实现-createElement-方法"><a href="#实现-createElement-方法" class="headerlink" title="实现 createElement 方法"></a>实现 createElement 方法</h2><p>这个方法平时开发我们并不会用到，因为它是经 babel 编译后的代码，我们新建一个 React 项目，index.js 最简单的代码结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">'title'</span>&gt;</span>Hello React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure>

<p>这里就 jsx 会变编译成真正的 DOM ，把 html 代码拿到 babel 官网编译</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287948badb8312?w=1162&h=182&f=png&s=14232" alt=""></p>
<p>于是我们就看到了 React.createElement() 方法，但这只是调用这个方法，它具体做了什么返回什么我们还不知道，我们可以打印这个函数运行的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  React.createElement(</span><br><span class="line">    <span class="string">'h1'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      className: <span class="string">'title'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'Hello React'</span></span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/1728796fcf7d2054?w=567&h=181&f=png&s=12796" alt=""><br>返回的这个对象就是虚拟 DOM 了。</p>
<p>我们来分析它返回的对象参数，首先第一个是</p>
<ul>
<li><code>$$typeof: REACT_ELEMENT_TYPE</code></li>
</ul>
<p>这个是 React 元素对象的标识属性</p>
<p>REACT_ELEMENT_TYPE 的值是一个 Symbol 类型，代表了一个独一无二的值。如果浏览器不支持 Symbol 类型，值就是一个二进制值。</p>
<blockquote>
<p>为什么是 Symbol？主要防止 XSS 攻击伪造一个假的 React 组件。因为 JSON 中是不会存在 Symbol 类型的。</p>
</blockquote>
<ul>
<li>key：这个比如循环中会用到这个 key 值</li>
<li>props：传入的属性值，比如 id, className, style, children 等</li>
<li>ref： DOM 的引用</li>
<li>剩下的是私有属性（本篇不展开讨论）</li>
</ul>
<p>在本篇我们会用自己简单的方式实现这两个方法，而不是根据源码，所以实现上的方法只要能实现它的基本功能即可；有个基本概念在，以后再循序渐进学习源码。</p>
<p>而 createElement 中有三个参数，更确切说是 n 个参数：</p>
<ul>
<li>type：表示要渲染的元素类型。这里可以传入一个元素 Tag 名称，也可以传入一个组件（如 div span 等，也可以是是函数组件和类组件）</li>
<li>props：创建 React 元素所需要的 props。</li>
<li>childrens（可选参数）：要渲染元素的子元素，这里可以向后传入 n 个参数。可以为文本字符串，也可以为数组</li>
</ul>
<p>初步 createElement 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 JSX 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...childrens</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type,</span><br><span class="line">        props: &#123;</span><br><span class="line">          ...props,</span><br><span class="line">          children: childrens.length &lt;= <span class="number">1</span> ? childrens[<span class="number">0</span>] || <span class="string">''</span> : childrens,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数中 props 和 childrens 是并列关系，然后返回的 props 对象，里面包含了 children，所以我们需要再 props 里面添加 children 参数，然后根据 children 参数为一个或多个的可能在进行取值处理。</p>
<p>调用该方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  createElement(</span><br><span class="line">    <span class="string">'h1'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      className: <span class="string">'title'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'Hello React'</span></span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287aecec9a3e91?w=237&h=116&f=png&s=4860" alt=""><br>除去其它本篇我们不讨论的属性，目前算是实现了一半；我们观察原来 React 自身方法输出的结果有 key, ref， 同输出的 props 也是并列关系，于是我们进一步作出处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...childrens</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ref, key</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'ref'</span> <span class="keyword">in</span> props) &#123;</span><br><span class="line">    ref = props[<span class="string">'ref'</span>]</span><br><span class="line">    props[<span class="string">'ref'</span>] = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'key'</span> <span class="keyword">in</span> props) &#123;</span><br><span class="line">    key = props[<span class="string">'key'</span>]</span><br><span class="line">    props[<span class="string">'key'</span>] = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children: childrens.length &lt;= <span class="number">1</span> ? childrens[<span class="number">0</span>] || <span class="string">''</span> : childrens,</span><br><span class="line">    &#125;,</span><br><span class="line">    ref,</span><br><span class="line">    key,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的方式调用结果如下：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287b33de749a06?w=453&h=145&f=png&s=8494" alt=""><br>如果添加多一些属性，我们来看看结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  createElement(</span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">'box'</span>, <span class="attr">className</span>: <span class="string">'box'</span>, <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125;, <span class="attr">key</span>: <span class="string">'20'</span> &#125;,</span><br><span class="line">    <span class="string">'this is text'</span>,</span><br><span class="line">    createElement(<span class="string">'h2'</span>, &#123; <span class="attr">className</span>: <span class="string">'title'</span> &#125;, <span class="string">'hello'</span>),</span><br><span class="line">    createElement(<span class="string">'div'</span>, &#123; <span class="attr">className</span>: <span class="string">'content'</span> &#125;, <span class="string">'Hi'</span>)</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287c9de8368ddd?w=467&h=280&f=png&s=17373" alt=""><br>用了这种比较粗鲁的方式添加，设置为 undefined 在实现 render 方法的时候我们会根据这个忽略 props 内部的 key 和 props 属性，这里就实现了最基本的 createElement 方法了。</p>
<h2 id="实现-render-方法"><a href="#实现-render-方法" class="headerlink" title="实现 render 方法"></a>实现 render 方法</h2><p>render 方法的第一个参数接收的是 createElement 返回的对象，也就是虚拟 DOM；<br>第二个参数则是挂载的目标 DOM。同样的做法，我们用 babel 编译来看：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287ca773a9b742?w=1259&h=362&f=png&s=43471" alt=""><br>执行后，就被挂在到页面了</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287cc414f3731c?w=343&h=122&f=png&s=6145" alt=""></p>
<p>实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 功能：把创建的对象生成对应的DOM元素，最后插入到页面中</span></span><br><span class="line"><span class="comment"> * objJSX： createElement 返回的 JSX 对象</span></span><br><span class="line"><span class="comment"> * container：挂载的容器，如 document.getElementById('root')</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">objJSX, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; type, props &#125; = objJSX</span><br><span class="line">  <span class="keyword">let</span> newElement = <span class="built_in">document</span>.createElement(type)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="comment">// 遍历传入的 props 属性</span></span><br><span class="line">    <span class="keyword">if</span> (!props.hasOwnProperty(attr)) <span class="keyword">break</span> <span class="comment">// 不是私有的直接结束遍历</span></span><br><span class="line">    <span class="keyword">let</span> value = props[attr] <span class="comment">// &gt;如果当前属性没有值,直接不处理即可</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">undefined</span>) <span class="keyword">continue</span> <span class="comment">// NULL OR UNDEFINED</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对几个特殊属性单独设置</span></span><br><span class="line">    <span class="keyword">switch</span> (attr.toUpperCase()) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'ID'</span>:</span><br><span class="line">        newElement.setAttribute(<span class="string">'id'</span>, value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'CLASSNAME'</span>:</span><br><span class="line">        newElement.setAttribute(<span class="string">'class'</span>, value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'STYLE'</span>: <span class="comment">// 传入的行内样式 style 是个对象，故需遍历赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> styleAttr <span class="keyword">in</span> value) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value.hasOwnProperty(styleAttr)) &#123;</span><br><span class="line">            newElement[<span class="string">'style'</span>][styleAttr] = value[styleAttr]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'CHILDREN'</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 可能是一个值：可能是字符串也可能是一个JSX对象</span></span><br><span class="line"><span class="comment">         * 可能是一个数组：数组中的每一项可能是字符串也可能是JSX对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 首先把一个值也变为数组，这样后期统一操作数组即可</span></span><br><span class="line">        !(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? (value = [value]) : <span class="literal">null</span></span><br><span class="line">        value.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 验证ITEM是什么类型的：如果是字符串就是创建文本节点，如果是对象，我们需要再次执行RENDER方法，把创建的元素放到最开始创建的大盒子中</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">'string'</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> text = <span class="built_in">document</span>.createTextNode(item)</span><br><span class="line">            newElement.appendChild(text)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            render(item, newElement)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        newElement.setAttribute(attr, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  container.appendChild(newElement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>ps： <a href="https://images.weserv.nl/?url=https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，鼓励我继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 redux-thunk 源码</title>
    <url>/2020/05/30/%E7%90%86%E8%A7%A3-redux-thunk-%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>前面几篇我们就 Redux 展开了几篇文章，这次我们来实现 react-thunk，就不是叫实现 redux-thunk 了，直接上源码，因为源码就 11 行。如果对 Redux 中间件还不理解的，可以看我写的 Redux 文章。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="https://jacky-summer.github.io/2020/04/22/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E4%BD%A0Redux%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/#more" target="_blank" rel="noopener">实现一个迷你 Redux（基础版）</a></li>
<li><a href="https://jacky-summer.github.io/2020/05/14/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARedux%EF%BC%88%E5%AE%8C%E5%96%84%E7%89%88%EF%BC%89/#more" target="_blank" rel="noopener">实现一个 Redux（完善版）</a></li>
<li><a href="https://jacky-summer.github.io/2020/04/28/%E6%B5%85%E8%B0%88React%E7%9A%84Context-API/#more" target="_blank" rel="noopener">浅谈 React 的 Context API</a></li>
<li><a href="https://jacky-summer.github.io/2020/05/24/%E5%B8%A6%E4%BD%A0%E5%AE%9E%E7%8E%B0-react-redux/" target="_blank" rel="noopener">带你实现 react-redux</a></li>
</ul>
<h2 id="为什么要用-redux-thunk"><a href="#为什么要用-redux-thunk" class="headerlink" title="为什么要用 redux-thunk"></a>为什么要用 redux-thunk</h2><p>在使用 Redux 过程，通过 dispatch 方法派发一个 action 对象。当我们使用 redux-thunk 后，可以 dispatch 一个 function。redux-thunk 会自动调用这个 function，并且传递 dispatch, getState 方法作为参数。这样一来，我们就能在这个 function 里面处理异步逻辑，处理复杂逻辑，这是原来 Redux 做不到的，因为原来就只能 dispatch 一个简单对象。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>redux-thunk 作为 redux 的中间件，主要用来处理异步请求，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// to do ...</span></span><br><span class="line">    axios.get(<span class="string">'https://jsonplaceholder.typicode.com/todos/1'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="redux-thunk-源码"><a href="#redux-thunk-源码" class="headerlink" title="redux-thunk 源码"></a>redux-thunk 源码</h2><p>redux-thunk 的源码比较简洁，实际就 11 行。前几篇我们说到 redux 的中间件形式，<br>本质上是对 store.dispatch 方法进行了增强改造，基本是类似这种形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const middleware &#x3D; (store) &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在这里就不详细解释了，可以看 <a href="https://juejin.im/post/5ebb9375f265da7bfe0bf16a" target="_blank" rel="noopener">实现一个 Redux（完善版）</a></p>
<p>先给个缩水版的实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thunk = <span class="function">(<span class="params">&#123; getState, dispatch &#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action(dispatch, getState)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk</span><br></pre></td></tr></table></figure>

<ul>
<li>原理：即当 action 为 function 的时候，就调用这个 function (传入 dispatch, getState)并返回；如果不是，就直接传给下一个中间件。</li>
</ul>
<p>完整源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果action是一个function，就返回action(dispatch, getState, extraArgument)，否则返回next(action)。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> action(dispatch, getState, extraArgument)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// next为之前传入的store.dispatch，即改写前的dispatch</span></span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleware()</span><br><span class="line"><span class="comment">// 给thunk设置一个变量withExtraArgument，并且将createThunkMiddleware整个函数赋给它</span></span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk</span><br></pre></td></tr></table></figure>

<p>我们发现其实还多了 extraArgument 传入，这个是自定义参数，如下用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> api = <span class="string">'https://jsonplaceholder.typicode.com/todos/1'</span></span><br><span class="line"><span class="keyword">const</span> whatever = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(thunk.withExtraArgument(&#123; api, whatever &#125;))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState, &#123; api, whatever &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// you can use api and something else here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同 redux-thunk 非常流行的库 redux-saga 一样，都是在 redux 中做异步请求等副作用。Redux 相关的系列文章就暂时写到这部分为止，下次会写其他系列。</p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>react-thunk</tag>
      </tags>
  </entry>
  <entry>
    <title>带你实现-react-redux</title>
    <url>/2020/05/24/%E5%B8%A6%E4%BD%A0%E5%AE%9E%E7%8E%B0-react-redux/</url>
    <content><![CDATA[<p>之前我们实现了 redux 的功能，这次我们来实现一下配合 redux 开发中经常会用到的一个库—— react-redux。本文不会详细介绍 react-redux 的使用，另外需要了解 Context API， 再看此文就很容易理解了。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>可以看看我之前写的几篇文章</p>
<ul>
<li><a href="https://jacky-summer.github.io/2020/04/22/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E4%BD%A0Redux%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/#more" target="_blank" rel="noopener">实现一个迷你 Redux（基础版）</a></li>
<li><a href="https://jacky-summer.github.io/2020/05/14/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARedux%EF%BC%88%E5%AE%8C%E5%96%84%E7%89%88%EF%BC%89/#more" target="_blank" rel="noopener">实现一个 Redux（完善版）</a></li>
<li><a href="https://jacky-summer.github.io/2020/04/28/%E6%B5%85%E8%B0%88React%E7%9A%84Context-API/#more" target="_blank" rel="noopener">浅谈 React 的 Context API</a></li>
</ul>
<h2 id="react-redux-基本使用"><a href="#react-redux-基本使用" class="headerlink" title="react-redux 基本使用"></a>react-redux 基本使用</h2><p>用个简单的加减数字作例子, 把代码贴出来：</p>
<ul>
<li>redux.js</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// actions</span></span><br><span class="line"><span class="keyword">const</span> ADD_NUM = <span class="string">'ADD_NUM'</span></span><br><span class="line"><span class="keyword">const</span> DESC_NUM = <span class="string">'DESC_NUM'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// action creators</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addNumAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_NUM,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reduceNumAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: DESC_NUM,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  num: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_NUM:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">num</span>: state.num + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">case</span> DESC_NUM:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">num</span>: state.num - <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">'./Demo'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./redux.js'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;Demo /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<p>Demo.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; addNumAction, reduceNumAction &#125; <span class="keyword">from</span> <span class="string">'./redux.js'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="keyword">this</span>.props.num&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.props.addNum&#125;&gt;增加1&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.props.reduceNum&#125;&gt;减少<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    num: state.num,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    addNum() &#123;</span><br><span class="line">      <span class="keyword">const</span> action = addNumAction()</span><br><span class="line">      dispatch(action)</span><br><span class="line">    &#125;,</span><br><span class="line">    reduceNum() &#123;</span><br><span class="line">      <span class="keyword">const</span> action = reduceNumAction()</span><br><span class="line">      dispatch(action)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Demo)</span><br></pre></td></tr></table></figure>

<p>就可以实现 num 的增减：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/5/24/172443ab8612774b?w=143&h=82&f=png&s=1764" alt=""><br>其实一个简单的 react-redux， 主要也就是实现 connect 和 Provider 的基本功能</p>
<ul>
<li><strong>connect</strong>：可以把 state 和 dispatch 绑定到 react 组件，使得组件可以访问到 redux 的数据</li>
<li><strong>Provider</strong>：提供的是一个顶层容器的作用，实现 store 的上下文传递</li>
</ul>
<h2 id="使用旧版-Context-API-实现"><a href="#使用旧版-Context-API-实现" class="headerlink" title="使用旧版 Context API 实现"></a>使用旧版 Context API 实现</h2><h3 id="实现-Provider"><a href="#实现-Provider" class="headerlink" title="实现 Provider"></a>实现 Provider</h3><p>首先我们看它的用法，就知道它不是一个函数，而是一个组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">    &lt;Demo &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Provider&gt;</span><br></pre></td></tr></table></figure>

<p>React 的 Context API 提供了一种通过组件树传递数据的方法，无需在每个级别手动传递 props 属性。</p>
<p>Provider 的实现比较简单，核心就是<strong>把 store 放到 context 里面，所有的子元素可以直接取到 store</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    store: PropTypes.object,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.store = props.store <span class="comment">// 也就是 Provider 组件从外部传入的 store</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">store</span>: <span class="keyword">this</span>.store &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children <span class="comment">// 中间包的组件传入了 context，其余原封不动返回组件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有个地方大家知道就好，两种写法一样的，对 context type 的约束</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 不用 static 来声明...</span></span><br><span class="line">&#125;</span><br><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line">  store: PropTypes.object,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-connect"><a href="#实现-connect" class="headerlink" title="实现 connect"></a>实现 connect</h3><p>connect 用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Demo)</span><br></pre></td></tr></table></figure>

<p>connect 是一个高阶组件，就是以组件作为参数，返回一个组件。</p>
<p><strong>connect 负责连接组件，给到 redux 的数据放到组件的属性里</strong></p>
<ol>
<li>负责接收一个组件，把 state 的一些数据放进去，返回一个组件</li>
<li>数据变化的时候，能够通知组件（需要进行监听）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">WrapComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">      <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">        store: PropTypes.object,</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">          props: &#123;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">        store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.update()) <span class="comment">// 监听更新事件</span></span><br><span class="line">        <span class="keyword">this</span>.update()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      update() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">        <span class="keyword">let</span> stateToProps = mapStateToProps(store.getState()) <span class="comment">// 传入 redux 的 state</span></span><br><span class="line">        <span class="keyword">let</span> dispatchToProps = mapDispatchToProps(store.dispatch) <span class="comment">// 传入 redux 的 dispatch</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          props: &#123;</span><br><span class="line">            ...this.state.props,</span><br><span class="line">            ...stateToProps,</span><br><span class="line">            ...dispatchToProps,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrapComponent</span> &#123;<span class="attr">...this.state.props</span>&#125; /&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样 connect 就实现了，但还有一个问题，像上面的例子，我们其实可以直接传入 action creators， 而不用自己定义函数传入 dispatch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default connect(mapStateToProps, &#123; addNumAction, reduceNumAction &#125;)(Demo)</span><br></pre></td></tr></table></figure>

<p>调用的时候：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onClick&#x3D;&#123;this.props.addNumAction&#125;&gt;增加1&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button onClick&#x3D;&#123;this.props.reduceNumAction&#125;&gt;减少1&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>那它的 dispatch 哪里来的，其实是用了 redux 的 bindActionCreators 函数，在我介绍 redux 的文章有提到，它作用是将 actionCreator 转化成 dispatch 形式，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; addNumAction &#125;  &#x3D;&gt;  (...args) &#x3D;&gt; dispatch(addNumAction(args))</span><br></pre></td></tr></table></figure>

<p>所以我们需要再更改 connect 函数，同时，这次我们用箭头函数的形式简化代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> connect = <span class="function">(<span class="params">mapStateToProps, mapDispatchToProps</span>) =&gt;</span> <span class="function"><span class="params">WrapComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">      store: PropTypes.object,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props)</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        props: &#123;&#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">      store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.update())</span><br><span class="line">      <span class="keyword">this</span>.update()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">      <span class="keyword">let</span> stateToProps = mapStateToProps(store.getState())</span><br><span class="line">      <span class="keyword">let</span> dispatchToProps</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> mapDispatchToProps === <span class="string">'function'</span>) &#123;</span><br><span class="line">        dispatchToProps = mapDispatchToProps(store.dispatch)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 传递了一个 actionCreator 对象过来</span></span><br><span class="line">        dispatchToProps = bindActionCreators(mapDispatchToProps, store.dispatch)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">          ...this.state.props,</span><br><span class="line">          ...stateToProps,</span><br><span class="line">          ...dispatchToProps,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrapComponent</span> &#123;<span class="attr">...this.state.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，我们实现了最基本版的 react-redux，然后接下来，我们用新版的 Context API 再写一次</p>
<h2 id="使用新版-Context-API-实现"><a href="#使用新版-Context-API-实现" class="headerlink" title="使用新版 Context API 实现"></a>使用新版 Context API 实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StoreContext = React.createContext(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这次 Provider 采取更简洁的形式写</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;StoreContext.Provider value=&#123;<span class="keyword">this</span>.props.store&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/StoreContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export function connect(mapStateToProps, mapDispatchToProps) &#123;</span></span><br><span class="line"><span class="regexp">  return function (WrapComponent) &#123;</span></span><br><span class="line"><span class="regexp">    class ConnectComponent extends Component &#123;</span></span><br><span class="line"><span class="regexp">      constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">        super(props)</span></span><br><span class="line"><span class="regexp">        this.state = &#123;</span></span><br><span class="line"><span class="regexp">          props: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">        const &#123; store &#125; = this.props</span></span><br><span class="line"><span class="regexp">        store.subscribe(() =&gt; this.update())</span></span><br><span class="line"><span class="regexp">        this.update()</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      update() &#123;</span></span><br><span class="line"><span class="regexp">        const &#123; store &#125; = this.props</span></span><br><span class="line"><span class="regexp">        let stateToProps = mapStateToProps(store.getState())</span></span><br><span class="line"><span class="regexp">        let dispatchToProps</span></span><br><span class="line"><span class="regexp">        if (typeof mapDispatchToProps === 'function') &#123;</span></span><br><span class="line"><span class="regexp">          dispatchToProps = mapDispatchToProps(store.dispatch)</span></span><br><span class="line"><span class="regexp">        &#125; else &#123;</span></span><br><span class="line"><span class="regexp">          /</span><span class="regexp">/ 传递了一个 actionCreator 对象过来</span></span><br><span class="line"><span class="regexp">          dispatchToProps = bindActionCreators(mapDispatchToProps, store.dispatch)</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        this.setState(&#123;</span></span><br><span class="line"><span class="regexp">          props: &#123;</span></span><br><span class="line"><span class="regexp">            ...this.state.props,</span></span><br><span class="line"><span class="regexp">            ...stateToProps,</span></span><br><span class="line"><span class="regexp">            ...dispatchToProps,</span></span><br><span class="line"><span class="regexp">          &#125;,</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      render() &#123;</span></span><br><span class="line"><span class="regexp">        return &lt;WrapComponent &#123;...this.state.props&#125; /</span>&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">      &lt;StoreContext.Consumer&gt;</span><br><span class="line">        &#123;value =&gt; <span class="xml"><span class="tag">&lt;<span class="name">ConnectComponent</span> <span class="attr">store</span>=<span class="string">&#123;value&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/StoreContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个Redux（完善版）</title>
    <url>/2020/05/14/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARedux%EF%BC%88%E5%AE%8C%E5%96%84%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p>上篇写了实现一个迷你 Redux（基础版），本篇将继续完善 Redux</p>
<a id="more"></a>

<p>阅读本文前先看：<a href="https://jacky-summer.github.io/2020/04/22/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E4%BD%A0Redux%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/" target="_blank" rel="noopener">实现一个迷你 Redux（基础版）</a></p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>Redux 有个 API 是 applyMiddleware， 专门用来使用中间件的，首先我们得知道，它用来干嘛的。</p>
<h3 id="为什么会需要中间件？"><a href="#为什么会需要中间件？" class="headerlink" title="为什么会需要中间件？"></a>为什么会需要中间件？</h3><p>假设我们现在需要记录每次的 dispatch 前后 state 的记录， 那要怎么做呢？于是，简单粗暴的在第一个 dispatch 方法前后加代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line"><span class="built_in">console</span>.log(action)</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br></pre></td></tr></table></figure>

<p>这部分运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">prev state &#123;<span class="attr">value</span>: <span class="number">10</span>&#125;</span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">"INCREMENT"</span>&#125;</span><br><span class="line">当前数字为：<span class="number">11</span></span><br><span class="line">next state &#123;<span class="attr">value</span>: <span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure>

<p>但加完发现情况不对，页面有多个 dispatch 的话，要这样写很多次，会产生大量重复代码。突然，又要加需求了，需要记录每次出错的原因,单独的功能要求如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  store.dispatch(action)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后两个需求都要，那就凑合两个，但叠一起看更乱了。</p>
<h3 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h3><p>显然，我们不能通过这种方式来做。比较理想的方案是 Redux 本身提供一个功能入口，让我们可以在外面添加功能进去，这样代码就不会复杂。</p>
<p>但如果给我们现有实现的 Redux 添加功能，在哪个环节添加比较合适呢？</p>
<ul>
<li>Reducer： 纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。</li>
<li>View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。</li>
<li>Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</li>
</ul>
<p>我们发现，以上需求都是和 dispatch 相关，只有发送 action 的这个步骤，即 store.dispatch() 方法，可以添加功能。比如添加日志功能，我们只要把日志放进 dispatch 函数里，不就好了吗，我们只需要改造 dispatch 函数，把 dispatch 进行一层封装。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="keyword">const</span> next = store.dispatch</span><br><span class="line">store.dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">    <span class="built_in">console</span>.log(action)</span><br><span class="line">    next(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码，对 store.dispatch 进行了重新定义，这就是中间件的雏形。</p>
<p>所以说 Redux 的中间件就是一个函数，是对 dispatch 方法的扩展，增强 dispatch 的功能。</p>
<h3 id="实现中间件"><a href="#实现中间件" class="headerlink" title="实现中间件"></a>实现中间件</h3><p>对于上述 dispatch 的封装，实际上是缺陷很大的。万一又来 n 多个需求怎么办? 那 dispatch 函数就混乱到无法维护了，故需要扩展性强的多中间件合作模式。</p>
<ol>
<li>我们把 loggerMiddleware 提取出来</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="keyword">const</span> next = store.dispatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loggerMiddleware = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">  <span class="built_in">console</span>.log(action)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    loggerMiddleware(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>把 exceptionMiddleware 提取出来</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    loggerMiddleware(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch = exceptionMiddleware</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>现在代码有个问题，就是 exceptionMiddleware 中间件写死 loggerMiddleware，但以后又万一不要记录功能呢，所以我们需要让 next(action) 变成动态的，即换哪个中间件都可以</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// loggerMiddleware(action)</span></span><br><span class="line">    next(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个写法可能刚开始看不太适应，实际就是函数里面，返回一个函数，即等效于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// loggerMiddleware(action)</span></span><br><span class="line">      next(action)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传参数的时候即是 exceptionMiddleware(next)(action)</p>
<ol start="4">
<li>同理，我们让 loggerMiddleware 里面无法扩展别的中间件了！我们也把 next 写成动态的</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loggerMiddleware = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">  <span class="built_in">console</span>.log(action)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前为止，整个中间件设计改造如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="keyword">const</span> next = store.dispatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loggerMiddleware = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">  <span class="built_in">console</span>.log(action)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    next(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch = exceptionMiddleware(loggerMiddleware(next))</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>现在又有一个新问题，想想平时使用中间件是从外部引入的，那外部中间件里面怎么会有 store.getState() 这个方法，于是我们把 store 也给独立出去。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="keyword">const</span> next = store.dispatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loggerMiddleware = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">  <span class="built_in">console</span>.log(action)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    next(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = loggerMiddleware(store)</span><br><span class="line"><span class="keyword">const</span> exception = exceptionMiddleware(store)</span><br><span class="line">store.dispatch = exception(logger(next))</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>如果又有一个新需求，需要在打印日志前输出当前时间戳，我们又需要构造一个中间件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timeMiddleware = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'time'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().getTime())</span><br><span class="line">  next(action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = loggerMiddleware(store)</span><br><span class="line"><span class="keyword">const</span> exception = exceptionMiddleware(store)</span><br><span class="line"><span class="keyword">const</span> time = timeMiddleware(store)</span><br><span class="line">store.dispatch = exception(time(logger(next)))</span><br></pre></td></tr></table></figure>

<h3 id="中间件使用方式优化"><a href="#中间件使用方式优化" class="headerlink" title="中间件使用方式优化"></a>中间件使用方式优化</h3><p>上面的写法可知，中间件的使用方式有点繁琐，故我们需要把细节封装起来，通过扩展 createStore 来实现。<br>先来看看期望的用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 接收旧的 createStore，返回新的 createStore */</span></span><br><span class="line"><span class="keyword">const</span> newCreateStore = applyMiddleware(</span><br><span class="line">  exceptionMiddleware,</span><br><span class="line">  timeMiddleware,</span><br><span class="line">  loggerMiddleware</span><br><span class="line">)(createStore)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回了一个 dispatch 被重写过的 store */</span></span><br><span class="line"><span class="keyword">const</span> store = newCreateStore(reducer)</span><br></pre></td></tr></table></figure>

<h3 id="实现-applyMiddleware"><a href="#实现-applyMiddleware" class="headerlink" title="实现 applyMiddleware"></a>实现 applyMiddleware</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> applyMiddleware = <span class="function"><span class="keyword">function</span> (<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 返回一个重写createStore的方法 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">rewriteCreateStoreFunc</span>(<span class="params">oldCreateStore</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 返回重写后新的 createStore */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">newCreateStore</span>(<span class="params">reducer, preloadedState</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 生成 store</span></span><br><span class="line">      <span class="keyword">const</span> store = oldCreateStore(reducer, preloadedState)</span><br><span class="line">      <span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 只暴露 store 部分给中间件用的API，而不传入整个store</span></span><br><span class="line">      <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">        getState: store.getState,</span><br><span class="line">        dispatch: <span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action),</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 给每个中间件传入API</span></span><br><span class="line">      <span class="comment">// 相当于 const logger = loggerMiddleware(store)，即 const logger = loggerMiddleware(&#123; getState, dispatch &#125;)</span></span><br><span class="line">      <span class="comment">// const chain = [exception, time, logger]</span></span><br><span class="line">      <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">      <span class="comment">// 实现 exception(time((logger(dispatch))))</span></span><br><span class="line">      chain.reverse().map(<span class="function"><span class="params">middleware</span> =&gt;</span> &#123;</span><br><span class="line">        dispatch = middleware(dispatch)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 重写dispatch</span></span><br><span class="line">      store.dispatch = dispatch</span><br><span class="line">      <span class="keyword">return</span> store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看这一处代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chain.reverse().map(<span class="function"><span class="params">middleware</span> =&gt;</span> &#123;</span><br><span class="line">  dispatch = middleware(dispatch)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>要注意一点，中间件是顺序执行，但是 dispatch 却是反序生成的。所以在这步会把数组顺序给反序（比如 applyMiddleware(A, B, C)，因为 A 在调用时需要知道 B 的 dispatch，B 在执行时需要知道 C 的 dispatch，那么需要先知道 C 的 dispatch。）</p>
<p>官方 Redux 源码，采用了 compose 函数，我们也试试这种方式来写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> applyMiddleware = <span class="function">(<span class="params">...middlewares</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compose(fn1, fn2, fn3)</span></span><br><span class="line"><span class="comment">// fn1(fn2(fn3))</span></span><br><span class="line"><span class="comment">// 从右到左来组合多个函数: 从右到左把接收到的函数合成后的最终函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> compose = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">ret, item</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> ret(item(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再对代码精简：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> applyMiddleware = <span class="function">(<span class="params">...middlewares</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">    <span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function"><span class="params">action</span> =&gt;</span> dispatch(action),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> compose = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">ret, item</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> ret(item(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createStore-的处理"><a href="#createStore-的处理" class="headerlink" title="createStore 的处理"></a>createStore 的处理</h3><p>现在的问题是，有两个 createStore 了，这怎么区分，上篇我们其实已经先告知了对中间件代码处理，但具体怎么推出的，我们继续看。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有中间件的 createStore</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有中间件的 createStore</span></span><br><span class="line"><span class="keyword">const</span> rewriteCreateStoreFunc = applyMiddleware(</span><br><span class="line">  exceptionMiddleware,</span><br><span class="line">  timeMiddleware,</span><br><span class="line">  loggerMiddleware</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> newCreateStore = rewriteCreateStoreFunc(createStore)</span><br><span class="line"><span class="keyword">const</span> store = newCreateStore(counter, preloadedState)</span><br></pre></td></tr></table></figure>

<p>为了让用户用起来统一一些，我们可以很简单的使他们的使用方式一致，我们修改下 createStore 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer, preloadedState, rewriteCreateStoreFunc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果有 rewriteCreateStoreFunc，那就采用新的 createStore</span></span><br><span class="line">  <span class="keyword">if</span> (rewriteCreateStoreFunc) &#123;</span><br><span class="line">    <span class="keyword">const</span> newCreateStore = rewriteCreateStoreFunc(createStore)</span><br><span class="line">    <span class="keyword">return</span> newCreateStore(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过 Redux 源码 rewriteCreateStoreFunc 换了个名字，还加了判断，也就是我们上篇的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以中间件的用法为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter, <span class="comment">/* preloadedState可选 */</span> applyMiddleware(logger))</span><br></pre></td></tr></table></figure>

<h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><p>如果我们做的项目很大，有大量 state，那么维护起来很麻烦。Redux 提供了 combineReducers 这个方法，作用是把多个 reducer 合并成一个 reducer， 每个 reducer 负责独立的模块。</p>
<p>我们用一个新例子来举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initCounterState = &#123;</span><br><span class="line">  value: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> initInfoState = &#123;</span><br><span class="line">  name: <span class="string">'jacky'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">  info: infoReducer,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// counter reducer处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counterReducer</span>(<span class="params">state = initCounterState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        value: state.value + <span class="number">1</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        value: state.value - <span class="number">1</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infoReducer</span>(<span class="params">state = initInfoState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'FULL_NAME'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        name: state.name + <span class="string">' lin'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = store.getState()</span><br><span class="line"><span class="comment">// 一开始counter为：10，info为 jacky</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`一开始counter为：<span class="subst">$&#123;init.counter.value&#125;</span>，info为 <span class="subst">$&#123;init.info.name&#125;</span>`</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  store.getState()</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(listener) <span class="comment">// 监听state的改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// counterReducer</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// infoReducer</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'FULL_NAME'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行完counter为：11，info为jacky lin</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="string">`执行完counter为：<span class="subst">$&#123;store.getState().counter.value&#125;</span>，info为<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">    store.getState().info.name</span></span></span><br><span class="line"><span class="string"><span class="subst">  &#125;</span>`</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>我们来尝试下如何实现这个 API，</p>
<p>首先要把一个函数里的所有 reducers 循环执行一遍，并且这个函数要遵循(state, action) =&gt; newState 格式。还需要把每个 reducer 的 initState 合并成一个 rootState。<br>实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// reducerKeys = ['counter', 'info']</span></span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">  <span class="comment">// 返回合并后的新的reducer函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 生成的新的state</span></span><br><span class="line">    <span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历执行所有的reducers，整合成为一个新的state</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = reducerKeys[i]</span><br><span class="line">      <span class="keyword">const</span> reducer = reducers[key]</span><br><span class="line">      <span class="comment">// 之前的 key 的 state</span></span><br><span class="line">      <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">      <span class="comment">// 执行 分 reducer，获得新的state</span></span><br><span class="line">      <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line"></span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="replaceReducer"><a href="#replaceReducer" class="headerlink" title="replaceReducer"></a>replaceReducer</h2><blockquote>
<p>在大型 Web 应用程序中，通常需要将应用程序代码拆分为多个可以按需加载的 JS 包。 这种称为“代码分割”的策略通过减小初次加载时的 JS 的包的大小，来提高应用程序的性能。</p>
</blockquote>
<p>reducer 拆分后，和组件是一一对应的。我们就希望在做按需加载的时候，reducer 也可以跟着组件在必要的时候再加载，然后用新的 reducer 替换老的 reducer。但实际上只有一个 root reducer 函数, 如果要实现的话就可以用 replaceReducer 这个函数，实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function"><span class="keyword">function</span> (<span class="params">reducer, initState</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> replaceReducer = <span class="function"><span class="params">nextReducer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the nextReducer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    reducer = nextReducer</span><br><span class="line">    <span class="comment">// 刷新一遍 state 的值，新来的 reducer 把自己的默认状态放到 state 树上去</span></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="built_in">Symbol</span>() &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    replaceReducer,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*生成新的reducer*/</span></span><br><span class="line"><span class="keyword">const</span> nextReducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">  info: infoReducer,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*replaceReducer*/</span></span><br><span class="line">store.replaceReducer(nextReducer)</span><br></pre></td></tr></table></figure>

<h2 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h2><p>bindActionCreators 一般比较少用到，在 react-redux 的 connect 函数实现会用到</p>
<p>会使用到 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 dispatch 或 Redux store 传给它。</p>
<p>我们通过普通的方式来 隐藏 dispatch 和 actionCreator 试试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">  info: infoReducer,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 action 的函数就叫 actionCreator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'INCREMENT'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'FULL_NAME'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> store.dispatch(increment.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> store.dispatch(getName.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他地方在实现自增的时候，根本不知道 dispatch，actionCreator等细节</span></span><br><span class="line">actions.increment() <span class="comment">// 自增</span></span><br><span class="line">actions.getName() <span class="comment">// 获得全名</span></span><br></pre></td></tr></table></figure>

<p>把 actions 生成时候的公共代码提取出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = bindActionCreators(&#123; increment, getName &#125;, store.dispatch)</span><br></pre></td></tr></table></figure>

<p>bindActionCreators 的实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回包裹 dispatch 的函数, 将 actionCreator 转化成 dispatch 形式</span></span><br><span class="line"><span class="comment">// eg. &#123; addNumAction &#125;  =&gt;  (...args) =&gt; dispatch(addNumAction(args))</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(actionCreator.apply(<span class="keyword">this</span>, args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params">actionCreators, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// actionCreators 必须是 function 或者 object</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators !== <span class="string">'object'</span> || actionCreators === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(actionCreators)</span><br><span class="line">  <span class="keyword">const</span> boundActionCreators = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">const</span> actionCreator = actionCreators[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span>) &#123;</span><br><span class="line">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> boundActionCreators</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能大家看到这里有点懵逼，让我们来回忆下 react-redux 中 connect 函数的用法，<br>比如有这样一个 actionCreators</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// actionCreators.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNumAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: <span class="string">'ADD_NUM'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Demo.js：在需要用到 store 数据的组件，如 Demo 组件底部我们用 connect 函数连接，如下:</span></span><br><span class="line"><span class="keyword">import</span> &#123; addNumAction &#125; <span class="keyword">from</span> <span class="string">'./actionCreators'</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;</span><br><span class="line">  addNum() &#123;</span><br><span class="line">    dispatch(addNumAction())</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Demo)</span><br></pre></td></tr></table></figure>

<p>然后通过页面的按钮来出发 action 为 ADD_NUM 对应事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.props.addNum&#125;&gt;增加<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<p>但除了上面的用法，mapDispatchToProps 也可以这样用，直接传入一个对象，都没有 dispatch 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, &#123; addNumAction &#125;)(Demo)</span><br></pre></td></tr></table></figure>

<p>然后只需触发 addNumAction 就能实现和上面一样的效果。</p>
<p>为什么可以不传，当你传入对象的时候， connect 函数会判断，大致代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatchToProps</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> mapDispatchToProps === <span class="string">'function'</span>) &#123;</span><br><span class="line">  dispatchToProps = mapDispatchToProps(store.dispatch)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 传递了一个 actionCreator 对象过来</span></span><br><span class="line">  dispatchToProps = bindActionCreators(mapDispatchToProps, store.dispatch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就使用了 bindActionCreators 函数，它就是把你传入的 actionCreator 再包一层 dispatch 方法，即</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; addNumAction &#125;  =&gt;  <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(addNumAction(args))</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redux 实现讲到这里就结束了，把原理搞懂了确实对 Redux 的理解加深了好多，之后会继续写相关插件的实现，如 react-redux 等。</p>
<p>参考资料：</p>
<p><a href="https://github.com/brickspert/blog/issues/22" target="_blank" rel="noopener">完全理解 redux（从零实现一个 redux）</a></p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励吧~</li>
</ul>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>总结JS数组方法</title>
    <url>/2020/05/10/%E6%80%BB%E7%BB%93JS%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在日常开发中，使用数组方法的情况是很多的。但总有几个方法用得不是很多，就容易忘记具体用法，于是，今天打算做下总结笔记，回顾数组方法。</p>
<a id="more"></a>

<h2 id="改变原数组的方法（9-个）"><a href="#改变原数组的方法（9-个）" class="headerlink" title="改变原数组的方法（9 个）"></a>改变原数组的方法（9 个）</h2><h3 id="push-和-pop"><a href="#push-和-pop" class="headerlink" title="push()和 pop()"></a>push()和 pop()</h3><p>共同点：<strong>数组尾部操作的方法</strong></p>
<h4 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h4><ul>
<li>用法：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</li>
<li>返回值：把指定的值添加到数组后的新长度。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.push(newEle1, newEle2, ..., newEleX)  要添加到数组末尾的元素</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr.push(<span class="number">4</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><ul>
<li>用法：pop() 方法用于删除并返回数组的最后一个元素。</li>
<li>返回值：arrayObject 的最后一个元素</li>
<li>说明：如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.pop()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.pop() <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="shift-和-unshift"><a href="#shift-和-unshift" class="headerlink" title="shift()和 unshift()"></a>shift()和 unshift()</h3><p>共同点：<strong>数组首部操作的方法</strong></p>
<h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><ul>
<li>用法：用于把数组的第一个元素从其中删除，并返回第一个元素的值。</li>
<li>返回值：数组原来的第一个元素的值。</li>
<li>说明：如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.shift()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.shift() <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><ul>
<li>用法：可向数组的开头添加一个或更多元素，并返回新的长度。</li>
<li>返回值：arrayObject 的新长度。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.unshift(newEle1, newEle2, ..., newEleX)  要添加到数组首部的元素</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.unshift(<span class="number">100</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [100, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="reverse-和-sort"><a href="#reverse-和-sort" class="headerlink" title="reverse()和 sort()"></a>reverse()和 sort()</h3><p>共同点：<strong>重排序的方法</strong></p>
<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><ul>
<li>用法：用于颠倒数组中元素的顺序。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.reverse()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">arr.reverse()</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ['c', 'b', 'a']</span></span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><ul>
<li>用法：用于对数组的元素进行排序。</li>
<li>说明：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.sort(sortby) 可选。规定排序顺序。必须是函数。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'monkey'</span>, <span class="string">'jacky'</span>, <span class="string">'tom'</span>, <span class="string">'john'</span>]</span><br><span class="line">arr.sort()</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ['jacky', 'john', 'monkey', 'tom']</span></span><br></pre></td></tr></table></figure>

<ul>
<li>比较函数的两个参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort的比较函数有两个默认参数，接受参数然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</span><br><span class="line"></span><br><span class="line">若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</span><br><span class="line">若 a 等于 b，则返回 0。</span><br><span class="line">若 a 大于 b，则返回一个大于 0 的值。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment">// 升序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 3, 4, 5, 7, 8, 100]</span></span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b - a</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [100, 8, 7, 5, 4, 3, 1]</span></span><br></pre></td></tr></table></figure>

<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><ul>
<li>用法：向/从数组中添加/删除项目，然后返回被删除的项目。</li>
<li>返回值：包含被删除项目的新数组，如果有的话。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.splice(index, howmany, item1, ....., itemX)</span><br><span class="line"><span class="comment">// index:必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</span></span><br><span class="line"><span class="comment">// howmany:必需。要删除的项目数量。如果设置为 0，则不会删除项目。</span></span><br><span class="line"><span class="comment">// item, ..., itemX:可选。向数组添加的新项目。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 删除数组下标为 1 的元素，删除一个</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line">arr.splice(<span class="number">-3</span>, <span class="number">2</span>) <span class="comment">// 从倒数第三个元素开始删除，删除两个</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 3, 4, 5, 8]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除并添加</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>) <span class="comment">// 删除数组下标为 0 的元素，删除两个；并在数组下标为0的位置添加100</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [100, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不删除只添加</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>) <span class="comment">// 在数组下标为0的位置添加9 10 11</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [9, 10, 11, 1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6：fill"><a href="#ES6：fill" class="headerlink" title="ES6：fill()"></a>ES6：fill()</h3><ul>
<li>用法：用于将一个固定值替换数组的元素。</li>
<li>返回值：修改后的数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.fill(value, start, end)</span><br><span class="line"><span class="comment">// value:必需。填充的值。</span></span><br><span class="line"><span class="comment">// start:可选。开始填充位置。</span></span><br><span class="line"><span class="comment">// end:	可选。停止填充位置 (默认为 arrayObject.length)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充 "replace" 到数组的第三和第四个元素：</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line">arr.fill(<span class="string">'replace'</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ["a", "b", "replace", "replace", "e"]</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6：copyWithin"><a href="#ES6：copyWithin" class="headerlink" title="ES6：copyWithin()"></a>ES6：copyWithin()</h3><ul>
<li>用法：用于从数组的指定位置拷贝元素到数组的另一个指定位置中。</li>
<li>返回值：修改后的数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.copyWithin(target, start, end)</span><br><span class="line"><span class="comment">// value:必需。复制到指定目标索引位置。。</span></span><br><span class="line"><span class="comment">// start:可选。元素复制的起始位置。</span></span><br><span class="line"><span class="comment">// end:	可选。停止复制的索引位置 (默认为 arrayObject.length)。如果为负值，表示倒数。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line">arr.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ["a", "b", "a", "b", "e"]</span></span><br></pre></td></tr></table></figure>

<h2 id="不改变原数组的方法（8-个）"><a href="#不改变原数组的方法（8-个）" class="headerlink" title="不改变原数组的方法（8 个）"></a>不改变原数组的方法（8 个）</h2><ul>
<li>注: 数组的每一项是简单数据类型，且未直接操作数组的情况下</li>
</ul>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><ul>
<li>用法：从已有的数组中返回选定的元素。</li>
<li>返回值：返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.slice(start, end)</span><br><span class="line"><span class="comment">// start:必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。</span></span><br><span class="line"><span class="comment">// end:可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.slice()) <span class="comment">// ["a", "b", "c", "d", "e"]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">2</span>)) <span class="comment">// ["c", "d", "e"]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">0</span>, <span class="number">3</span>)) <span class="comment">// ["a", "b", "c"]</span></span><br></pre></td></tr></table></figure>

<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><ul>
<li>用法：方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.indexOf(item, start)</span><br><span class="line"><span class="comment">// start:必须。查找的元素。</span></span><br><span class="line"><span class="comment">// end:	可选的整数参数。规定在数组中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'c'</span>)) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'a'</span>, <span class="number">1</span>)) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h3><ul>
<li>用法：返回一个指定的元素在数组中最后出现的位置，从该字符串的后面向前查找。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.lastIndexOf(item, start)</span><br><span class="line"><span class="comment">// start:必须。查找的元素。</span></span><br><span class="line"><span class="comment">// end:	可选的整数参数。规定在数组中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。则将从字符串的最后一个字符处开始检索。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'a'</span>)) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'b'</span>, <span class="number">2</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><ul>
<li>用法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。</li>
<li>返回值：返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入 separator 字符串而生成的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.join(separator)</span><br><span class="line"><span class="comment">// separator:可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.join()) <span class="comment">// a,b,c,b,e,a</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">'.'</span>)) <span class="comment">// a.b.c.b.e.a</span></span><br></pre></td></tr></table></figure>

<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ul>
<li>用法：用于连接两个或多个数组。</li>
<li>返回值：返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.concat(arrayX, arrayX, ......, arrayX)</span><br><span class="line"><span class="comment">// arrayX: 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(<span class="number">4</span>, <span class="number">5</span>)) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(arr2)) <span class="comment">// [1, 2, 3, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><ul>
<li>用法：把数组转换为字符串，并返回结果。</li>
<li>返回值：arrayObject 的字符串表示。返回值与没有参数的 join() 方法返回的字符串相同。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.toString()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// a,b,c,b,e,a</span></span><br></pre></td></tr></table></figure>

<p>相对 join() 方法，更推荐使用 join() 方法，不推荐使用该方法</p>
<h3 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString()"></a>toLocaleString()</h3><ul>
<li>用法：把数组转换为本地字符串。</li>
<li>返回值：arrayObject 的本地字符串表示。</li>
<li>说明：首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.toLocaleString()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="number">23</span>, &#123; <span class="attr">name</span>: <span class="string">'jacky'</span> &#125;, <span class="keyword">new</span> <span class="built_in">Date</span>()]</span><br><span class="line"><span class="built_in">console</span>.log(arr.toLocaleString()) <span class="comment">// a,23,[object Object],2020/5/10 上午10:58:37</span></span><br></pre></td></tr></table></figure>

<h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><ul>
<li>用法：用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。</li>
<li>返回值：arrayObject 的本地字符串表示。</li>
<li>说明：首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.includes(searchElement, fromIndex)</span><br><span class="line"><span class="comment">// searchElement：必须。需要查找的元素值。</span></span><br><span class="line"><span class="comment">// fromIndex：可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">2</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">4</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">3</span>, <span class="number">3</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">3</span>, <span class="number">-1</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><ul>
<li>用法：用于调用数组的每个元素，并将元素传递给回调函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。传递给函数的值一般用 "<span class="title">this</span>" 值。如果这个参数为空， "<span class="title">undefined</span>" 会传递给 "<span class="title">this</span>" 值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item) <span class="comment">// 1 2 4 6 8</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item, index, arr)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 0 [1, 2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 2 1 [1, 2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 4 2 [1, 2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 6 3 [1, 2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 8 4 [1, 2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><ul>
<li>用法：用于检测数组所有元素是否都符合指定条件（通过函数提供）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。对象作为该执行回调时使用，传递给函数，用作 "<span class="title">this</span>" 的值。</span></span><br><span class="line"><span class="function">如果省略了 <span class="title">thisValue</span> ，"<span class="title">this</span>" 的值为 "<span class="title">undefined</span>"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>every() 方法使用指定函数检测数组中的所有元素：</p>
<ul>
<li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</li>
<li>如果所有元素都满足条件，则返回 true。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res1 = arr.every(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 检测数组中的所有元素是否大于2</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> res2 = arr.every(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 检测数组中的所有元素是否大于10</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(res2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><ul>
<li>用法：用于检测数组中的元素是否满足指定条件（函数提供）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。对象作为该执行回调时使用，传递给函数，用作 "<span class="title">this</span>" 的值。</span></span><br><span class="line"><span class="function">如果省略了 <span class="title">thisValue</span> ，"<span class="title">this</span>" 的值为 "<span class="title">undefined</span>"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>some() 方法会依次执行数组的每个元素：</p>
<ul>
<li>如果有一个元素满足条件，则表达式返回 true , 剩余的元素不会再执行检测。</li>
<li>如果没有满足条件的元素，则返回 false。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res1 = arr.some(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 检测数组中是否有一个元素是否大于10</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> res2 = arr.some(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 检测数组中是否有一个元素是否大于100</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">100</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(res2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><ul>
<li>用法：创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</li>
<li>返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。对象作为该执行回调时使用，传递给函数，用作 "<span class="title">this</span>" 的值。</span></span><br><span class="line"><span class="function">如果省略了 <span class="title">thisValue</span> ，"<span class="title">this</span>" 的值为 "<span class="title">undefined</span>"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res1 = arr.filter(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回数组中所有大于5的元素</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> res2 = arr.filter(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回数组中所有小于5的元素</span></span><br><span class="line">  <span class="keyword">return</span> num &lt; <span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// [6, 8, 10, 12]</span></span><br><span class="line"><span class="built_in">console</span>.log(res2) <span class="comment">// [4]</span></span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><ul>
<li>用法：返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。对象作为该执行回调时使用，传递给函数，用作 "<span class="title">this</span>" 的值。</span></span><br><span class="line"><span class="function">如果省略了 <span class="title">thisValue</span> ，"<span class="title">this</span>" 的值为 "<span class="title">undefined</span>"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.map(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 数组每个元素都乘10</span></span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// [40, 60, 80, 100, 120]</span></span><br></pre></td></tr></table></figure>

<h2 id="数组归并方法"><a href="#数组归并方法" class="headerlink" title="数组归并方法"></a>数组归并方法</h2><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><ul>
<li>用法：接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</li>
<li>reduce() 可以作为一个高阶函数，用于函数的 compose。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total, currentValue, currentIndex, arr</span>), <span class="title">initialValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">total</span>：必需。初始值, 或者计算结束后的返回值。</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">currentIndex</span>：可选。当前元素的索引</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">initialValue</span>：可选。传递给函数的初始值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total + num</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<h3 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h3><ul>
<li>用法：方法的功能和 reduce() 功能是一样的，不同的是 reduceRight() 从数组的末尾向前将数组中的数组项做累加。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">total, currentValue, currentIndex, arr</span>), <span class="title">initialValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">total</span>：必需。初始值, 或者计算结束后的返回值。</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">currentIndex</span>：可选。当前元素的索引</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">initialValue</span>：可选。传递给函数的初始值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduceRight(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total - num</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈React的Context-API</title>
    <url>/2020/04/28/%E6%B5%85%E8%B0%88React%E7%9A%84Context-API/</url>
    <content><![CDATA[<p>上下文(Context) 提供了在组件之间共享这些值的方法，而不必在树的每个层级显式传递一个 prop 。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般情况下，在你没有绝对把握用好和必须的场景下，是不推荐使用的。</p>
<p>但是我们依然间接的使用着它，比如许多官方依赖在使用，如：react-redux, mobx-react，react-router。我们需要它功能的时候，更多是靠第三方依赖库就能实现，而不是自己手动写 context。但是，依然需要理解它，对用它的一些依赖库源码理解很有帮助。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: <span class="string">'GrandPa组件的信息'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Father info=&#123;<span class="keyword">this</span>.state.info&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Father extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Son info=&#123;this.props.info&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Son extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;div&gt;我是Son组件，拿到信息为：&#123;this.props.info&#125;&lt;/</span>div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Grandpa</span><br></pre></td></tr></table></figure>

<p>最后页面输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是Son组件，拿到信息为：GrandPa组件的信息</span><br></pre></td></tr></table></figure>

<p>我们会发现这样的缺点是一层一层传值，如果有更多层级和更多数据的话，会让代码看起来很不整洁，如果中间哪个组件忘了传值基本就完了；而且 Father 组件也并没有用到 info 值，只是将值传给 Son 组件。</p>
<p>如果使用 context，就能帮我们解决这个层级不停传值的问题。</p>
<p>context 有旧版和新版之分，以 React v16.3.0 版本划分。</p>
<h2 id="旧版-Context-API"><a href="#旧版-Context-API" class="headerlink" title="旧版 Context API"></a>旧版 Context API</h2><p>我们先来说下旧版 context API</p>
<p>将代码改成如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: <span class="string">'GrandPa组件的信息'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">info</span>: <span class="keyword">this</span>.state.info &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Father /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 声明Context对象属性</span></span><br><span class="line"><span class="regexp">Grandpa.childContextTypes = &#123;</span></span><br><span class="line"><span class="regexp">  info: PropTypes.string,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Father extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Son /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Son extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;div&gt;我是Son组件，拿到信息为：&#123;this.context.info&#125;&lt;/</span>div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据约定好的参数类型声明</span></span><br><span class="line">Son.contextTypes = &#123;</span><br><span class="line">  info: PropTypes.string,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Grandpa</span><br></pre></td></tr></table></figure>

<p>对 PropTypes 类型检查，还可以写成下面这种写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    info: PropTypes.string,</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: <span class="string">'GrandPa组件的信息'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">info</span>: <span class="keyword">this</span>.state.info &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Father /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在需要传出去的 context 值和需要接收 context 值都要进行类型检查判断。</p>
<p>正常用这个 api 可能没什么问题，但如果中间哪个组件用到<code>shouldComponentUpdate</code>方法的话，就很可能出现问题。</p>
<p>三个组件的层级关系如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;GrandPa&gt;</span><br><span class="line">  &lt;Father&gt;</span><br><span class="line">    &lt;Son /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Father&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>GrandPa&gt;</span><br></pre></td></tr></table></figure>

<p>如果在 GrandPa 组件设置按钮点击可以更新 info 的值，即通过<code>this.setState({info: &#39;改变值&#39;})</code>方法<br>更新 Context：<br>那么</p>
<ul>
<li>GrandPa 组件通过 setState 设置新的 Context 值同时触发子组件重新 render。</li>
<li>Father 组件重新 render。</li>
<li>Son 组件重新 render，并拿到更新后的 Context。</li>
</ul>
<p>假如在 Father 组件添加函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Father 并不依赖任何值，所以我们默认让它无需重新 render。但是，这会导致 Son 组件也不会重新 render，即无法获取到最新的 Context 值。</p>
<p>这样的不确定性对于目标组件来说是完全不可控的，也就是说目标组件无法保证自己每一次都可以接收到更新后的 Context 值。这是旧版 API 存在的一个大问题。</p>
<p>而新版 API 解决了这个问题，我们来看下新版 API 怎么写的</p>
<h2 id="新版-Context-API"><a href="#新版-Context-API" class="headerlink" title="新版 Context API"></a>新版 Context API</h2><blockquote>
<p>新版 Context 新增了 creactContext() 方法用来创建一个 context 对象。这个对象包含两个组件，一个是 Provider（生产者），另一个是 Consumer（消费者）。</p>
</blockquote>
<ol>
<li>Provider 和 Consumer 必须来自同一个 Context 对象，即一个由 React.createContext()创建的 Context 对象。</li>
<li>React.createContext()方法接收一个参数做默认值，当 Consumer 外层没有对应的 Provider 时就会使用该默认值。</li>
<li>Provider 组件使用 Object.is 方法判断 prop 值是否发生改变，当 prop 的值改变时，其内部组件树中对应的 Consumer 组件会接收到新值并重新渲染。此过程不受 shouldComponentUpdete 方法的影响。</li>
<li>Consumer 组件接收一个函数作为 children prop 并利用该函数的返回值生成组件树的模式被称为 Render Props 模式。</li>
</ol>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol>
<li>首先创建一个 context 对象</li>
</ol>
<blockquote>
<p>React.createContext 方法用于创建一个 Context 对象。该对象包含 Provider 和 Consumer 两个属性，分别为两个 React 组件。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> InfoContext = React.createContext(<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 Provider 组件生成一个 context</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: <span class="string">'GrandPa组件的信息'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;InfoContext.Provider value=&#123;&#123; <span class="attr">info</span>: <span class="keyword">this</span>.state.info &#125;&#125;&gt;</span><br><span class="line">        &lt;Father /&gt;</span><br><span class="line">      &lt;<span class="regexp">/InfoContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 Consumer 组件获取 context 对象的值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;InfoContext.Consumer&gt;</span><br><span class="line">        &#123;value =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是Son组件，拿到信息为：&#123;value.info&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;<span class="regexp">/InfoContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>ContextAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个迷你Redux（基础版）</title>
    <url>/2020/04/22/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E4%BD%A0Redux%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p>本文从将从Redux原理出发，一步步自己实现一个简单的Redux，主要目的是了解Redux内部之间的联系。看本文之前先要知道Redux是怎么用的，对Redux用法不会讲解太多。</p>
<a id="more"></a>

<h2 id="Redux介绍"><a href="#Redux介绍" class="headerlink" title="Redux介绍"></a>Redux介绍</h2><p>首先要知道的是，Redux 和 React 没有关系，Redux 可以用在任何框架中。<br>Redux 是一个JavaScript 状态管理器，是一种新型的前端“架构模式”。</p>
<p>还有通常与redux一起用的一个库——react-redux， 它就是把 Redux 这种架构模式和 React.js 结合起来的一个库，就是 Redux 架构在 React.js 中的体现。</p>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ol>
<li>Web 应用是一个状态机，视图与状态是一一对应的。</li>
<li>所有的状态，保存在一个对象里面。</li>
</ol>
<h2 id="何时使用Redux"><a href="#何时使用Redux" class="headerlink" title="何时使用Redux"></a>何时使用Redux</h2><ol>
<li>用户的使用方式复杂</li>
<li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li>
<li>多个用户之间可以协作</li>
<li>与服务器大量交互，或者使用了WebSocket</li>
<li>View要从多个来源获取数据</li>
</ol>
<p>从组件的角度看：</p>
<ol>
<li>某个组件的状态，需要共享</li>
<li>某个状态需要在任何地方都可以拿到</li>
<li>一个组件需要改变全局状态</li>
<li>一个组件需要改变另一个组件的状态</li>
</ol>
<h2 id="Redux工作流程"><a href="#Redux工作流程" class="headerlink" title="Redux工作流程"></a>Redux工作流程</h2><p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718ce1ceca204e3?w=898&h=421&f=png&s=148790" alt=""></p>
<ol>
<li>Redux 将整个应用状态(state)存储到一个地方(通常我们称其为 store)</li>
<li>当我们需要修改状态时，必须派发(dispatch)一个 action( action 是一个带有 type 字段的对象)</li>
<li>专门的状态处理函数 reducer 接收旧的 state 和 action ，并会返回一个新的 state</li>
<li>通过 subscribe 设置订阅，每次派发动作时，通知所有的订阅者。</li>
</ol>
<p>从这个流程中可以看出，Redux 的核心就是一个 观察者 模式。一旦 store 发生了变化就会通知所有的订阅者，视图(在这里是react组件)接收到通知之后会进行重新渲染。</p>
<h2 id="Redux案例"><a href="#Redux案例" class="headerlink" title="Redux案例"></a>Redux案例</h2><p>为了简化说明，我用和官网差不多的例子改写来作案例<br><a href="https://redux.js.org/introduction/getting-started" target="_blank" rel="noopener">官网redux demo</a></p>
<p>新建一个文件redux.js，然后直接引入，观察控制台输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">    value: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// reducer处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span> (<span class="params">state = defaultState, action</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(state, action)</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                value: state.value + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                value: state.value - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = store.getState()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`一开始数字为：<span class="subst">$&#123;init.value&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> current = store.getState()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`当前数字为：<span class="subst">$&#123;current.value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(listener) <span class="comment">// 监听state的改变</span></span><br><span class="line"></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line"><span class="comment">// 当前数字为：11</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line"><span class="comment">// 当前数字为：12</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;)</span><br><span class="line"><span class="comment">// 当前数字为：11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;value: 10&#125; &#123;type: &quot;@@redux&#x2F;INIT1.a.7.g.7.t&quot;&#125;</span><br><span class="line">一开始数字为：10</span><br><span class="line">&#123;value: 10&#125; &#123;type: &quot;INCREMENT&quot;&#125;</span><br><span class="line">当前数字为：11</span><br><span class="line">&#123;value: 11&#125; &#123;type: &quot;INCREMENT&quot;&#125;</span><br><span class="line">当前数字为：12</span><br><span class="line">&#123;value: 12&#125; &#123;type: &quot;DECREMENT&quot;&#125;</span><br><span class="line">当前数字为：11</span><br></pre></td></tr></table></figure>
<p>所有对数据的操作必须通过 dispatch 函数，它接受一个参数action，action是一个普通的JavaScript对象，action必须包含一个<code>type</code>字段，告诉它要修改什么，只有它允许才能修改。</p>
<p>在每次调用进来reducer函数我们都打印了state和action，我们手动通过store.dispatch方法派发了三次action，但你会发现输出了四次.这是因为Redux内部初始化就自动执行了一次dispatch方法，可以看到第一次执行它的type对我们数据来说是没有影响的（因为type取值<code>@@redux/INIT1.a.7.g.7.t</code>，我们自己redux的数据type不会取名成这个样子，所以不会跟它重复），即默认输出state值</p>
<h2 id="动手实现一个Redux"><a href="#动手实现一个Redux" class="headerlink" title="动手实现一个Redux"></a>动手实现一个Redux</h2><ol>
<li>首先要手动实现一个Redux之前，先看看有上述代码涉及到Redux什么方法，首先引入了<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#39;redux&#39;</span><br><span class="line">&#x2F;&#x2F; 传入reducer</span><br><span class="line">const store &#x3D; createStore(reducer)</span><br></pre></td></tr></table></figure>
createStore 会返回一个对象，这个对象包含三个方法，于是我们可以列出Redux雏形。</li>
</ol>
<p>新建mini-redux.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function createStore (reducer) &#123;</span><br><span class="line"></span><br><span class="line">    const getState &#x3D; () &#x3D;&gt; &#123;&#125;</span><br><span class="line">    const subscribe &#x3D; () &#x3D;&gt; &#123;&#125;</span><br><span class="line">    const dispatch &#x3D; () &#x3D;&gt; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    return &#123; </span><br><span class="line">        getState, </span><br><span class="line">        subscribe, </span><br><span class="line">        dispatch </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>store.getState()用于获取 state 数据，其实就是简单地把 state 参数返回。于是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        getState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>dispatch方法会接收一个action，执行会调用 <code>reducer</code> 返回一个新状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        getState,</span><br><span class="line">        dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 subscribe 设置监听函数（设置订阅），一旦 state 发生变化，就自动执行这个函数（通知所有的订阅者）。</p>
</li>
</ol>
<p>怎么实现呢？我们可以直接使用subscribe函数把你要监听的事件添加到数组, 然后执行dispatch方法的时候把listeners数组的监听函数给执行一遍。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听函数，可添加多个</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        currentListeners.push(listener)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">        currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        getState,</span><br><span class="line">        subscribe,</span><br><span class="line">        dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻开一开始我们那个Redux例子，其实就是把<code>store.getState()</code>添加进来，dispatch派发一个action后，reducer执行返回新的state，并执行了监听函数<code>store.getState()</code>，state的值就发生变化了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> current = store.getState()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`当前数字为：<span class="subst">$&#123;current.value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(listener) <span class="comment">// 监听state的改变</span></span><br></pre></td></tr></table></figure>
<p>上述代码，跟React依然没有关系，只是纯属Redux例子。但想一想当我们把Redux和React一起用的时候，还会多做这么一步。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = store.getState()</span><br><span class="line">    <span class="keyword">this</span>.storeChange = <span class="keyword">this</span>.storeChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    store.subscribe(<span class="keyword">this</span>.storeChange)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">storeChange () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(store.getState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在React里面监听的方法，还要用<code>this.setState()</code>, 这是因为React中state的改变必须依赖于<code>this.setState</code>方法。所以对于 React 项目，就是组件的render方法或setState方法放入listen（监听函数），才会实现视图的自动渲染，改变页面中的state值。</p>
<p>最后一步，注意我们上面说的，当初始化的时候，dispatch会先自动执行一次，继续改代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        currentListeners.push(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">        currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尽量写得复杂，使不会与我们自定义的action有重复可能</span></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'@@mini-redux/~GSDG4%FDG#*&amp;'</span> &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        getState, </span><br><span class="line">        subscribe, </span><br><span class="line">        dispatch </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写到这里，我们把引入的redux替换我们写的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#39;.&#x2F;mini-redux&#39;</span><br></pre></td></tr></table></figure>
<p>当我们执行的时候，发现结果并不如我们所愿：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#125; &#123;type: &quot;@@mini-redux&#x2F;~GSDG4%FDG#*&amp;&quot;&#125;</span><br><span class="line">一开始数字为：undefined</span><br><span class="line">&#123;&#125; &#123;type: &quot;INCREMENT&quot;&#125;</span><br><span class="line">当前数字为：NaN</span><br><span class="line">&#123;type: &quot;INCREMENT&quot;&#125;</span><br><span class="line">当前数字为：NaN</span><br><span class="line">&#123;value: NaN&#125; &#123;type: &quot;DECREMENT&quot;&#125;</span><br><span class="line">当前数字为：NaN</span><br></pre></td></tr></table></figure>
<p>这个怎么回事呢？因为我们写的redux一开始就给state赋值为{}，在事实state初始值是由外部传入的，通常我们自己写的时候会设置默认值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">    value: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span> (<span class="params">state = defaultState, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在我们Redux实现中却把它手动置为空对象，在这里我们暂时解决方法就是不给它赋值，让它为undefined，这样reducer的默认参数就会生效。redux初始化第一次dispatch时，就会让它自动赋值为reducer传入的第一个参数state默认值（ES6函数默认赋值），所以修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState </span><br><span class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        currentListeners.push(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">        currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'@@mini-redux/~GSDG4%FDG#*&amp;'</span> &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        getState, </span><br><span class="line">        subscribe, </span><br><span class="line">        dispatch </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个mini-redux.js，我们就可以实现跟原来的redux完全一样的输出效果了。</p>
<h2 id="完善Redux"><a href="#完善Redux" class="headerlink" title="完善Redux"></a>完善Redux</h2><p>接下来我们继续补充知识点</p>
<ol>
<li>createStore实际有三个参数，即<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">createStore(reducer, [preloadedState], enhancer)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>第二个参数 <code>[preloadedState] (any)</code>是可选的: initial state</p>
<p>第三个参数<code>enhancer(function)</code>也是可选的：用于添加中间件的</p>
<p>通常情况下，通过 preloadedState 指定的 state 优先级要高于通过 reducer 指定的 state。这种机制的存在允许我们在 reducer 可以通过指明默认参数来指定初始数据，而且还为通过服务端或者其它机制注入数据到 store 中提供了可能。</p>
<p>第三个参数我们下篇会说，先继续完善一下代码，我们需要对第二个和第三个可选参数进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当第二个参数没有传preloadedState，而直接传function的话，就会直接把这个function当成enhancer</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        enhancer = preloadedState</span><br><span class="line">        preloadedState = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当第三个参数传了但不是function也会报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reducer必须为函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the reducer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentState = preloadedState <span class="comment">// 第二个参数没传默认就是undefined赋给currentState</span></span><br><span class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于第三个参数判断为什么返回<br><code>return enhancer(createStore)(reducer, preloadedState)</code>我们下篇会说，这篇先忽略。<br>2. 我们实现了store.subscribe()方法，但还是不完整的，subscribe方法可以添加监听函数listener,它还有返回值，返回一个移除listener的函数；另外我们依然要对类型进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        currentListeners.push(listener)</span><br><span class="line">        <span class="comment">// 通过filter过滤，执行的时候将之前本身已经添加进数组的事件名移除数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            currentListeners = currentListeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过找数组下标的方式移除listener</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    currentListeners.push(listener)</span><br><span class="line">    <span class="comment">// 通过filter过滤，执行的时候将之前本身已经添加进数组的事件名移除数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = currentListeners.indexOf(listener)</span><br><span class="line">        currentListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移除listener实际就是取消订阅，使用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">unsubscribe(); <span class="comment">// 取消监听</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>diaptch方法执行完返回为action，然后我们同样需要为它作判断<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> isDispatching = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 用于判断action是否为一个普通对象</span></span><br><span class="line">        <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Actions must be plain objects. '</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止多次dispatch请求同时改状态，一定是前面的dispatch结束之后，才dispatch下一个</span></span><br><span class="line">        <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isDispatching = <span class="literal">true</span></span><br><span class="line">            currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            isDispatching = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于判断一个值是否为一个普通的对象(普通对象即直接以字面量形式或调用 new Object() 所创建的对象)</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> proto = obj</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">Object</span>.getPrototypeOf(proto) !== <span class="literal">null</span>) &#123;</span><br><span class="line">        proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(obj) === proto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
isPlainObject函数中通过 while 不断地判断 Object.getPrototypeOf(proto) !== null 并执行, 最终 proto 会指向 Object.prototype. 这时再判断 Object.getPrototypeOf(obj) === proto, 如果为 true 的话就代表 obj 是通过字面量或调用 new Object() 所创建的对象了。</li>
</ol>
<p>保持action对象是简单对象的作用是方便reducer进行处理，不用处理其他的情况（比如function/class实例等）</p>
<p>至此，我们实现了最基本能用的Redux代码，下篇再继续完善Redux代码，最后放出基础版Redux所有代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当第二个参数没有传preloadedState，而直接传function的话，就会直接把这个function当成enhancer</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        enhancer = preloadedState </span><br><span class="line">        preloadedState = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当第三个参数传了但不是function也会报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reducer必须为函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the reducer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentState = preloadedState <span class="comment">// 第二个参数没传默认就是undefined赋给currentState</span></span><br><span class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line">    <span class="keyword">let</span> isDispatching = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        currentListeners.push(listener)</span><br><span class="line">        <span class="comment">// 通过filter过滤，执行的时候将之前本身已经添加进数组的事件名移除数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            currentListeners = currentListeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 用于判断action是否为一个普通对象</span></span><br><span class="line">        <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Actions must be plain objects. '</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止多次dispatch请求同时改状态，一定是前面的dispatch结束之后，才dispatch下一个</span></span><br><span class="line">        <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isDispatching = <span class="literal">true</span></span><br><span class="line">            currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            isDispatching = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'@@mini-redux/~GSDG4%FDG#*&amp;'</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        getState, </span><br><span class="line">        subscribe, </span><br><span class="line">        dispatch </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于判断一个值是否为一个普通的对象(普通对象即直接以字面量形式或调用 new Object() 所创建的对象)</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> proto = obj</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">Object</span>.getPrototypeOf(proto) !== <span class="literal">null</span>) &#123;</span><br><span class="line">        proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(obj) === proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">Redux 入门教程（一）：基本用法</a></p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文Github仓库</a>，觉得不错的话欢迎star，给我一点鼓励吧~</li>
</ul>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>React函数this绑定的原因及四种绑定方式对比</title>
    <url>/2020/04/16/React%E5%87%BD%E6%95%B0this%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E5%9B%9B%E7%A7%8D%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>react组件在绑定函数时，通常有三种方法，此文将对三种方法性能和写法展开写…</p>
<a id="more"></a>

<h2 id="为什么要绑定this"><a href="#为什么要绑定this" class="headerlink" title="为什么要绑定this"></a>为什么要绑定this</h2><p>首先，第一个很重要的问题就是，绑定this是什么原因？</p>
<p>js里面的this绑定是代码执行的时候进行绑定的，而不是编写的时候，所以this的指向取决于函数调用时的各种条件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'jacky'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BindEvent;</span><br></pre></td></tr></table></figure>
<p>来看上面这个例子，运行点击按钮，发现程序报错，即this指向不是所在类。由于类的方法默认不会绑定this，因此在调用的时候如果没有绑定，this的值将会是undefined。故我们需要手动绑定this</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property &#39;state&#39; of undefined</span><br></pre></td></tr></table></figure>
<p>需要我们自己绑定this，其实这不是react的锅，本质原因是 JavaScript 的 this 机制问题</p>
<h2 id="this机制"><a href="#this机制" class="headerlink" title="this机制"></a>this机制</h2><p>来看下面一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName(); <span class="comment">// &#123;name: "obj", getName: ƒ&#125; "obj"</span></span><br></pre></td></tr></table></figure>
<p>结果理所应当，使用<code>.</code>操作符调用函数obj.getName()，this指向的是obj对象，即obj对象是函数getName的调用者，但如果改成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleObj = obj.getName;</span><br><span class="line">middleObj(); <span class="comment">// Window &#123;...&#125; ""</span></span><br></pre></td></tr></table></figure>
<p>将getName函数引用赋值给middleObj变量，并使用这个新的函数引用去调用该函数时，打印出this为Window对象，关于this的指向，可简单粗暴理解为<strong>this 永远指向最后调用它的那个对象</strong>。</p>
<p>如果没有显式调用一个函数，JS 的解释器就会把全局对象当作调用者，在浏览器则是Window对象为调用者。</p>
<p>如果使用严格模式，那么没有显式的使用调用者的情况下，this指向undefined 。</p>
<p>理解完上面，我们用类来作为参照：</p>
<p>下面定义了一个类，类里的display访问this.name属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    display() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 运行打印： Foo &#123;name: "jacky"&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo(<span class="string">'jacky'</span>);</span><br><span class="line">foo.display(); <span class="comment">// jacky</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> display = foo.display; </span><br><span class="line">display();  </span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot read property 'name' of undefined</span></span><br></pre></td></tr></table></figure>
<p>当我们将一个函数引用赋值给某个其他变量，并使用这个新的函数引用去调用该函数时，在 display() 方法this为<code>undefined</code>，故找不到name值报错。</p>
<p>在这里又有一个问题了，display这样直接调用，在非严格模式下调用者不是应该为Window对象吗？在这里，要知道一个知识点：</p>
<p><strong>ES6 的 class 语法，所有在 class 中声明的方法都会自动地使用严格模式</strong></p>
<h2 id="React的JSX"><a href="#React的JSX" class="headerlink" title="React的JSX"></a>React的JSX</h2><p>说了这么多，这跟React那个有什么联系呢，想搞清楚为什么绑定this这个问题前，就想先弄明白JSX到底是一个什么东西。</p>
<blockquote>
<p>本质上来讲，JSX 只是为 React.createElement(component, props, …children) 方法提供的语法糖。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button className=<span class="string">"btn"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">    Click Me</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>经babel编译为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">    <span class="string">"button"</span>, </span><br><span class="line">    &#123; <span class="attr">className</span>: <span class="string">"btn"</span>, <span class="attr">onClick</span>: <span class="keyword">this</span>.handleClick &#125;, </span><br><span class="line">    <span class="string">"Click Me"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们把render方法里的JSX手动写成编译后这种形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    handleClick(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> React.createElement(</span><br><span class="line">            <span class="string">"button"</span>, </span><br><span class="line">            &#123; <span class="attr">className</span>: <span class="string">"btn"</span>, <span class="attr">onClick</span>: <span class="keyword">this</span>.handleClick &#125;, </span><br><span class="line">            <span class="string">"Click Me"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>React.createElement的第二个参数，传入的是一个对象，而这个对象里面有属性的值是取this 对象里面的属性 ，当这个对象放入React.createElement执行后，去取这个this.handleClick属性的时候，this已经不是我们在书写的时候认为的绑定在Example组件上了。this.handleClick这里的this会默认绑定，但是又是在ES6的class中，所以this绑定了undefined。</p>
<p> 在JSX语法中: <code>onClick={ this.handleClick }</code>中onClick这个属性就是相当于上面的”中间变量”。</p>
<p> 即是将<code>this.handleClick</code>函数赋值给onClick这个中间变量，后面不仅要进行JSX语法转化,将JSX组件转换成<strong>JS对象</strong>,还要再将Javascript对象转换成真实DOM。把onClick作为中间变量,指向一个函数的时候,后面的一系列处理中，使用onClick这个中间变量所指向的函数，里面的this自然就丢失掉了，不是再指向组件实例了。</p>
<p> 所以，当在组件定义方法想访问this，才需要手动绑定。</p>
<h2 id="绑定this的方法"><a href="#绑定this的方法" class="headerlink" title="绑定this的方法"></a>绑定this的方法</h2><h3 id="render方法中绑定this"><a href="#render方法中绑定this" class="headerlink" title="render方法中绑定this"></a>render方法中绑定this</h3> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'jacky'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法即是在事件函数后使用<code>.bind(this)</code>将this绑定到当前组件中。因为 bind 函数会返回一个新的函数，所以每次父组件刷新时，都会重新生成一个函数，即使父组件传递给子组件其他的 props 值不变，子组件每次都会刷新，这将会影响性能，故不推荐使用。</p>
<h3 id="render方法中使用箭头函数"><a href="#render方法中使用箭头函数" class="headerlink" title="render方法中使用箭头函数"></a>render方法中使用箭头函数</h3> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'jacky'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.handleClick()&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首选要明确一点，<strong>箭头函数中，this 永远绑定了定义箭头函数所在的那个对象</strong></p>
<p>这种方法写法比较简洁， 最大好处就是传参很灵活，父组件刷新的时候，即使两个箭头函数的函数体是一样的，都会生成一个新的箭头函数。这种方式重新创建函数性能的损耗小于第1种。</p>
<h3 id="构造函数绑定this"><a href="#构造函数绑定this" class="headerlink" title="构造函数绑定this"></a>构造函数绑定this</h3> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'jacky'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;点击&lt;<span class="regexp">/button&gt; </span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 为了避免在render中绑定this引发可能的性能问题，可以在constructor中预先进行绑定。好处是仅需要绑定一次，避免每次渲染时都要重新绑定，也是常推荐的写法，就是写起来繁琐一点，要单独绑定。</p>
<h3 id="在定义阶段使用箭头函数绑定"><a href="#在定义阶段使用箭头函数绑定" class="headerlink" title="在定义阶段使用箭头函数绑定"></a>在定义阶段使用箭头函数绑定</h3>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'jacky'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;点击&lt;<span class="regexp">/button&gt; </span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法是ES7的写法，ES6并不支持，不过我们可以配置你的开发环境支持ES7。</p>
<p>这种方法避免了第1种和第2种的可能潜在的性能问题，也比第3种方法简洁，也是常推荐的写法。</p>
<p>至于哪一种是最好的写法，目前还真的无法定论，有待以后开发中得出最佳实践…</p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文Github仓库</a>，欢迎star</li>
</ul>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>原生JavaScript DOM操作常见汇总</title>
    <url>/2020/04/09/%E5%8E%9F%E7%94%9FJavaScript-DOM%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>最近在看 JS 性能优化方面，说到了 createDocumentFragment()方法，对该方法有印象，但为了进一步了解，我还是重新查阅一遍，顺便把 DOM 操作也给总结一下。</p>
<a id="more"></a>

<h2 id="创建新节点"><a href="#创建新节点" class="headerlink" title="创建新节点"></a>创建新节点</h2><ul>
<li><strong>createDocumentFragment()方法</strong></li>
</ul>
<p>该方法是用来创建一个虚拟的节点对象，或者说，是用来创建文档碎片节点。它可以包含各种类型的节点，在创建之初是空的。</p>
<p>DocumentFragment 不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。</p>
<p>当把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点，即插入的是括号里的节点。这个特性使得 DocumentFragment 成了占位符，暂时存放那些一次插入文档的节点。</p>
<ul>
<li><strong>createElement()方法</strong></li>
</ul>
<p>在 HTML 文档中，document.createElement() 方法用于创建一个由标签名称 tagName 指定的 HTML 元素</p>
<p>来看一个例子, 对于页面已存在的<code>&lt;ul id=&quot;ul&quot;&gt;&lt;/ul&gt;</code>元素，我们想往里面添加 li 标签</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line">  li.innerHTML = <span class="string">'index: '</span> + i</span><br><span class="line">  ul.appendChild(li)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面操作看起来很正常，但实际要很多的插入操作和改动；而每一次的插入都会引起重新渲染，该操作会引发多次渲染，在性能优化方面，有一点是减少 DOM 操作，因为 DOM 操作导致了页面的重绘或重排。</p>
<ul>
<li>createDocumentFragment()方法和 createElement()方法区别</li>
</ul>
<p>如果是用 createDocumentFragment()方法操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>)</span><br><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line">  li.innerHTML = <span class="string">'index: '</span> + i</span><br><span class="line">  fragment.appendChild(li)</span><br><span class="line">&#125;</span><br><span class="line">ul.appendChild(fragment)</span><br></pre></td></tr></table></figure>

<p>相比 createElement()方法，这次是先将这些元素添加到 fragment 中，再统一将 fragment 添加到页面，会减少页面渲染 dom 的次数，效率会明显提升。因为 fragment 文档片段存在于内存中，并不在 DOM 中，所以将子元素插入到文档片段中时不会引起页面回流（新创建的 fragment 片段在文档内是没有对应的标签的，这里添加的是片段的所有子节点）</p>
<ul>
<li>createTextNode()方法</li>
</ul>
<p>该方法会创建一个文本节点。</p>
<p>HTML 元素通常是由元素节点和文本节点组成。创建一个标题 (h1), 你必须创建 “h1” 元素和文本节点:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> h = <span class="built_in">document</span>.createElement(<span class="string">'h1'</span>)</span><br><span class="line"><span class="keyword">var</span> t = <span class="built_in">document</span>.createTextNode(<span class="string">'Hello World'</span>)</span><br><span class="line">h.appendChild(t)</span><br></pre></td></tr></table></figure>

<h2 id="DOM-更改：添加、移除、替换、插入"><a href="#DOM-更改：添加、移除、替换、插入" class="headerlink" title="DOM 更改：添加、移除、替换、插入"></a>DOM 更改：添加、移除、替换、插入</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加、删除子元素</span></span><br><span class="line">ele.appendChild(el)</span><br><span class="line">ele.removeChild(el)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换子元素</span></span><br><span class="line">ele.replaceChild(el1, el2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入子元素</span></span><br><span class="line">parentElement.insertBefore(newElement, referenceElement)</span><br></pre></td></tr></table></figure>

<p>前面三个用法就一目了然，对于 insertBefore()方法来举个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newEle = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">'insertNode'</span>)</span><br><span class="line">newEle.appendChild(textNode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>)</span><br><span class="line">ul.insertBefore(newEle, ul.firstChild)</span><br></pre></td></tr></table></figure>

<p>页面输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insertNode</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="DOM-查询"><a href="#DOM-查询" class="headerlink" title="DOM 查询"></a>DOM 查询</h2><p>元素查询的 API 返回的的结果是 DOM 节点或者 DOM 节点的列表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getElementById()</span><br><span class="line">getElementsByName()</span><br><span class="line">getElementsByTagName()</span><br><span class="line">getElementsByClassName()</span><br><span class="line">querySelector()</span><br><span class="line">querySelectorAll()</span><br></pre></td></tr></table></figure>

<p>querySelector() 方法返回匹配指定 CSS 选择器元素的第一个子元素， 该方法只返回匹配指定选择器的第一个元素。如果要返回所有匹配元素，需要使用 querySelectorAll() 方法替代．</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.querySelector(&quot;#test&quot;); &#x2F;&#x2F; 获取到id名为test的首个元素</span><br></pre></td></tr></table></figure>

<ul>
<li>querySelector 系列方法与 getElementBy 系列方法对比</li>
</ul>
<ol>
<li>得到的元素不是需要很麻烦的多次 getElementBy..的话，尽量使用 getElementBy 系列方法,因为 getElementBy 系列执行速度更快。</li>
<li>得到的元素需要很麻烦的多次 getElementBy…组合才能得到的话使用 querySelector，方便。</li>
<li>querySelector()选择的标签是静态的，也就是说在选中之后，能够一直保存，也就是脱离了被选择的成为副本。而 getelementsBy 系列方法是动态的，相互映射，在调用时，变化可以及时的反映在页面上。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 querySelector 操作元素</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>)</span><br><span class="line"><span class="keyword">var</span> list = ul.querySelectorAll(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 创建3个新的li标签，添加到ul列表中</span></span><br><span class="line">  ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'li'</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(list.length) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 输出的是添加前li的数量3，而非此时li的总数量6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> list = ul.getElementsByTagName(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 创建3个新的li标签，添加到ul列表中</span></span><br><span class="line">  ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'li'</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(list.length) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>还有元素的 DOM 导航方法：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取父元素、父节点</span></span><br><span class="line"><span class="keyword">var</span> parent = ele.parentElement</span><br><span class="line"><span class="keyword">var</span> parent = ele.parentNode</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子节点，子节点可以是任何一种节点，可以通过nodeType来判断</span></span><br><span class="line"><span class="keyword">var</span> nodes = ele.children</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询子元素</span></span><br><span class="line"><span class="keyword">var</span> els = ele.getElementsByTagName(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">var</span> els = ele.getElementsByClassName(<span class="string">'test'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前元素的第一个/最后一个子元素节点</span></span><br><span class="line"><span class="keyword">var</span> el = ele.firstElementChild</span><br><span class="line"><span class="keyword">var</span> el = ele.lastElementChild</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一个/上一个兄弟元素节点</span></span><br><span class="line"><span class="keyword">var</span> el = ele.nextElementSibling</span><br><span class="line"><span class="keyword">var</span> el = ele.previousElementSibling</span><br></pre></td></tr></table></figure>

<h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getAttribute(key)</span><br><span class="line">setAttribute(key,value)</span><br><span class="line">hasAttribute(key)</span><br><span class="line">removeAttribute(key)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>用React+Antd封装Axios实现全局Loading效果</title>
    <url>/2020/03/29/%E7%94%A8React-Antd%E5%B0%81%E8%A3%85Axios%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80Loading%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>今天在做 react 后台管理的时候要实现一个全局 Loading 效果，通常使用 axios 库与后端进行数据交互。为了更好的用户体验，在每次请求前添加一个加载效果，让用户知道在等待加载。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要实现这个功能，我们可以在每个组件请求手动添加加载效果返回后再将其隐藏，但如果每个请求都这么做，就要做多次重复设置显得很麻烦，但好处是可以设置定制多种请求效果。但考虑到该项目场景为后台管理系统，给管理员使用，花样可以不用搞太多，统一优雅即可，故采取全局设置 loading 效果。</p>
<h2 id="开发版本"><a href="#开发版本" class="headerlink" title="开发版本"></a>开发版本</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"react"</span>: <span class="string">"^16.13.1"</span>,</span><br><span class="line"><span class="string">"antd"</span>: <span class="string">"^4.0.4"</span>,</span><br><span class="line"><span class="string">"axios"</span>: <span class="string">"^0.19.2"</span></span><br></pre></td></tr></table></figure>

<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><ol>
<li>通过 axios 提供的请求拦截和响应拦截的接口，控制 loading 的显示或者隐藏。在此我还设置了没有网络和网络超时的提示信息</li>
<li>采用 antd 的 Spin 组件来实现 loading 效果，message 组件来进行消息提示（antd.css 这里没有引入，是因为我设置了按需加载）</li>
<li>定义变量 requestCount 作为计数器，确保同一时刻如果有多个请求的话，不会同时添加多个 loading，而是只有 1 个，并在所有请求结束后才会隐藏 loading。</li>
<li>默认所有请求都会自动有 loading 效果。如果某个请求不需要 loading 效果，可以在请求 headers 中设置 isLoading 为 false。</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>在 src 目录下新建一个文件 axios.js</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; message, Spin &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Axios = axios.create(&#123;</span><br><span class="line">  <span class="comment">// baseURL: process.env.BASE_URL, // 设置请求的base url</span></span><br><span class="line">  timeout: <span class="number">20000</span>, <span class="comment">// 设置超时时长</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置post请求头</span></span><br><span class="line">Axios.defaults.headers.post[<span class="string">'Content-Type'</span>] =</span><br><span class="line">  <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前正在请求的数量</span></span><br><span class="line"><span class="keyword">let</span> requestCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示loading</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showLoading</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (requestCount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    dom.setAttribute(<span class="string">'id'</span>, <span class="string">'loading'</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(dom)</span><br><span class="line">    ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Spin</span> <span class="attr">tip</span>=<span class="string">'加载中...'</span> <span class="attr">size</span>=<span class="string">'large'</span> /&gt;</span></span>, dom)</span><br><span class="line">  &#125;</span><br><span class="line">  requestCount++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏loading</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hideLoading</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  requestCount--</span><br><span class="line">  <span class="keyword">if</span> (requestCount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'loading'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求前拦截</span></span><br><span class="line">Axios.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="comment">// requestCount为0，才创建loading, 避免重复创建</span></span><br><span class="line">    <span class="keyword">if</span> (config.headers.isLoading !== <span class="literal">false</span>) &#123;</span><br><span class="line">      showLoading()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断当前请求是否设置了不显示Loading</span></span><br><span class="line">    <span class="keyword">if</span> (err.config.headers.isLoading !== <span class="literal">false</span>) &#123;</span><br><span class="line">      hideLoading()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回后拦截</span></span><br><span class="line">Axios.interceptors.response.use(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断当前请求是否设置了不显示Loading</span></span><br><span class="line">    <span class="keyword">if</span> (res.config.headers.isLoading !== <span class="literal">false</span>) &#123;</span><br><span class="line">      hideLoading()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.config.headers.isLoading !== <span class="literal">false</span>) &#123;</span><br><span class="line">      hideLoading()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err.message === <span class="string">'Network Error'</span>) &#123;</span><br><span class="line">      message.warning(<span class="string">'网络连接异常！'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err.code === <span class="string">'ECONNABORTED'</span>) &#123;</span><br><span class="line">      message.warning(<span class="string">'请求超时，请重试'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把组件引入，并定义成原型属性方便使用</span></span><br><span class="line">Component.prototype.$axios = Axios</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Axios</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>添加 loading 样式在共用的 css 文件里</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#loading</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.75</span>);</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">9999</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>axios 请求</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 引入自定义axios文件路径</span></span><br><span class="line"><span class="comment">// 2. 引入共用css文件（loading样式）</span></span><br><span class="line"><span class="comment">// 3. 在react组件中正常写法请求url即可</span></span><br><span class="line">componentDidMount () &#123;</span><br><span class="line">    axios(&#123;</span><br><span class="line">      url: <span class="string">'/manage/statistic/base_count.do'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(res.data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不加 loading 效果，这样写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">'/manage/statistic/base_count.do'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(res.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/3/29/17126d31a0fc0571?w=1854&h=954&f=gif&s=427836" alt=""></p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Ant Design</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解之JavaScript之call, apply, bind方法</title>
    <url>/2020/03/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BJavaScript%E4%B9%8Bcall-apply-bind%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在JavaScript中，call、apply和bind是Function对象自带的三个方法，这三个方法的主要作用是改变函数执行时的上下文，再具体一点就是<strong>改变函数运行时的this指向</strong>。</p>
<a id="more"></a>
<ul>
<li><h2 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h2></li>
</ul>
<p>call() 方法调用一个函数, 其具有一个指定的 this 值和多个参数(参数的列表)。</p>
<blockquote>
<p>fun.call(thisArg, arg1, arg2, …)</p>
</blockquote>
<p>thisArg的取值有以下4种情况：</p>
<ol>
<li>不传，或者传null, undefined， 函数中的this指向window对象（非严格模式下）</li>
<li>传递另一个函数的函数名，函数中的this指向这个函数的引用</li>
<li>传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean</li>
<li>传递一个对象，函数中的this指向这个对象.</li>
</ol>
<p>我们可以用如下代码验证一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);   </span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;&#125;       </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"jacky"</span> &#125;;  </span><br><span class="line"></span><br><span class="line">func1.call();   <span class="comment">// Window</span></span><br><span class="line">func1.call(<span class="literal">null</span>);   <span class="comment">// Window</span></span><br><span class="line">func1.call(<span class="literal">undefined</span>);   <span class="comment">// Window</span></span><br><span class="line">func1.call(<span class="number">1</span>);   <span class="comment">// Number &#123;1&#125;</span></span><br><span class="line">func1.call(<span class="string">''</span>);   <span class="comment">// String &#123;""&#125;</span></span><br><span class="line">func1.call(<span class="literal">true</span>);   <span class="comment">// Boolean &#123;true&#125;</span></span><br><span class="line">func1.call(func2);   <span class="comment">// ƒ func2() &#123;&#125;</span></span><br><span class="line">func1.call(obj);   <span class="comment">// &#123;name: "jacky"&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们再来看个例子，理解怎么改变this的指向：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'animal'</span>;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'cat'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">animal.sayName.call(cat); <span class="comment">// cat</span></span><br><span class="line"><span class="comment">// this 永远指向最后调用它的那个对象</span></span><br><span class="line"><span class="comment">// 该例子中sayName方法的this指向Cat</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h2></li>
</ul>
<p>call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个<strong>数组</strong>里面作为它的第二个参数，他们俩之间的差别在于<strong>参数</strong>的区别。</p>
<p>如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> 和其他参数 <span class="subst">$&#123;args&#125;</span>`</span>); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = &#123;</span><br><span class="line">    name: <span class="string">'xiaomao'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用 call</span></span><br><span class="line">Animal.call(cat, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// xiaomao 和其他参数 1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 apply</span></span><br><span class="line">Animal.apply(cat, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// xiaomao 和其他参数 1,2,3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="call、apply使用"><a href="#call、apply使用" class="headerlink" title="call、apply使用"></a>call、apply使用</h2></li>
</ul>
<p>由于两个方法实际效果是一样的，对于两者平时用该如何选择呢？</p>
<ol>
<li>参数数量/顺序确定就用call，参数数量/顺序不确定的话就用apply。</li>
<li>考虑可读性：参数数量不多就用call，参数数量比较多的话，把参数整合成数组，使用apply。</li>
<li>参数集合已经是一个数组的情况，用apply。</li>
</ol>
<ul>
<li><h2 id="call-apply-的应用"><a href="#call-apply-的应用" class="headerlink" title="call, apply 的应用"></a>call, apply 的应用</h2></li>
</ul>
<h3 id="数组拼接"><a href="#数组拼接" class="headerlink" title="数组拼接"></a>数组拼接</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 apply方法</span></span><br><span class="line">[].push.apply(arr1, arr2);  <span class="comment">// 给arr1添加arr2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h3 id="获取数组中的最大值或最小值"><a href="#获取数组中的最大值或最小值" class="headerlink" title="获取数组中的最大值或最小值"></a>获取数组中的最大值或最小值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">98</span>]; </span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, numbers) );   <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">98</span>) ); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.min.call(<span class="built_in">Math</span>, ...numbers) ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'string'</span>,</span><br><span class="line">    obj = &#123; <span class="attr">name</span>: <span class="string">'jacky'</span> &#125;</span><br><span class="line"><span class="comment">// 判断传入参数是否为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isArray(arr)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isArray(str)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr)); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(str)); <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(obj)); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>

<h3 id="调用父类构造函数实现继承"><a href="#调用父类构造函数实现继承" class="headerlink" title="调用父类构造函数实现继承"></a>调用父类构造函数实现继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;      </span><br><span class="line">    <span class="keyword">this</span>.name = name;      </span><br><span class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      </span><br><span class="line">    &#125;      </span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;    </span><br><span class="line">    Animal.call(<span class="keyword">this</span>, name);    </span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">"xiaomao"</span>);     </span><br><span class="line">cat.showName();   <span class="comment">// xiaomao</span></span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ol>
<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>
<li>每次子类实例化都要执行父类函数，重新声明父类this里所定义的方法，因此父类方法无法复用。</li>
</ol>
<h3 id="类数组对象转数组"><a href="#类数组对象转数组" class="headerlink" title="类数组对象转数组"></a>类数组对象转数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。</p>
<h3 id="代理console-log方法"><a href="#代理console-log方法" class="headerlink" title="代理console.log方法"></a>代理console.log方法</h3><p>注意这里传入多少个参数是不确定的，所以使用apply是最好的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">log(<span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line">log(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h2></li>
</ul>
<p>MDN的解释是：</p>
<blockquote>
<p>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
</blockquote>
<p>说直白一点，bind方法是创建一个函数，然后可以在需要调用的时候再执行函数，并非是立即执行函数；而call，apply是在改变了上下文中的this指向后并立即执行函数。</p>
<p>bind 接收的参数类型与 call 是一样的，给它传递的是一组用逗号分隔的参数列表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123; </span><br><span class="line">    x: <span class="number">2</span>   </span><br><span class="line">&#125;   </span><br><span class="line">bar(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo);   </span><br><span class="line">func(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="bind的应用"><a href="#bind的应用" class="headerlink" title="bind的应用"></a>bind的应用</h2></li>
</ul>
<h3 id="bind绑定回调函数的this指向"><a href="#bind绑定回调函数的this指向" class="headerlink" title="bind绑定回调函数的this指向"></a>bind绑定回调函数的this指向</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(callBack) &#123;</span><br><span class="line">        <span class="keyword">this</span>.className = <span class="string">'PageA'</span></span><br><span class="line">        <span class="keyword">this</span>.MessageCallBack = callBack </span><br><span class="line">        <span class="keyword">this</span>.MessageCallBack(<span class="string">'执行了'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.className = <span class="string">'PageB'</span></span><br><span class="line">        <span class="keyword">this</span>.pageClass = <span class="keyword">new</span> PageA(<span class="keyword">this</span>.handleMessage)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回调函数</span></span><br><span class="line">    handleMessage(msg) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'处理'</span> + <span class="keyword">this</span>.className + <span class="string">'的回调 '</span> + msg) <span class="comment">// 处理PageA的回调 执行了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> PageB();</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，我们发现回调函数this丢失了？问题出在这行代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.pageClass = <span class="keyword">new</span> PageA(<span class="keyword">this</span>.handleMessage)</span><br></pre></td></tr></table></figure>
<p>传递过去的this.handleMessage是一个函数内存地址，没有上下文对象，也就是说该函数没有绑定它的this指向。</p>
<p>解决方案：用bind绑定this的指向</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.pageClass = <span class="keyword">new</span> PageA(<span class="keyword">this</span>.handleMessage.bind(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure>
<p>这也是为什么react的render函数在绑定回调函数的时候，也要使用bind绑定一下this的指向，也是因为同样的问题以及原理。</p>
<ul>
<li><p>多个bind的情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    x: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    x: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">    x: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func1 = bar.bind(obj1).bind(obj2);</span><br><span class="line"><span class="keyword">var</span> func2 = bar.bind(obj1).bind(obj2).bind(obj3);</span><br><span class="line">func1(); <span class="comment">// 2</span></span><br><span class="line">func2(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>输出结果都为第一个绑定的obj对象的x值。原因是，在Javascript中，bind()方法返回的外来的绑定函数对象仅在创建的时候记忆上下文（如果提供了参数），多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。</p>
</li>
<li><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li>
</ul>
<p>call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现; apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数，他们俩之间的差别在于参数的区别。</p>
<p>call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数,其内的this指向为创建它时传入bind的第一个参数，而传入bind的第二个及以后的参数作为原函数的参数来调用原函数。bind的参数可以在函数执行的时候再次添加。</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之作用域链与闭包</title>
    <url>/2020/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>作用域和闭包是 Js 很重要的概念，对此进行深入了解</p>
<a id="more"></a>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是指程序源代码中定义变量的区域。</p>
<p>实际上描述的就是查找变量的范围，作用域必须有的两个功能就是<strong>存储变量</strong>以及<strong>查找变量</strong>，作用域就是发挥这两个作用以及更多作用的规则。</p>
<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<h3 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h3><ul>
<li>词法作用域：（静态作用域）函数的作用域在函数定义的时候就决定了。</li>
<li>动态作用域：函数的作用域是在函数调用的时候才决定的。</li>
</ul>
<p>JavaScript 采用的是词法作用域</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域</p>
<p>全局变量：</p>
<blockquote>
<ol>
<li>生命周期将存在于整个程序之内。</li>
<li>能被程序中任何函数或者方法访问。</li>
<li>在 JavaScript 内默认是可以被修改的。</li>
</ol>
</blockquote>
<p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p>
<h4 id="显式声明"><a href="#显式声明" class="headerlink" title="显式声明"></a>显式声明</h4><p>带有关键字 var 的声明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> winValue = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.winValue) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h4 id="隐式声明"><a href="#隐式声明" class="headerlink" title="隐式声明"></a>隐式声明</h4><p>不带有声明关键字的变量，JS 会默认帮你声明一个全局变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  result = value + <span class="number">1</span> <span class="comment">// 没有用 var 声明</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.result) <span class="comment">// 2 &lt;=  挂在了 window全局对象上</span></span><br></pre></td></tr></table></figure>

<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数作用域内，对外是封闭的，从外层的作用域无法直接访问函数内部的作用域。</p>
<p>在函数内部的变量权限称为函数作用域，有以下特点：</p>
<ol>
<li>每个函数都有自己的作用域，而且调用一次就会生成新的作用域</li>
<li>只能在函数内部才能访问，外部是没有权限访问的</li>
<li>进入函数内部时开启，函数执行完毕后销毁</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">'test'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="块级作用域（ES6-新增）"><a href="#块级作用域（ES6-新增）" class="headerlink" title="块级作用域（ES6 新增）"></a>块级作用域（ES6 新增）</h3><p>凡是由{}符号包裹起来的都是块作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>

<p>在 for 循环执行完毕之后 i 变量就被释放了</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链：当访问一个变量时，解释器会首先在当前作用域查找，如果没有找到，就去父作用域找，直到找到该变量或者不在父作用域中，这就是作用域链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>

<p>从上面代码的执行结果可以看出，foo 函数取到了它外部的变量 a, 而最外层的 console.log(b) 操作并没能取得 foo 函数里面的变量 b。</p>
<ul>
<li>作用域链和原型继承查找时的区别：</li>
</ul>
<p>如果去查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回 undefined；但查找的属性在作用域链中不存在的话就会抛出 ReferenceError。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>闭包是指<strong>有权访问另外一个函数作用域中的变量的函数</strong></p>
<p>在 javascript 中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成”定义在一个函数内部的函数”。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p>
<ul>
<li>闭包由两部分构成：</li>
</ul>
<ol>
<li>函数</li>
<li>能访问另外一个函数作用域中的变量</li>
</ol>
<h3 id="为什么有闭包"><a href="#为什么有闭包" class="headerlink" title="为什么有闭包?"></a>为什么有闭包?</h3><blockquote>
<p>之所以出现闭包是因为 JS 的垃圾回收机制，JS 本身为了避免解释器过量消耗内存，造成系统崩溃，自带有一套垃圾回收机制，垃圾回收机制能够检测到一个对象是不是无用的。检测到之后，就会把它占用的内存释放掉。但是实际工作中，我们也会需要一些变量不那么及时的被清理，所以就出现了闭包，用来达成这个效果。</p>
</blockquote>
<h3 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h3><ul>
<li>闭包可以访问当前函数以外的变量</li>
<li>即使外部函数已经返回，闭包仍能访问外部函数定义的变量</li>
<li>参数和变量不会被垃圾回收机制收回。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOuter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'jacky'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str + name) <span class="comment">// 可以访问getName函数外部的name</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getName(<span class="string">'名字是：'</span>)</span><br><span class="line">&#125;</span><br><span class="line">getOuter() <span class="comment">// 名字是：jacky</span></span><br></pre></td></tr></table></figure>

<p>再来看下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = bar() <span class="comment">// 这一句执行完，变量x并没有被回收，因为要内部函数还需要引用</span></span><br><span class="line"><span class="built_in">console</span>.log(foo()) <span class="comment">// 3  执行内部函数，引用外部变量x</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，在全局执行上下文中定义了一个函数 bar 和变量 foo，函数 bar 内部返回一个匿名函数，所以此刻匿名函数的作用域链初始化为包含了全局变量对象和 bar 中的变量对象。</p>
<p>当执行 var foo = bar()时，把函数 bar 的执行上下文压入栈，当 bar 执行完后，其执行上下文应该弹出栈，但是因为 bar 内部的匿名函数作用域链还引用这 bar 函数内的变量 x，所以 bar 的执行上下文得不到释放，这样就形成了闭包。</p>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><ol>
<li>设计私有的方法和变量（封装，定义模块）。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span> <span class="comment">//私有变量</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      change(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      change(<span class="number">-1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>匿名函数最大的用途是创建闭包。减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objEvent = objEvent || &#123;&#125;</span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">  objEvent.addEvent = addEvent</span><br><span class="line">  objEvent.removeEvent = removeEvent</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>addEvent 和 removeEvent 都是局部变量，但我们可以通过全局变量 objEvent 使用它</p>
<h3 id="如何销毁闭包"><a href="#如何销毁闭包" class="headerlink" title="如何销毁闭包"></a>如何销毁闭包</h3><p>javascript 中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收。如果两个对象互相引用，而不再被第 3 者所引用，那么这两个互相引用的对象也会被回收。</p>
<p>即释放对闭包的引用，使引用变量为 null。</p>
<h3 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h3><p>优点：</p>
<ol>
<li>闭包里的变量不会污染全局，因为变量被封在闭包里；</li>
<li>所有变量都在闭包里保证了隐私性和私有性；</li>
<li>可以让这些局部变量保存在内存中，实现变量数据共享。</li>
</ol>
<p>缺点：</p>
<p>形成闭包即要把一个函数当成值传递，而且该函数还引用这另一个函数的作用域链使得被引用的函数不能被回收，使用不当容易造成内存泄漏；</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>作用域链</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之 new 原理及模拟实现</title>
    <url>/2020/02/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B-new-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>探讨 new 原理……</p>
<a id="more"></a>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例</p>
<p>先看看 new 实现了哪些功能, 先来看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'年龄为:'</span> + <span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="number">18</span>)</span><br><span class="line">person.age <span class="comment">// 访问构造函数里的属性</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">person.getAge() <span class="comment">// 访问原型里的属性</span></span><br><span class="line"><span class="comment">// 年龄为:18</span></span><br></pre></td></tr></table></figure>

<p>从上面代码可以知道，实例 person 可以：</p>
<ol>
<li>访问到 Person 构造函数里的属性</li>
<li>访问到 Person.prototype 中的属性</li>
</ol>
<p>这个是最基本的了，也是刚学会 new 一个对象就知道这是 new 的特点</p>
<h2 id="探讨-new-还做了什么？"><a href="#探讨-new-还做了什么？" class="headerlink" title="探讨 new 还做了什么？"></a>探讨 new 还做了什么？</h2><p>探讨完上面，接下来看看 new 还做了什么？来看几个例子</p>
<h3 id="没有-return-语句"><a href="#没有-return-语句" class="headerlink" title="没有 return 语句"></a>没有 return 语句</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// Person &#123;age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>从构造函数直观看，最后是没有 return 语句的，但我们从返回结果也可以看出构造函数时默认情况会返回一个新对象</p>
<h3 id="return-对象数据类型"><a href="#return-对象数据类型" class="headerlink" title="return 对象数据类型"></a>return 对象数据类型</h3><p>我们尝试在构造函数最后返回一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">'手动返回一个对象'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// &#123;name: "手动返回一个对象"&#125;</span></span><br></pre></td></tr></table></figure>

<p>打印出来的结果可以看出：return 之前的代码片段都被覆盖了，最后返回 return 后面的对象。</p>
<h3 id="return-基本数据类型"><a href="#return-基本数据类型" class="headerlink" title="return 基本数据类型"></a>return 基本数据类型</h3><p>如果构造函数最后 return 的不是对象呢，试下基本数据类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// Person &#123;age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>从打印出来的结果可知，和没有 return 效果一样。</p>
<h2 id="new-原理"><a href="#new-原理" class="headerlink" title="new 原理"></a>new 原理</h2><p>mdn 上把内部操作大概分为 4 步：</p>
<blockquote>
<ol>
<li>创建一个空的简单 JavaScript 对象（即{ } ）；</li>
<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；(因此 this 就指向了这个新对象)</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>如果该函数没有返回对象，则返回 this。</li>
</ol>
</blockquote>
<h2 id="模拟实现-new"><a href="#模拟实现-new" class="headerlink" title="模拟实现 new"></a>模拟实现 new</h2><p>new 是关键词，不可以直接覆盖。这里使用 create 来模拟实现 new 的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空的对象</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">    <span class="comment">// 获得构造函数，arguments中去除第一个参数</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 链接到原型，obj 可以访问到构造函数原型中的属性</span></span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line">  <span class="comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">  <span class="keyword">var</span> ret = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 优先返回构造函数返回的对象</span></span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看看上面是怎么一步步模拟实现的：</p>
<ol>
<li>用 new Object() 的方式新建了一个空对象 obj</li>
<li>取出第一个参数，即是传入的构造函数。shift 会修改原数组，数组原来的第一个元素的值。</li>
<li>将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性</li>
<li>使用 apply，改变构造函数 this 的指向。将 this 指向 obj 对象 就可以访问到构造函数中的属性</li>
<li>处理返回值。</li>
</ol>
<ul>
<li>构造函数返回值有三种情况：</li>
</ul>
<ol>
<li>没有 return，默认返回之前创建的对象</li>
<li>返回一个对象</li>
<li>返回的不是对象，默认返回之前创建的空对象</li>
</ol>
<p>在上面我们用 instanceof 方法来判断是否为对象</p>
<blockquote>
<p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</p>
</blockquote>
<p>测试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'年龄为:'</span> + <span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = create(Person, <span class="number">18</span>)</span><br><span class="line">person.age <span class="comment">// 访问构造函数里的属性</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">person.getAge() <span class="comment">// 访问原型里的属性</span></span><br><span class="line"><span class="comment">// 年龄为:18</span></span><br></pre></td></tr></table></figure>

<p>模拟实现成功！</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之原型与原型链</title>
    <url>/2020/02/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>对于 JavaScript，原型是很重要的一个基础知识点，涉及的内容很多，在此总结一下</p>
<a id="more"></a>

<h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><p>原型是一个对象，把 prototype 称为原型对象，prototype 可以让所有的对象实例共享它包含的属性和方法。</p>
<p>JavaScript 规定，每一个函数都有一个 prototype 对象属性，指向另一个对象。prototype 对象属性的所有属性和方法都会被构造函数的实例继承。</p>
<h2 id="只有函数有-prototype-属性"><a href="#只有函数有-prototype-属性" class="headerlink" title="只有函数有 prototype 属性"></a>只有函数有 prototype 属性</h2><p>js 分为函数对象和普通对象，每个对象都有<strong>proto</strong>属性，但是只有函数对象才有 prototype 属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(func.prototype) <span class="comment">// &#123; constructor: function()&#123;...&#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>JS 通过 new 关键字，即靠构造函数生成对象，每次生成的对象都不一样。因为常常需要在两个对象之间共享属性，由于 JS 在设计之初没有类的概念，所以 JS 使用函数的 prototype 属性来处理这部分需要被共享的属性。</p>
<h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Animal.prototype.name = <span class="string">'kiki'</span></span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="built_in">console</span>.log(animal1.name, animal2.name) <span class="comment">// kiki kiki</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 animal1 和 animal2 的原型</p>
<p>每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p>
<p>构造函数和实例原型关系如下图：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/15/17049498b6d308cb?w=885&h=207&f=png&s=21292" alt=""></p>
<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>那么如何表示实例与实例原型之间的关系呢，这里需要讲到另一个属性<strong>proto</strong></p>
<p>每一个 JavaScript 对象(除了 null)都具有的一个属性，叫<strong>proto</strong>，这个属性会指向该对象的原型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="built_in">console</span>.log(dog.__proto__ === Animal.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>于是更新实例与实例原型之间的关系如下图：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/15/17049522bfa417ec?w=866&h=336&f=png&s=32709" alt=""></p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>每个原型都有一个 constructor 属性指向关联的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Animal === Animal.prototype.constructor) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/15/170496796080e487?w=849&h=347&f=png&s=35480" alt=""></p>
<p>则可以得出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="built_in">console</span>.log(dog.__proto__ === Animal.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Object.getPrototypeOf() 方法返回指定对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(dog) === Animal.prototype) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Animal.prototype.constructor == Animal) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>再提一点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="built_in">console</span>.log(dog.constructor === Animal) <span class="comment">// true</span></span><br><span class="line"><span class="comment">/* 当获取 dog.constructor 时，其实 dog 中并没有 constructor 属性,</span></span><br><span class="line"><span class="comment">当不能读取到constructor 属性时，</span></span><br><span class="line"><span class="comment">会从 dog 的原型也就是 Animal.prototype 中读取，正好原型中有该属性, 所以下列代码为true */</span></span><br><span class="line">dog.constructor === Animal.prototype.constructor</span><br></pre></td></tr></table></figure>

<h2 id="实例和原型"><a href="#实例和原型" class="headerlink" title="实例和原型"></a>实例和原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.name = <span class="string">'kiki'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal()</span><br><span class="line"></span><br><span class="line">dog.name = <span class="string">'xiaobai'</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.name) <span class="comment">// xiaobai</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> dog.name</span><br><span class="line"><span class="built_in">console</span>.log(dog.name) <span class="comment">// kiki</span></span><br></pre></td></tr></table></figure>

<p>上述代码。首先构造函数原型设置了 name 值，接着 dog 实例添加了 name 属性，覆盖原型的 name 值，打印 dog.name 时结果自然是 xiaobai。</p>
<p>当删除了 dog 的 name 属性时，读取 dog.name 时，从对象中无法找到 name 属性，就会从 dog 的原型，也就是 dog.<strong>proto</strong>，即 Animal.prototype 中查找，找到结果为 kiki。</p>
<p>如果原型没有设置 name 值，找不到呢？原型的原型又是谁？</p>
<h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>原型本身也是一个对象，既然是对象，我们就可以用最原始的方式创建它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">obj.name = <span class="string">'kiki'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// kiki</span></span><br></pre></td></tr></table></figure>

<p>其实原型对象就是通过 Object 构造函数生成的，所有函数的 默认原型 都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype。</p>
<p>由此，更新关系图：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/16/1704bf72a35f1a74?w=861&h=505&f=png&s=54960" alt=""></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ol>
<li>每个对象都拥有一个原型对象: dog 的原型是 Animal.prototype。</li>
<li>对象的原型可能也是继承其他原型对象的: Animal.prototype 也有它的原型 Object.prototype。</li>
<li>一层一层的，以此类推，这种关系就是原型链。</li>
</ol>
<p>那么<code>Object.prototype</code>的原型是什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。null 表示此处不应该有值，也就是原型链的终点了，所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/16/1704bffc23da9aaf?w=800&h=592&f=png&s=54550" alt=""></p>
<p>上图中的红色线组成的链就可以称之为原型链。</p>
<p>由上述关系图我们可以重新描述一下原型链：</p>
<blockquote>
<p>从一个实例对象开始往上找，这个实例对象的<strong>proto</strong>属性所指向的则是这个实例对象的原型对象，如果用 dog 表示这个实例，则原型对象表示为<code>dog.__proto__</code>。同时，这个原型也是一个对象，而且它也有上一级的原型对象，相对于上一级原型对象而言，它也是一个实例对象，那么它也拥有<strong>proto</strong>属性，它的<strong>proto</strong>属性也指向它的原型对象，后面也以此类推，一直到 Object.prototype 这个原型为止，这就是整个原型链。</p>
</blockquote>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之Generator生成器全解析</title>
    <url>/2020/01/13/ES6%E7%B3%BB%E5%88%97%E4%B9%8BGenerator%E7%94%9F%E6%88%90%E5%99%A8%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>上一篇我们写完了 Iterator 迭代器，这次我们来讲下 Generator 生成器，如果不了解 Iterator 的话建议先看我上一篇博客，因为这篇会涉及迭代器的内容。</p>
<a id="more"></a>

<h2 id="为什么需要-Generator"><a href="#为什么需要-Generator" class="headerlink" title="为什么需要 Generator"></a>为什么需要 Generator</h2><p>在 JavaScript 中，异步编程场景使用非常多，经常会出现需要逐步完成多个异步操作的情况。之前用回调函数实现异步编程如果碰到了这种问题就需要嵌套使用回调函数，异步操作越多，嵌套得就越深，导致代码的可维护性较差，代码阅读起来也很困难。</p>
<p>Generator 函数是 ES6 提出的一种异步编程解决方案，它可以避免回调的嵌套，语法行为与传统函数完全不同。除此之外，Generator 的特性在某些场景使用也十分方便。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>语法上，首先可以把它理解成，Generator 函数是一个状态机，还是一个 Iterator 对象生成函数。它返回的遍历器对象可以依次遍历 Generator 函数内部的每一个状态。Generator 函数是生成一个对象，但是调用的时候前面不能加 new 命令。</p>
<p>通俗来说，Generator 函数它可以随时暂停函数运行，并可以在任意时候恢复函数运行。</p>
<h2 id="与-Iterator-接口的关系"><a href="#与-Iterator-接口的关系" class="headerlink" title="与 Iterator 接口的关系"></a>与 Iterator 接口的关系</h2><p>任意一个对象的 Symbol.iterator 方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p>
<p>由于 Generator 函数就是 Iterator 迭代器生成函数，因此可以把 Generator 赋值给对象的 Symbol.iterator 属性，从而使得该对象具有 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...myIterable]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，Generator 函数赋值给 Symbol.iterator 属性，从而使得 myIterable 对象具有了 Iterator 接口，可以被…运算符遍历了。</p>
<p>Generator 函数执行后，返回一个迭代器对象。该对象本身也具有 Symbol.iterator 属性，执行后返回自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g[<span class="built_in">Symbol</span>.iterator]() === g) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，gen 是一个 Generator 函数，调用它会生成一个迭代器对象 g。它的 Symbol.iterator 属性，也是一个遍历器对象生成函数，执行后返回它自己。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>function 关键字与函数名之间有一个<code>*</code>号，而且这个<code>*</code>前后允许有空白字符，如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>以上四种写法都可以，根据个人不同习惯，一般第三和第四种用得比较多</p>
<ol start="2">
<li>函数体内部使用 yield 表达式，定义不同的内部状态</li>
<li>普通函数的执行模式是: <strong>执行-结束</strong>, 生成器的执行模式是: <strong>执行-暂停-结束</strong>。生成器可以在执行当中暂停自身，可以立即恢复执行也可以过一段时间之后恢复执行。最大的区别就是它不像普通函数那样保证运行到完毕。</li>
</ol>
<h2 id="yield-关键字"><a href="#yield-关键字" class="headerlink" title="yield 关键字"></a>yield 关键字</h2><p>生成器函数中，有一个特殊的新关键字：<code>yield</code>。由于 Generator 函数返回的是一个 Iterator 对象，只有调用 next 方法才会遍历下一个内部状态,而<code>yield</code>关键字就是<strong>暂停标志</strong>。因为有它，所以才能实现执行-暂停-结束的执行模式。</p>
<p><code>yield</code> 后面可以是任意合法的 JavaScript 表达式，<code>yield</code>语句可以出现的位置可以等价于一般的赋值表达式（比如 a=2）能够出现的位置。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b = <span class="number">2</span> + a = <span class="number">2</span> <span class="comment">// 不合法</span></span><br><span class="line">b = <span class="number">2</span> + <span class="keyword">yield</span> <span class="number">2</span> <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">2</span> + (a = <span class="number">2</span>) <span class="comment">// 合法</span></span><br><span class="line">b = <span class="number">2</span> + (<span class="keyword">yield</span> <span class="number">2</span>) <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>

<p><code>yield</code>关键字的优先级比较低，几乎<code>yield</code>之后的任何表达式都会先进行计算，然后再通过<code>yield</code>向外界产生值。而且<code>yield</code>是右结合运算符，也就是说</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yield yield 2 等价于 (yield (yield 2))</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：</p>
<ol>
<li>它可以指定调用 next 方法时的返回值以及调用顺序。</li>
<li>每当执行完 yield 语句，函数就会停止执行，直到再次调用 next 方法才会继续执行</li>
<li>yield 关键字只能在生成器内部使用，其他地方会导致语法错误</li>
</ol>
<h2 id="运行生成器函数"><a href="#运行生成器函数" class="headerlink" title="运行生成器函数"></a>运行生成器函数</h2><p>说了这么多，我们来举个简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述为一个生成器函数，如何运行它呢？我们知道，生成器还是一个遍历器/迭代器生成函数，也就是说，返回的 Iterator 对象，可以依次遍历生成器函数内部的每一个状态，所以我们可以使用 next()方法让它运行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = gen() <span class="comment">// 生成器返回的是一个指向内部状态的generator对象</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>首先要知道的是，Generator 函数，不管内部有没有<code>yield</code>语句，调用函数时都不会执行任何语句，也不返回函数执行结果，而是返回一个指向内部状态的 generator 对象，也可以看作是一个 Iterator 对象。只有当调用 next(),内部语句才会执行。</p>
<p>在该函数内部有 3 个<code>yield</code>表达式，即该函数有三个状态：1、2、3。而 Generator 函数在此分段执行，调用 next 方法函数内部逻辑开始执行，遇到<code>yield</code>表达式停止，返回 Iterator 对象，再次调用 next 方法，会从上一次停止时的<code>yield</code>处开始，直到最后。所以我们也不难理解<code>yield</code>语句只是函数暂停执行的一个标记。</p>
<p>再来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen()</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上述生成器函数 gen 有三个状态：hello，world 和 return 语句。</p>
<p>第一次调用 next 方法，生成器函数开始执行，遇到第一个 yield 表达式，返回一个对象，它的 value 属性就是当前 yield 表达式的值 hello，done 属性的值 false，表示遍历还没有结束。</p>
<p>同理第二次调用也是按上述逻辑推</p>
<p>第三次调用 next 方法，遇到了 return 语句（如果没有 return 语句，就执行到函数结束）。此时 next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值，在这里 return 后的值即是”ending”（如果没有 return 语句，则 value 属性的值为 undefined），done 属性的值 true，表示遍历已经结束。</p>
<p>第四次调用，此时 生成器函数已经运行完毕，故 next 方法返回对象的 value 属性为 undefined，done 属性为 true。以后无论调用多少次 next 方法，返回的都是这个值。</p>
<h2 id="next-传递参数"><a href="#next-传递参数" class="headerlink" title="next 传递参数"></a>next 传递参数</h2><p>由上述我们知道总结 next 方法的运行逻辑：</p>
<ol>
<li>遇到 <code>yield</code> 语句暂停执行后面的操作，并将在 <code>yield</code> 后面那个表达式的值，作为返回对象的 value 属性值</li>
<li>下次调用 next 方法时，再继续往下执行，直到遇到下一个 <code>yield</code> 语句</li>
<li>如果没有遇到新的 <code>yield</code> 语句，就一直运行函数结束 到 return 语句为止，将 return 的值作为返回的对象 value 的属性值</li>
<li>如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined</li>
</ol>
<p>那 next 方法可以带参数吗？答案当然是可以的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> a + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> b * <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator1 = gen(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(generator1.next()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator1.next()) <span class="comment">// &#123;value: NaN, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator2 = gen(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(generator2.next(<span class="number">2</span>)) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator2.next(<span class="number">4</span>)) <span class="comment">// &#123;value: 16, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面两个例子中，生成器函数 gen 都接收了一个参数 a,都传入了 1。</p>
<p>第一个例子中：第一次调用 next 方法，let b = yield 1 + 1 = yield 2,即返回<code>yield</code>的 value 值为 2；到了第二次调用时，语句 return b _ 2，返回的对象 value 值居然为 NaN。由此可推断此时的 b 并不是上次计算的结果 2，而是 undefined，所以 undefined _ 4 = NaN</p>
<p>看到这里，不懂生成器的小伙伴可能有点懵逼，表面上变量 b 已经用 yield 语句赋值了，但并没有赋值成功。</p>
<p>再第二个例子：第一次调用 next 方法，let b = yield (1 + 1),此时的 next 方法传入了参数，值为 1，这个参数有什么用呢？答：确实没什么用，这里只是为了示范它对结果无影响。</p>
<blockquote>
<p>第一个 next 方法只是用来启动生成器函数内部的遍历器，传参也没有多大意义。即使传了值，它只是将这个传入的值抛弃而已。ES6 表明，generator 函数在这种情况只是忽略了这些没有被用到的值。</p>
</blockquote>
<p>所以 let b = yield (1 + 1) = yield 2, 返回 value 值仍然为 2；第二次调用 next 方法时传入了参数 4，此时 4 覆盖上次 yield 语句的返回值 2，即 let b = 4;故执行 return b _ 4 语句时，即 return 4 _ 4，即返回了 16。</p>
<ul>
<li>上述结果可以说明：<ul>
<li><strong>yield 语句没有返回值，或者总是返回 undefined；</strong></li>
<li><strong>next 方法如果带上一个参数，这个参数就是作为上一个 yield 语句的返回值。<br>注意：因为 next 方法表示上一个 yield 语句的返回值，所以必须有上一个 yield 语句的存在，那么第一次调用 next 方法时就不能传参数。第一个 next 只是用来启动 Generator 函数内部的遍历器，传参也没有多大意义。</strong></li>
</ul>
</li>
</ul>
<p>对于上述两点，我们需要代码再次加深理解：</p>
<p>yield 后可以不带任何表达式的时候，返回的 value 为 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(gen.next()) <span class="comment">// &#123; value: undefined, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>再举一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> x + <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> y / <span class="number">4</span></span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 4, done: false&#125; 返回yield（2+2）= 4</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next(<span class="number">7</span>)) <span class="comment">// &#123;value: 3.5, done: false&#125; 设置yield(x+2) = 7,那么y= 2*7=14,那么yield(y/4) = 3.5</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next(<span class="number">3</span>)) <span class="comment">// &#123;value: 19, done: false&#125; 设置z = yield(y/4) = 3 那么 x+y+z = 2+14+3 = 19</span></span><br></pre></td></tr></table></figure>

<ol>
<li>第一次调用 next 方法，返回 yield（2+2）= 4，返回 value 值为 4</li>
<li>第二次调用 next 方法，next 参数值为 7，覆盖上一次的 yield 值，故 let y = 2 * 7 = 14，则 let z = yield(14 / 4) = 3.5</li>
<li>第三次调用 next 方法，next 参数值为 3，覆盖上一次的 yield 值，故 z = 3，x + y + z = 2 + 14 + 3 = 19</li>
</ol>
<p>这里初次看可能有点绕，建议多看多试几次就容易理解了。</p>
<h2 id="return-与-yield-区别"><a href="#return-与-yield-区别" class="headerlink" title="return 与 yield 区别"></a>return 与 yield 区别</h2><p>从以上的例子也可以看出，函数不仅是碰到 yield 语句才会停止执行，碰到 return 语句也会停止执行。普通函数遇到 return 也会停止执行，Generator 函数也是一个函数，所以很好理解。那么，两者的区别是什么呢？先来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen()</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: "hello", done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>从上面例子可以看出，当碰到 return 语句时，返回对象的 value 值为紧跟 return 后面的值，done 属性值就为 true，代表遍历结束，不管后面是否还有 yield 或者 return 语句。这种区别本质上是因为 yield 语句具备位置记忆功能而 return 语句则没有该功能。</p>
<h2 id="return-与-next-参数区别"><a href="#return-与-next-参数区别" class="headerlink" title="return 与 next 参数区别"></a>return 与 next 参数区别</h2><p>可以总结为三点：</p>
<ol>
<li>return 终结遍历，之后的 yield 语句都失效；next 返回本次 yield 语句的返回值。</li>
<li>return 没有参数的时候，返回{ value: undefined, done: true }；next 没有参数的时候返回本次 yield 语句的返回值。</li>
<li>return 有参数的时候，覆盖本次 yield 语句的返回值，也就是说，返回{ value: 参数, done: true }；next 有参数的时候，覆盖上次 yield 语句的返回值，返回值可能跟参数有关（参数参与计算的话），也可能跟参数无关（参数不参与计算）。</li>
</ol>
<h2 id="return-value-方法"><a href="#return-value-方法" class="headerlink" title="return(value)方法"></a>return(value)方法</h2><p>在生成器里使用 return(value)方法，随时终止生成器，如下面代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = gen()</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.return(<span class="number">10</span>)) <span class="comment">// &#123;value: 10, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>从上述代码我们看出，使用 return()方法我们提前终止了生成器，返回 return 里的值，再次调用 next()方法时，done 属性的值为 true,遍历结束，由此可见 return 提前终止了生成器。</p>
<h2 id="throw-exception-方法"><a href="#throw-exception-方法" class="headerlink" title="throw(exception)方法"></a>throw(exception)方法</h2><p>除了用 return(value)方法可以终止生成生成器，我们还可以调用 throw(exception) 进行提前终止生成器，示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen()</span><br><span class="line"><span class="built_in">console</span>.log(generator.next())</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  generator.throw(<span class="string">'throw error msg'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'必执行的finally语句块'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(generator.next())</span><br></pre></td></tr></table></figure>

<p>输出结果;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"><span class="keyword">throw</span> error msg</span><br><span class="line">必执行的<span class="keyword">finally</span>语句块</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>由此可以看出，在生成器外部调用 try…catch…finally,throw()异常被 try…catch 捕捉并返回，并执行了 finally 代码块中的代码。当再次调用 next 方法，done 属性返回 true,说明生成器已被终止。</p>
<p>我们不仅可以在 next 执行过程中插入 throw()语句，我们还可以在生成器内部插入 try…catch 进行错误处理。</p>
<blockquote>
<p>throw 方法抛出的错误要被内部捕获，前提是必须至少执行过一次 next 方法。</p>
</blockquote>
<p>代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'first Exception'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'second Exception'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = gen()</span><br><span class="line"><span class="built_in">console</span>.log(generator.next())</span><br><span class="line"><span class="built_in">console</span>.log(generator.throw(<span class="string">'exception string'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(generator.throw(<span class="string">'exception string'</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">first Exception</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">second Exception</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>从代码输出可以输出，当我们在 generator.throw()方法时，被生成器内部上个暂停点的异常处理代码所捕获，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次 next 方法。由此可见在生成器内部使用 try…catch 可以捕获异常，并不会影响到遍历器的状态。</p>
<h2 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h2><p>如果想要在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span></span><br><span class="line">  <span class="comment">// for...of遍历 gen1()</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> gen1()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> gen2()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p>如果有多个 Generator 函数嵌套，写起来就非常麻烦。<br>ES6 提供了<code>yield*</code>表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p>
<p>把上面的 gen2 函数改写如下,如下也能得到相同的输出结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span></span><br><span class="line">  <span class="keyword">yield</span>* gen1()</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>yield*</code>可以将可迭代的对象 iterable 放在一个生成器里，生成器函数运行到<code>yield*</code> 位置时，将控制权委托给这个迭代器，直到执行完成为止。举个例子，数组也是可迭代对象，因此<code>yield*</code>也可委托给数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span>* gen1()</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = gen2()</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 5, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Generator-的应用场景"><a href="#Generator-的应用场景" class="headerlink" title="Generator 的应用场景"></a>Generator 的应用场景</h2><h3 id="异步操作的同步化表达"><a href="#异步操作的同步化表达" class="headerlink" title="异步操作的同步化表达"></a>异步操作的同步化表达</h3><p>Generator 函数的暂停执行的效果，意味着可以把异步操作写在 yield 表达式里面，等到调用 next 方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在 yield 表达式下面，反正要等到调用 next 方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数，避免回调嵌套。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loadUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  showLoadingScreen()</span><br><span class="line">  <span class="keyword">yield</span> loadUIDataAsynchronously()</span><br><span class="line">  hideLoadingScreen()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loader = loadUI()</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.next()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.next()</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一次调用 next 方法时，则会显示 Loading 界面，并且异步加载数据。等到数据加载完成，再一次使用 next 方法，则会隐藏 Loading 界面。可以看到，这种写法的好处是所有 Loading 界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p>
<h3 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span></span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url)</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"><span class="keyword">var</span> result = g.next()</span><br><span class="line"></span><br><span class="line">result.value</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.json()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    g.next(data)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。不过也可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<h3 id="部署-Iterator-接口"><a href="#部署-Iterator-接口" class="headerlink" title="部署 Iterator 接口"></a>部署 Iterator 接口</h3><p>利用 Generator 函数，可以在任意对象上部署 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i]</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">bar</span>: <span class="number">7</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，myObj 是一个普通对象，通过 iterEntries 函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署 next 方法。</p>
<h3 id="抽奖程序"><a href="#抽奖程序" class="headerlink" title="抽奖程序"></a>抽奖程序</h3><p>比如当前用户还可以抽奖 5 次，用户点了 5 次抽奖后就不能继续抽奖了，如做一个剩余抽奖次数的限制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"start"</span>&gt;</span>抽奖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> draw = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 具体抽奖逻辑</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`剩余<span class="subst">$&#123;count&#125;</span>次`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> residue = <span class="function"><span class="keyword">function</span>* (<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 抽奖次数的限制</span></span><br><span class="line">    count--</span><br><span class="line">    <span class="keyword">yield</span> draw(count) <span class="comment">//执行抽奖的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = residue(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'start'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  start.next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后我们通过点击 5 次抽奖按钮,依次输出剩余几次。当剩余 0 次时，再点击按钮不会有任何输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">剩余4次</span><br><span class="line">剩余3次</span><br><span class="line">剩余2次</span><br><span class="line">剩余1次</span><br><span class="line">剩余0次</span><br></pre></td></tr></table></figure>

<p>上述通过 generator 来控制抽奖的次数限制的好处是：抽奖次数无需保存在全局变量中，而且把抽奖具体逻辑给分离开。</p>
<h2 id="Generator-函数的语法糖—async-函数"><a href="#Generator-函数的语法糖—async-函数" class="headerlink" title="Generator 函数的语法糖—async 函数"></a>Generator 函数的语法糖—async 函数</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便，而 async 函数是就是 Generator 函数的语法糖。</p>
<ol>
<li><code>async</code> 对应的是 <code>*</code></li>
<li><code>await</code> 对应的是 <code>yield</code></li>
</ol>
<p><code>async</code>和<code>await</code>，比起<code>*</code>号和<code>yield</code>，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p>
<p>比如我们假装模拟一个请求 ajax 方法返回用户数据并输出显示的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'用户数据...'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">yield</span> ajax()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`输出的user数据:<span class="subst">$&#123;user&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当然真实项目不可能这么写，在此只是方便拿数据</span></span><br><span class="line"><span class="keyword">const</span> generator = fetchUser()</span><br><span class="line"><span class="keyword">let</span> obj = generator.next()</span><br><span class="line">generator.next(obj.value)</span><br></pre></td></tr></table></figure>

<p>如果用 async 函数代替,代码就会优雅很多</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> ajax()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`输出的user数据:<span class="subst">$&#123;user&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">fetchUser()</span><br></pre></td></tr></table></figure>

<p>这里可以看出并不需要调用 next()方法，因为 async 函数自带执行器。也就是说，<br>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Generator 是一个可以暂停和继续执行的函数，他可以完全实现 Iterator 的功能，并且由于可以保存上下文，他非常适合实现简单的状态机。另外通过一些流程控制代码的配合，可以比较容易进行异步操作。</p>
<p>Async/Await 就是 generator 进行异步操作的语法糖，该语法糖相比下有更好的应用和语义化，它们搭配 promise，可以通过编写形似同步的代码来处理异步流程，提高代码的简洁性和可读性。</p>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之一文彻底弄懂Iterator</title>
    <url>/2020/01/11/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Iterator/</url>
    <content><![CDATA[<p>本文主要来深入剖析ES6的Iterator（迭代器/遍历器），在了解它之前，我们首先要知道为什么需要Iterator? 它出现的原因是什么?</p>
<a id="more"></a>
<h2 id="从循环说起"><a href="#从循环说起" class="headerlink" title="从循环说起"></a>从循环说起</h2><p>平时开发中，我们经常会用到循环，拿最基本的来说，比如循环一个数组:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]); <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用forEach循环</span></span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用for in循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]); <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是循环输出字符串的每一个字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abcde'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str[i]); <span class="comment">// a b c d e</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for in循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> str)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str[k]); <span class="comment">// a b c d e</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach不能遍历字符串，如果硬要用则只能先把字符串转为数组再用数组方式循环</span></span><br></pre></td></tr></table></figure>


<p>如果是循环输出一个map对象呢, 妥妥的就一个foreach循环，普通的for循环和for…in都不行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'第一'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'第二'</span>);</span><br><span class="line">map.set(<span class="string">'third'</span>, <span class="string">'第三'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach循环</span></span><br><span class="line">map.forEach(<span class="function">(<span class="params">val,key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val, key);</span><br><span class="line">    <span class="comment">// 第一 first</span></span><br><span class="line">    <span class="comment">// 第二 second</span></span><br><span class="line">    <span class="comment">// 第三 third</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对于上述各集合数据，我们发现没有一个循环方法是可以一次性解决的。</p>
<p>虽然forEach循环不能循环字符串，但字符串可以转为数组再使用forEach即可输出，但这操作并不舒服每次使用都要转换。而且forEach循环存在缺点：<code>不能使用break，continue语句跳出循环，或者使用return从函数体返回</code>。</p>
<p>而for循环在有些情况写代码会增加复杂度，而且不能循环对象。</p>
<p>相比下，for…in的缺点是不仅遍历数字键名，还会遍历手动添加的自定义键，甚至包括原型链上的键。for…in主要还是为遍历对象而设计的，并不太适用于遍历数组。</p>
<p>如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.protoValue = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr.test = <span class="string">'test'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]); <span class="comment">// 1 2 3 4 test hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>话说回来，有没有一种更好的循环能一统上述循环问题？ ES6就有了，用for…of循环</p>
<h2 id="for…of循环出现"><a href="#for…of循环出现" class="headerlink" title="for…of循环出现"></a>for…of循环出现</h2><p>它的出现解决了什么问题呢？首先是当然是能解决了上述我们的问题</p>
<p>对上述数据进行循环输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// a b c d e</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="comment">// (2) ["first", "第一"]</span></span><br><span class="line">    <span class="comment">// (2) ["second", "第二"]</span></span><br><span class="line">    <span class="comment">// (2) ["third", "第三"]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看看它的优点：</p>
<ol>
<li>简洁直接的遍历数组语法</li>
<li>它避开了 for-in 循环的所有缺点</li>
<li>与forEach循环不同的是，它可以使用break、continue 和 return 语句</li>
</ol>
<p>阮一峰老师的《ECMAScript 6 入门》提到：</p>
<blockquote>
<p>ES6中引入了for…of循环，作为遍历所有数据结构的统一的方法。</p>
</blockquote>
<blockquote>
<p>Iterator是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
</blockquote>
<p>一个数据结构只要具有 iterator 接口，就可以用for…of循环遍历它的成员。</p>
<p>也就是说，并不是所有的对象都能使用for…of循环，只有实现了Iterator接口的对象，才能够for…of来进行遍历取值。</p>
<p>那么，Iterator是什么呢？我们接着说</p>
<h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
</blockquote>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>为各种数据结构，提供一个统一的、简便的访问接口；</li>
<li>使得数据结构的成员能够按某种次序排列；</li>
<li>创造一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。</li>
</ol>
<p>现在明白了，Iterator的产生主要是为了使用for…of方法。但具体Iterator概念还是有些抽象，如果要直接具体的描述的话：</p>
<p>Iterator其实就是一个具有 next()方法的对象，并且每次调用next()方法都会返回一个结果对象，这个结果对象有两个属性, 如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    value: 表示当前的值,</span><br><span class="line">    done: 表示遍历是否结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里多了一些概念，我们来梳理一下：</p>
<p>Iterator是一个特殊的对象：</p>
<ol>
<li>它具有next()方法，调用该方法就会返回一个结果对象</li>
<li>结果对象有两个属性值：<code>value</code>和<code>done</code>。</li>
<li><code>value</code>表示具体的返回值；done是布尔类型，表示集合是否完成遍历，没有则返回true，否则返回false</li>
<li>内部有一个指针，指向数据结构的起始位置。每调用一次next()方法，指针都会向后移动一个位置，直到指向最后一个位置。</li>
</ol>
<h3 id="模拟Iterator"><a href="#模拟Iterator" class="headerlink" title="模拟Iterator"></a>模拟Iterator</h3><p>根据上述描述，我们来模拟一个迭代器，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> done = (i &gt;= item.length);</span><br><span class="line">            <span class="keyword">var</span> value = !done ? items[i++] : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: done,</span><br><span class="line">                value: value</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator 就是一个迭代器对象</span></span><br><span class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: false, value: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: false, value: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: false, value: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>

<p>过程:</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的next方法，next 方法内部通过闭包来保存指针<code>i</code> 的值，每次调用<code>i</code>都会<code>+1</code>，指向下一个。故第一次指针指向数据结构的第一个成员，输出1。</li>
<li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员，输出2。</li>
<li>第三次调用指针对象的next方法，数组长度为3，此时数据结构的结束位置，输出3。</li>
<li>第四次调用指针对象的next方法，此时已遍历完成了，输出done为true表示完成，value为undefined，此后第n次调用都是该结果。</li>
</ol>
<p>看到这里大家大概知道<code>Iterator</code>了，但Iterator接口主要供for…of消费。我们试着用for…of循环上面创建Iterator对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var iterator &#x3D; makeIterator([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">for (let value of iterator) &#123;</span><br><span class="line">    console.log(value); &#x2F;&#x2F; Uncaught TypeError: iterator is not iterable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果报错，说明我们生成的 iterator 对象并不是可遍历的，这样的结构还不能够被for…of循环</p>
<p>那什么样的结构才是可遍历的呢？</p>
<h2 id="可迭代对象Iterable"><a href="#可迭代对象Iterable" class="headerlink" title="可迭代对象Iterable"></a>可迭代对象Iterable</h2><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>ES6还引入了一个新的Symbol对象，symbol值是唯一的。</p>
<p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口；调用这个接口，就会返回一个遍历器对象。这样的数据结构才能被称为可迭代对象(Iterator)，该对象可被for…of遍历。</p>
<p>照着上面的规定来创建一个可迭代对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> done = (i &gt;= _this.length);</span><br><span class="line">            <span class="keyword">var</span> value = !done ? _this[i++] : <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: done,</span><br><span class="line">                value: value</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时可以for...of遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// 1 2 3 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，我们也可以知道 for…of 遍历的其实是对象的 Symbol.iterator 属性。</p>
<h3 id="原生具备Iterator接口的数据结构"><a href="#原生具备Iterator接口的数据结构" class="headerlink" title="原生具备Iterator接口的数据结构"></a>原生具备Iterator接口的数据结构</h3><p>在ES6中，所有的集合对象，包括数组，类数组对象（arguments对象、DOM NodeList 对象），Map和Set，还有字符串都是可迭代的，都可以被for…of遍历，因为他们都有默认的迭代器。</p>
<p>下面就挑其中几个类型来举例子：</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> iteratorObj = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next());</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next());</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next());</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next());</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/8/16f8433c4b0b041a?w=294&h=282&f=png&s=23046" alt=""><br>由上述对迭代器的概念认识，输出结果也完全符合我们预期。</p>
<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>我们知道普通对象是默认没有部署这个接口的，所以arguments这个属性没有在原型上，而是在对象自身的属性上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj = <span class="built_in">arguments</span>[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(obj.next());</span><br><span class="line">   <span class="built_in">console</span>.log(obj.next());</span><br><span class="line">   <span class="built_in">console</span>.log(obj.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/8/16f8446fec7e2102?w=508&h=197&f=png&s=20591" alt=""></p>
<h4 id="NodeList"><a href="#NodeList" class="headerlink" title="NodeList"></a>NodeList</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nodeList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'test'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> nodeList) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/8/16f84531078f206d?w=236&h=61&f=png&s=3489" alt=""></p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>这次直接从原型上找来证明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Map</span>.prototype.hasOwnProperty(<span class="built_in">Symbol</span>.iterator)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>至于其他类型的可迭代对象大家可举一反三。</p>
<h2 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h2><p>有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法）</p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set().add('a').add('b').add('c');</span><br><span class="line"></span><br><span class="line">let [x, y] = <span class="keyword">set</span>;</span><br><span class="line">console.log(x, y); // a b</span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（…）也会调用默认的 Iterator 接口，可以将当前迭代对象转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log([...str]); <span class="comment">// ["h", "e", "l", "l", "o"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>]); <span class="comment">// ["a", "b", "c", "d"]</span></span><br></pre></td></tr></table></figure>

<h3 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h3><p>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = generator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>关于yield之后会再写一篇专题</p>
<h3 id="其他场合"><a href="#其他场合" class="headerlink" title="其他场合"></a>其他场合</h3><p>例如：for…of、Set()、Map()、Array.from()等。我们主要是为了证明调用上面这些函数时着实是用到了Iterator接口。</p>
<p>我们贴出上面的实现可迭代对象的代码，进行改动。想一想，尽管我们没有手动添加 Symbol.iterator属性，但因为 ES6 默认部署了 Symbol.iterator，数组还是可以遍历成功，那当然我们也可以手动修改这个属性，重新部署也可以。</p>
<p>如果我们手动修改生效，影响了输出，证明某方法调用需要用到Iterator接口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> done = (i &gt;= _this.length);</span><br><span class="line">            <span class="keyword">var</span> value = !done ? _this[i++] : <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: done,</span><br><span class="line">                value: value + <span class="string">' 手动添加的属性'</span> <span class="comment">// 添加自定义值</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果显示手动修改生效，证明for...of调用了Iterator接口</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">    <span class="comment">// 1 手动添加的属性</span></span><br><span class="line">    <span class="comment">// 2 手动添加的属性</span></span><br><span class="line">    <span class="comment">// 3 手动添加的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = new Set(arr);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(3) &#123;<span class="number">1</span> 手动添加的属性<span class="string">", 2 手动添加的属性"</span>, <span class="number">3</span> 手动添加的属性<span class="string">"&#125;</span></span><br></pre></td></tr></table></figure>
<p>上述其他方法证明也是如此，就不一一列出了。</p>
<h2 id="计算生成的数据结构"><a href="#计算生成的数据结构" class="headerlink" title="计算生成的数据结构"></a>计算生成的数据结构</h2><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p>
<ol>
<li>entries() 返回一个遍历器对象，用来遍历[键名,键值]组成的数组。对于数组，键名就是索引值。</li>
<li>keys() 返回一个遍历器对象，用来遍历所有的键名。</li>
<li>values() 返回一个遍历器对象，用来遍历所有的键值。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"third"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 0, "first" ]</span></span><br><span class="line"><span class="comment">// [ 1, "second" ]</span></span><br><span class="line"><span class="comment">// [ 2, "third" ]</span></span><br></pre></td></tr></table></figure>


<h2 id="判断对象是否可迭代"><a href="#判断对象是否可迭代" class="headerlink" title="判断对象是否可迭代"></a>判断对象是否可迭代</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isIterable = <span class="function"><span class="params">obj</span> =&gt;</span> obj != <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> obj[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>())); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>())); <span class="comment">// true  </span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">"hello world"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


<h3 id="for…of循环不支持遍历普通对象"><a href="#for…of循环不支持遍历普通对象" class="headerlink" title="for…of循环不支持遍历普通对象"></a>for…of循环不支持遍历普通对象</h3><p>梳理了半天，回到最初，Iterator的产生主要是为了使用for…of方法。而对象不像数组的值是有序的，遍历的时候根本不知道如何确定他们的先后顺序，所以要注意的是for…of循环不支持遍历对象。</p>
<p>如果非要遍历对象，同理对象也必须包含[Symbol.iterator]的属性并实现迭代器方法，可以通过手动利用Object.defineProperty方法添加该属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// Uncaught TypeError: obj is not iterable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于Iterator就写到这里了，下一篇写ES6的Generator生成器。</p>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之箭头函数全解析</title>
    <url>/2020/01/07/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>ES6中允许使用箭头来定义箭头函数，是ES6中较受欢迎也较常使用的新增特性。本文将从箭头函数的基本语法，与普通函数对比，箭头函数不适用场景三个方面进行梳理。</p>
<a id="more"></a>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出，定义箭头函数语法上要比普通函数简洁得多。箭头函数省去了<code>function</code>关键字，采用箭头<code>=&gt;</code>来定义函数。函数的参数放在<code>=&gt;</code>前面的括号中，函数体跟在<code>=&gt;</code>后的花括号中，箭头函数在参数和箭头之间不能换行。</p>
<h3 id="箭头函数的参数"><a href="#箭头函数的参数" class="headerlink" title="箭头函数的参数"></a>箭头函数的参数</h3><ol>
<li>如果箭头函数没有参数，直接写一个空括号即可。</li>
<li>如果箭头函数的参数只有一个，可以省略包裹参数的括号。</li>
<li>如果箭头函数有多个参数，将参数依次用逗号分隔，参数必须被包裹在括号中。</li>
</ol>
<h3 id="箭头函数的函数体"><a href="#箭头函数的函数体" class="headerlink" title="箭头函数的函数体"></a>箭头函数的函数体</h3><p>如果箭头函数的函数体只有一句代码，即返回某个变量或者返回一个简单的JS表达式，可以省去函数体的大括号{ }。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">val</span> =&gt;</span> val;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123; <span class="keyword">return</span> val &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mulFunction = <span class="function">(<span class="params">num1, num2 ,num3</span>) =&gt;</span> num1 * num2 * num3;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> mulFunction = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2 ,num3</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 * num2 * num3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数返回一个对象"><a href="#箭头函数返回一个对象" class="headerlink" title="箭头函数返回一个对象"></a>箭头函数返回一个对象</h3><p>如果箭头函数的函数体只有一句代码且返回一个对象（对象字面量）时，直接写一个表达式是不行的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;; </span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">// 执行后返回undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是这样还会直接报错</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>原因是花括号被解释为函数体的大括号，解决办法：<strong>用圆括号把对象字面量包起来</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">// &#123;foo: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不过上面那样解决的缺点是可读性变差了，所以更推荐直接当成多条语句的形式来写，可读性高  </span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        foo: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简化回调函数"><a href="#简化回调函数" class="headerlink" title="简化回调函数"></a>简化回调函数</h3><p>这是箭头函数比较常见的用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>
<h2 id="跟普通函数的区别"><a href="#跟普通函数的区别" class="headerlink" title="跟普通函数的区别"></a>跟普通函数的区别</h2><h3 id="没有this绑定"><a href="#没有this绑定" class="headerlink" title="没有this绑定"></a>没有this绑定</h3><p>箭头函数没有自己的this，它会捕获自己在<em>定义时</em>）所处的外层执行环境的this，并继承这个this值。所以，箭头函数中this的指向在它被定义的时候就已经确定了，之后永远不会改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;    </span><br><span class="line">&#125;</span><br><span class="line">obj.a();  <span class="comment">// 打印结果：obj对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	a:<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">obj.a();  <span class="comment">// 打印结果： Window对象</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，箭头函数与外层的this保持一致，最外层的this就是Window对象。</p>
<h3 id="没有arguments"><a href="#没有arguments" class="headerlink" title="没有arguments"></a>没有arguments</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func2 = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">func1(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line">func2(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// Uncaught ReferenceError: arguments is not defined</span></span><br></pre></td></tr></table></figure>
<p>如果非要打印函数参数，可以在箭头函数中使用rest参数代替arguments对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func2 = <span class="function">(<span class="params">...rest</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rest); <span class="comment">// (2) [1, 2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不能通过-new-关键字调用"><a href="#不能通过-new-关键字调用" class="headerlink" title="不能通过 new 关键字调用"></a>不能通过 new 关键字调用</h3><p>在构造函数中，this指向新创建的对象实例</p>
<p>而箭头函数没有 [[Construct]]方法，箭头函数不可以当作构造函数，如果这样做会抛出异常</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Person is not a constructor</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'jacky'</span>);</span><br></pre></td></tr></table></figure>
<p>箭头函数在创建时this对象就绑定了，故不会指向对象实例。</p>
<h3 id="没有-new-target"><a href="#没有-new-target" class="headerlink" title="没有 new.target"></a>没有 new.target</h3><p>new.target是ES6新引入的属性，普通函数如果通过new调用，new.target会返回该函数的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(); <span class="comment">// ƒ Cat() &#123; console.log(new.target); &#125;</span></span><br></pre></td></tr></table></figure>
<p>此属性主要：用于确定构造函数是否为new调用的。 </p>
<p>箭头函数的this指向全局对象，在箭头函数中使用箭头函数会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target);</span><br><span class="line">&#125;</span><br><span class="line">a(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target); <span class="comment">// 报错：Uncaught SyntaxError: new.target expression is not allowed here</span></span><br><span class="line">&#125;;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure>

<h3 id="没有原型"><a href="#没有原型" class="headerlink" title="没有原型"></a>没有原型</h3><p>由于不能通过 new 关键字调用，不能作为构造函数，所以箭头函数不存在 prototype 这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(func.prototype) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="没有-super"><a href="#没有-super" class="headerlink" title="没有 super"></a>没有 super</h3><p>箭头函数没有原型，故也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的。同this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。</p>
<h3 id="call-apply-bind方法无法改变箭头函数中this的指向"><a href="#call-apply-bind方法无法改变箭头函数中this的指向" class="headerlink" title="call/apply/bind方法无法改变箭头函数中this的指向"></a>call/apply/bind方法无法改变箭头函数中this的指向</h3><p>call()、apply()、bind()方法的共同特点是可以改变this的指向，用来动态修改函数执行时this的指向。但由于箭头函数的this定义时就已经确定了且不会改变。所以这三个方法永远也改变不了箭头函数this的指向。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global name'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'jacky'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数定义在全局作用域</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func();     <span class="comment">// global name</span></span><br><span class="line"><span class="comment">// this的指向不会改变，永远指向Window对象,放到到window下的全局变量</span></span><br><span class="line">func.call(obj);     <span class="comment">// global name</span></span><br><span class="line">func.apply(obj);    <span class="comment">// global name</span></span><br><span class="line">func.bind(obj)();   <span class="comment">// global name</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数的解析顺序相对靠前"><a href="#箭头函数的解析顺序相对靠前" class="headerlink" title="箭头函数的解析顺序相对靠前"></a>箭头函数的解析顺序相对靠前</h3><p>虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> callback;</span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;      </span><br><span class="line"><span class="comment">// SyntaxError:非法箭头函数属性</span></span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;&#125;);    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数不支持重名参数"><a href="#箭头函数不支持重名参数" class="headerlink" title="箭头函数不支持重名参数"></a>箭头函数不支持重名参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, <span class="built_in">arguments</span>); <span class="comment">// 2 Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boo = <span class="function">(<span class="params">a, a</span>) =&gt;</span> &#123; <span class="comment">// 直接报错：Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">boo(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1使用-yield-关键字"><a href="#1使用-yield-关键字" class="headerlink" title="1使用 yield 关键字"></a>1使用 yield 关键字</h3><p>yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器（ Generator ）。</p>
<h2 id="箭头函数不适用的场景"><a href="#箭头函数不适用的场景" class="headerlink" title="箭头函数不适用的场景"></a>箭头函数不适用的场景</h2><p><strong>1.不应被用在定义对象的方法上</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.x, <span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.x, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">obj.b(); <span class="comment">// 10  &#123;x: 10, b: ƒ, c: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line">obj.c(); <span class="comment">// undefined Window</span></span><br></pre></td></tr></table></figure>
<p>因为它内部this的指向原因，当使用obj.c()的时候，我们希望c方法里面的this指向obj，但是它却指向了obj所在上下文中的this（即window），违背了我们的需求，所以箭头函数不适合作为对象的方法。</p>
<p><strong>2.具有动态上下文的回调函数，也不应使用箭头函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;);</span><br><span class="line">为btn的监听函数是一个箭头函数，导致里面的<span class="keyword">this</span>就是全局对象,而不符合我们想操作按钮本身的需求。如果改成普通函数，<span class="keyword">this</span>就会动态指向被点击的按钮对象</span><br></pre></td></tr></table></figure>

<p>除了前面两点，剩下的跟上面讲的与普通函数的区别重复了，故只作总结不贴代码了:</p>
<ol>
<li>不应被用在定义对象的方法上</li>
<li>具有动态上下文的回调函数，也不应使用箭头函数</li>
<li>不能应用在构造函数中</li>
<li>避免在 prototype 上使用</li>
<li>避免在需要 arguments 上使用</li>
</ol>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之模板字符串</title>
    <url>/2020/01/05/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>模板字符串是ES6中非常重要的一个新特性，这个特性使得处理相关业务变得更加容易。</p>
<a id="more"></a>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">`hello world`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>
<p>注意这里不是双引号，而是反撇号`</p>
<p>在模板字符串中，还可以拼接html元素，同时空格、缩进、换行都会被保留，并且如果模板字符串中的变量没有声明，将报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;ul&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;11&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;22&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/5/16f75f81fdc039fd?w=283&h=118&f=png&s=3077" alt=""></p>
<p>上面代码中，<code>&lt;div&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;ul&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;11&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;22&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>.trim();</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/5/16f75fa6f941fbc2?w=285&h=115&f=png&s=3098" alt=""></p>
<p>在模版字符串内使用反引号`时，需要在它前面加转义符\</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">`hello \\n`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<h2 id="嵌入变量"><a href="#嵌入变量" class="headerlink" title="嵌入变量"></a>嵌入变量</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'jacky'</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'我叫'</span> + name + <span class="string">'，大家好'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 我叫jacky，大家好</span></span><br></pre></td></tr></table></figure>
<p>当有变量参与拼接时，ES5下必须用+号这样的形式进行拼接，这样很麻烦而且很容易出错。<br>ES6新增了字符串模版，可以很好的解决这个问题。这时再引用str变量就需要用${name}这种形式了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'jacky'</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'我叫$&#123;name&#125;，大家好'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 我叫jacky，大家好</span></span><br></pre></td></tr></table></figure>
<p>如果大括号内部是一个字符串，将会原样输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> world = <span class="string">'666'</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">`hello <span class="subst">$&#123;<span class="string">'world'</span>&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="对运算的支持"><a href="#对运算的支持" class="headerlink" title="对运算的支持"></a>对运算的支持</h2><p>在${}里面，可以写任意的JS表达式，比如我们用它进行运算</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="string">`<span class="subst">$&#123;a+b&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="模板字符串调用函数"><a href="#模板字符串调用函数" class="headerlink" title="模板字符串调用函数"></a>模板字符串调用函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span>); <span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之变量的解构赋值</title>
    <url>/2020/01/04/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<p>解构赋值在开发中很常用，在此总结它的用法…</p>
<a id="more"></a>

<h2 id="什么是解构？"><a href="#什么是解构？" class="headerlink" title="什么是解构？"></a>什么是解构？</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。它在语法上比 ES5 所提供的更加简洁、紧凑、清晰。它不仅能减少你的代码量，还能从根本上改变你的编码方式。</p>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>以前，为变量赋值，我们只能直接指定值，比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>现在可以用数组解构的方式来进行赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1, 2, 3</span></span><br></pre></td></tr></table></figure>

<p>这是数组解构最基本类型的用法，还可以解构对象数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象数组解构</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [&#123; <span class="attr">name</span>: <span class="string">'jacky'</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">'monkey'</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">'houge'</span> &#125;]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// &#123;name: 'jacky'&#125;, &#123;name: 'monkey'&#125;, &#123;name: 'houge'&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组模式和赋值模式统一"><a href="#数组模式和赋值模式统一" class="headerlink" title="数组模式和赋值模式统一"></a>数组模式和赋值模式统一</h2><p>这条可以理解为等号左边和等号右边的形式要统一，如果不统一解构将失败。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [b, c], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d) <span class="comment">// 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取除第二、三个外的所有数值</span></span><br><span class="line"><span class="keyword">let</span> [a, , , d] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, d) <span class="comment">// 1 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 1 [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, , , ...d] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, d) <span class="comment">// 1 [4, 5]</span></span><br></pre></td></tr></table></figure>

<p>如果解构不成功，变量的值就等于<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// 2 3 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [c] = []</span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上述是完全解构的情况，还有一种是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组，解构依然可以成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(x, y) <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, d) <span class="comment">// 1 2 4</span></span><br></pre></td></tr></table></figure>

<h2 id="解构的默认值"><a href="#解构的默认值" class="headerlink" title="解构的默认值"></a>解构的默认值</h2><p>解构赋值允许指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b = <span class="number">2</span>] = [<span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b = <span class="number">2</span>, c, d = <span class="number">13</span>] = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d) <span class="comment">// 10 11 12 13</span></span><br></pre></td></tr></table></figure>

<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而非前者。</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">'aaa'</span>, <span class="attr">b</span>: <span class="string">'bbb'</span> &#125;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: x, <span class="attr">b</span>: y &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(x, y) <span class="comment">// aaa bbb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="string">'aaa'</span>, <span class="attr">b</span>: <span class="string">'bbb'</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// aaa bbb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不按照顺序</span></span><br><span class="line"><span class="keyword">let</span> &#123; b, a &#125; = &#123; <span class="attr">a</span>: <span class="string">'test1'</span>, <span class="attr">b</span>: <span class="string">'test2'</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// test1 test2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套解构</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  obj: &#123; name &#125;,</span><br><span class="line">&#125; = &#123; <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="string">'jacky'</span>, <span class="attr">age</span>: <span class="string">'22'</span> &#125; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// jacky</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稍微复杂的嵌套</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [<span class="string">'Hello'</span>, &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  p: [x, &#123; y &#125;],</span><br><span class="line">&#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(x, y) <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>

<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: rename &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(rename) <span class="comment">// aaa</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>

<p>如果在解构之前就定义了变量，这时候再解构会出现问题。下面是错误的代码，编译会报错（因为 js 引擎会将{a}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 js 将其解释成代码块，才能解决这个问题）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">"aaa"</span> &#125;;</span><br><span class="line">&#123;a&#125; = obj; <span class="comment">// Uncaught SyntaxError: Unexpected token '='</span></span><br></pre></td></tr></table></figure>

<p>要解决报错，使程序正常，这时候只要在解构的语句外边加一个圆括号就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">'aaa'</span> &#125;</span><br><span class="line">;(&#123; a &#125; = obj)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数的参数也可以使用解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>函数参数的解构也可以使用默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y = <span class="number">7</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">3</span>)) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串解构"><a href="#字符串解构" class="headerlink" title="字符串解构"></a>字符串解构</h2><p>字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e, f] = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//h</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">//e</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">//l</span></span><br><span class="line"><span class="built_in">console</span>.log(d) <span class="comment">//l</span></span><br><span class="line"><span class="built_in">console</span>.log(e) <span class="comment">//o</span></span><br><span class="line"><span class="built_in">console</span>.log(f) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toString</span>: s &#125; = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(s === <span class="built_in">Number</span>.prototype.toString) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toString</span>: s &#125; = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(s === <span class="built_in">Boolean</span>.prototype.toString) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span> <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h2 id="解构赋值的应用"><a href="#解构赋值的应用" class="headerlink" title="解构赋值的应用"></a>解构赋值的应用</h2><h3 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h3><p>通常交换两个变量的方法需要一个额外的临时变量,如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> temp</span><br><span class="line"></span><br><span class="line">temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure>

<p>用 ES6 解构赋值的话，会变得很简洁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">;[a, b] = [b, a]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure>

<h3 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h3><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example()</span><br></pre></td></tr></table></figure>

<h3 id="访问数组中元素"><a href="#访问数组中元素" class="headerlink" title="访问数组中元素"></a>访问数组中元素</h3><p>有种场景，比如有一个数组（可能为空）。并且希望访问数组的第一个、第二个或第 n 个项，但如果该项不存在，则使用指定默认值。<br>通常会使用数组的<code>length</code>属性来判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstItem = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">if</span> (list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  firstItem = list[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstItem) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>如果用 ES6 解构赋值来实现上述逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = []</span><br><span class="line"><span class="keyword">const</span> [firstItem = <span class="string">'hello'</span>] = list</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstItem) <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>

<h3 id="提取-JSON-数据"><a href="#提取-JSON-数据" class="headerlink" title="提取 JSON 数据"></a>提取 JSON 数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">'OK'</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number)</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历-Map-结构"><a href="#遍历-Map-结构" class="headerlink" title="遍历 Map 结构"></a>遍历 Map 结构</h3><p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>)</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">' is '</span> + value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>

<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文章部分内容参考：阮一峰老师的《ECMAScript 6 入门》一书</li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之let和const与var的区别</title>
    <url>/2019/12/28/ES6%E7%B3%BB%E5%88%97%E4%B9%8Blet%E5%92%8Cconst%E4%B8%8Evar%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>ES6规范新增了let、const两种变量声明方式，项目中也经常要用到，今天借着温习ES6语法，来总结let 、const、var的区别。</p>
<a id="more"></a>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>来看下面三段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// Uncaught ReferenceError: c is not defined</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>用var声明的变量，会在其作用域中发生变量提升，js默认给变量一个undefined值。</p>
<p>但是，在ES6中使用let/const声明的变量，不存在变量提升过程。也就是说，在使用let/const声明的变量，声明前访问它，都会报错。</p>
<h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><blockquote>
<p>代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'global'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    a = <span class="string">'block'</span>;    <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，if代码块里，在let声明变量a之前，都是a的”暂时性死区”,在该范围内访问a都会报错。<br>由此可见，块级作用域内存在let声明的话，它所声明的变量就绑定在这个块级作用域，不再受外部影响。</p>
<h2 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h2><p>let 和 const 命令声明的变量不允许重复声明；而使用var声明变量，可以多次重复声明一个同名变量，但最终变量的值为最后一次声明赋值的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'last value'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// last value</span></span><br></pre></td></tr></table></figure>

<p>let与const在相同作用域声明重复的变量会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure>
<p>var和let同时声明同一个变量，也是报同样的错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'b' has already been declared</span></span><br></pre></td></tr></table></figure>
<p>或先var，再let</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'c' has already been declared</span></span><br></pre></td></tr></table></figure>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>这里就涉及到一个最经典的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 5 5 5 5 5 </span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个问题的解决可以使用闭包等，ES6的let为这个问题提供了新的解决方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用let声明的变量仅在块级作用域内有效。 i在循环体内的局部作用域，不受外界影响。</p>
<p>在ES6之前，都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以花括号{}限定不了var声明变量的访问范围。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">9</span>;     <span class="comment">// es6的let: b变量只在花括号内有效</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="let、const声明的全局变量不会作为window对象的一个属性"><a href="#let、const声明的全局变量不会作为window对象的一个属性" class="headerlink" title="let、const声明的全局变量不会作为window对象的一个属性"></a>let、const声明的全局变量不会作为window对象的一个属性</h2><p>使用var声明的全局变量，会被JS自动添加在全局对象window上，但let和const不会</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>



<h2 id="const声明常量"><a href="#const声明常量" class="headerlink" title="const声明常量"></a>const声明常量</h2><p>由于const用来声明常量，一旦声明，就必须立即初始化，而且声明之后值不能改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<p>常量的值不变，实际上是指常量指向的那个内存地址中所保存的数据不可更改。</p>
<p>对于基本数据类型（数值，字符串、布尔值），他们本身具体的值就保存在常量所指向对应的栈内存地址中，所以修改值就等于修改栈内存地址，这显然不允许会报错。</p>
<p>但是，如果一个常量的值是一个引用类型值，那么常量所指向的内存地址（堆内存）中实际保存的是指向该引用类型值的一个指针（也就是引用类型值在内存中的地址）。所以const只能保证该引用类型地址不变，但该地址中的具体数据是可以变化的。</p>
<p>如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;a: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当obj指向了另一个对象，即obj中保存的地址发生了变化，即会报错</span></span><br><span class="line">obj = &#123;&#125;;  <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<h2 id="如何正确使用"><a href="#如何正确使用" class="headerlink" title="如何正确使用"></a>如何正确使用</h2><p>在开发的时候，声明变量我们应该少使用var，避免产生不必要的全局变量。当需要改变变量的值时声明用let，对于需要写保护的变量或定义常量使用const。</p>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>swiper父级元素处于隐藏状态滚动效果失效问题</title>
    <url>/2019/12/25/swiper%E7%88%B6%E7%BA%A7%E5%85%83%E7%B4%A0%E5%A4%84%E4%BA%8E%E9%9A%90%E8%97%8F%E7%8A%B6%E6%80%81%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在使用 vue-awesome-swiper 的时候，实现这样一个功能, 点击页面的 banner 图（Banner.vue），进入一个图片画廊（Gallary.vue），可以查看更多相关的照片，但发现轮播图滚动效果失效,本文将解决这个问题。</p>
<a id="more"></a>

<p><img src="https://user-gold-cdn.xitu.io/2019/12/25/16f3aa7f03be6109?w=432&h=764&f=gif&s=1825248" alt=""></p>
<p>原因是：一开始 Gallay.vue 的所有用 swiper 控制的图片处于隐藏状态，直到点击才进入图片画廊显示图片。swiper 其父级元素处于隐藏状态(display:none), 会导致 swiper 初始化失败, 页面中的滚动效果就会有问题。</p>
<p>Gallary.vue 的结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span> @<span class="attr">click</span>=<span class="string">"handleGallaryClick"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">:options</span>=<span class="string">"swiperOption"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">swiper-slide</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of imgs"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"swiper-img"</span> <span class="attr">:src</span>=<span class="string">"item"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span> <span class="attr">slot</span>=<span class="string">"pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一开始 Gallary 组件都是通过父组件 Banner 的 v-show 值设置处于隐藏状态</p>
<p>解决办法：<br>通过 swiper 的配置项：</p>
<blockquote>
<p>observer<br>启动动态检查器(OB/观众/观看者)，当改变 swiper 的样式（例如隐藏/显示）或者修改 swiper 的子元素时</p>
</blockquote>
<blockquote>
<p>observeParents<br>将 observe 应用于 Swiper 的父元素。当 Swiper 的父元素变化时，例如 window.resize，Swiper 更新。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        swiperOption: &#123;</span><br><span class="line">            pagination : &#123;</span><br><span class="line">                el: &#39;.swiper-pagination&#39;,</span><br><span class="line">                type: &#39;fraction&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            observeParents: true, &#x2F;&#x2F;修改swiper的父元素时，自动初始化swiper</span><br><span class="line">            observer: true   &#x2F;&#x2F;修改swiper自己或子元素时，自动初始化swiper</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/12/25/16f3ab29259088a7?w=431&h=759&f=gif&s=974520" alt=""></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>swiper</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义checkbox样式</title>
    <url>/2019/12/14/%E8%87%AA%E5%AE%9A%E4%B9%89checkbox%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>由于原生的checkbox样式比较难看，所以我们经常需要改写它的样式，美化复选框，所以今天总结下自定义checkbox样式的方法</p>
<a id="more"></a>
<p>html文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox-inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">class</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"hobby"</span>&gt;</span>羽毛球<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"checkmark"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox-inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">class</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"hobby"</span>&gt;</span>跑步<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"checkmark"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.checkbox-inline</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkbox</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkmark</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hobby</span>&#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkbox-inline</span> <span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> ~ <span class="selector-class">.checkmark</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#492c94</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkbox-inline</span> <span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> ~ <span class="selector-class">.checkmark</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkbox-inline</span> <span class="selector-class">.checkmark</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border</span>: solid white;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图（未选中与选中对比）：</p>
<p><img src="/images/custom-checkbox.png" alt="image.png"></p>
<p>采取的做法是</p>
<ol>
<li>先将原生的checkbox样式隐藏，设置宽高为0，使其隐藏不占位。</li>
<li>在label标签里面添加额外的span标签，用来做自定义样式</li>
<li>添加伪元素，利用css3的transform属性做矩形旋转，做出打勾的样式，并将其隐藏。</li>
<li>当checkbox被选中时，利用css3的选择器:checked，匹配每个已被选中的 checkbox 元素；再使用兄弟选择符~，匹配到同层级checkmark类，就可以显示和触发自定义checkbox选中状态的样式了</li>
</ol>
<p>这里还涉及到一个知识点，伪元素属于主元素的一部分，因此点击伪元素触发的是主元素的click事件。</p>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-awesome-swiper修改轮播图pagination的颜色</title>
    <url>/2019/12/12/vue-awesome-swiper%E4%BF%AE%E6%94%B9%E8%BD%AE%E6%92%AD%E5%9B%BEpagination%E7%9A%84%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<p>在使用 vue-awsome-swiper 轮播图的时候，pagination 处于当前选中状态默认是蓝色，但通过修改这个类并无法改变其背景颜色…</p>
<a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">:options</span>=<span class="string">"swiperOption"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of swiperList"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"swiper-img"</span> <span class="attr">:src</span>=<span class="string">"item.imgUrl"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span> <span class="attr">slot</span>=<span class="string">"pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/12/22/16f2bbbf5fbc739b?w=433&h=140&f=png&s=141401" alt=""></p>
<p>原因是为 style 设置了 scoped 以后，swiper 分页样式就失效了。分页是在 mounted 里创建的，此时创建的 DOM，vue 不会帮 swiper 的 pagination 加上 scoped 自定义属性。</p>
<p>解决办法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &gt;&gt;&gt; <span class="selector-class">.swiper-pagination-bullet-active</span></span><br><span class="line">    <span class="selector-tag">background</span>: <span class="selector-id">#ff0</span></span><br></pre></td></tr></table></figure>

<pre><code>.wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active
表示的是在wrapper下所有出现.swiper-pagination-bullet-active</code></pre><p>效果如下：<br><img src="https://user-gold-cdn.xitu.io/2019/12/22/16f2bc67d4dbfa0f?w=426&h=136&f=png&s=151132" alt=""></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>swiper</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue实现星级评价效果</title>
    <url>/2019/12/09/Vue%E5%AE%9E%E7%8E%B0%E6%98%9F%E7%BA%A7%E8%AF%84%E4%BB%B7%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>在做店家评价的时候，常常会有星级评价的效果，今天来试试看怎么实现它…</p>
<a id="more"></a>
<p>我们把星级评价单独做成一个Star组件，抽离出来，其中父组件中引入(传入的是评分的值)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"score"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Star</span> <span class="attr">:score</span>=<span class="string">"poiInfo.wm_poi_score"</span>&gt;</span><span class="tag">&lt;/<span class="name">Star</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>初始Star.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;star&quot;&gt;</span><br><span class="line">          &lt;span class&#x3D;&quot;star-item&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123; score &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;Star&#39;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        score: Number</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>首先我们把要做星级图片用类名为star-item的span标签循环出来，星级图片有三张，全星，半星，空星<br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/29/16f51be56d1a5ea8?w=20&h=19&f=png&s=1215" alt=""><br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/29/16f51bdf50383e0f?w=20&h=19&f=png&s=1349" alt=""><br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/29/16f51be27b49b42d?w=20&h=19&f=png&s=1220" alt=""></p>
<p>下面只罗列关键的css部分, 通过增加类区分图片</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.star-item</span><span class="selector-class">.on</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(./img/star24_on@<span class="number">2</span>x.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-item</span><span class="selector-class">.half</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(./img/star24_half@<span class="number">2</span>x.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-item</span><span class="selector-class">.off</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(./img/star24_off@<span class="number">2</span>x.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来修改Star.vue的代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"star"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"star-item"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"(itemClass, index) in itemClasses"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:class</span>=<span class="string">"itemClass"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>itemClasses值是通过计算属性获取的，思路：</p>
<ol>
<li>通过computed返回一个长度为5的数组（显示5颗星）</li>
<li>数组的值是上述css取的不同星对应的类名，再通过绑定每一个循环添加的class，从而遍历星级。</li>
</ol>
<p>比如举例评分：</p>
<ul>
<li>4.7分对应的数组为[‘on’, ‘on’, ‘on’, ‘on’, ‘half’]</li>
<li>3.4分对应的数组为[‘on’, ‘on’, ‘on’, ‘half’, ‘half’]</li>
</ul>
<p>JS部分的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 星星长度 </span></span><br><span class="line"><span class="keyword">const</span> LENGTH = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 星星的状态</span></span><br><span class="line"><span class="keyword">const</span> CLS_ON = <span class="string">'on'</span></span><br><span class="line"><span class="keyword">const</span> CLS_HALF = <span class="string">'half'</span></span><br><span class="line"><span class="keyword">const</span> CLS_OFF = <span class="string">'off'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'Star'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        score: <span class="built_in">Number</span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        itemClasses () &#123;</span><br><span class="line">            <span class="keyword">let</span> result = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> score = <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.score * <span class="number">2</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 半星 (通过跟1取余判断是否为小数)</span></span><br><span class="line">            <span class="keyword">let</span> hasDecimal = score % <span class="number">1</span> !== <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 全星 （向下取整，获取全星部分）</span></span><br><span class="line">            <span class="keyword">let</span> integer = <span class="built_in">Math</span>.floor(score)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历全星</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; integer; i++)&#123;</span><br><span class="line">                result.push(CLS_ON)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理半星</span></span><br><span class="line">            <span class="keyword">if</span>(hasDecimal)&#123;</span><br><span class="line">                result.push(CLS_HALF)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 补齐</span></span><br><span class="line">            <span class="keyword">while</span>(result.length &lt; LENGTH)&#123; <span class="comment">// 到这里还不够五颗星，则凑空星</span></span><br><span class="line">                result.push(CLS_OFF)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>itemClasses最终是返回了一个长度为5的数组，需要注意的是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let score &#x3D; Math.floor(this.score * 2) &#x2F; 2</span><br></pre></td></tr></table></figure>
<p>半星的划分：只有当小数第一位大于或等于5才可以算为半星，否则是空星。该计算是为了小数部分&gt;=0.5的计算结果带有小数，从而再后面跟1取余判断是否为半星。一开始有点蒙，多试几个数想想就懂了。</p>
<blockquote>
<p>比如4.3分没有半星，4.5有半星出现</p>
</blockquote>
<p>结果：<br>比如传入的值为4.7，则显示</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/29/16f51d7db002aa38?w=161&h=28&f=png&s=5690" alt=""></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>页面内容是否超出可视高度，footer始终保持底部显示</title>
    <url>/2019/12/07/CSS%E7%B3%BB%E5%88%97%E4%B9%8B%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E8%B6%85%E5%87%BA%E5%8F%AF%E8%A7%86%E9%AB%98%E5%BA%A6%EF%BC%8Cfooter%E5%A7%8B%E7%BB%88%E4%BF%9D%E6%8C%81%E5%BA%95%E9%83%A8%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>记录一个项目中经常会用到的技巧，footer区（比如版权信息）要始终居于页面底部。如果用fixed定位显然不可取，因为要保证页面高度大于屏幕高度时，footer区要跟随着页面滚动保持在底部</p>
<a id="more"></a>
<p>如下图：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/7/16ee0e36c5c55fea?w=1737&h=899&f=png&s=23364" alt=""></p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/7/16ee0e3a25e302bd?w=1577&h=903&f=png&s=27932" alt=""></p>
<ul>
<li>tip：以下两个方法仅适用于footer区高度固定的情况</li>
</ul>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>页面结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main-container&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;box&quot;&gt;这是主要内容&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;footer&gt;这是底部&lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>关键的css<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-container</span>&#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">footer</span>&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如上代码，主要内容区和footer区必须为并列关系。设置main-container为border-box，即元素的内边距和边框都在已设定的高度内绘制，我们设置了min-height为100%，即最小高度是铺满整屏幕。padding-bottom在border-box盒子中，留出高度40px的空白块。footer的margin-top为-40px（如果footer有设置高度，padding-bottom的值应以footer高度为准），即向上拉到空白块内，main-container最小高度为整个屏幕，故页面内容不足也可以显示在底部。</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>页面结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main-container&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;box&quot;&gt;这是主要内容&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;footer&gt;这是底部&lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>关键的css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html,body&#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.wrapper&#123;</span><br><span class="line">    min-height: 100%;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.main-container&#123;</span><br><span class="line">    padding-bottom: 40px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">footer&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    height: 40px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码时用绝对定位，相对于wrapper居于底部，跟第一个方法有异曲同工之妙。</p>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之执行上下文和变量对象</title>
    <url>/2019/11/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>继续接着上篇文章，今天再细说执行上下文中的变量对象…</p>
<a id="more"></a>

<p>上篇我们说到函数上下文的结构可表示为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ExecutionContextObj = &#123;</span><br><span class="line">  VO: <span class="built_in">window</span>, <span class="comment">// 变量对象</span></span><br><span class="line">  ScopeChain: &#123;&#125;, <span class="comment">// 作用域链</span></span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即每个函数上下文，都要有这三个重要属性：</p>
<ul>
<li>变量对象(Variable object, VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><h3 id="什么是变量对象"><a href="#什么是变量对象" class="headerlink" title="什么是变量对象"></a>什么是变量对象</h3><p>变量对象是与执行上下文的相关的数据作用域，存储了在上下文中定义的变量和函数声明。因为不同执行上下文的变量对象略有不同，所以变量对象一般分为全局上下文下的变量对象和函数上下文下的变量对象。</p>
<h3 id="变量对象-VO-的创建过程"><a href="#变量对象-VO-的创建过程" class="headerlink" title="变量对象(VO)的创建过程"></a>变量对象(VO)的创建过程</h3><p>变量对象的创建，属于执行上下文中的创建阶段，依次经过以下三个过程：</p>
<p>创建执行上下文有两个阶段：一个是创建阶段，一个是执行阶段。变量对象的创建，属于执行上下文中的创建阶段，会依次经过三个过程：</p>
<h4 id="1-为函数的形参赋值（函数上下文）"><a href="#1-为函数的形参赋值（函数上下文）" class="headerlink" title="1.为函数的形参赋值（函数上下文）"></a>1.为函数的形参赋值（函数上下文）</h4><p>在进入函数执行上下文时，会首先检查实参个数，接着对实参对象和形参进行赋值。如果没有实参，属性值设为 undefined；当传入的实参数量小于形参数量，则会将没有被赋值的形参赋值为 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1 2 undefined</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>此时变量对象的结构为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">VO = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="literal">undefined</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-函数声明"><a href="#2-函数声明" class="headerlink" title="2.函数声明"></a>2.函数声明</h4><p>遇到同名的函数时，后面函数会覆盖前面的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'先声明的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'后声明的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">//ƒ fn() &#123; console.log('后声明的'); &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-变量声明"><a href="#3-变量声明" class="headerlink" title="3.变量声明"></a>3.变量声明</h4><p>检查当前环境中通过变量声明(var)并赋值为 undefined（变量提升产生的原因）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">// ƒ fn() &#123; console.log('后声明的');&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'先声明的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'后声明的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>由上面我们看出，当变量名称与函数名称同名时，会忽略此变量声明，即同名时，函数声明优先</p>
<p>js 虽然单线程的语言，执行顺序为顺序执行，但 JS 引擎并不是一行一行地分析和执行程序，而是一段一段地分析执行。</p>
<p>让我们从 JS 引擎的角度理一理上述三个过程：<strong>函数提升和变量提升，是全局执行上下文做的准备工作；当执行函数时，又会创建一个执行上下文，做的是这个函数内部的准备工作；这就是 JS 引擎分析代码的”预编译阶段”，做完该工作才进入执行阶段。</strong></p>
<h3 id="全局上下文的变量对象"><a href="#全局上下文的变量对象" class="headerlink" title="全局上下文的变量对象"></a>全局上下文的变量对象</h3><p>在客户端 JavaScript 中，全局对象就是 Window 对象;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> <span class="comment">// 在全局上下文使用var定义变量a，作为全局变量的宿主</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>对于全局上下文中来说，变量对象就是全局对象，</p>
<h3 id="变量对象变为活动对象"><a href="#变量对象变为活动对象" class="headerlink" title="变量对象变为活动对象"></a>变量对象变为活动对象</h3><p>执行上下文的第二个阶段为执行阶段，此时会进行变量赋值，执行其他代码等工作，此时，变量对象变为活动对象(Active object, AO)。</p>
<blockquote>
<p>活动对象和变量对象其实是同个东西，只是规范概念上的差异。只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫活动对象。而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p>
</blockquote>
<p>所以明确，活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">// ƒ fn() &#123; console.log('后声明的');&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'先声明的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'后声明的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>上述代码，真正开始执行是从第一行 console.log(fn)。在此之前，变量对象 VO 是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建过程</span></span><br><span class="line">EC= &#123;</span><br><span class="line">  VO：&#123;&#125;, <span class="comment">// 创建变量对象</span></span><br><span class="line">  scopeChain: [&#123;VO&#125;], <span class="comment">// 作用域链</span></span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span> <span class="comment">// this绑定</span></span><br><span class="line">&#125;</span><br><span class="line">VO = &#123;</span><br><span class="line">  <span class="comment">// argument: &#123;&#125;, // 当前为全局上下文，不存在arguments</span></span><br><span class="line">  fn: reference to <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="comment">// 函数fn的引用地址</span></span><br><span class="line">  b: undefiend  <span class="comment">// 变量提升</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据变量对象创建的三个过程，</p>
<ol>
<li>首先是 arguments 对象的创建（全局上下文没有则忽略）</li>
<li>其次，是检查函数的声明。此时，函数 fn 声明了两次，则后一次的声明会覆盖上一次的声明。</li>
<li>最后，是检查变量的声明，先声明了变量 b，将它赋值为 undefined；接着遇到 fn 的变量声明，由于 fn 已经被声明为一个函数，故忽略该变量声明。</li>
</ol>
<p>到此，变量对象的创建阶段完成，接下来进行执行阶段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.执行console.log(fn);此时fn为声明的第二个函数，故输出结果：&quot;后声明的&quot;。</span><br><span class="line">2.执行console.log(b)，此时b已被赋值为undefined，故输出结果：&quot;undefined&quot;。</span><br><span class="line">3.执行赋值操作： b &#x3D; 10;</span><br><span class="line">4.执行console.log(b) ，故输出b为10。</span><br><span class="line">5.执行赋值操作： fn &#x3D; 20;</span><br><span class="line">6.执行console.log(fn) ，故输出fn为20。</span><br></pre></td></tr></table></figure>

<p>执行到最后一步时，执行上下文如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行阶段</span></span><br><span class="line">EC = &#123;</span><br><span class="line">  VO = &#123;&#125;;</span><br><span class="line">  scopeChain: &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// VO ---- AO</span></span><br><span class="line">AO = &#123;</span><br><span class="line">  argument: &#123;&#125;;</span><br><span class="line">  fn: <span class="number">20</span>;</span><br><span class="line">  b: <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，就是变量对象在代码执行前及执行后的变化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>全局上下文的变量对象初始化是全局对象</p>
</li>
<li><p>函数上下文的变量对象初始化只包括 arguments 对象</p>
</li>
<li><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p>
</li>
<li><p>在代码执行阶段，会再次修改变量对象的属性值</p>
</li>
</ol>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>执行上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之执行上下文和执行栈</title>
    <url>/2019/11/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
    <content><![CDATA[<p>都说想成为出色的 JavaScript 开发者，就要深入学习 JavaScript 程序内部的执行机制，最近学了一遍 JS 的执行上下文和执行栈，以此作总结。</p>
<a id="more"></a>

<p>首先先来了解几个专业概念</p>
<ul>
<li><p>EC：函数执行环境（或执行上下文），Execution Context</p>
</li>
<li><p>ECS：执行环境栈，Execution Context Stack</p>
</li>
<li><p>VO：变量对象，Variable Object</p>
</li>
<li><p>AO：活动对象，Active Object</p>
</li>
<li><p>scope chain：作用域链</p>
</li>
</ul>
<h2 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h2><p>每次当控制器转到 ECMAScript 可执行代码的时候，它都是在执行上下文中运行，即是指当前执行环境中的变量、函数声明，参数，作用域链，this 等信息。</p>
<h3 id="组成代码示例"><a href="#组成代码示例" class="headerlink" title="组成代码示例"></a>组成代码示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ExecutionContextObj = &#123;</span><br><span class="line">  VO: <span class="built_in">window</span>, <span class="comment">// 变量对象</span></span><br><span class="line">  ScopeChain: &#123;&#125;, <span class="comment">// 作用域链</span></span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><p>JavaScript 中有三种执行上下文类型。</p>
<ol>
<li><p><strong>全局执行上下文</strong>—— 这是默认上下文，浏览器中的全局对象就是 window 对象，任何不在函数内部的代码都在全局上下文中，this 指向这个全局对象。</p>
</li>
<li><p><strong>函数执行上下文</strong> —— 当<strong>函数被调用时创建</strong>,会为该函数创建一个新的执行上下文，可以有任意个。</p>
</li>
<li><p><strong>Eval 函数执行上下文</strong> ——<br>执行 eval 函数内部的代码也有属于它的上下文，由于开发中是尽量避免或不用 eval 函数，故此不作讨论。</p>
</li>
</ol>
<h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也叫调用栈，被用来存储代码运行时创建的所有执行上下文。</p>
<blockquote>
<p>栈：一种数据结构，遵循后进先出的原则</p>
</blockquote>
<p>当 JavaScript 引擎第一次遇到脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p>
<p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn1被调用了 -- 创建了fn1的函数执行上下文，压入栈'</span>)</span><br><span class="line">  fn2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn2执行完成，fn2的执行上下文会从栈中弹出'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn2被调用了 -- 创建了fn2的函数执行上下文，压入栈'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn1执行完成，fn2的执行上下文会从栈中弹出'</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fn1被调用了 -- 创建了fn1的函数执行上下文，压入栈</span><br><span class="line">fn2被调用了 -- 创建了fn2的函数执行上下文，压入栈</span><br><span class="line">fn2执行完成，fn2的执行上下文会从栈中弹出</span><br><span class="line">fn1执行完成，fn2的执行上下文会从栈中弹出</span><br></pre></td></tr></table></figure>

<p>上述代码的执行上下文栈：<br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/11/27/16ead7c041a4b415?w=1276&h=316&f=png&s=30716" alt=""></p>
<p>当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入栈中，当函数 fn1()被调用时，JavaScript 为该函数创建了一个函数执行上下文，并把它压入当前执行栈的顶部。</p>
<p>当 fn1()函数内部调用 fn2()函数时，JavaScript 引擎同样创建了 fn2()的函数执行上下文并压入栈的顶部。然后执行了 fn2()函数后，fn2()函数会从当前栈（后进先出结构）弹出，并且按程序执行顺序继续执行 fn1()函数，即此刻处于 fn1 的函数执行上下文。</p>
<p>当 fn1()函数执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。</p>
<h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>已经知道 JavaScript 怎样管理执行上下文了，现在来了解 JavaScript 引擎是怎么创建执行上下文的。</p>
<p>创建执行上下文有两个阶段：</p>
<ol>
<li>创建阶段</li>
<li>执行阶段。</li>
</ol>
<p>在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：</p>
<ol>
<li>this 绑定</li>
<li>创建(LexicalEnvironment)词法环境组件</li>
<li>创建(VariableEnvironment)变量环境组件</li>
</ol>
<p>执行上下文在概念可表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecutionContext &#x3D; &#123;</span><br><span class="line">  ThisBinding &#x3D; &lt;this value&gt;,</span><br><span class="line">  LexicalEnvironment &#x3D; &#123; ... &#125;,</span><br><span class="line">  VariableEnvironment &#x3D; &#123; ... &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-创建阶段"><a href="#1-创建阶段" class="headerlink" title="1. 创建阶段"></a>1. 创建阶段</h3><h4 id="this-绑定"><a href="#this-绑定" class="headerlink" title="this 绑定"></a>this 绑定</h4><p>在全局执行上下文中，this 的值指向全局对象。(在浏览器中，this 引用 window 对象)</p>
<p>在函数执行上下文中，this 的指向取决于函数是如何被调用的,在本篇暂不对 this 指向做详细讨论。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> win = obj.fn</span><br><span class="line"></span><br><span class="line">obj.fn() <span class="comment">//this指向obj</span></span><br><span class="line">win() <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>

<h4 id="词法环境（Lexical-Environment）"><a href="#词法环境（Lexical-Environment）" class="headerlink" title="词法环境（Lexical Environment）"></a>词法环境（Lexical Environment）</h4><p>ES6 官方文档把词法环境定义为：</p>
<blockquote>
<p>词法环境是用来定义 基于词法嵌套结构的 ECMAScript 代码内的标识符与变量值和函数值之间的关联关系 的一种规范类型。一个词法环境由环境记录（Environment Record）和一个可能为 null 的对外部词法环境的引用（outer）组成。一般来说，词法环境都与特定的 ECMAScript 代码语法结构相关联，例如函数、代码块、TryCatch 中的 Catch 从句，并且每次执行这类代码时都会创建新的词法环境。</p>
</blockquote>
<p>可以理解为词法环境是一种包含标识符(变量/函数的名称)和变量(函数/原始值/数组对象等)映射的数据结构</p>
<h5 id="词法环境有两个组成部分"><a href="#词法环境有两个组成部分" class="headerlink" title="词法环境有两个组成部分"></a>词法环境有两个组成部分</h5><ol>
<li><p>声明式环境记录器：存储变量和函数声明的实际位置</p>
</li>
<li><p>对象环境记录器：可以访问其外部词法环境(作用域)</p>
</li>
</ol>
<h5 id="词法环境有两种类型"><a href="#词法环境有两种类型" class="headerlink" title="词法环境有两种类型"></a>词法环境有两种类型</h5><ol>
<li><p>全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</p>
</li>
<li><p>函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p>
</li>
</ol>
<h4 id="变量环境-VariableEnvironment"><a href="#变量环境-VariableEnvironment" class="headerlink" title="变量环境 (VariableEnvironment)"></a>变量环境 (VariableEnvironment)</h4><p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p>
<p>在 ES6 中，词法环境组件和变量环境组件之间的一个区别是前者用于存储函数声明和变量 let 和 const 绑定，而后者仅用于存储变量 var 绑定。</p>
<h3 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2.执行阶段"></a>2.执行阶段</h3><p>在此阶段，完成对所有这些变量的分配，最后执行代码。（在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined）</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>执行上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之实现继承的7种方式</title>
    <url>/2019/11/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%847%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>有必要搞清楚 JS 实现继承的方式…</p>
<a id="more"></a>

<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>核心：<strong>将父类的实例作为子类的原型</strong></p>
<p>首先，要知道构造函数、原型和实例之间的关系：构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'父类的名字'</span></span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'子类的名字'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果此时有Son的原型对象有方法或属性，下面Son.prototype = new Father()，由于原型重定向，原型上的方法和属性会丢失</span></span><br><span class="line">Son.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'子类的年龄'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father() <span class="comment">// 核心:创建父类的实例，并将该实例赋值给子类的prototype</span></span><br><span class="line"></span><br><span class="line">Son.prototype.getSonName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'子类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son()</span><br><span class="line">son.getFatherName() <span class="comment">// 父类的方法</span></span><br><span class="line">Son.prototype.__proto__.getFatherName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缺点：如果有多个实例对其父类原型，则会互相影响</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'子类改变父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line">son.getFatherName() <span class="comment">// 子类改变父类的方法</span></span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ol>
<li><p>父类使用 this 声明的属性(私有属性和公有属性)被所有实例共享,在多个实例之间对引用类型数据操作会互相影响。</p>
</li>
<li><p>创建子类实例时，无法向父类构造函数传参。</p>
</li>
</ol>
<h2 id="借用构造函数继承-call"><a href="#借用构造函数继承-call" class="headerlink" title="借用构造函数继承(call)"></a>借用构造函数继承(call)</h2><p>核心：<strong>使用父类的构造函数来增强子类实例</strong>，即复制父类的实例属性给子类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>, name, age) <span class="comment">// 继承自Father</span></span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>, <span class="number">22</span>, <span class="string">'前端开发'</span>)</span><br><span class="line"><span class="comment">//son.getFatherName(); // Uncaught TypeError: son.getFatherName is not a function</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>可以向父类传递参数,而且解决了原型链继承中：父类属性使用 this 声明的属性会在所有实例共享的问题。</li>
</ol>
<p>缺点：</p>
<ol>
<li>只能继承父类通过 this 声明的属性/方法，不能继承父类 prototype 上的属性/方法。</li>
<li>每次子类实例化都要执行父类函数，重新声明父类 this 里所定义的方法，因此父类方法无法复用。</li>
</ol>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>核心：<strong>组合上述两种方法，用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sex = <span class="string">'man'</span></span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>, name, age) <span class="comment">// 第二次调用:创建子类型实例的时候</span></span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father() <span class="comment">// 第一次调用:设置子类型实例的原型的时候</span></span><br><span class="line">Son.prototype.constructor = Son <span class="comment">// prototype构造器指回自己</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>, <span class="number">22</span>, <span class="string">'前端开发'</span>)</span><br><span class="line">son.getFatherName()</span><br><span class="line"><span class="built_in">console</span>.log(son)</span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/11/20/16e89812367319c7?w=517&h=227&f=png&s=19707" alt=""></p>
<p>优点：</p>
<ol>
<li>可以继承父类原型上的属性，可以传参，可复用。</li>
<li>每个新子类对象实例引入的构造函数属性是私有的。</li>
</ol>
<p>缺点：</p>
<ol>
<li>两次调用父类函数(new fatherFn()和 fatherFn.call(this))，造成一定的性能损耗。</li>
<li>在使用子类创建实例对象时，其原型中会存在两份相同属性/方法的问题。</li>
</ol>
<p>拓展：</p>
<h3 id="constructor-的作用"><a href="#constructor-的作用" class="headerlink" title="constructor 的作用"></a>constructor 的作用</h3><p><strong>返回创建实例对象的 Object 构造函数的引用</strong>。</p>
<blockquote>
<p>当我们只有实例对象没有构造函数的引用时：<br>某些场景下，我们对实例对象经过多轮导入导出，我们不知道实例是从哪个函数中构造出来或者追踪实例的构造函数，较为艰难。(它主要防止一种情况下出错，就是你显式地去使用构造函数。比如，我并不知道 instance 是由哪个函数实例化出来的，但是我想 clone 一个，这时就可以这样——&gt;instance.constructor)<br>这个时候就可以通过实例对象的 constructor 属性来得到构造函数的引用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> sonFn() <span class="comment">// 实例化子类</span></span><br><span class="line"><span class="keyword">export</span> instance;</span><br><span class="line"><span class="comment">// 多轮导入+导出，导致sonFn追踪非常麻烦，或者不想在文件中再引入sonFn</span></span><br><span class="line"><span class="keyword">let</span>  fn = instance.constructor</span><br></pre></td></tr></table></figure>

<p>因此每次<strong>重写</strong>函数的 prototype 都应该修正一下 constructor 的指向，以保持读取 constructor 指向的一致性</p>
<h2 id="原型式继承（Object-create-）"><a href="#原型式继承（Object-create-）" class="headerlink" title="原型式继承（Object.create()）"></a>原型式继承（Object.create()）</h2><p>核心：利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Object.create() 的实现原理 */</span></span><br><span class="line"><span class="comment">// cloneObject()对传入其中的对象执行了一次浅拷贝，将构造函数F的原型直接指向传入的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = obj <span class="comment">// 将传进来obj对象作为空函数的prototype</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F() <span class="comment">// 此对象的原型为被继承的对象, 通过原型链查找可以拿到被继承对象的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> father = &#123;</span><br><span class="line">  name: <span class="string">'jacky'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  courses: [<span class="string">'前端'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var son1 = Object.create(father); // 效果一样</span></span><br><span class="line"><span class="keyword">var</span> son1 = cloneObject(father)</span><br><span class="line">son1.courses.push(<span class="string">'后端'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son2 = cloneObject(father)</span><br><span class="line">son2.courses.push(<span class="string">'全栈'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(father.courses) <span class="comment">//  ["前端", "后端", "全栈"]</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>从已有对象衍生新对象，不需要创建自定义类型</p>
<p>缺点：</p>
<p>与原型链继承一样。多个实例共享被继承对象的属性，存在篡改的可能；也无法传参。</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>核心：<strong>在原型式继承的基础上，创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象(增加了一些新的方法和属性)，最后返回对象。</strong></p>
<p>使用场景：专门为对象来做某种固定方式的增强。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(obj)</span><br><span class="line">  clone.skill = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = &#123;</span><br><span class="line">  eat: <span class="string">'food'</span>,</span><br><span class="line">  drink: <span class="string">'water'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = createAnother(animal)</span><br><span class="line">dog.skill()</span><br></pre></td></tr></table></figure>

<p>优点：没有创建自定义类型，因为只是套了个壳子增加特定属性/方法返回对象，以达到增强对象的目的</p>
<p>缺点：</p>
<p>同原型式继承：原型链继承多个实例的引用类型属性指向相同，存在篡改的可能，也无法传递参数</p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>核心：结合借用构造函数传递参数和寄生模式实现继承</p>
<ol>
<li>通过借用构造函数(call)来继承父类 this 声明的属性/方法</li>
<li>通过原型链来继承方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>, name, age) <span class="comment">// 借用构造继承: 继承父类通过this声明属性和方法至子类实例的属性上</span></span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄生式继承：封装了son.prototype对象原型式继承father.prototype的过程，并且增强了传入的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">son, father</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(father.prototype) <span class="comment">// 原型式继承：浅拷贝father.prototype对象</span></span><br><span class="line">  clone.constructor = son <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  son.prototype = clone <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Son, Father) <span class="comment">// 将父类原型指向子类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">Son.prototype.getSonName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'子类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>, <span class="number">22</span>, <span class="string">'前端开发'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(son)</span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/11/23/16e97782ff645ca0?w=361&h=182&f=png&s=24333" alt=""></p>
<ul>
<li>寄生组合式继承相对于组合继承有如下优点：</li>
</ul>
<ol>
<li>只调用一次父类 Father 构造函数。不必为了指定子类的原型而调用构造函数，而是间接的让 Son.prototype 访问到 Father.prototype。</li>
<li>避免在子类 prototype 上创建不必要多余的属性。<br>使用原型式继承父类的 prototype，保持了原型链上下文不变, instanceof 和 isPrototypeOf()也能正常使用。 3.寄生组合式继承是最成熟的继承方法, 也是现在最常用的继承方法，众多 JS 库采用的继承方案也是它。</li>
</ol>
<p>缺点：</p>
<p>硬要说的话，就是给子类原型添加属性和方法的时候，一定要放在 inheritPrototype()方法之后</p>
<h2 id="ES6-extends-继承（最优方式）"><a href="#ES6-extends-继承（最优方式）" class="headerlink" title="ES6 extends 继承（最优方式）"></a>ES6 extends 继承（最优方式）</h2><p>核心： 类之间通过 extends 关键字实现继承，清晰方便。 class 仅仅是一个语法糖，它的核心思想仍然是寄生组合式继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  skill() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类的技能'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, job) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age) <span class="comment">// 调用父类的constructor,只有调用super之后，才可以使用this关键字</span></span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.job)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>, <span class="number">22</span>, <span class="string">'前端开发'</span>)</span><br><span class="line">son.skill() <span class="comment">// 父类的技能</span></span><br><span class="line">son.getInfo() <span class="comment">// jacky 22 前端开发</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果子类没有定义 constructor 方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有 constructor 方法。</li>
</ul>
<blockquote>
<p>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。</p>
</blockquote>
<h2 id="ES5-继承与-ES6-继承的区别"><a href="#ES5-继承与-ES6-继承的区别" class="headerlink" title="ES5 继承与 ES6 继承的区别"></a>ES5 继承与 ES6 继承的区别</h2><ol>
<li>ES5 的继承实质上是先创建子类的实例对象，再将父类的方法添加到 this 上( Father.call(this) )。</li>
<li>ES6 的继承是先创建父类的实例对象 this，再用子类的构造函数修改 this。</li>
<li>因为子类没有自己的 this 对象，所以必须先调用父类的 super()方法。</li>
</ol>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>实现swiper自定义分页器</title>
    <url>/2019/11/16/%E5%AE%9E%E7%8E%B0swiper%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E9%A1%B5%E5%99%A8/</url>
    <content><![CDATA[<p><strong>问题:不想使用swiper(用的是4.5.1版本)的自带的圆钮式的分页器，需要自定义样式同时分页器需要摆在图片外面</strong></p>
<a id="more"></a>

<p>解决办法:利用swiper提供的renderCustom()方法</p>
<p>html文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-wrapper"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/IMG_20191109_141728.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/IMG_20191109_154050.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--分页器要放图片外显示的话，需要移出来--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;div class="swiper-pagination"&gt;&lt;/div&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySwiper = <span class="keyword">new</span> Swiper (<span class="string">'.swiper-container'</span>, &#123;</span><br><span class="line">        autoplay: &#123;</span><br><span class="line">            delay: <span class="number">3000</span>,</span><br><span class="line">            disableOnInteraction: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        pagination: &#123;</span><br><span class="line">            el: <span class="string">'.swiper-pagination'</span>,</span><br><span class="line">            type: <span class="string">'custom'</span>,</span><br><span class="line">            renderCustom: <span class="function"><span class="keyword">function</span> (<span class="params">swiper, current, total</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> customPaginationHtml = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">                    <span class="comment">// 判断哪个分页器此刻应该被激活</span></span><br><span class="line">                    <span class="keyword">if</span>(i == (current - <span class="number">1</span>)) &#123;</span><br><span class="line">                        customPaginationHtml += <span class="string">'&lt;span class="swiper-pagination-customs swiper-pagination-customs-active"&gt;&lt;/span&gt;'</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        customPaginationHtml += <span class="string">'&lt;span class="swiper-pagination-customs"&gt;&lt;/span&gt;'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> customPaginationHtml;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>css文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.swiper-box</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">74vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">34vw</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">4vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-container</span> <span class="selector-class">.swiper-slide</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-pagination</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">74vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-pagination-bullet</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">4vw</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 包裹自定义分页器的div的位置的样式 */</span></span><br><span class="line"><span class="selector-class">.swiper-pagination-custom</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: -<span class="number">5vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-pagination-customs</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../img/point-grey.png); <span class="comment">/* 未轮播到的图片分页样式 */</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: contain;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.4vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.4vw</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">2vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*自定义分页器激活时的样式表现*/</span></span><br><span class="line"><span class="selector-class">.swiper-pagination-customs-active</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../img/point-green.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：<img src="/images/swiper-pagination.png" alt=" "></p>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端原生JS之开启和禁止页面滚动</title>
    <url>/2019/11/10/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%8E%9F%E7%94%9FJS%E4%B9%8B%E5%BC%80%E5%90%AF%E5%92%8C%E7%A6%81%E6%AD%A2%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/</url>
    <content><![CDATA[<p>在做移动端页面通常有操作需要禁止页面的滚动，来看看原生js怎么操作</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 禁止页面滚动</span></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'touchmove'</span>, handler, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>passive：false。 设置该属性的目的主要是为了在阻止事件默认行为导致的卡顿。等待监听器的执行是耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。加上{ passive: false }能防止页面卡顿。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启页面滚动</span></span><br><span class="line"><span class="built_in">document</span>.body.removeEventListener(<span class="string">'touchmove'</span>, handler, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure></li>
<li>注意点，不能这样写<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启页面滚动</span></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">&#125;, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure></li>
<li>添加和移除的函数对象应该是同一个,否则移除不起作用,即listener不能直接用匿名函数</li>
</ul>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>sessionStorage、localStorage用法总结</title>
    <url>/2019/11/03/sessionStorage%E3%80%81localStorage%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>在工作中使用 sessionStorage 存储数据时，发现 sessionStorage 无法直接存储数组和对象，如存入对象则显示为”[object Object]”，对此作下记录，重新温习 sessionStorage 和 localStorage</p>
<a id="more"></a>

<p>html5 中的 web Storage 包括了两种存储方式：sessionStorage 和 localStorage</p>
<h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><p>存储大小为 5MB，都保存在客户端，不与服务器进行交互通信，有相同的 Web API</p>
<h2 id="sessionStorage、localStorage-区别"><a href="#sessionStorage、localStorage-区别" class="headerlink" title="sessionStorage、localStorage 区别"></a>sessionStorage、localStorage 区别</h2><p>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</p>
<p>sessionStorage 数据在当前浏览器窗口关闭后自动删除。</p>
<p>因此<strong>sessionStorage 和 localStorage 的主要区别在于他们存储数据的生命周期</strong>，sessionStorage 存储的数据的生命周期是一个会话，而 localStorage 存储的数据的生命周期是永久，除非主动删除数据，否则永远不会过期</p>
<h2 id="Web-Storage-API"><a href="#Web-Storage-API" class="headerlink" title="Web Storage API"></a>Web Storage API</h2><p>localStorage 和 sessionStorage 有着统一的 API 接口，下面以 sessionStorage 为例介绍一下 API 接口使用方法</p>
<h3 id="添加键值对"><a href="#添加键值对" class="headerlink" title="添加键值对"></a>添加键值对</h3><p><strong>setItem(key,value)：为指定 key 值设置一个对应的 value 值</strong></p>
<p>除了使用 setItem 方法，还可以使用 sessionStorage.key = value 或者 sessionStorage[‘key’] = value 这两种形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把name值存储到name的键上</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'name'</span>, <span class="string">'jacky'</span>) <span class="comment">// 法1</span></span><br><span class="line"><span class="comment">// sessionStorage.name = 'jacky'; // 法2</span></span><br><span class="line"><span class="comment">// sessionStorage['name'] = 'jacky'; // 法3</span></span><br></pre></td></tr></table></figure>

<p><strong>添加数组和对象</strong></p>
<p>需要注意的是 key 和 value 值必须是<strong>字符串形式</strong>的，如果不是字符串，会调用它们相应的 toString()方法来转换成字符串再存储。</p>
<p>所以要存储数组或对象时，应先转换成字符串格式（如 JSON 格式）再进行存储，使用<strong>JSON.stringify(obj)方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'jacky'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">&#125;</span><br><span class="line">sessionStorage[<span class="string">'person'</span>] = <span class="built_in">JSON</span>.stringify(obj)</span><br><span class="line"><span class="comment">//sessionStorage['person'] = obj; 不能这样存储，这样存进去结果是"[object Object]"</span></span><br></pre></td></tr></table></figure>

<p>存进去之后则为字符串格式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;"</span>name<span class="string">":"</span>jacky<span class="string">","</span>age<span class="string">":22&#125;"</span></span><br></pre></td></tr></table></figure>

<p>需要拿出来使用的时候则使用<strong>JSON.parse()方法</strong>将 JSON 字符串转换为对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="built_in">JSON</span>.parse(sessionStorage[<span class="string">'person'</span>])</span><br></pre></td></tr></table></figure>

<p>同理，数组也是这个用这个方法进行存储。</p>
<h3 id="getItem（key）：根据指定的-key-值获取对应的-value-值"><a href="#getItem（key）：根据指定的-key-值获取对应的-value-值" class="headerlink" title="getItem（key）：根据指定的 key 值获取对应的 value 值"></a>getItem（key）：根据指定的 key 值获取对应的 value 值</h3><p>和 setItem 一样，getItem 也有两种等效形式,value = sessionStorage.key 和 value = sessionStorage[‘key’]。获取到的 value 值是字符串类型，如果需要其他类型，需要自己做类型转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取存储到 name 的键上的值</span></span><br><span class="line"><span class="keyword">var</span> name = sessionStorage.getItem(<span class="string">'name'</span>)</span><br><span class="line"><span class="comment">// var name = sessionStorage.name;</span></span><br><span class="line"><span class="comment">// var name = sessionStorage['name'];</span></span><br></pre></td></tr></table></figure>

<h3 id="removeItem（key）：删除指定的-key-值对应的-value-值"><a href="#removeItem（key）：删除指定的-key-值对应的-value-值" class="headerlink" title="removeItem（key）：删除指定的 key 值对应的 value 值"></a>removeItem（key）：删除指定的 key 值对应的 value 值</h3><p>注意 localStorage 没有数据过期的概念，所有数据如果失效了，需要开发者手动删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = sessionStorage.getItem(<span class="string">'name'</span>) <span class="comment">// "jacky"</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">'name'</span>)</span><br><span class="line">name = sessionStorage.getItem(<span class="string">'name'</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h3 id="clear-：删除所有存储的内容"><a href="#clear-：删除所有存储的内容" class="headerlink" title="clear()：删除所有存储的内容"></a>clear()：删除所有存储的内容</h3><p>它和 removeItem 不同的地方是 removeItem 删除的是某一项，而 clear 是删除所有。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清除 localStorage</span></span><br><span class="line">sessionStorage.clear()</span><br><span class="line"><span class="keyword">var</span> len = sessionStorage.length <span class="comment">// 0</span></span><br><span class="line"><span class="comment">//length属性用于获取 sessionStorage 中键值对的数量。</span></span><br></pre></td></tr></table></figure>

<h3 id="key-index-：在指定的数字位置获取该位置的名字"><a href="#key-index-：在指定的数字位置获取该位置的名字" class="headerlink" title="key(index)：在指定的数字位置获取该位置的名字"></a>key(index)：在指定的数字位置获取该位置的名字</h3><p>需要注意的是赋值早的键值对应的索引值大，赋值完的键值对应的索引小,key 方法可用于遍历 sessionStorage 存储的键值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">'name'</span>, <span class="string">'jacky'</span>)</span><br><span class="line"><span class="keyword">var</span> key = sessionStorage.key(<span class="number">0</span>) <span class="comment">// 'name'</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'age'</span>, <span class="number">10</span>)</span><br><span class="line">key = sessionStorage.key(<span class="number">0</span>) <span class="comment">// 'age'</span></span><br><span class="line">key = sessionStorage.key(<span class="number">1</span>) <span class="comment">// 'name'</span></span><br></pre></td></tr></table></figure>

<h2 id="两者应用场景"><a href="#两者应用场景" class="headerlink" title="两者应用场景"></a>两者应用场景</h2><h3 id="sessionStorage-应用场景"><a href="#sessionStorage-应用场景" class="headerlink" title="sessionStorage 应用场景"></a>sessionStorage 应用场景</h3><p>进行页面传值</p>
<h3 id="localStorage-应用场景"><a href="#localStorage-应用场景" class="headerlink" title="localStorage 应用场景"></a>localStorage 应用场景</h3><ol>
<li>适合长期保存在本地的数据</li>
<li>可以用于存储该浏览器对该页面的访问次数</li>
</ol>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>storage</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之获取数组中的最大值方法（this,apply）</title>
    <url>/2019/10/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E6%96%B9%E6%B3%95%EF%BC%88this-apply%EF%BC%89/</url>
    <content><![CDATA[<p>1.排序法 2.假设法 3.基于 Math.max 与 apply 4.ES6 展开运算符</p>
<a id="more"></a>

<h2 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h2><p>思路：给数组先排序(由大到小排序),第一项就是最大值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> max1 = arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b - a</span><br><span class="line">&#125;)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(max1)</span><br></pre></td></tr></table></figure>

<h2 id="假设法"><a href="#假设法" class="headerlink" title="假设法"></a>假设法</h2><p>思路：假设第一个值是最大值,依次遍历数组中后面的每一项,和假设的值进行比较,如果比假设的值要大,把当前项赋值给 MAX…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> max2 = arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> item = arr[i]</span><br><span class="line">  item &gt; max2 ? (max2 = item) : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(max2)</span><br></pre></td></tr></table></figure>

<h2 id="基于-Math-max-与-apply"><a href="#基于-Math-max-与-apply" class="headerlink" title="基于 Math.max 与 apply"></a>基于 Math.max 与 apply</h2><p>思路：基于基于 Math.max 完成和 apply 特性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr))</span><br></pre></td></tr></table></figure>

<p>这个是要重点理解的一个方案，call,apply,bind 常常会被放一起比较<br>首先，call，apply，bind 这三个方法其实都是继承自 Function.prototype 中的，属于实例方法。<br>三个方法的作用，都是<strong>改变 this 的指向</strong>，只是用法稍微有些区别</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>什么是 this</p>
<p><strong>this 既不指向函数自身，也不指函数的词法作用域</strong>。它在函数定义的时候是确定不了的,在函数被调用时才发生的绑定，也就是说<code>this具体指向什么，取决于你是怎么调用的函数</code>。</p>
<p>怎么判断 this</p>
<blockquote>
<p>1.给当前元素的某个事件绑定方法, 当事件触发方法执行的时候，方法中的 THIS 是当前操作的元素对象 2.普通函数执行，函数中的 THIS 取决于执行的主体，谁执行的，THIS 就是谁（执行主体：方法执行，看方法名前面是否有“点”，有的话，点前面是谁 this 就是谁，没有 this 是 window）<br>下面看个例子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  myFunction() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">myFunction() <span class="comment">// true</span></span><br><span class="line">obj.myFunction() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>对 this 有了大致了解后，再来看 call 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'windowName'</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'objName'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'obj1Name'</span>,</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">//windowName</span></span><br><span class="line">fn.call(obj) <span class="comment">// objName：虽然是fn调用，但call改变了this指向，this的指向是obj,故obj.name的值为objName</span></span><br><span class="line">fn.call(obj1) <span class="comment">// obj1Name</span></span><br></pre></td></tr></table></figure>

<p>call 方法执行的时候，内部处理了一些事情。首先把要操作函数中的 this 关键字变为 call 方法第一个传递的实参值,把 call 方法第二个及第二个以后的实参获取到，把要操作的函数执行，并且把第二个以后的传递进来的实参传给函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line">fn.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>CALL 中的细节</p>
<blockquote>
<p>1.非严格模式下，如果参数不传，或者第一个传递的是 null/undefined，this 都指向 window 2.在严格模式下，第一个参数是谁，this 就指向谁（包括 null/undefined），不传 this 是 undefined<br>在上述代码中，如果用 apply，则是</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line">fn.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>apply：和 call 基本上一模一样，唯一区别在于<strong>传参方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">fn.apply(obj, [<span class="number">10</span>, <span class="number">20</span>]) <span class="comment">//APPLY把需要传递给FN的参数放到一个数组（或者类数组）中传递进去，虽然写的是一个数组，但是也相当于给FN一个个的传递</span></span><br></pre></td></tr></table></figure>

<p>bind：语法和 call 一模一样，唯一的区别在于立即执行还是等待执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">10</span>,<span class="number">20</span>) 改变FN中的THIS,并且把FN立即执行</span><br><span class="line">fn.bind(obj,<span class="number">10</span>,<span class="number">20</span>) 改变FN中的THIS,此时的FN并没有执行（不兼容IE6~<span class="number">8</span>）</span><br></pre></td></tr></table></figure>

<p>bind 调用之后是返回原函数，需要再调用一次才行</p>
<hr>
<p>回到原题，求数组最大值<br>Math.max(arr)这样肯定是报错的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(ary)) <span class="comment">// =&gt; NaN</span></span><br><span class="line"><span class="comment">// =&gt; Math.max是获取一堆数中的最大值,需要我们把比较的数,一个个的传递给这个方法 //=&gt;Math.max(12,13,14...) =&gt;Math.max([12,13,14...])这样只是传递一个值</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br><span class="line"><span class="comment">// =&gt; 利用了apply的一个特征：虽然放的是一个数组，但是执行方法的时候，也是把数组中的每一项一个个的传递给函数</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6-展开运算符"><a href="#ES6-展开运算符" class="headerlink" title="ES6 展开运算符"></a>ES6 展开运算符</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...arr))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之由一道题来思考闭包</title>
    <url>/2019/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E6%9D%A5%E6%80%9D%E8%80%83%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>从一道很经典的闭包问题说起…</p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>闭包就是指有权访问另一个函数作用域中的变量的函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;点击li标签弹出对应数字&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">0</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;1&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">2</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;3&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var list = document.getElementsByTagName('li');</span></span><br><span class="line"><span class="regexp">    for(var i = 0;i &lt; list.length;i++)&#123;</span></span><br><span class="line"><span class="regexp">     list[i].onclick = function()&#123;</span></span><br><span class="line"><span class="regexp">         alert(i);</span></span><br><span class="line"><span class="regexp">     &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>如上题，最为常见的一个例子，这里解释由这道题引出的 js 知识点，如上我们知道在浏览器运行无论点击哪个 li 标签都是弹出 3,首先来理解为什么会弹出 3。</p>
<p>程序通过 for 循环给每个 li 标签绑定了事件，然后通过点击 li 标签触发方法，即执行 alert(i)。js 中有个作用域链查找机制，首先会在 onclick 返回的函数作用域查找 i 变量的值，找不到则往上一层找 i，上一层即是 window 全局作用域，即找到全局变量 i，即 for 循环定义的 i。</p>
<p>注意 for 循环的 i 并不是私有变量，而是全局变量。</p>
<blockquote>
<p>js 中所有的事件绑定都是异步编程（当前这件事件没有彻底完成，不再等待，继续执行下面的任务）</p>
</blockquote>
<p>当绑定 onclick 事件后，不需要等待执行，继续执行下一个循环任务，所以当我们点击执行方法的时候，循环早已结束,即是最后 i=3。故程序执行后全局变量 i 被循环执行后赋值为最终的 3，所以当点击的时候，外层循环已经结束，页面加载完成预示着 js 代码都已经执行完成，即执行 alert(i)时，由于 i 不是私有变量，便会找到上一级 window 作用域全局的 i，所以无论点击哪个 li 标签都是弹出 3</p>
<h2 id="为什么要用闭包"><a href="#为什么要用闭包" class="headerlink" title="为什么要用闭包"></a>为什么要用闭包</h2><p>那么，解决这个问题的缘由，在于 i 每次在页面加载完就赋值为 3，alert(i)的时候总是找到全局变量 i。在 ES5 传统语法中，能形成作用域的只有全局和函数，现在每次 i 找的都是全局，那么要保住 i 的值只能在全局和 onclick 返回函数的作用域中间再加一个小的私有作用域，即是大的作用域外再加一个小的作用域，这样 i 往上一层作用域查找时，就会获取小作用域的 i 的值，而不会去获取全局变量的 i 值。</p>
<p>这个思路解决问题就需要引入闭包，在这个理解上闭包是指函数变量可以保存在函数作用域内，因此看起来是函数将变量“包裹”了起来。于是，代码改成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  list[i].onclick = (<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//形参n</span></span><br><span class="line">    <span class="comment">//=&gt;让自执行函数执行,把执行的返回值(return)赋值给onclick</span></span><br><span class="line">    <span class="comment">//（此处onclick绑定的是返回的小函数，点击的时候执行的是小函数）,</span></span><br><span class="line">    <span class="comment">// 自执行函数在给事件赋值的时候就已经执行了</span></span><br><span class="line">    <span class="comment">// 自执行函数形成一个私有作用域</span></span><br><span class="line">    <span class="keyword">var</span> i = n</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i) <span class="comment">//传入实参i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环三次，形成三个不销毁的私有作用域（自执行函数执行），而每一个不销毁的栈内存中都存储了一个私有变量 i，而这个值分别是每一次执行传递进来的全局 i 的值（也就是：第一个不销毁的作用域存储的是 0，第二个是 1，第三个是 2，第四个是 3）；当点击的时候，执行返回的小函数，遇到变量 i，向它自己的上级作用域查找。这样就达到了我们需要的效果，这种闭包实现，也可以有另一种写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*原理同法二都是形成三个不销毁的私有作用域,分别存储需要的索引值*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  ;(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    list[n].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(n)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于初始的代码，如果说为什么不能实现，那原因就可归纳为：</p>
<blockquote>
</blockquote>
<ol>
<li>执行方法,形成一个私有的栈内存,遇到变量 i,i 不是私有变量,向上一级作用域查找（上级作用域 window）</li>
<li>所有的事件绑定都是异步编程,绑定事件后,不需要等待执行,继续执行下一个循环任务,所以当我们点击执行方法的时候,循环早已结束（让全局的 i 等于循环最后的结果 3）</li>
</ol>
<h2 id="ES6-语法的解决方式"><a href="#ES6-语法的解决方式" class="headerlink" title="ES6 语法的解决方式"></a>ES6 语法的解决方式</h2><p>在 ES6 中，解决这种问题只需要一个 let 变量，ES6 中才有块级作用域（类似于私有作用域）的概念</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  list[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包对内存的影响"><a href="#闭包对内存的影响" class="headerlink" title="闭包对内存的影响"></a>闭包对内存的影响</h2><p>从上面可知，每次 for 都会形成一个私有作用域，每个都里面保存的变量 i 的值，程序运行后这些作用域并不会被销毁，所以由于闭包会携带包含它的函数的作用域，所以会比其他函数占用更多内容，过度使用闭包会导致内存占用过多。</p>
<p>在真实项目中为了保证 JS 的性能（堆栈内存的性能优化），应该尽可能的减少闭包的使用（不销毁的堆栈内存是耗性能的）</p>
<h2 id="堆内存和栈内存的释放"><a href="#堆内存和栈内存的释放" class="headerlink" title="堆内存和栈内存的释放"></a>堆内存和栈内存的释放</h2><p>这里又要提到一个知识点，js 中存储方式的分类：</p>
<blockquote>
<p>JS 中的内存分为堆内存和栈内存<br>堆内存：存储引用数据类型值（对象：键值对 函数：代码字符串）<br>栈内存：提供 JS 代码执行的环境和存储基本类型值</p>
</blockquote>
<p>粗暴理解 var 定义的变量存在栈内存中，如 for 循环中的 i 是存在栈内存中的；而函数，它是存在堆内存中</p>
<p><strong>一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉（在栈内存中存储的值也都会释放掉）</strong>，那为什么闭包的栈内存不会被自动释放掉，在 js 中也有特殊不被销毁的情况：</p>
<blockquote>
<p>1.函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用了，此时栈内存不能释放（一旦释放外面找不到原有的内容了） 2.全局栈内存只有在页面关闭的时候才会被释放掉</p>
</blockquote>
<p>闭包则是属于第一种情况，onclick 函数形成的栈内存，被小函数【alert(i)，i 找到 onclick 作用域获取 i 值】占用了 onclick 函数的栈内存（变量 i 是存在栈内存中），故栈内存不能被释放，所以才会说闭包过度使用容易导致内存被占用过多，因为不会自动释放内存。</p>
<p><strong>堆内存的释放</strong></p>
<blockquote>
<p>堆内存让所有引用堆内存空间地址的变量赋值为 null 即可（没有变量占用这个堆内存了，浏览器会在空闲的时候把它释放掉）</p>
</blockquote>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之变量提升</title>
    <url>/2019/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>原理：JS 引擎的工作方式是先解析代码，获取所有被声明的变量；然后在运行。JS 代码自上而下执行之前，浏览器首先会把所有带”VAR”/“FUNCTION”关键词的进行提前”声明”或者”定义”，这种预先处理机制称之为 “变量提升”。</p>
<a id="more"></a>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">//undefined undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>,</span><br><span class="line">  b = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b) <span class="comment">//=&gt;undefined 12</span></span><br><span class="line">  <span class="keyword">var</span> a = (b = <span class="number">13</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(a, b) <span class="comment">//=&gt;13 13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">//=&gt;12 13</span></span><br></pre></td></tr></table></figure>

<ul>
<li>undefined undefined：首先输出这个结果是因为变量提升，即前三行变成</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">//undefined undefined</span></span><br><span class="line">a = <span class="number">12</span></span><br><span class="line">b = <span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>undefined 12：接下来执行函数 fn（fn 一开始也被执行了变量提升,只不过函数中存储的都是字符串而已），对 fn 内部进行分析，即内部代码变成：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">//undefined 12</span></span><br><span class="line">a = <span class="number">13</span></span><br><span class="line">b = <span class="number">13</span> <span class="comment">//不加var的本质是WIN的属性，即相当于window.b = 13;</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">//13 13</span></span><br></pre></td></tr></table></figure>

<p>一开始 b 在 fn 内部找不到，便会开始往上一层找，找到了全局的 b，于是 b 输出 12。</p>
<p>当经过 var a = b = 13; 后，b 被赋值为 13，于是输出先从函数内部找 b，找到了 b=13，第二次输出 b 为 13。（！同时，最先定义的全局变量 b = 12 也被赋值为 13，故最后的 b 也等于 13）</p>
<blockquote>
<p>私有作用域中带 var 和不带 var 的区别：</p>
<ol>
<li>带 var 的在私有作用于变量提升阶段，都声明为私有变量，和外界没有任何的关系</li>
<li>不带 var 不是私有变量，会向它的上级作用于查找，一直找到 window 为止（这种查找机制叫做：“作用域链”），也就是在私有作用域中操作的这个非私有变量，是一直操作别人的</li>
</ol>
</blockquote>
<h2 id="只对等号左边进行变量提升"><a href="#只对等号左边进行变量提升" class="headerlink" title="只对等号左边进行变量提升"></a>只对等号左边进行变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sum()</span><br><span class="line">fn() <span class="comment">// Uncaught TypeError: fn is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;匿名函数之函数表达式</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn'</span>)</span><br><span class="line">&#125; <span class="comment">//=&gt;代码执行到此处会把函数值赋值给fn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;普通的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sum'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件判断下的变量提升"><a href="#条件判断下的变量提升" class="headerlink" title="条件判断下的变量提升"></a>条件判断下的变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在当前作用域下，不管条件是否成立都要进行变量提升</span></span><br><span class="line"><span class="comment"> *   =&gt;带VAR的还是只声明</span></span><br><span class="line"><span class="comment"> *   =&gt;带FUNCTION的在老版本浏览器渲染机制下，声明和定义都处理，但是为了迎合ES6中的块级作用</span></span><br><span class="line"><span class="comment"> *     域，新版浏览器对于函数（在条件判断中的函数），</span></span><br><span class="line"><span class="comment"> *     不管条件是否成立，都只是先声明，没有定义，类似于var</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="重名问题的处理"><a href="#重名问题的处理" class="headerlink" title="重名问题的处理"></a>重名问题的处理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn() <span class="comment">//=&gt;4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">//=&gt;4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">//=&gt;4</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">100</span> <span class="comment">//=&gt;带VAR的在提升阶段只把声明处理了,赋值操作没有处理,所以在代码执行的时候需要完成赋值 FN=100</span></span><br><span class="line">fn() <span class="comment">//=&gt;100() Uncaught TypeError: fn is not a function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<p>带 VAR 和 FUNCTION 关键字声明相同的名字，这种也算是重名了（其实是一个 FN，只是存储值的类型不一样）<br>关于重名的处理：如果名字重复了，不会重新的声明，但是会重新的定义（重新赋值）[不管是变量提升还是代码执行阶段皆是如此]</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>变量提升</tag>
      </tags>
  </entry>
  <entry>
    <title>jquery设计的巧妙</title>
    <url>/2019/09/07/jquery%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B7%A7%E5%A6%99/</url>
    <content><![CDATA[<p>最近开始阅读jquery的源码，首先先提炼出jquery的核心结构。</p>
<a id="more"></a>
<h2 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window,undefined</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<h3 id="为什么传入window"><a href="#为什么传入window" class="headerlink" title="为什么传入window?"></a>为什么传入window?</h3><p><strong>1.代码压缩</strong></p>
<p>首先从代码压缩混淆的角度考虑，用线上工具来压缩混淆下面这段示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name=<span class="string">"hello"</span>;</span><br><span class="line">  <span class="built_in">window</span>.description=<span class="string">"hi "</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>压完混完后瘦了一点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> a=<span class="string">"hello"</span>;<span class="built_in">window</span>.description=<span class="string">"hi "</span>+a&#125;</span><br></pre></td></tr></table></figure>
<p>用a代替了name，但是window既不是声明的局部变量也不是参数，是不会被压缩混淆的。<br>所以将window作为参数传入可解决这个问题。将window作为参数传入，可以在压缩代码时进行优化，即参数名可以压缩变短。也可以在函数内另起个简短的变量名代替。  </p>
<p><strong>2.作用域</strong></p>
<p>访问当前作用域下的变量比访问全局变量要快<br>如果不传入，每个语句都要去找一次window。如果将window作为参数传递过去，不要每个语句都去找window，提高了效率。</p>
<h3 id="为什么要传入undefined？"><a href="#为什么要传入undefined？" class="headerlink" title="为什么要传入undefined？"></a>为什么要传入undefined？</h3><p>undefined并不是作为JavaScript的保留关键字；undefined在IE8及以下中是可以对其重新赋值的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var undefined&#x3D;&quot;new value&quot;;</span><br><span class="line">alert(undefined);&#x2F;&#x2F;alert “new value&quot;</span><br></pre></td></tr></table></figure>
<p>执行匿名函数的时候，只传递一个参数window，而不传递undefined，那么函数体中的undefined局部变量的值，刚好就是undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">8</span>;  </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window </span>) </span>&#123;   </span><br><span class="line">    alert(<span class="built_in">window</span>.undefined); <span class="comment">// 8  </span></span><br><span class="line">    alert(<span class="literal">undefined</span>); <span class="comment">// 8  </span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>加了undefined后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">8</span>;  </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;   </span><br><span class="line">    alert(<span class="built_in">window</span>.undefined);  <span class="comment">// 8  </span></span><br><span class="line">    alert(<span class="literal">undefined</span>); <span class="comment">// 此处undefined参数为局部的名称为undefined变量，值为undefined  </span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>在 自调用匿名函数 的作用域内，确保undefined是真的未定义。因为undefined能够被重写，赋予新的值.</p>
<h2 id="new-jQuery-fn-init-selector-context"><a href="#new-jQuery-fn-init-selector-context" class="headerlink" title="new jQuery.fn.init( selector, context );"></a>new jQuery.fn.init( selector, context );</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context );</span><br><span class="line">    <span class="comment">//=&gt;创建了init这个类的实例，也相当于创建了jQuery这个类的实例（因为在后面的时候，让init.prototype=jQuery.prototype）&#125;;</span></span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要理解这段代码，首先要理解jquery的两种调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'body'</span>).css(<span class="string">'background'</span>,<span class="string">'red'</span>);</span><br><span class="line">$.parseJSON(<span class="string">'&#123;&#125;'</span>);</span><br></pre></td></tr></table></figure>
<p>$(‘body’)应该是一个实例对象，css是每个实例共享的方法，是原型上的方法。<br>而$则是一个类，parseJSON则是类的静态方法。  </p>
<h3 id="如何不用new关键字得到jQuery对象？"><a href="#如何不用new关键字得到jQuery对象？" class="headerlink" title="如何不用new关键字得到jQuery对象？"></a>如何不用new关键字得到jQuery对象？</h3><p>一般获取实例对象调取实例方法的例子，如果没有使用new则会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo=<span class="keyword">new</span> Demo(<span class="string">"jacky"</span>);</span><br><span class="line">demo.change();</span><br></pre></td></tr></table></figure>
<p>但是获取jQuery对象（以下简称JQ对象）用new和不用new都可以，返回的是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log($(<span class="string">'*'</span>).length);<span class="comment">//14</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> $(<span class="string">'*'</span>).length);<span class="comment">//14</span></span><br></pre></td></tr></table></figure>
<p>为了做到这点，我们很容易想到需要<strong>在构造函数内部返回对象</strong>。</p>
<p>构造函数有return值怎么办？<br><strong>构造函数里没有显式调用return时，默认是返回this对象，也就是新创建的实例对象。</strong></p>
<p>当构造函数里调用return时，分两种情况：</p>
<blockquote>
<p>1.return的是五种简单数据类型：String，Number，Boolean，Null，Undefined。 这种情况下，忽视return值，依然返回this对象。<br>2.return的是Object 这种情况下，不再返回this对象，而是返回return语句的返回值。</p>
</blockquote>
<p>所以我们应该在jQuery构造函数内部去返回一个对象，这样就可以不用new的方式去创建JQ对象了，其实这时候，构造函数就相当于一个工厂函数了。</p>
<p>该返回什么样的对象？对于这个对象有何要求？<br>这个对象必须可以调用jQuery.prototype上的方法</p>
<p>我们使用或自己写jQuery插件的时候会经常遇到$.fn这个对象，很多插件都是通过扩展这个对象来实现的。<br>$.fn其实对应着jQuery.prototype，$和fn分别是jQuery和prototype的简写方式，只要我们把方法扩展到这个原型对象身上，通过$()获取的JQ对象都是可以访问到方法的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.fn.greeting=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'hi'</span>)&#125;;</span><br><span class="line">$(<span class="string">'body'</span>).greeting();<span class="comment">// alert 'hi'</span></span><br></pre></td></tr></table></figure>
<p>jquery源码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context, rootjQuery );</span><br><span class="line">&#125;,</span><br><span class="line">jQuery.fn = jQuery.prototype = &#123; <span class="comment">// fn即对应prototype</span></span><br><span class="line">    <span class="keyword">constructor</span>: jQuery,</span><br><span class="line">    init: function( selector, context, rootjQuery ) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jQuery.fn.init.prototype = jQuery.fn;<br>看到上面这段源码，原因就很明显了，”jQuery.fn.init.prototype = jQuery.fn”这句很重要，它将init的原型指向jQuery的原型，所以JQ对象才可以访问‘css’、’show’、’hide’这些写在jQuery.fn上的方法。其实我们所说的JQ对象根本就是init函数的实例对象，而init则是jQuery原型上的一个对象，它本身是没有什么方法的，全靠从jQuery原型上拿。</p>
<p>为何要从init这绕这么一大圈来访问jQuery的原型，而不是直接返回一个jQuery实例直接通过这个实例来访问自身原型？比如说代码可以写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> jQuery();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题很明显，死在循环里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jQuery.fn.init();<span class="comment">// 不同点在于去掉了new关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做点动作来证明加上new是有用的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jQuery.fn.init();</span><br><span class="line">&#125;,</span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name=<span class="string">'sheila'</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    anotherName:<span class="string">'sunwukong'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> jq=jQuery();</span><br><span class="line"><span class="built_in">console</span>.log(jq.anotherName);<span class="comment">// "sunwukong"</span></span><br><span class="line"><span class="built_in">console</span>.log(jq.name);<span class="comment">// "sheila"</span></span><br></pre></td></tr></table></figure>
<p>上面这段代码是为了说明this的作用域问题，其不仅能访问init函数内部，还能向上一层到fn对象，作用域不独立.如果是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(jq.anotherName);<span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(jq.name);<span class="comment">//  "sheila"</span></span><br></pre></td></tr></table></figure>
<p>加不加new还牵涉到一个更重要的问题：返回的对象究竟是谁。</p>
<p>不加new的情况下，’jQuery.fn.init()’相当于调用方法，this指向的以及最后返回的都是同一个jQuery.fn对象，$(‘body’)和$(‘p’)就没有区分了。</p>
<p>显然，这是不合理的。而加了new，就是每次用构造函数实例化了一个新对象，彼此都是不同的</p>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>this.props.history.push()报错解决</title>
    <url>/2019/04/05/this-props-history-push%E6%96%B9%E6%B3%95%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>在使用 React 的路由跳转时，出现了这个错误”cannot read property ‘push’ of undefined”，找来找去，发现是子组件这样调用时才会报错,它不是路由组件。以下是解决方案：</p>
<a id="more"></a>

<p>在我的每个页面中，Header 组件都会引入，使其成为子组件</p>
<h3 id="通过父组件传值给子组件"><a href="#通过父组件传值给子组件" class="headerlink" title="通过父组件传值给子组件"></a>通过父组件传值给子组件</h3><p>在父组件中，传递一个 history 给子组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Header history=&#123;<span class="keyword">this</span>.props.history&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>子组件方法还是一样写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.history.push(<span class="string">'/login'</span>)</span><br></pre></td></tr></table></figure>

<p>但如果 Header 组件被嵌套封装更深的话是不行的，这时只能选择第二种方法。</p>
<h3 id="使用-withRouter"><a href="#使用-withRouter" class="headerlink" title="使用 withRouter"></a>使用 withRouter</h3><blockquote>
<p>默认情况下必须经过路由匹配渲染的组件才存在 this.props,才拥有路由参数，执行 this.props.history.push(‘/login’)跳转到对应路由的页面，然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用 withRouter 就可以给此组件传入路由参数，将 react-router 的 history、location、match 三个对象传入 props 对象上，此时就可以使用 this.props。</p>
</blockquote>
<p>可见当一个非路由组件也想访问到当前路由的 match,location,history 对象，那么 withRouter 将是一个非常好的选择，可以理解为将一个组件包裹成路由组件。</p>
<p>用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Header) <span class="comment">// export时要使用withRouter</span></span><br></pre></td></tr></table></figure>

<p>在 Header 组件引入并使用，就可以使用 this.props.history.push 方法进行正常跳转了~~</p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB性能之逐条插入与批量插入</title>
    <url>/2018/05/12/MongoDB%E6%80%A7%E8%83%BD%E4%B9%8B%E9%80%90%E6%9D%A1%E6%8F%92%E5%85%A5%E4%B8%8E%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/</url>
    <content><![CDATA[<p>在 mongoDB 中，当我们要插入很多数据时，可以选择用循环依次逐条插入，或者可以先把所有数据装在一个数组再整个数组插入集合，但是，最好使用第二种方式…</p>
<a id="more"></a>

<p>如下代码所示（已新建数据库 log 和集合 test），在 js 写入如下代码</p>
<h2 id="逐条插入"><a href="#逐条插入" class="headerlink" title="逐条插入"></a>逐条插入</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() <span class="comment">//获得开始时间</span></span><br><span class="line"><span class="keyword">var</span> db = connect(<span class="string">'log'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  db.test.insert(&#123; <span class="attr">num</span>: <span class="number">1</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> runTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - startTime <span class="comment">//获得运行时间</span></span><br><span class="line">print(<span class="string">'runTime is '</span> + runTime + <span class="string">'ms'</span>) <span class="comment">//runTime is 745ms</span></span><br></pre></td></tr></table></figure>

<h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() <span class="comment">//获得开始时间</span></span><br><span class="line"><span class="keyword">var</span> db = connect(<span class="string">'log'</span>)</span><br><span class="line"><span class="keyword">var</span> tempArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  tempArr.push(&#123; <span class="attr">num</span>: <span class="number">1</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">db.test.insert(tempArr)</span><br><span class="line"><span class="keyword">var</span> runTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - startTime</span><br><span class="line">print(<span class="string">'runTime is '</span> + runTime + <span class="string">'ms'</span>) <span class="comment">// runTime is 48ms</span></span><br></pre></td></tr></table></figure>

<p>由运行时间来看，批量插入比逐条插入所用的时间少了很多，在小型项目中可能感受不到的差距，在大项目就是性能的问题了，故应使用第二种方式来批量插入数据。</p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
</search>
