<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入理解JavaScript之变量提升</title>
    <url>/2019/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>原理：JS引擎的工作方式是先解析代码，获取所有被声明的变量；然后在运行。JS代码自上而下执行之前，浏览器首先会把所有带”VAR”/“FUNCTION”关键词的进行提前”声明”或者”定义”，这种预先处理机制称之为 “变量提升”。</p>
<a id="more"></a>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">//undefined undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>,</span><br><span class="line">    b = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b);<span class="comment">//=&gt;undefined 12</span></span><br><span class="line">    <span class="keyword">var</span> a = b = <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b);<span class="comment">//=&gt;13 13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">//=&gt;12 13</span></span><br></pre></td></tr></table></figure>

<ul>
<li>undefined undefined：首先输出这个结果是因为变量提升，即前三行变成<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//undefined undefined</span></span><br><span class="line">a = <span class="number">12</span>;</span><br><span class="line">b = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li>
<li>undefined 12：接下来执行函数fn（fn一开始也被执行了变量提升,只不过函数中存储的都是字符串而已），对fn内部进行分析，即内部代码变成：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//undefined 12</span></span><br><span class="line">a = <span class="number">13</span>;</span><br><span class="line">b = <span class="number">13</span>; <span class="comment">//不加var的本质是WIN的属性，即相当于window.b = 13; </span></span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//13 13</span></span><br></pre></td></tr></table></figure>
<p>一开始b在fn内部找不到，便会开始往上一层找，找到了全局的b，于是b输出12。</p>
<p>当经过var a = b = 13; 后，b被赋值为13，于是输出先从函数内部找b，找到了b=13，第二次输出b为13。（！同时，最先定义的全局变量b = 12也被赋值为13，故最后的b也等于13）</p>
<blockquote>
<p>私有作用域中带var和不带var的区别：</p>
<ol>
<li>带var的在私有作用于变量提升阶段，都声明为私有变量，和外界没有任何的关系</li>
<li>不带var不是私有变量，会向它的上级作用于查找，一直找到window为止（这种查找机制叫做：“作用域链”），也就是在私有作用域中操作的这个非私有变量，是一直操作别人的</li>
</ol>
</blockquote>
<h2 id="只对等号左边进行变量提升"><a href="#只对等号左边进行变量提升" class="headerlink" title="只对等号左边进行变量提升"></a>只对等号左边进行变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sum();</span><br><span class="line">fn();<span class="comment">// Uncaught TypeError: fn is not a function </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;匿名函数之函数表达式</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn'</span>);</span><br><span class="line">&#125;<span class="comment">//=&gt;代码执行到此处会把函数值赋值给fn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;普通的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sum'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件判断下的变量提升"><a href="#条件判断下的变量提升" class="headerlink" title="条件判断下的变量提升"></a>条件判断下的变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在当前作用域下，不管条件是否成立都要进行变量提升</span></span><br><span class="line"><span class="comment"> *   =&gt;带VAR的还是只声明</span></span><br><span class="line"><span class="comment"> *   =&gt;带FUNCTION的在老版本浏览器渲染机制下，声明和定义都处理，但是为了迎合ES6中的块级作用 </span></span><br><span class="line"><span class="comment"> *     域，新版浏览器对于函数（在条件判断中的函数），</span></span><br><span class="line"><span class="comment"> *     不管条件是否成立，都只是先声明，没有定义，类似于var</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> === <span class="number">2</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="重名问题的处理"><a href="#重名问题的处理" class="headerlink" title="重名问题的处理"></a>重名问题的处理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn();<span class="comment">//=&gt;4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line">fn();<span class="comment">//=&gt;4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;</span><br><span class="line">fn();<span class="comment">//=&gt;4</span></span><br><span class="line"><span class="keyword">var</span> fn=<span class="number">100</span>;<span class="comment">//=&gt;带VAR的在提升阶段只把声明处理了,赋值操作没有处理,所以在代码执行的时候需要完成赋值 FN=100</span></span><br><span class="line">fn();<span class="comment">//=&gt;100() Uncaught TypeError: fn is not a function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>);&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>);&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p>带VAR和FUNCTION关键字声明相同的名字，这种也算是重名了（其实是一个FN，只是存储值的类型不一样）<br>关于重名的处理：如果名字重复了，不会重新的声明，但是会重新的定义（重新赋值）[不管是变量提升还是代码执行阶段皆是如此]</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
