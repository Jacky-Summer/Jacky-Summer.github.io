<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>项目优化实践：Webpack 动态导入 react-toastify</title>
    <url>/2021/03/27/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%EF%BC%9AWebpack-%E5%8A%A8%E6%80%81%E5%AF%BC%E5%85%A5-react-toastify/</url>
    <content><![CDATA[<p>如果你的项目正在使用 <code>react-toastify</code>，可以看看本文。我是最近通过<code>webpack-bundle-analyzer</code>发现的一个问题，其实我们只有某个页面会可能用到弹框，比如你点了收藏之后会有弹框出来。但是通过打包结果和运行得出，每个页面无论有没有使用，一开始都引入了 <code>react-toastify</code>。</p><a id="more"></a><h2 id="react-toastify-的使用"><a href="#react-toastify-的使用" class="headerlink" title="react-toastify 的使用"></a>react-toastify 的使用</h2><p>如果你打开它 <a href="https://github.com/fkhadra/react-toastify#readme" target="_blank" rel="noopener">Github</a>，它是这么使用的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; ToastContainer, toast &#125; <span class="keyword">from</span> <span class="string">'react-toastify'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'react-toastify/dist/ReactToastify.css'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> notify = <span class="function"><span class="params">()</span> =&gt;</span> toast(<span class="string">'Wow so easy!'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;notify&#125;&gt;Notify!&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ToastContainer /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>而如果整个项目多个地方用或者需要控制好数据流的话，一个做法往往是把它拉到 Redux 管理，在我们项目就变成</p><p><code>app.tsx</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 里面封装了逻辑和返回了 &lt;ToastContainer /&gt;</span></span><br><span class="line"><span class="keyword">import</span> Toast <span class="keyword">from</span> <span class="string">"src/containers/Toast"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; noToast &#125; = <span class="keyword">this</span>.props</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    &#123;!noToast &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Toast</span> /&gt;</span></span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>项目使用的是 <strong>Next.js</strong></p><p>我们的每个<code>pages/</code>页面都引入了这个<code>app.tsx</code>公共文件，上面代码中，Toast 是经过 Redux 等封装好的 Toast 组件，由上面代码粗略看出，如果在每个页面的<code>app.tsx</code>组件传入<code>noToast</code>属性，那么<code>&lt;Toast /&gt;</code>就不会被加载，调用 <code>toast</code>方法也不会有弹框出现。</p><p>这段代码已经是几年前的了，推测是这个意图，默认导入，假设确认你页面真的不需要弹框，就传<code>noToast</code>属性，然而我搜索了整个项目，用到<code>noToast</code>的地方只有一个，所以这个属性并不被后来接手的人所知，也就不会手动传入<code>noToast</code>，导致每个页面都引入了<code>react-toasify</code></p><blockquote><p>使用 toast 方法必须页面要挂载了 <code>&lt;ToastContainer /&gt;</code>，才可以弹出弹框</p></blockquote><h2 id="现有的问题"><a href="#现有的问题" class="headerlink" title="现有的问题"></a>现有的问题</h2><ol><li>我们只有在页面详情页点击收藏，才会有弹框（使用<code>react-toastify</code>），其他页面都没有。但每个页面都加载了该 chunk 包</li><li>项目中使用 toast 方法是通过 Redux 触发，通过<code>useUpdateEffect</code>监听了全局</li></ol><p><code>src/containers/Toast.tsx</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useUpdateEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// toastProp从redux获取而来的</span></span><br><span class="line">  <span class="keyword">if</span> (toastProp.message || toastProp.errors) notify(toastProp) <span class="comment">// notify里面判断和调用toast</span></span><br><span class="line">&#125;, [notify, toastProp])</span><br></pre></td></tr></table></figure><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ol><li>当然是不要每个页面都引入，而是用到的页面再引入</li><li>最好用到的页面，没点击时也不加载，比如只有点击收藏，才让<code>react-toasify</code>加载。</li></ol><p>这就让人想到动态导入了，做法即是不再需要在<code>app.tsx</code>判断引入<code>react-toastify</code>，如新封装了一个组件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ToastContent, ToastOptions &#125; <span class="keyword">from</span> <span class="string">'react-toastify'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态导入	 ./Toastify是封装好的 Toastify</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toastify = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./Toastify'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toast = <span class="function">(<span class="params">message: ToastContent, toastOptions?: ToastOptions</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> toastify().then(<span class="function"><span class="params">toast</span> =&gt;</span> &#123;</span><br><span class="line">    toast.showToast(message, toastOptions)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面做到的效果即是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">import</span> &#123; toast &#125; <span class="keyword">from</span> <span class="string">'./toastify'</span></span><br><span class="line">toast(<span class="string">'Hello World'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">'./toastify'</span>).then(<span class="function"><span class="params">module</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.toast(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在看看这个文件 <code>./Toastify.tsx</code>（省略很多代码…）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> setupToastContainer = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasToastContainer) &#123;</span><br><span class="line">    hasToastContainer = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// 需要去给根html添加一个div，id为 root-toastify</span></span><br><span class="line">    ReactDOM.render(</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;ToastGlobalStyle /&gt;</span><br><span class="line">        &lt;ToastWrapper /&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;,</span></span><br><span class="line"><span class="regexp">      document.getElementById('root-toastify')</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export const showToast = (message, toastOptions = &#123;&#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  setupToastContainer()</span></span><br><span class="line"><span class="regexp">  toast(message, toastOptions)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>直接摆脱了 Redux 依赖，而且只有你点击的一瞬间才会加载<code>react-toastify</code>的 chunk 包，初始加载并不会，故最后优化结果是每个页面都打包压缩体积都减少 15-20K+。</p><p>这次就有点偷懒写文了，因为这只是项目优化的其中一个小点，以前也没有记录优化点，这次做了就马上回顾一下，上面代码可能看的有点懵，没有放出完整代码和做个 Demo。</p><p>不过没关系，因为我在 Github 找到了完整的 PR 例子供大家参考 <a href="https://github.com/getfider/fider/pull/645/files" target="_blank" rel="noopener">enhancement: move react-toastify to its own bundle</a>，同样是动态导入<code>react-toastify</code>，做法一样。</p><br><ul><li>ps：<ul><li><a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a></li></ul></li></ul>]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>动态导入</tag>
      </tags>
  </entry>
  <entry>
    <title>Webpack SourceMap 回顾</title>
    <url>/2021/03/21/Webpack-SourceMap-%E5%9B%9E%E9%A1%BE/</url>
    <content><![CDATA[<p>本文同步发布在我的 <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">Github 个人博客</a></p><p>前几天在优化项目时，发现<code>next.config.js</code>的配置里，development 模式下的 sourcemap 为<code>cheap-module-sourcemap</code>，仔细想了想，记忆中好像有个更推荐常用的开发模式 sourcemap 配置：<code>cheap-module-eval-source-map</code>。</p><p>看了一下是三年前添加的代码，于是又回顾研究了下 webpack 的 sourcemap 配置，开个 PR。</p><a id="more"></a><h2 id="什么是-Sourcemap"><a href="#什么是-Sourcemap" class="headerlink" title="什么是 Sourcemap"></a>什么是 Sourcemap</h2><p>我们的项目在打包后，将开发环境中源代码经过压缩，去空格，babel 编译等工程化转换，最终的项目代码和源代码之间差异性很大，会造成无法 debug 的问题，在线上环境定位到的代码是压缩处理后的代码。</p><p>而 Sourcemap 就是是为了解决开发代码与实际运行代码不一致时帮助我们 debug 到原始开发代码的技术，解决上述<strong>代码定位</strong>的问题，是<strong>源代码和目标代码出错位置的映射</strong>。</p><h2 id="Sourcemap-关键词"><a href="#Sourcemap-关键词" class="headerlink" title="Sourcemap 关键词"></a>Sourcemap 关键词</h2><p>Sourcemap 的关键词组合眼花缭乱，我们不可能一个一个去记每种 sourcemap 用途，我们只需知道几个关键词的意思，便可推测它们组合的 sourcemap 类型。</p><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p><strong>每一个模块都执行 eval() 过程，执行后不会生成<code>.map</code>文件，而是在每一个模块后追加<code>//@ sourceURL</code>来关联代码处理前后的对应关系</strong>。使用 eval 包裹模块代码，可以提高 <strong>rebuild</strong> 的速度。故一般 sourcemap 带有<code>eval</code>的选项，<code>rebuild</code> 速度都快一些。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpackJsonp([1],[</span><br><span class="line">function(module,exports,__webpack_require__)&#123;</span><br><span class="line">eval(</span><br><span class="line">      ...</span><br><span class="line">&#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;&#x2F;.&#x2F;src&#x2F;js&#x2F;index.js?&#39;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">function(module,exports,__webpack_require__)&#123;</span><br><span class="line">eval(</span><br><span class="line">      ...</span><br><span class="line">&#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;&#x2F;.&#x2F;src&#x2F;static&#x2F;css&#x2F;app.less?.&#x2F;~&#x2F;.npminstall&#x2F;css-loader&#x2F;0.23.1&#x2F;css-loader!.&#x2F;~&#x2F;.npminstall&#x2F;postcss-loader&#x2F;1.1.1&#x2F;postcss-loader!.&#x2F;~&#x2F;.npminstall&#x2F;less-loader&#x2F;2.2.3&#x2F;less-loader&#39;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">function(module,exports,__webpack_require__)&#123;</span><br><span class="line"> eval(</span><br><span class="line">      ...</span><br><span class="line"> &#x2F;&#x2F;# sourceURL&#x3D;webpack:&#x2F;&#x2F;&#x2F;.&#x2F;src&#x2F;tmpl&#x2F;appTemplate.tpl?&quot;</span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">...])</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42794b4bbbc3449599a92327f6c6d45a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>为什么 eval 模式 rebuild 的速度会快?</p><blockquote><p>因为带 eval 的构建模式能够 cache Sourcemap，猜测可能是带 eval 的模式能把每个模块的生成代码单独打在一行里，并且都以 DataURL 的形式添加 sourcemap，这样它在 rebuild 时会对每一个模块进行检查，如果没有发生改动，就直接使用之前的 sourcemap，故只需要为改动的模块重新生成 sourcemap；而非 eval 的构建模式下生成代码不管有任何模块作出修改，都会影响到最后 bundle 文件整体的行列格式，所以它每次都要重新生成整体的 sourcemap，rebuild 的速度会很慢。</p></blockquote><h3 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h3><p>会为每一个打包后的模块生成独立的<code>.map</code>文件，会在 bundle 文件末尾追加 <code>sourceURI=指定.map文件路径</code>，会在浏览器开发者工具中看到<code>webpack://</code>的文件夹</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpackJsonp([1],[</span><br><span class="line">function(e,t,i)&#123;...&#125;,</span><br><span class="line">function(e,t,i)&#123;...&#125;,</span><br><span class="line">function(e,t,i)&#123;...&#125;,</span><br><span class="line">function(e,t,i)&#123;...&#125;,</span><br><span class="line">  ...</span><br><span class="line">])&#x2F;&#x2F;# sourceMappingURL&#x3D;index.js.map</span><br></pre></td></tr></table></figure><p>打包后的模块在模块后面会对应引用一个<code>.map</code>文件，同时在打包好的目录下会针对每一个模块生成相应的<code>.map</code> 文件，在上例中会生成一个 index.js.map 文件，这个文件是一个典型的 sourcemap 文件，形式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;version&quot;:3,</span><br><span class="line">&quot;sources&quot;:[</span><br><span class="line">    &quot;webpack:&#x2F;&#x2F;&#x2F;js&#x2F;index.js&quot;,&quot;webpack:&#x2F;&#x2F;&#x2F;.&#x2F;src&#x2F;js&#x2F;index.js&quot;,</span><br><span class="line">    &quot;webpack:&#x2F;&#x2F;&#x2F;.&#x2F;~&#x2F;.npminstall&#x2F;css-loader&#x2F;0.23.1&#x2F;css-loader&#x2F;lib&#x2F;css-base.js&quot;,</span><br><span class="line">    ...</span><br><span class="line">],</span><br><span class="line">&quot;names&quot;:[&quot;webpackJsonp&quot;,&quot;module&quot;,&quot;exports&quot;...],</span><br><span class="line">&quot;mappings&quot;:&quot;AAAAA,cAAc,IAER,SAASC...&quot;,</span><br><span class="line">&quot;file&quot;:&quot;js&#x2F;index.js&quot;,</span><br><span class="line">&quot;sourcesContent&quot;:[...],</span><br><span class="line">&quot;sourceRoot&quot;:&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cheap"><a href="#cheap" class="headerlink" title="cheap"></a>cheap</h3><p>不包含列信息也不包含 loader 的 sourcemap，会为每一个模块生成<code>.map</code>文件，与<code>source-map</code>的区别在于 cheap 生成的<code>.map</code>文件会忽略原始代码中的列信息。</p><p>由于生成的 sourcemap 不会有列信息而只有行信息，编译计算量少，所以速度较快。</p><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p>包含 <strong>loader</strong> 模块之间的 sourcemap（比如 jsx 语法代码经 loader 编译为原生 js 代码）,这样可以看到 loader 处理前的原始代码</p><h3 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h3><p>正常的 sourcemap 的生成是在 dist 目录下创建一个<code>.map</code> 文件， inline 的含义就是不产生独立的 <code>.map</code> 文件，把 sourcemap 的内容以 <strong>DataURI</strong> 的方式追加到 bundle 件末尾，即将<code>.map</code> 作为 DataURI 嵌入。（一般使用该类型如造成体积过大，该类型比较少用）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webpackJsonp([1],[</span><br><span class="line">function(e,t,i)&#123;...&#125;,</span><br><span class="line">function(e,t,i)&#123;...&#125;,</span><br><span class="line">function(e,t,i)&#123;...&#125;,</span><br><span class="line">function(e,t,i)&#123;...&#125;,</span><br><span class="line">  ...</span><br><span class="line">])</span><br><span class="line">&#x2F;&#x2F;# sourceMappingURL&#x3D;data:application&#x2F;json;charset&#x3D;utf-8;base64,eyJ2ZXJzaW9...</span><br></pre></td></tr></table></figure><blockquote><p>DataURL 最早是出现在 HTML 文件 img 标签中的关于图片的引用，如 base64 图片</p></blockquote><p>DataURL 使用于如下的场景</p><ul><li>访问外部资源受限</li><li>图片体积小，占用一个 HTTP 会话资源浪费</li></ul><h3 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a>hidden</h3><p>bundle 里不包含 sourcemap 的引用地址，这样浏览器开发者工具里看不到原始代码</p><h2 id="Sourcemap-类型"><a href="#Sourcemap-类型" class="headerlink" title="Sourcemap 类型"></a>Sourcemap 类型</h2><p>上述的关键词混一起搭配，又增加了好几种 sourcemap 类型</p><ul><li><p><strong>eval-source-map</strong>：每一个模块在执行 eval()过程之后，并且会为每一个模块生成 <code>.map</code> 文件，生成的 sourcemap 文件通过 DataURL 的方式添加（把 eval 的 sourceURL 换成了完整 sourcemap 信息的 DataURL）</p></li><li><p><strong>cheap-eval-source-map</strong>：跟 eval-source-map 相同，唯一不同的就是增加了”cheap”，”cheap”是指忽略了行信息。这个属性同时也不会生成不同 loader 模块之间的 sourcemap。</p></li><li><p><strong>cheap-module-eval-source-map</strong>：与 cheap-eval-source-map 相同，但是包含了不同 loader 模块之间的 sourcemap</p></li><li><p><strong>cheap-source-map</strong>： 不包含列信息，不包含 loader 的 sourcemap</p></li><li><p><strong>inline-source-map</strong>： 为每一个文件添加 sourcemap 的 DataURL，注意这里的文件是打包前的每一个文件而不是最后打包出来的，同时这个 DataURL 是包含一个文件完整 sourcemap 信息的 base64 格式化后的字符串</p></li></ul><p>-<strong>hidden-source-map</strong>：不在 bundle 文件结尾处追加 sourceURL 指定其 sourcemap 文件的位置，但是仍然会生成 sourcemap 文件。这样，浏览器开发者工具就无法应用 sourcemap, 目的是避免把 sourcemap 文件发布到生产环境，造成源码泄露。</p><p>不仅还有这几种，还可以继续组合，这里就列举这么多了</p><h2 id="如何选择-Sourcemap"><a href="#如何选择-Sourcemap" class="headerlink" title="如何选择 Sourcemap"></a>如何选择 Sourcemap</h2><ul><li>首先在源代码的列信息意义不大，因为只要有行信息就能完整的建立打包前后代码之间的依赖关系，够我们定位了。</li><li>其次，不管在生产环境还是开发环境，我们都需要定位 debug 到最最原始的资源，比如定位错误到 jsx 的原始代码处，而不是编译成 js 的代码处，因此，不能忽略 module 属性。</li><li><code>eval-source-map</code> 使用 DataURL 本身包含完整 sourcemap 信息，并不需要像 sourceURL 那样，浏览器需要发送一个完整请求去获取 sourcemap 文件，这会略微提高点效率</li></ul><p>开发环境中使用：<strong>cheap-module-eval-source-map</strong>（该配置值能保留 loader 处理前的原始代码信息，而打包速度也较快，是一个较佳的选择。）</p><p>生产环境中使用 sourcemap 会有泄露源代码的风险，但如果要保留定位线上的错误，应该禁止浏览器开发者工具看到源代码，而是用一些错误收集系统，将 sourcemap 文件传到系统上，通过系统 source map 分析出原始代码的错误堆栈，如使用<code>hidden-source-map</code>。</p><p>当然，也有使用<code>nosources-source-map</code>, <code>source-map</code>的，依据你们需求场景选择。总之，最终结果是不能被人通过开发者工具看到源代码的。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a674f3f10dc0482da017738a79772d50~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>我们项目目前还是 Webpack4.x，如果你们项目已经用 Webpack5，sourcemap 名称有些不<br>同，具体请查阅 Webpack5 文档。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/forthealllight/blog/issues/6" target="_blank" rel="noopener">Webpack 中的 sourcemap 以及如何在生产和开发环境中合理的设置 sourcemap 的类型</a></p><br><p>ps：</p><ul><li><a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a></li></ul>]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>SourceMap</tag>
      </tags>
  </entry>
  <entry>
    <title>带你入门体验 Vue3</title>
    <url>/2021/03/09/%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C-Vue3/</url>
    <content><![CDATA[<p>本文同步发布在我的<a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">Github 个人博客</a></p><p>一直都是 React 进行开发，虽然 Vue 是接触最早的，但现在实际工作也不怎么有机会用，Vue3 都出了。其中新写法有点像 React Hook，于是，这段时间迅速对 Vue3 进行了基本知识入门，体验下 Vue3。</p><a id="more"></a><h2 id="Vue2-x-有哪些痛点"><a href="#Vue2-x-有哪些痛点" class="headerlink" title="Vue2.x 有哪些痛点"></a>Vue2.x 有哪些痛点</h2><p>首先 Vue3 出现之前，让我们来理理 Vue2.x 有什么痛点，需要 Vue3 补上的。</p><ul><li>Vue2.x 对数组对象的深层监听无法实现。因为组件每次渲染都是将 data 里的数据通过 defineProperty 进行响应式或者双向绑定上，之前没有后加的属性是不会被绑定上，也就不会触发更新渲染。</li><li>代码的可读性随着组件变大而变差</li><li>每一种代码复用的方式，都存在缺点</li><li>vue2.x 对 typescript 支持不太友好，需要使用一堆装饰器语法</li></ul><h2 id="Options-API-到-Composition-API-的转变"><a href="#Options-API-到-Composition-API-的转变" class="headerlink" title="Options API 到 Composition API 的转变"></a>Options API 到 Composition API 的转变</h2><p>Options API 即是通过定义 methods，computed，watch，data 等属性与方法，共同处理页面逻辑。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9c1026434744a1bae136ac31e1bcac4~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>可以看到 Options 代码编写方式，如果是组件状态，则写在 data 属性上，如果是方法，则写在 methods 属性上</p><p>当组件变得复杂时，会导致对应属性的列表也会增长，这可能会导致组件难以阅读和理解。</p><p>下面表示组件是一个大型组件（不同颜色表示不同逻辑），会看到同个功能逻辑的代码被分散到各处，这种碎片化使得理解和维护复杂组件变得困难，需要不断”跳”到相关代码处。<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de12120d2468456fb75465ecae3b9ee0~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>而 Composition API 是根据逻辑功能来组织的，一个功能所定义的所有 API 会放在一起（更加的高内聚，低耦合）</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f21b64d574254722b9a13d3b491aeedb~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>用 Composition API 来表示一个大型组件与上面 Options API 的对比，可以直观地感受到 Composition API 在逻辑组织方面的优势，以后修改一个属性功能的时候，只需要跳到控制该属性的方法中即可，在逻辑组织和逻辑复用方面更好。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4cd55d676c034223a99adc64936d39ef~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>Options API 是面向对象的思想，Composition API 是函数式编程的思想。</p><p>Vue3 将 Vue2.x 里面的 Options API，细粒度拆分成细小的函数，然后统一放到 setup 这一个入口函数中调用。</p><p>这样做的好处：</p><ul><li>保留了 Vue2.x 中各个函数的功能，做到兼容</li><li>同时以小的函数形式被调用，更加灵活，更好维护，更好 tree-shaking</li></ul><h2 id="vue3-有哪些优化"><a href="#vue3-有哪些优化" class="headerlink" title="vue3 有哪些优化"></a>vue3 有哪些优化</h2><ul><li>打包大小减少 41%，初次渲染快 55%，更新快 133%，内存使用减少 54%（官方数据）</li><li>采用 Typescript 开发，更好支持 Typescript</li><li>使用 Proxy 代替 vue2.x 中的 defineProperty，能够深层监听数组对象的变化。</li><li>Options API 到 Composition API，使复杂组件逻辑复用变得更容易和维护。</li></ul><h2 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h2><p>字面意思就是组合式 API，也就是将原来的很多底层的方法拆分开，暴露出来让大家去使用。</p><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p><code>setup</code> 是 Composition API 的核心，它在<code>props</code>、<code>data</code>、<code>computed</code>、<code>methods</code>、<code>生命周期函数</code>之前运行的。</p><p>它返回一个对象，该对象上的属性将合并到组件模板的渲染上下文中，还可以返回一个 render 函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;setup&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="comment">// Composition API 逻辑组织的入口</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>它将 Vue2.x 中的 <code>beforeCreate</code> 和 <code>created</code> 代替了，以一个 <code>setup</code> 函数的形式灵活组织代码；还可以 return 数据或者 template，相当于把 data 和 render 也一并代替了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; foo &#125;&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">"ts"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="number">2</span> <span class="comment">// 普通变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo, <span class="comment">// 必须 return 出去才能在模板使用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>顺带一提，通常为了在 TypeScript 下能让组件有正确的参数类型推断、IDE 有更好的提示效果，会在<code>export default</code>处再包一层函数<code>defineComponent</code>（该函数只返回传递给它的对象）</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script lang=<span class="string">"ts"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="comment">// Composition API 逻辑组织的入口</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p><strong><code>setup</code>函数使用需要注意的点：</strong></p><ul><li>由于在执行<code>setup</code>函数的时候，还没有执行<code>created</code> 生命周期方法，所以在<code>setup</code> 函数中，无法使用 <code>data</code>和 <code>methods</code> 的变量和方法</li><li><code>setup</code>函数只能是同步的不能是异步的</li></ul><p>由于 <code>setup</code> 是一个入口函数，本质是面向函数编程，而 <code>this</code> 是面向对象的一种体现，这里其实相当于取消<code>this</code>了，在 Vue3<code>setup</code> 函数里的<code>this</code>为 <code>undefined</code>。</p><p>而取消了<code>this</code>，取而代之的是<code>setup</code>增加了 2 个参数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">props：组件参数</span><br><span class="line">context：上下文信息（如attrs、slots、emit）</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    title: <span class="built_in">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.log(props.title, context)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      foo,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>接受一个内部值并返回一个响应式且可变的 ref 对象（响应式对象），<code>ref()</code>创建的数据会触发模版更新。ref 对象具有指向内部值的单个 property <code>.value</code>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">    &lt;button @click=<span class="string">"handleClick"</span>&gt;加<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; defineComponent, ref &#125; from 'vue'</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default defineComponent(&#123;</span></span><br><span class="line"><span class="regexp">  setup() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 被 ref 方法包裹后的元素就变成了一个代理对象</span></span><br><span class="line"><span class="regexp">    const count = ref(0)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    const handleClick = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      count.value++ /</span><span class="regexp">/ 在setup里面使用ref代理对象需要 `.value`，模板中使用时由于vue帮我们做了自动解析所以不用 `.value`</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      count,</span></span><br><span class="line"><span class="regexp">      handleClick,</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>reactive 也是实现响应式的一种方法，它接收一个普通对象然后返回该普通对象的响应式代理，相当于 Vue2.x 中的 <code>Vue.observable()</code></p><p>一般约定 reactive 的参数是一个对象，而<code>ref</code>的参数通常是原始数据类型，虽然反过来也可以。</p><p><code>ref</code>的本质还是 reactive 系统会自动根据<code>ref()</code>函数的入参将其转换成<code>ref(x)</code>即<code>reactive({ value:x })</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; obj1.count1 &#125;&#125;</span><br><span class="line">    &#123;&#123; count2 &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">"ts"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> obj1 = reactive(&#123;</span><br><span class="line">      count1: <span class="number">10</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> obj2 = reactive(&#123;</span><br><span class="line">      count2: <span class="number">20</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      obj1,</span><br><span class="line">      ...toRefs(obj2),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码可以看到，直接 return obj1，在模板使用时需要<code>obj.count1</code>，那为什么不直接<code>...obj1</code>呢，那是因为 obj1 是<code>proxy</code>代理对象，整个对象都是响应式，所以不能使用剩余运算符。</p><p>如果觉得麻烦，可以使用<code>...toRefs(obj2)</code>，这样就可以在模板直接使用定义的数据了。</p><blockquote><p><code>toRefs</code> 函数是将<code>reactive</code>创建的响应式对象，转化成为普通的对象，并且这个对象上的每个节点，都是<code>ref</code>类型的响应式数据</p></blockquote><h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><p>可以用来为源响应式对象上的某个 property 新创建一个 ref。然后，ref 可以被传递，它会保持对其源 property 的响应式连接。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">      foo: <span class="number">1</span>,</span><br><span class="line">      bar: <span class="number">2</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> fooRef = toRef(state, <span class="string">'foo'</span>)</span><br><span class="line"></span><br><span class="line">    fooRef.value++</span><br><span class="line">    <span class="built_in">console</span>.log(state.foo) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    state.foo++</span><br><span class="line">    <span class="built_in">console</span>.log(fooRef.value) <span class="comment">// 3</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>toRef()</code>接收两个参数，第一个为对象，第二个为对象中的某个属性。它是对原数据的一个引用，当值改变时会影响到原始值；创建的响应式数据并不会触发 vue 模版更新。</p><h3 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h3><p>将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的 ref。</p><p><code>toRefs()</code>接收一个对象作为参数，并遍历对象身上的所有属性，然后逐个调用<code>toRef()</code>执行。以此，将响应式对象转化为普通对象，便于在模版中可以直接使用属性。</p><p>通常用来将一组的响应式对象拆成单个的响应式对象，如将一个 reactive 代理对象打平，转换为 ref 代理对象，使得对象的属性可以直接在 template 上使用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; foo &#125;&#125;</span><br><span class="line">    &#123;&#123; bar &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">"ts"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent, reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="comment">// 创建一个响应式对象state</span></span><br><span class="line">    <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">      foo: <span class="number">1</span>,</span><br><span class="line">      bar: <span class="number">2</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> stateAsRefs = toRefs(state) <span class="comment">// 将响应式的对象变为普通对象结构, 且能使用ES6的扩展运算符，也仍具有响应性</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ref 和原始 property 已经“链接”起来了</span></span><br><span class="line">    state.foo++</span><br><span class="line">    <span class="built_in">console</span>.log(stateAsRefs.foo.value) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    stateAsRefs.foo.value++</span><br><span class="line">    <span class="built_in">console</span>.log(state.foo) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...stateAsRefs,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>接受一个 getter 函数，并为从 getter 返回的值返回一个不变的响应式 ref 对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> plusOne = computed(<span class="function"><span class="params">()</span> =&gt;</span> count.value + <span class="number">1</span>) <span class="comment">// 结果是一个 ref 代理对象，取值需要 .value</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(plusOne.value) <span class="comment">// 2</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>与 Vue2.x 中的作用类似，获取一个计算结果。当 computed 参数使用 object 对象书写时，不仅支持取值 get（默认），还支持赋值 set。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">  <span class="keyword">const</span> count = ref(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">const</span> plusOne = computed(&#123;</span><br><span class="line">    <span class="keyword">get</span>: () =&gt; count.value + 1,</span><br><span class="line">    <span class="keyword">set</span>: (val) =&gt; &#123;</span><br><span class="line">      count.value = val - <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  plusOne.value = <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(count.value) <span class="comment">// 0</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>watch API 与选项式 API <code>this.$watch</code> (以及相应的 watch 选项) 完全等效。watch 需要侦听特定的数据源，并在单独的回调函数中执行副作用。默认情况下，它也是惰性的——即回调仅在侦听源发生更改时被调用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">    &lt;button @click=<span class="string">"changeCount"</span>&gt;count加<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; defineComponent, watch, ref &#125; from 'vue'</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default defineComponent(&#123;</span></span><br><span class="line"><span class="regexp">  setup() &#123;</span></span><br><span class="line"><span class="regexp">    const count = ref(0)</span></span><br><span class="line"><span class="regexp">    const changeCount = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      count.value++</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    watch(count, (newCount, prevCount) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      console.log('newCount:', newCount, ' oldCount:', prevCount)</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      count,</span></span><br><span class="line"><span class="regexp">      changeCount,</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>也可以使用数组同时侦听多个源。</p><h3 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h3><p>在响应式地跟踪其依赖项时立即执行传入的一个函数，并在更改依赖项时重新运行它。</p><p>当组件的 setup()或者生命周期钩子被调用时，watchEffect 会被链接到该组件的生命周期，并在组件卸载时自动停止。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">    &lt;button @click=<span class="string">"changeCount"</span>&gt;count加<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; defineComponent, ref, watchEffect &#125; from 'vue'</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default defineComponent(&#123;</span></span><br><span class="line"><span class="regexp">  setup() &#123;</span></span><br><span class="line"><span class="regexp">    const count = ref(0)</span></span><br><span class="line"><span class="regexp">    const changeCount = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      count.value++</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    watchEffect(() =&gt; console.log(count.value))</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ -&gt; logs 0</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      count.value++</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ -&gt; logs 1</span></span><br><span class="line"><span class="regexp">    &#125;, 100)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      count,</span></span><br><span class="line"><span class="regexp">      changeCount,</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p><strong>watch 与 watchEffect 比较，watch 允许我们</strong></p><ul><li>惰性地执行副作用；</li><li>更具体地说明应触发侦听器重新运行的状态；</li><li>访问被侦听状态的先前值和当前值。</li></ul><h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>接受一个对象 (响应式或纯对象) 或 ref 并返回原始对象的只读代理。只读代理是深层的：任何被访问的嵌套 property 也是只读的。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setup() &#123;</span><br><span class="line">  <span class="keyword">const</span> original = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回的 readonly 对象，一旦修改就会在 console 有 warning 警告。程序还是会照常运行，不会报错。</span></span><br><span class="line">  <span class="keyword">const</span> copy = readonly(original)</span><br><span class="line"></span><br><span class="line">  watchEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只要有数据变化，这个函数都会执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(copy.count)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里会触发 watchEffect</span></span><br><span class="line">  original.count++</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里不会触发上方的 watchEffect，因为是 readonly。</span></span><br><span class="line">  copy.count++ <span class="comment">// warning!</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="Fragments-Template"><a href="#Fragments-Template" class="headerlink" title="Fragments Template"></a>Fragments Template</h3><p>Vue3.x 中，可以不用唯一根节点。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure><h3 id="Teleport-组件"><a href="#Teleport-组件" class="headerlink" title="Teleport 组件"></a>Teleport 组件</h3><p>Teleport 在国内翻译成了瞬间移动组件或者独立组件，它可以把你写的组件挂载到任何你想挂载的 DOM 上。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"user-card"</span>&gt;</span><br><span class="line">    &lt;b&gt; &#123;&#123; name &#125;&#125; &lt;<span class="regexp">/b&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button @click="isModalOpen = true"&gt;删除用户&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 注意这一块代码 --&gt;</span><br><span class="line">    &lt;Teleport to=<span class="string">"#modal"</span>&gt;</span><br><span class="line">      &lt;div v-show=<span class="string">"isModalOpen"</span>&gt;</span><br><span class="line">        &lt;p&gt;确定删除?&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button @click="removeUser"&gt;确定&lt;/</span>button&gt;</span><br><span class="line">        &lt;button @click=<span class="string">"isModalOpen = false"</span>&gt;取消&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/Teleport&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script lang="ts"&gt;</span></span><br><span class="line"><span class="regexp">import &#123; defineComponent, reactive, ref, toRefs &#125; from 'vue'</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default defineComponent(&#123;</span></span><br><span class="line"><span class="regexp">  setup() &#123;</span></span><br><span class="line"><span class="regexp">    const isModalOpen = ref(false)</span></span><br><span class="line"><span class="regexp">    const user = reactive(&#123;</span></span><br><span class="line"><span class="regexp">      name: 'jacky',</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    const removeUser = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      console.log('removeUser')</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      isModalOpen,</span></span><br><span class="line"><span class="regexp">      removeUser,</span></span><br><span class="line"><span class="regexp">      ...toRefs(user),</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b44366dd9a654ef9b540d89132d43936~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>运行这段代码之前，需要去<code>./public/index.html</code>加上个 id 为<code>modal</code>元素供挂载，当然也可以到组件里面添加。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"modal"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Teleport 提供了一种干净的方法，允许我们控制在 DOM 中哪个父节点下渲染了 HTML，而不必求助于全局状态或将其拆分为两个组件。</p><h3 id="Suspense-组件"><a href="#Suspense-组件" class="headerlink" title="Suspense 组件"></a>Suspense 组件</h3><p>Suspense 提供两个 template 的位置，一个是没有请求未完成或失败显示的内容，一个是全部请求完毕的内容。这样进行异步内容的渲染就会非常简单。</p><p>下面 Demo 我就模拟一下用法，不写真实请求了。</p><p>新建<code>AsyncShow.vue</code>组件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; result &#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">import &#123; defineComponent &#125; from 'vue'</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default defineComponent(&#123;</span></span><br><span class="line"><span class="regexp">  name: 'AsyncShow',</span></span><br><span class="line"><span class="regexp">  setup() &#123;</span></span><br><span class="line"><span class="regexp">    return new Promise((resolve) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      setTimeout(() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">        return resolve(&#123;</span></span><br><span class="line"><span class="regexp">          result: '这是请求结果',</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">      &#125;, 3000)</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure><p>新建<code>Suspense.vue</code>组件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Suspense&gt;</span><br><span class="line">      &lt;template #default&gt;</span><br><span class="line">        &lt;!-- 请求成功展示 --&gt;</span><br><span class="line">        &lt;<span class="keyword">async</span>-show /&gt;</span><br><span class="line">      &lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">      &lt;template #fallback&gt;</span></span><br><span class="line"><span class="regexp">        &lt;!-- 请求中和失败展示 --&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h2&gt;Promise Loading...（请求中）&lt;/</span>h2&gt;</span><br><span class="line">      &lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Suspense&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">"ts"</span>&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; defineComponent &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> AsyncShow <span class="keyword">from</span> <span class="string">'./AsyncShow.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> defineComponent(&#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    AsyncShow,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Vue3-x-生命周期变化"><a href="#Vue3-x-生命周期变化" class="headerlink" title="Vue3.x 生命周期变化"></a>Vue3.x 生命周期变化</h2><h3 id="被替换"><a href="#被替换" class="headerlink" title="被替换"></a>被替换</h3><ul><li>beforeCreate -&gt; setup()</li><li>created -&gt; setup()</li></ul><h3 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h3><p>生命周期方法前面都统一加了<code>on</code>；<code>destroy</code>被改名成<code>Unmount</code>更贴切也对应<code>Mount</code></p><ul><li>beforeMount -&gt; onBeforeMount</li><li>mounted -&gt; onMounted</li><li>beforeUpdate -&gt; onBeforeUpdate</li><li>updated -&gt; onUpdated</li><li>beforeDestroy -&gt; onBeforeUnmount</li><li>destroyed -&gt; onUnmounted</li><li>errorCaptured -&gt; onErrorCaptured</li></ul><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><p>新增的以下 2 个方便调试 debug 的回调钩子：</p><ul><li>onRenderTracked：状态跟踪，它会跟踪页面上所有响应式变量和方法的状态，也就是我们用 return 返回去的值，他都会跟踪。只要页面有 update 的情况，他就会跟踪，然后生成一个 event 对象，我们通过 event 对象来查找程序的问题所在。</li><li>onRenderTriggered：状态触发，它不会跟踪每一个值，而是给你变化值的信息，并且新值和旧值都会给你明确的展示出来。</li></ul><h3 id="新旧生命周期谁先运行？"><a href="#新旧生命周期谁先运行？" class="headerlink" title="新旧生命周期谁先运行？"></a>新旧生命周期谁先运行？</h3><ul><li>在 Vue2.x 中通过补丁形式引入 Composition API，进行 Vue2.x 和 Vue3.x 的回调函数混用时：Vue2.x 的回调函数会相对先执行，比如：mounted 优先于 onMounted。</li><li>在 Vue3.x 中，为了兼容 Vue2.x 的语法，所有旧的生命周期函数得到保留（除了 beforeDestroy 和 destroyed）。当生命周期混合使用时：Vue3.x 的生命周期相对优先于 Vue2.x 的执行，比如：onMounted 比 mounted 先执行。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>暂时就写这么多了，并不完全，但也能大概对 Vue3 有个初步了解了。</p><p>本文案例代码：<a href="https://github.com/Jacky-Summer/vue-tutorial" target="_blank" rel="noopener">vue3-tutorial</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844904096265142279" target="_blank" rel="noopener">vue2.x/React/vue3.x 简单横评（4）</a></li><li><a href="https://juejin.cn/post/6899702587977646088" target="_blank" rel="noopener">vue3 composition api</a></li><li><a href="https://www.cnblogs.com/houxianzhou/p/14368919.html" target="_blank" rel="noopener">Vue3.0 所采用的 Composition Api 与 Vue2.x 使用的 Options Api 有什么不同？</a></li></ul>]]></content>
      <categories>
        <category>Vue 系列</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Vue3</tag>
        <tag>Composition API</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析 requestIdleCallback</title>
    <url>/2021/02/25/%E6%B5%85%E6%9E%90-requestIdleCallback/</url>
    <content><![CDATA[<p>最近在研究 React Fiber 相关的知识，上一篇文章 <a href="https://juejin.cn/post/6926432527980691470" target="_blank" rel="noopener">浅谈对 React Fiber 的理解</a> 简单提到了 requestIdleCallback， React 源码中 polyfill 了这个方法，了解它对 Fiber 也能有进一步理解。本篇会深入介绍下这个方法。</p><a id="more"></a><h2 id="requestIdleCallback-是什么"><a href="#requestIdleCallback-是什么" class="headerlink" title="requestIdleCallback 是什么"></a>requestIdleCallback 是什么</h2><p>requestIdleCallback 是 window 属性上的方法，它的作用是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务。</p><h2 id="为什么需要-requestIdleCallback"><a href="#为什么需要-requestIdleCallback" class="headerlink" title="为什么需要 requestIdleCallback"></a>为什么需要 requestIdleCallback</h2><p>在网页运行中，有很多耗时但又不是那么重要的任务。这些任务和重要的任务如对用户的输入作出及时响应的之类的任务，它们共享事件队列。如果两者发生冲突，用户体验会很糟糕。</p><p>requestIdleCallback 就解决了这个痛点，requestIdleCallback 会在每一帧结束时并且有空闲时间执行回调。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ea116d4702c45edaf176599952cb0af~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>假设需要大量涉及到 DOM 的操作的计算，在运算时，浏览器可能就会出现明显的卡顿行为，甚至不能进行任何操作，因为是 JS 单线程，就算用在输入处理，给定帧渲染和合成之后，用户的主线程就会变得空闲，直到下一帧的开始。</p><p>而这些空闲时间可以拿来处理低优先级的任务，React16 的调度策略异步可中断，其中关键就靠的这个（polyfill）方法功能；React 把任务细分（时间切片），在浏览器空闲的时间去执行，从而尽可能地提高渲染性能。</p><p>时间切片的本质是模拟实现 requestIdleCallback</p><p>讲到这里，从 React15 到 React16 Fiber，对整体性能来说是大优化了；但要知道的是，React16 相对 15 做出的优化，并不是大大减少了任务量，你写的代码的任务总量并没有变化，只是把空闲时间利用起来了，不停的干活，就能更快的把活干完；这只是其中一个角度，React 还做了区分优先级执行等等。</p><h2 id="屏幕刷新率和-FPS-的关系"><a href="#屏幕刷新率和-FPS-的关系" class="headerlink" title="屏幕刷新率和 FPS 的关系"></a>屏幕刷新率和 FPS 的关系</h2><p>当前大多数的屏幕刷新率都是 60HZ，一秒 60 帧（FPS 为 60），也就是每秒屏幕刷新 60 次，此时一帧的时间为 16.7ms（1000ms/60）低于 60HZ 人眼就会感知卡顿掉帧等情况。</p><blockquote><p>浏览器的一帧说的就是一次完整的重绘。</p></blockquote><p>前端浏览器所说的渲染频率 FPS(Frames Per Second)是每秒传输帧数，即是每秒刷新的次数，理论上 FPS 越高人眼觉得界面越流畅。</p><h2 id="window-requestIdleCallback-用法"><a href="#window-requestIdleCallback-用法" class="headerlink" title="window.requestIdleCallback() 用法"></a>window.requestIdleCallback() 用法</h2><p>window.requestIdleCallback()方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间 timeout，则有可能为了在超时前执行函数而打乱执行顺序。</p><p>你可以在空闲回调函数中调用 requestIdleCallback()，以便在下一次通过事件循环之前调度另一个回调。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="built_in">window</span>.requestIdleCallback(callback[, options])</span><br></pre></td></tr></table></figure><p>返回一个 ID 标识符。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">callback：</span><br><span class="line">一个在事件循环空闲时即将被调用的函数的引用。函数会接收到一个名为 deadline 的参数，这个参数可以获取当前空闲时间以及回调是否在超时时间前已经执行的状态；该对象上有两个属性：</span><br><span class="line">  - timeRemaining：timeRemaining属性是一个函数，函数的返回值表示返回当前空闲时间的剩余时间</span><br><span class="line">  - didTimeout：didTimeout属性是一个布尔值，如果didTimeout是true，那么表示本次callback的执行是因为超时的原因</span><br><span class="line"></span><br><span class="line">options 可选</span><br><span class="line">包括可选的配置参数。具有如下属性：</span><br><span class="line">timeout：如果指定了timeout并具有一个正值，并且尚未通过超时毫秒数调用回调，那么回调会在下一次空闲时期被强制执行，尽管这样很可能会对性能造成负面影响。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNonEssentialWork</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> ((deadline.timeRemaining() &gt; <span class="number">0</span> || deadline.didTimeout) &amp;&amp; tasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    doWorkIfNeeded()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tasks.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    requestIdleCallback(myNonEssentialWork)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestIdleCallback(myNonEssentialWork, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure><p>来看一个实际的例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">requestIdleCallback(myWork)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个任务队列</span></span><br><span class="line"><span class="keyword">let</span> tasks = [</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">t1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行任务1'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">t2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行任务2'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">t3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'执行任务3'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// deadline是requestIdleCallback返回的一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myWork</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`当前帧剩余时间: <span class="subst">$&#123;deadline.timeRemaining()&#125;</span>`</span>)</span><br><span class="line">  <span class="comment">// 查看当前帧的剩余时间是否大于0 &amp;&amp; 是否还有剩余任务</span></span><br><span class="line">  <span class="keyword">if</span> (deadline.timeRemaining() &gt; <span class="number">0</span> &amp;&amp; tasks.length) &#123;</span><br><span class="line">    <span class="comment">// 在这里做一些事情</span></span><br><span class="line">    <span class="keyword">const</span> task = tasks.shift()</span><br><span class="line">    task()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果还有任务没有被执行，那就放到下一帧调度中去继续执行，类似递归</span></span><br><span class="line">  <span class="keyword">if</span> (tasks.length) &#123;</span><br><span class="line">    requestIdleCallback(myWork)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的运行结果如下（每次运行，不同机器运行都不一样）：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当前帧剩余时间: 15.120000000000001</span><br><span class="line">执行任务1</span><br><span class="line">当前帧剩余时间: 15.445000000000002</span><br><span class="line">执行任务2</span><br><span class="line">当前帧剩余时间: 15.21</span><br><span class="line">执行任务3</span><br></pre></td></tr></table></figure><p>如果是因为 timeout 回调才得以执行的话，其实用户就有可能会感觉到卡顿了，因为一帧的执行时间必然已经超过 16ms 了</p><h2 id="requestIdleCallback-方法的缺陷"><a href="#requestIdleCallback-方法的缺陷" class="headerlink" title="requestIdleCallback 方法的缺陷"></a>requestIdleCallback 方法的缺陷</h2><p>这个方法理论上可行，但为什么 React 团队又 polyfill 这个方法呢？</p><ol><li><p>浏览器兼容不好的问题</p></li><li><p>requestIdleCallback 的 FPS 只有 20，也就是 50ms 刷新一次，远远低于页面流畅度的要求，所以 React 团队需要自己实现。</p></li></ol><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc589c5d1b0f4c30997ed0fda92f68fe~tplv-k3u1fbpfcp-watermark.image" alt=""></p><blockquote><p>注意：timeRemaining 最大为 50ms，是有根据研究得出的，即是说人对用户输入的 100 毫秒以内的响应通常被认为是瞬时的，不会被人察觉到。将空闲时间限制在 50ms 内意味着即使在闲置任务开始后立即发生用户操作，用户代理仍然有剩余的 50ms 可以在其中响应用户输入而不会产生用户可察觉的滞后。</p></blockquote><h2 id="requestIdleCallback-和-requestAnimationFrame-区别"><a href="#requestIdleCallback-和-requestAnimationFrame-区别" class="headerlink" title="requestIdleCallback 和 requestAnimationFrame 区别"></a>requestIdleCallback 和 requestAnimationFrame 区别</h2><ul><li>requestAnimationFrame 的回调会在每一帧确定执行，属于高优先级任务</li><li>requestIdleCallback 的回调则不一定，有空闲时间才执行，属于低优先级任务。</li></ul><blockquote><p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行</p></blockquote><p>requestAnimationFrame 比起 setTimeout、setInterval 的优势主要有两点：</p><ul><li><p>requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒 60 帧。</p></li><li><p>在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。</p></li></ul><h2 id="模拟实现-requestIdleCallback"><a href="#模拟实现-requestIdleCallback" class="headerlink" title="模拟实现 requestIdleCallback"></a>模拟实现 requestIdleCallback</h2><h3 id="setTimeout-模拟"><a href="#setTimeout-模拟" class="headerlink" title="setTimeout 模拟"></a>setTimeout 模拟</h3><p>当然一般不会用 setTimeout 的，因为误差很大</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.requestIdleCallback = <span class="function"><span class="keyword">function</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="built_in">Date</span>.now()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    handler(&#123;</span><br><span class="line">      didTimeout: <span class="literal">false</span>,</span><br><span class="line">      timeRemaining: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.max(<span class="number">0</span>, <span class="number">50.0</span> - (<span class="built_in">Date</span>.now() - startTime))</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 团队则是用 requestAnimationFrame 和 postMessage 模拟实现的，本篇就不讲了，有兴趣的可以去了解看看。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://juejin.cn/post/6844904196345430023" target="_blank" rel="noopener">熟悉 requestidlecallback 到了解 react ric polyfill 实现</a></li><li><a href="https://juejin.cn/post/6861590253434585096" target="_blank" rel="noopener">react 中 requestIdleCallback 的实现原理</a></li></ul><br><p>我近期会维护的开源项目：</p><ul><li><a href="https://github.com/Jacky-Summer/monki-ui" target="_blank" rel="noopener">基于 React + TypeScript + Dumi + Jest + Enzyme 开发 UI 组件库</a></li><li><a href="https://github.com/Jacky-Summer/nextjs-ts-antd-redux-storybook-starter" target="_blank" rel="noopener">Next.js 企业级项目脚手架模板</a></li><li><a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a><br>觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>requestIdleCallback</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈对 React Fiber 的理解</title>
    <url>/2021/02/07/%E6%B5%85%E8%B0%88%E5%AF%B9-React-Fiber-%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>本文作为自己深入学习 React Fiber (<code>Reactv16.8.6</code>)的理解，本篇仅介绍大致流程，Fiber 详细源码本文不作细节描述。</p><p>本文同步发布在我的 <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">Github 个人博客</a></p><a id="more"></a><h2 id="Fiber-出现的背景"><a href="#Fiber-出现的背景" class="headerlink" title="Fiber 出现的背景"></a>Fiber 出现的背景</h2><p>首先要知道的是，JavaScript 引擎和页面渲染引擎两个线程是互斥的，当其中一个线程执行时，另一个线程只能挂起等待。</p><p>在这样的机制下，如果 JavaScript 线程长时间地占用了主线程，那么渲染层面的更新就不得不长时间地等待，界面长时间不更新，会导致页面响应度变差，用户可能会感觉到卡顿。</p><p>而这正是 React 15 的 Stack Reconciler 所面临的问题，即是 JavaScript 对主线程的超时占用问题。Stack Reconciler 是一个同步的递归过程，使用的是 JavaScript 引擎自身的函数调用栈，它会一直执行到栈空为止，所以当 React 在渲染组件时，从开始到渲染完成整个过程是一气呵成的。如果渲染的组件比较庞大，js 执行会占据主线程较长时间，会导致页面响应度变差。</p><p>而且所有的任务都是按照先后顺序，没有区分优先级，这样就会导致优先级比较高的任务无法被优先执行。</p><h2 id="Fiber-是什么"><a href="#Fiber-是什么" class="headerlink" title="Fiber 是什么"></a>Fiber 是什么</h2><p>Fiber 的中文翻译叫纤程，与进程、线程同为程序执行过程，Fiber 就是比线程还要纤细的一个过程。纤程意在对渲染过程实现进行更加精细的控制。</p><p>从架构角度来看，Fiber 是对 React 核心算法（即调和过程）的重写。</p><p>从编码角度来看，Fiber 是 React 内部所定义的一种数据结构，它是 Fiber 树结构的节点单位，也就是 React 16 新架构下的”虚拟 DOM”。</p><p>一个 fiber 就是一个 JavaScript 对象，Fiber 的数据结构如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">type Fiber = &#123;</span><br><span class="line">  <span class="comment">// 用于标记fiber的WorkTag类型，主要表示当前fiber代表的组件类型如FunctionComponent、ClassComponent等</span></span><br><span class="line">  tag: WorkTag,</span><br><span class="line">  <span class="comment">// ReactElement里面的key</span></span><br><span class="line">  key: <span class="literal">null</span> | string,</span><br><span class="line">  <span class="comment">// ReactElement.type，调用`createElement`的第一个参数</span></span><br><span class="line">  elementType: any,</span><br><span class="line">  <span class="comment">// The resolved function/class/ associated with this fiber.</span></span><br><span class="line">  <span class="comment">// 表示当前代表的节点类型</span></span><br><span class="line">  type: any,</span><br><span class="line">  <span class="comment">// 表示当前FiberNode对应的element组件实例</span></span><br><span class="line">  stateNode: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向他在Fiber节点树中的`parent`，用来在处理完这个节点之后向上返回</span></span><br><span class="line">  <span class="keyword">return</span>: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向自己的第一个子节点</span></span><br><span class="line">  child: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 指向自己的兄弟结构，兄弟节点的return指向同一个父节点</span></span><br><span class="line">  sibling: Fiber | <span class="literal">null</span>,</span><br><span class="line">  index: number,</span><br><span class="line"></span><br><span class="line">  ref: <span class="literal">null</span> | <span class="function">(<span class="params">((handle: mixed</span>) =&gt;</span> <span class="keyword">void</span>) &amp; &#123; <span class="attr">_stringRef</span>: ?string &#125;) | RefObject,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前处理过程中的组件props对象</span></span><br><span class="line">  pendingProps: any,</span><br><span class="line">  <span class="comment">// 上一次渲染完成之后的props</span></span><br><span class="line">  memoizedProps: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该Fiber对应的组件产生的Update会存放在这个队列里面</span></span><br><span class="line">  updateQueue: UpdateQueue&lt;any&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上一次渲染的时候的state</span></span><br><span class="line">  memoizedState: any,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个列表，存放这个Fiber依赖的context</span></span><br><span class="line">  firstContextDependency: ContextDependency&lt;mixed&gt; | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  mode: TypeOfMode,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Effect</span></span><br><span class="line">  <span class="comment">// 用来记录Side Effect</span></span><br><span class="line">  effectTag: SideEffectTag,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单链表用来快速查找下一个side effect</span></span><br><span class="line">  nextEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子树中第一个side effect</span></span><br><span class="line">  firstEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line">  <span class="comment">// 子树中最后一个side effect</span></span><br><span class="line">  lastEffect: Fiber | <span class="literal">null</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 代表任务在未来的哪个时间点应该被完成，之后版本改名为 lanes</span></span><br><span class="line">  expirationTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 快速确定子树中是否有不在等待的变化</span></span><br><span class="line">  childExpirationTime: ExpirationTime,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fiber的版本池，即记录fiber更新过程，便于恢复</span></span><br><span class="line">  alternate: Fiber | <span class="literal">null</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 2020 年 5 月，以 expirationTime 属性为代表的优先级模型被 lanes 取代。</p></blockquote><h2 id="Fiber-如何解决问题的"><a href="#Fiber-如何解决问题的" class="headerlink" title="Fiber 如何解决问题的"></a>Fiber 如何解决问题的</h2><p>Fiber 把一个渲染任务分解为多个渲染任务，而不是一次性完成，把每一个分割得很细的任务视作一个”执行单元”，React 就会检查现在还剩多少时间，如果没有时间就将控制权让出去，故任务会被分散到多个帧里面，中间可以返回至主进程控制执行其他任务，最终实现更流畅的用户体验。</p><p>即是实现了”增量渲染”，实现了可中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber 节点。</p><h2 id="Fiber-实现原理"><a href="#Fiber-实现原理" class="headerlink" title="Fiber 实现原理"></a>Fiber 实现原理</h2><p>实现的方式是<code>requestIdleCallback</code>这一 API，但 React 团队 polyfill 了这个 API，使其对比原生的浏览器兼容性更好且拓展了特性。</p><blockquote><p><code>window.requestIdleCallback()</code>方法将在浏览器的空闲时段内调用的函数排队。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间 timeout，则有可能为了在超时前执行函数而打乱执行顺序。</p></blockquote><p><code>requestIdleCallback</code>回调的执行的前提条件是当前浏览器处于空闲状态。</p><p>即<code>requestIdleCallback</code>的作用是在浏览器一帧的剩余空闲时间内执行优先度相对较低的任务。首先 React 中任务切割为多个步骤，分批完成。在完成一部分任务之后，将控制权交回给浏览器，让浏览器有时间再进行页面的渲染。等浏览器忙完之后有剩余时间，再继续之前 React 未完成的任务，是一种合作式调度。</p><p>简而言之，由浏览器给我们分配执行时间片，我们要按照约定在这个时间内执行完毕，并将控制权还给浏览器。</p><p>React 16 的<code>Reconciler</code>基于 Fiber 节点实现，被称为 Fiber Reconciler。</p><p>作为静态的数据结构来说，每个 Fiber 节点对应一个 React element，保存了该组件的类型（函数组件/类组件/原生组件等等）、对应的 DOM 节点等信息。</p><p>作为动态的工作单元来说，每个 Fiber 节点保存了本次更新中该组件改变的状态、要执行的工作。</p><p>每个 Fiber 节点有个对应的 React element，多个 Fiber 节点是如何连接形成树呢？靠如下三个属性：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指向父级Fiber节点</span></span><br><span class="line"><span class="keyword">this</span>.return = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 指向子Fiber节点</span></span><br><span class="line"><span class="keyword">this</span>.child = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 指向右边第一个兄弟Fiber节点</span></span><br><span class="line"><span class="keyword">this</span>.sibling = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h2 id="Fiber-架构核心"><a href="#Fiber-架构核心" class="headerlink" title="Fiber 架构核心"></a>Fiber 架构核心</h2><p>Fiber 架构可以分为三层：</p><ul><li>Scheduler 调度器 —— 调度任务的优先级，高优任务优先进入 Reconciler</li><li>Reconciler 协调器 —— 负责找出变化的组件</li><li>Renderer 渲染器 —— 负责将变化的组件渲染到页面上</li></ul><p>相比 React15，React16 多了<strong>Scheduler（调度器）</strong>，调度器的作用是调度更新的优先级。</p><p>在新的架构模式下，工作流如下：</p><ul><li>每个更新任务都会被赋予一个优先级。</li><li>当更新任务抵达调度器时，高优先级的更新任务（记为 A）会更快地被调度进 Reconciler 层；</li><li>此时若有新的更新任务（记为 B）抵达调度器，调度器会检查它的优先级，若发现 B 的优先级高于当前任务 A，那么当前处于 Reconciler 层的 A 任务就会被中断，调度器会将 B 任务推入 Reconciler 层。</li><li>当 B 任务完成渲染后，新一轮的调度开始，之前被中断的 A 任务将会被重新推入 Reconciler 层，继续它的渲染之旅，即“可恢复”。</li></ul><p><strong>Fiber 架构的核心即是”可中断”、”可恢复”、”优先级”</strong></p><h3 id="Scheduler-调度器"><a href="#Scheduler-调度器" class="headerlink" title="Scheduler 调度器"></a>Scheduler 调度器</h3><p>这个需要上面提到的<code>requestIdleCallback</code>，React 团队实现了功能更完备的 <code>requestIdleCallback</code> polyfill，这就是 Scheduler。除了在空闲时触发回调的功能外，Scheduler 还提供了多种调度优先级供任务设置。</p><h3 id="Reconciler-协调器"><a href="#Reconciler-协调器" class="headerlink" title="Reconciler 协调器"></a>Reconciler 协调器</h3><p>在 React 15 中是递归处理虚拟 DOM 的，React 16 则是变成了可以中断的循环过程，每次循环都会调用<code>shouldYield</code>判断当前是否有剩余时间。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    <span class="comment">// workInProgress表示当前工作进度的树。</span></span><br><span class="line">    workInProgress = performUnitOfWork(workInProgress)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 16 是如何解决中断更新时 DOM 渲染不完全的问题呢？</p><p>在 React 16 中，<code>Reconciler</code>与<code>Renderer</code>不再是交替工作。当<code>Scheduler</code>将任务交给<code>Reconciler</code>后，<code>Reconciler</code>会为变化的虚拟 DOM 打上的标记。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Placement = <span class="comment">/*             */</span> <span class="number">0b0000000000010</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Update = <span class="comment">/*                */</span> <span class="number">0b0000000000100</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> PlacementAndUpdate = <span class="comment">/*    */</span> <span class="number">0b0000000000110</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Deletion = <span class="comment">/*              */</span> <span class="number">0b0000000001000</span></span><br></pre></td></tr></table></figure><ul><li><code>Placement</code>表示插入操作</li><li><code>PlacementAndUpdate</code>表示替换操作</li><li><code>Update</code>表示更新操作</li><li><code>Deletion</code>表示删除操作</li></ul><p>整个<code>Scheduler</code>与<code>Reconciler</code>的工作都在内存中进行，所以即使反复中断，用户也不会看见更新不完全的 DOM。只有当所有组件都完成<code>Reconciler</code>的工作，才会统一交给<code>Renderer</code>。</p><h3 id="Renderer-渲染器"><a href="#Renderer-渲染器" class="headerlink" title="Renderer 渲染器"></a>Renderer 渲染器</h3><p><code>Renderer</code>根据<code>Reconciler</code>为虚拟 DOM 打的标记，同步执行对应的 DOM 操作。</p><h2 id="Fiber-架构对生命周期的影响"><a href="#Fiber-架构对生命周期的影响" class="headerlink" title="Fiber 架构对生命周期的影响"></a>Fiber 架构对生命周期的影响</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8eb7f64f3f94a9f8038949001284385~tplv-k3u1fbpfcp-watermark.image" alt=""></p><ol><li>render 阶段：纯净且没有副作用，可能会被 React 暂停、终止或重新启动。</li><li>pre-commit 阶段：可以读取 DOM。</li><li>commit 阶段：可以使用 DOM，运行副作用，安排更新。</li></ol><p>其中 pre-commit 和 commit 从大阶段上来看都属于 commit 阶段。</p><p>在 render 阶段，React 主要是在内存中做计算，明确 DOM 树的更新点；而 commit 阶段，则负责把 render 阶段生成的更新真正地执行掉。</p><p>新老两种架构对 React 生命周期的影响主要在 render 这个阶段，这个影响是通过增加 Scheduler 层和改写 Reconciler 层来实现的。</p><p>在 render 阶段，一个庞大的更新任务被分解为了一个个的工作单元，这些工作单元有着不同的优先级，React 可以根据优先级的高低去实现工作单元的打断和恢复。</p><p>之前写过一篇文章关于为什么 React 一些旧生命周期函数打算废弃的原因：<a href="https://juejin.cn/post/6900703477480685582" target="_blank" rel="noopener">谈谈对 React 新旧生命周期的理解</a></p><p>而这次从 Firber 机制 render 阶段的角度看这三个生命周期，这三个生命周期的共同特点是都处于 render 阶段：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">componentWillMount</span><br><span class="line">componentWillUpdate</span><br><span class="line">componentWillReceiveProps</span><br></pre></td></tr></table></figure><p>由于 render 阶段是允许暂停、终止和重启的，这就导致 render 阶段的生命周期都有可能被重复执行，故也是废弃他们的原因之一。</p><h2 id="Fiber-更新过程"><a href="#Fiber-更新过程" class="headerlink" title="Fiber 更新过程"></a>Fiber 更新过程</h2><p>虚拟 DOM 更新过程分为 2 个阶段：</p><ul><li><strong>render/reconciliation 协调阶段(可中断/异步)</strong>：通过 Diff 算法找出所有节点变更，例如节点新增、删除、属性变更等等, 获得需要更新的节点信息，对应早期版本的 Diff 过程。</li><li><strong>commit 提交阶段(不可中断/同步)</strong>：将需要更新的节点一次过批量更新，对应早期版本的 patch 过程。</li></ul><h3 id="协调阶段"><a href="#协调阶段" class="headerlink" title="协调阶段"></a>协调阶段</h3><p>在协调阶段会进行 Diff 计算，会生成一棵 Fiber 树。</p><p>该阶段开始于<code>performSyncWorkOnRoot</code>或<code>performConcurrentWorkOnRoot</code>方法的调用。这取决于本次更新是同步更新还是异步更新。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// performSyncWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// performConcurrentWorkOnRoot会调用该方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们唯一的区别是是否调用<code>shouldYield</code>。如果当前浏览器帧没有剩余时间，<code>shouldYield</code>会中止循环，直到浏览器有空闲时间后再继续遍历。</p><p><code>workInProgress</code>代表当前已创建的 workInProgress fiber。</p><p><code>performUnitOfWork</code>方法将触发对 <code>beginWork</code> 的调用，进而实现对新 Fiber 节点的创建。若 <code>beginWork</code> 所创建的 Fiber 节点不为空，则 <code>performUniOfWork</code> 会用这个新的 Fiber 节点来更新 <code>workInProgress</code> 的值，为下一次循环做准备。</p><p>通过循环调用 <code>performUnitOfWork</code> 来触发 <code>beginWork</code>，新的 Fiber 节点就会被不断地创建。当 <code>workInProgress</code> 终于为空时，说明没有新的节点可以创建了，也就意味着已经完成对整棵 Fiber 树的构建。</p><p>我们知道 Fiber Reconciler 是从 Stack Reconciler 重构而来，通过遍历的方式实现可中断的递归，所以<code>performUnitOfWork</code>的工作可以分为两部分：”递”和”归”。</p><p><strong>“递阶段”</strong></p><p>首先从 rootFiber 开始向下深度优先遍历。为遍历到的每个 Fiber 节点调用<code>beginWork</code>方法。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null, <span class="regexp">//</span> 当前组件对应的Fiber节点在上一次更新时的Fiber节点</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber, <span class="regexp">//</span> 当前组件对应的Fiber节点</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: ExpirationTime <span class="regexp">//</span> 优先级相关</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...省略函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法会根据传入的 Fiber 节点创建子 Fiber 节点，并将这两个 Fiber 节点连接起来。</p><p>当遍历到叶子节点（即没有子组件的组件）时就会进入”归”阶段。</p><p><strong>“归阶段”</strong></p><p>在”归”阶段会调用<code>completeWork</code>处理 Fiber 节点。</p><blockquote><p>completeWork 将根据 workInProgress 节点的 tag 属性的不同，进入不同的 DOM 节点的创建、处理逻辑。</p></blockquote><p>completeWork 内部有 3 个关键动作：</p><ul><li>创建 DOM 节点（CreateInstance）</li><li>将 DOM 节点插入到 DOM 树中（AppendAllChildren）</li><li>为 DOM 节点设置属性（FinalizeInitialChildren）</li></ul><p>当某个 Fiber 节点执行完<code>completeWork</code>，如果其存在兄弟 Fiber 节点（即<code>fiber.sibling !== null</code>），会进入其兄弟 Fiber 的”递”阶段。</p><p>如果不存在兄弟 Fiber，会进入父级 Fiber 的”归”阶段。</p><p>“递”和”归”阶段会交错执行直到”归”到 rootFiber。至此，协调阶段的工作就结束了。</p><h3 id="commit-提交阶段"><a href="#commit-提交阶段" class="headerlink" title="commit 提交阶段"></a>commit 提交阶段</h3><p>commit 阶段的主要工作（即 Renderer 的工作流程）分为三部分：</p><ul><li>before mutation 阶段，这个阶段 DOM 节点还没有被渲染到界面上去，过程中会触发 <code>getSnapshotBeforeUpdate</code>，也会处理 <code>useEffect</code> 钩子相关的调度逻辑。</li><li>mutation 阶段，这个阶段负责 DOM 节点的渲染。在渲染过程中，会遍历 effectList，根据 flags（effectTag）的不同，执行不同的 DOM 操作。</li><li>layout 阶段，这个阶段处理 DOM 渲染完毕之后的收尾逻辑。比如调用 <code>componentDidMount/componentDidUpdate</code>，调用 <code>useLayoutEffect</code> 钩子函数的回调等。除了这些之外，它还会把 fiberRoot 的 current 指针指向 workInProgress Fiber 树。</li></ul><p>参考：</p><ul><li>修言-深入浅出搞定 React</li><li>React 技术揭秘</li></ul>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Fiber</tag>
      </tags>
  </entry>
  <entry>
    <title>深入 React 的 setState 机制</title>
    <url>/2021/01/23/%E6%B7%B1%E5%85%A5-React-%E7%9A%84-setState-%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>本篇写的 setState（涉及源码部分）是针对 React15 版本，即是没有 Fiber 介入的；为了方便看和写，所以选择旧版本，Fiber 写起来有点难，先留着将会写。setState 在 React 15 的原理能理解，16 版本的也是大同小异。</p><p>虽然已经用 React Hooks 很久了，React15 的<code>this.setState()</code>形式都很少用了，但依然是站在回顾与总结的角度，看待 React 的变迁和发展，所以最近开始重新回顾以前一知半解的一些原理问题，慢慢沉淀技术。</p><a id="more"></a><h2 id="setState-经典问题"><a href="#setState-经典问题" class="headerlink" title="setState 经典问题"></a>setState 经典问题</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setState(updater, [callback])</span><br></pre></td></tr></table></figure><p>React 通过 <code>this.setState()</code> 来更新 state，当使用 <code>this.setState()</code>的时候 ，React 会调用 render 方法来重新渲染 UI。</p><p>setState 的几种用法就不用我说了，来看看网上讨论 setState 比较多的问题：</p><h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;加<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure><p>点击按钮触发事件，打印的都是 1，页面显示 count 的值为 2。</p><p>这就是常常说的 setState 批量更新，对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行结果。所以每次 setState 之后立即打印值都是初始值 1，而最后页面显示的值则为最后一次的执行结果，也就是 2。</p><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 3</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;加<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure><p>点击按钮触发事件，发现 setTimeout 里面的 count 值打印值为 3，页面显示 count 的值为 3。setTimeout 里面 setState 之后能马上能到最新值。</p><p>在 setTimeout 里面，setState 是同步的；经过前面两次的 setState 批量更新，count 值已经更新为 2。在 setTimeout 里面的首先拿到新的 count 值 2，再一次 setState，然后能实时拿到 count 的值为 3。</p><h3 id="DOM-原生事件"><a href="#DOM-原生事件" class="headerlink" title="DOM 原生事件"></a>DOM 原生事件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    count: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>).addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.handleClick)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 4</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;button id=<span class="string">'btn'</span>&gt;触发原生事件&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;&#123;this.state.count&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure><p>点击按钮，会发现每次 setState 打印出来的值都是实时拿到的，不会进行批量更新。</p><p>在 DOM 原生事件里面，setState 也是同步的。</p><h2 id="setState-同步异步问题"><a href="#setState-同步异步问题" class="headerlink" title="setState 同步异步问题"></a>setState 同步异步问题</h2><p>这里讨论的同步和异步并不是指 setState 是否异步执行，使用了什么异步代码，而是指调用 setState 之后 this.state 能否立即更新。</p><p>React 中的事件都是合成事件，都是由 React 内部封装好的。React 本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，就是我们所说的”异步”了。</p><p>由上面也可以得知 setState 在原生事件和 setTimeout 中都是同步的。</p><h2 id="setState-源码层面"><a href="#setState-源码层面" class="headerlink" title="setState 源码层面"></a>setState 源码层面</h2><p>源码选择的 React 版本为<code>15.6.2</code></p><h3 id="setState-函数"><a href="#setState-函数" class="headerlink" title="setState 函数"></a>setState 函数</h3><p>源码里面，setState 函数的代码</p><p>React 组件继承自<code>React.Component</code>，而 setState 是<code>React.Component</code>的方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span> (<span class="params">partialState, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState)</span><br><span class="line">  <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback, <span class="string">'setState'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它直接调用了 <code>this.updater.enqueueSetState</code> 这个方法。</p><h3 id="enqueueSetState"><a href="#enqueueSetState" class="headerlink" title="enqueueSetState"></a>enqueueSetState</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">enqueueSetState: <span class="function"><span class="keyword">function</span>(<span class="params">publicInstance, partialState</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到对应的组件实例</span></span><br><span class="line">  <span class="keyword">var</span> internalInstance = getInternalInstanceReadyForUpdate(</span><br><span class="line">    publicInstance,</span><br><span class="line">    <span class="string">'setState'</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="comment">// queue 对应一个组件实例的 state 数组</span></span><br><span class="line">  <span class="keyword">var</span> queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);</span><br><span class="line">  queue.push(partialState); <span class="comment">// 将 partialState 放入待更新 state 队列</span></span><br><span class="line">  <span class="comment">// 处理当前的组件实例</span></span><br><span class="line">  enqueueUpdate(internalInstance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_pendingStateQueue</code>表示待更新队列</p><p><code>enqueueSetState</code> 做了两件事：</p><ul><li>将新的 state 放进组件的状态队列里；</li><li>用 enqueueUpdate 来处理将要更新的实例对象。</li></ul><p>接下来看看 <code>enqueueUpdate</code> 做了什么：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>) </span>&#123;</span><br><span class="line">  ensureInjected()</span><br><span class="line">  <span class="comment">// isBatchingUpdates 标识着当前是否处于批量更新过程</span></span><br><span class="line">  <span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    <span class="comment">// 若当前没有处于批量创建/更新组件的阶段，则立即更新组件</span></span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 需要批量更新，则先把组件塞入 dirtyComponents 队列</span></span><br><span class="line">  dirtyComponents.push(component)</span><br><span class="line">  <span class="keyword">if</span> (component._updateBatchNumber == <span class="literal">null</span>) &#123;</span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>batchingStrategy</code> 表示批量更新策略，<code>isBatchingUpdates</code>表示当前是否处于批量更新过程，默认是 false。</p><p><code>enqueueUpdate</code>做的事情：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35dce2754bb844808bf65fcc12cd1b24~tplv-k3u1fbpfcp-watermark.image" alt=""></p><ul><li><p>判断组件是否处于批量更新模式，如果是，即<code>isBatchingUpdates</code>为 true 时，不进行 state 的更新操作，而是将需要更新的组件添加到<code>dirtyComponents</code>数组中；</p></li><li><p>如果不是处于批量更新模式，则对所有队列中的更新执行<code>batchedUpdates</code>方法</p></li></ul><p>当中 <code>batchingStrategy</code>该对象的<code>isBatchingUpdates</code>属性直接决定了是马上要走更新流程，还是应该进入队列等待；所以大概可以得知<code>batchingStrategy</code>用于管控批量更新的对象。</p><p>来看看它的源码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  batchingStrategy源码</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">var</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  isBatchingUpdates: <span class="literal">false</span>, <span class="comment">// 初始值为 false 表示当前并未进行任何批量更新操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发起更新动作的方法</span></span><br><span class="line">  batchedUpdates: <span class="function"><span class="keyword">function</span> (<span class="params">callback, a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates</span><br><span class="line"></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (alreadyBatchingUpdates) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(a, b, c, d, e)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 启动事务，将 callback 放进事务里执行</span></span><br><span class="line">      <span class="keyword">return</span> transaction.perform(callback, <span class="literal">null</span>, a, b, c, d, e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>每当 React 调用 batchedUpdate 去执行更新动作时，会先把<code>isBatchingUpdates</code>置为 true，表明正处于批量更新过程中。</strong></p><p>看完批量更新整体的管理机制，发现还有一个操作是<code>transaction.perform</code>，这就引出 React 中的 Transaction（事务）机制。</p><h3 id="Transaction（事务）机制"><a href="#Transaction（事务）机制" class="headerlink" title="Transaction（事务）机制"></a>Transaction（事务）机制</h3><p>Transaction 是创建一个黑盒，该黑盒能够封装任何的方法。因此，那些需要在函数运行前、后运行的方法可以通过此方法封装（即使函数运行中有异常抛出，这些固定的方法仍可运行）。</p><p>在 React 中源码有关于 Transaction 的注释如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">* <span class="xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="xml">*                       wrappers (injected at creation time)</span></span><br><span class="line"><span class="xml">*                                      +        +</span></span><br><span class="line"><span class="xml">*                                      |        |</span></span><br><span class="line"><span class="xml">*                    +-----------------|--------|--------------+</span></span><br><span class="line"><span class="xml">*                    |                 v        |              |</span></span><br><span class="line"><span class="xml">*                    |      +---------------+   |              |</span></span><br><span class="line"><span class="xml">*                    |   +--|    wrapper1   |---|----+         |</span></span><br><span class="line"><span class="xml">*                    |   |  +---------------+   v    |         |</span></span><br><span class="line"><span class="xml">*                    |   |          +-------------+  |         |</span></span><br><span class="line"><span class="xml">*                    |   |     +----|   wrapper2  |--------+   |</span></span><br><span class="line"><span class="xml">*                    |   |     |    +-------------+  |     |   |</span></span><br><span class="line"><span class="xml">*                    |   |     |                     |     |   |</span></span><br><span class="line"><span class="xml">*                    |   v     v                     v     v   | wrapper</span></span><br><span class="line"><span class="xml">*                    | +---+ +---+   +---------+   +---+ +---+ | invariants</span></span><br><span class="line"><span class="xml">* perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained</span></span><br><span class="line"><span class="xml">* +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;</span></span><br><span class="line"><span class="xml">*                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="xml">*                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="xml">*                    | |   | |   |   |         |   |   | |   | |</span></span><br><span class="line"><span class="xml">*                    | +---+ +---+   +---------+   +---+ +---+ |</span></span><br><span class="line"><span class="xml">*                    |  initialize                    close    |</span></span><br><span class="line"><span class="xml">*                    +-----------------------------------------+</span></span><br><span class="line"><span class="xml">* <span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>根据以上注释，可以看出：一个 Transaction 就是将需要执行的 method 使用 wrapper（一组 initialize 及 close 方法称为一个 wrapper） 封装起来，再通过 Transaction 提供的 perform 方法执行。</p><p>在 perform 之前，先执行所有 wrapper 中的 initialize 方法；perform 完成之后（即 method 执行后）再执行所有的 close 方法，而且 Transaction 支持多个 wrapper 叠加。这就是 React 中的事务机制。</p><h3 id="batchingStrategy-批量更新策略"><a href="#batchingStrategy-批量更新策略" class="headerlink" title="batchingStrategy 批量更新策略"></a>batchingStrategy 批量更新策略</h3><p>再看回<code>batchingStrategy</code>批量更新策略，ReactDefaultBatchingStrategy 其实就是一个批量更新策略事务，它的 wrapper 有两个：<code>FLUSH_BATCHED_UPDATES</code> 和 <code>RESET_BATCHED_UPDATES</code>。</p><p><code>isBatchingUpdates</code>在 close 方法被复位为 false，如下代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  flushBatchedUpdates 将所有的临时 state 合并并计算出最新的 props 及 state</span></span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]</span><br></pre></td></tr></table></figure><p><strong>React 钩子函数</strong></p><p>都说 React 钩子函数也是异步更新，则必须一开始 isBatchingUpdates 为 ture，但默认 isBatchingUpdates 为 false，它是在哪里被设置为 true 的呢？来看下面代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReactMount.js</span></span><br><span class="line">_renderNewRootComponent: <span class="function"><span class="keyword">function</span>(<span class="params"> nextElement, container, shouldReuseMarkup, context </span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实例化组件</span></span><br><span class="line">  <span class="keyword">var</span> componentInstance = instantiateReactComponent(nextElement);</span><br><span class="line">  <span class="comment">// 调用 batchedUpdates 方法</span></span><br><span class="line">  ReactUpdates.batchedUpdates(</span><br><span class="line">    batchedMountComponentIntoNode,</span><br><span class="line">    componentInstance,</span><br><span class="line">    container,</span><br><span class="line">    shouldReuseMarkup,</span><br><span class="line">    context</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是在首次渲染组件时会执行的一个方法，可以看到它内部调用了一次 <code>batchedUpdates</code> 方法（将 isBatchingUpdates 设为 true），这是因为在组件的渲染过程中，会按照顺序调用各个生命周期(钩子)函数。如果在函数里面调用 setState，则看下列代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">  <span class="comment">// 立即更新组件</span></span><br><span class="line">  batchingStrategy.batchedUpdates(enqueueUpdate, component)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 批量更新，则先把组件塞入 dirtyComponents 队列</span></span><br><span class="line">dirtyComponents.push(component)</span><br></pre></td></tr></table></figure><p>则所有的更新都能够进入 dirtyComponents 里去，即 setState 走的异步更新</p><p><strong>React 合成事件</strong></p><p>当我们在组件上绑定了事件之后，事件中也有可能会触发 setState。为了确保每一次 setState 都有效，React 同样会在此处手动开启批量更新。看下面代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ReactEventListener.js</span></span><br><span class="line"></span><br><span class="line">dispatchEvent: <span class="function"><span class="keyword">function</span> (<span class="params">topLevelType, nativeEvent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 处理事件：batchedUpdates会将 isBatchingUpdates设为true</span></span><br><span class="line">    ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    TopLevelCallbackBookKeeping.release(bookKeeping);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isBatchingUpdates</code> 这个变量，在 React 的生命周期函数以及合成事件执行前，已经被 React 改为 true，这时我们所做的 setState 操作自然不会立即生效。当函数执行完毕后，事务的 close 方法会再把 isBatchingUpdates 改为 false。</p><p>就像最上面的例子，整个过程模拟大概是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// isBatchingUpdates = true</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 1</span></span><br><span class="line">  <span class="comment">// isBatchingUpdates = false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果有 setTimeout 介入后</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// isBatchingUpdates = true</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// setTimeout异步执行，此时 isBatchingUpdates 已经被重置为 false</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      count: <span class="keyword">this</span>.state.count + <span class="number">1</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 3</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// isBatchingUpdates = false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isBatchingUpdates</code>是在同步代码中变化的，而 setTimeout 的逻辑是异步执行的。当 this.setState 调用真正发生的时候，isBatchingUpdates 早已经被重置为 false，这就使得 setTimeout 里面的 setState 具备了立刻发起同步更新的能力。</p><h3 id="batchedUpdates-方法"><a href="#batchedUpdates-方法" class="headerlink" title="batchedUpdates 方法"></a>batchedUpdates 方法</h3><p>看到这里大概就可以了解 setState 的同步异步机制了，接下来让我们进一步体会，可以把 React 的<code>batchedUpdates</code>拿来试试，在该版本中此方法名称被置为<code>unstable_batchedUpdates</code>即不稳定的方法。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &#39;react&#39;</span><br><span class="line">import &#123; unstable_batchedUpdates as batchedUpdates &#125; from &#39;react-dom&#39;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    count: 1,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      count: this.state.count + 1,</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(this.state.count) &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      count: this.state.count + 1,</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(this.state.count) &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      batchedUpdates(() &#x3D;&gt; &#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">          count: this.state.count + 1,</span><br><span class="line">        &#125;)</span><br><span class="line">        console.log(this.state.count) &#x2F;&#x2F; 2</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;button onClick&#x3D;&#123;this.handleClick&#125;&gt;加1&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;div&gt;&#123;this.state.count&#125;&lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App</span><br></pre></td></tr></table></figure><p>如果调用<code>batchedUpdates</code>方法，则 <code>isBatchingUpdates</code>变量会被设置为 true，由上述得为 true 走的是批量更新策略，则 setTimeout 里面的方法也变成异步更新了，所以最终打印值为 2，与本文第一道题结果一样。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>setState 同步异步的表现会因调用场景的不同而不同：在 React 钩子函数及合成事件中，它表现为异步；而在 setTimeout/setInterval 函数，DOM 原生事件中，它都表现为同步。这是由 React 事务机制和批量更新机制的工作方式来决定的。</p><p>在 React16 中，由于引入了 Fiber 机制，源码多少有点不同，但大同小异，之后我也会写 React16 原理的文章，敬请关注！</p><br><p>我近期会维护的开源项目：</p><ul><li><a href="https://github.com/Jacky-Summer/monki-ui" target="_blank" rel="noopener">基于 React + TypeScript + Dumi + Jest + Enzyme 开发 UI 组件库</a></li><li><a href="https://github.com/Jacky-Summer/nextjs-ts-antd-redux-storybook-starter" target="_blank" rel="noopener">Next.js 企业级项目脚手架模板</a></li><li><a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a><br>觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>setState</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 系列之 Proxy</title>
    <url>/2021/01/03/ES6-%E7%B3%BB%E5%88%97%E4%B9%8B-Proxy/</url>
    <content><![CDATA[<p>前几天模拟实现了 MobX 的两个函数 —— <a href="https://github.com/Jacky-Summer/personal-blog/blob/master/React%E7%B3%BB%E5%88%97/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0MobX%E7%9A%84observable%E5%92%8Cautorun%E6%96%B9%E6%B3%95.md" target="_blank" rel="noopener">手写实现 MobX 的 observable 和 autorun 方法</a>，其中用到了 Proxy，所以打算再对 Proxy 深入了解一下，做个笔记。</p><a id="more"></a><h2 id="Proxy-是什么"><a href="#Proxy-是什么" class="headerlink" title="Proxy 是什么"></a>Proxy 是什么</h2><p><strong>Proxy</strong> 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p><blockquote><p>const p = new Proxy(target, handler)</p></blockquote><ul><li>target: 使用 Proxy 包装的目标对象（可以是任何类型的 JavaScript 对象，包括原生数组，函数，甚至另一个代理）。</li><li>handler: 一个通常以函数作为属性的对象，用来定制拦截行为。</li></ul><p>在支持 Proxy 的浏览器环境中，Proxy 是一个全局对象，可以直接使用。<code>Proxy(target, handler)</code>是一个构造函数，<code>target</code>是被代理的对象，最终返回一个代理对象。</p><h2 id="为什么需要-Proxy"><a href="#为什么需要-Proxy" class="headerlink" title="为什么需要 Proxy"></a>为什么需要 Proxy</h2><p>学习一样东西之前我们先要想想为什么需要它，在我看来，一般几种情况。</p><ol><li>被代理的对象不想直接被访问</li><li>控制和修改被代理对象的行为（调用属性、属性赋值、方法调用等等），使之可以进行访问控制和增加功能。</li></ol><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>API 概览如下：</p><ul><li><strong>get(target, propKey, receiver)</strong>：拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’] 。</li><li><strong>set(target, propKey, value, receiver)</strong>：拦截对象属性的设置，比如 proxy.foo = v 或 proxy[‘foo’] = v ，返回一个布尔值。</li><li><strong>has(target, propKey)</strong>：拦截 propKey in proxy 的操作，返回一个布尔值。</li><li><strong>deleteProperty(target, propKey)</strong>：拦截 delete proxy[propKey]的操作，返回一个布尔值。</li><li><strong>ownKeys(target)</strong>：拦截 Object.getOwnPropertyNames(proxy) 、 Object.getOwnPropertySymbols(proxy) 、 Object.keys(proxy) 、 for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys() 的返回结果仅包括目标对象自身的可遍历属性。</li><li><strong>getOwnPropertyDescriptor(target, propKey)</strong>：拦截 Object.getOwnPropertyDescriptor(proxy, propKey) ，返回属性的描述对象。</li><li><strong>defineProperty(target, propKey, propDesc)</strong>：拦截 Object.defineProperty(proxy, propKey, propDesc） 、</li><li><strong>Object.defineProperties(proxy, propDescs)</strong>，返回一个布尔值。</li><li><strong>preventExtensions(target)</strong>：拦截 Object.preventExtensions(proxy) ，返回一个布尔值。</li><li><strong>getPrototypeOf(target)</strong>：拦截 Object.getPrototypeOf(proxy)，返回一个对象 。</li><li><strong>isExtensible(target)</strong>：拦截 Object.isExtensible(proxy) ，返回一个布尔值。</li><li><strong>setPrototypeOf(target, proto)</strong>：拦截 Object.setPrototypeOf(proxy, proto) ，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li><li><strong>apply(target, object, args)</strong>：拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)`。</li><li><strong>construct(target, args)</strong>：拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args) 。</li></ul><p>最常用的方法就是<code>get</code>和<code>set</code></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  name: <span class="string">'jacky'</span>,</span><br><span class="line">  sex: <span class="string">'man'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'获取名字/性别'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br></pre></td></tr></table></figure><p>运行，打印台输出:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取名字&#x2F;性别</span><br><span class="line">jacky</span><br></pre></td></tr></table></figure><p>在获取<code>name</code>属性是先进入<code>get</code>方法，在<code>get</code>方法里面打印了<code>获取名字/性别</code>，然后通过<code>Reflect.get(target, key)</code>的返回值拿到属性值，相当于<code>target[key]</code></p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">  name: <span class="string">'jacky'</span>,</span><br><span class="line">  sex: <span class="string">'man'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'获取名字/性别'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, <span class="string">`强行设置为 <span class="subst">$&#123;value&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line">proxy.name = <span class="string">'monkey'</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name)</span><br></pre></td></tr></table></figure><p>运行输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取名字&#x2F;性别</span><br><span class="line">强行设置 monkey</span><br></pre></td></tr></table></figure><p>设置<code>proxy.name = &#39;monkey&#39;</code>，这是修改属性的值，则会触发到<code>set</code>方法， 然后我们强行更改设置的值再返回，达到拦截对象属性的设置的目的。</p><hr><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。</span><br><span class="line">Reflect.get(target, name, receiver) ：查找并返回target对象的name属性，如果没有该属性，则返回undefined。</span><br><span class="line">Reflect.set(target, name, value, receiver) ：设置target对象的name属性等于value。</span><br></pre></td></tr></table></figure><h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><p>proxy 会改变 target 中的 this 指向，一旦 Proxy 代理了 target，target 内部的 this 则指向了 Proxy 代理</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2021-01-03'</span>)</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.getDate(target)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.getDate())</span><br></pre></td></tr></table></figure><p>运行代码，会发现报错，提示<code>TypeError: proxy.getDate is not a function</code>，即 this 不是 Date 对象的实例，这时需要我们手动绑定原始对象即可解决：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2021-01-03'</span>)</span><br><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, prop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'getDate'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> target.getDate.bind(target) <span class="comment">// 绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(proxy.getDate()) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>警告或阻止特定操作</li><li>get 方法取不到对应值可以返回我们想指定的其它值</li><li>数据校验。判断数据是否满足条件</li></ul><p>等等…</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/proxy</a></li></ul><br><ul><li>ps：<ul><li><a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a></li></ul></li></ul><p>觉得不错的话赏个 star，给我持续创作的动力吧！</p>]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>手写实现MobX的observable和autorun方法</title>
    <url>/2021/01/01/%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0MobX%E7%9A%84observable%E5%92%8Cautorun%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>学了 MobX，了解了简单原理，故简单粗略的方式实现下</p><a id="more"></a><p>Demo</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, autorun &#125; <span class="keyword">from</span> <span class="string">'./mobx'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = observable(&#123;</span><br><span class="line">  name: <span class="string">'jacky'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// autorun方法这个回调函数会在初始化的时候被执行一次，之后每次内部相关的observable中的依赖发生变动时被再次调用</span></span><br><span class="line">autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'autorun'</span>, obj.name, obj.age)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.name = <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure><p>实现 observable 方法</p><p><code>./mobx/observable.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Reaction <span class="keyword">from</span> <span class="string">'./reaction'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深层Proxy代理返回</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepProxy</span>(<span class="params">val, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val !== <span class="string">'object'</span>) <span class="keyword">return</span> val</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> val) &#123;</span><br><span class="line">    <span class="comment">// 从后往前依次实现代理的功能，相当于是后序遍历</span></span><br><span class="line">    val[key] = deepProxy(val[key], handler)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(val, handler())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObservable</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个专门用来代理的对象</span></span><br><span class="line">  <span class="keyword">let</span> handler = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> reaction = <span class="keyword">new</span> Reaction()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">        reaction.collect()</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">        <span class="comment">// 对于数组的值设置处理: 当对数组进行观察监听时，由于对数组的操作会有两步执行:</span></span><br><span class="line">        <span class="comment">// 更新数组元素值</span></span><br><span class="line">        <span class="comment">// 更改数组的length属性，所以需要将更改length属性的操作给拦截，避免一次操作数组，多次触发handler</span></span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'length'</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">let</span> r = <span class="built_in">Reflect</span>.set(target, key, value)</span><br><span class="line">        reaction.run()</span><br><span class="line">        <span class="keyword">return</span> r</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> deepProxy(val, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params">target, key, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// 装饰器写法：先把装饰的对象进行深度代理</span></span><br><span class="line">    <span class="keyword">let</span> v = descriptor.initializer()</span><br><span class="line">    v = createObservable(v)</span><br><span class="line">    <span class="keyword">let</span> reaction = <span class="keyword">new</span> Reaction()</span><br><span class="line">    <span class="comment">// 返回描述器</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        reaction.collect()</span><br><span class="line">        <span class="keyword">return</span> v</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(value) &#123;</span><br><span class="line">        v = value</span><br><span class="line">        reaction.run()</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> createObservable(target) <span class="comment">// 不是装饰器写法：将目标对象进行代理操作，创建成可操作对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> observable</span><br></pre></td></tr></table></figure><p>autorun 方法</p><p><code>./mobx/autorun.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Reaction <span class="keyword">from</span> <span class="string">'./reaction'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">autorun</span>(<span class="params">handler</span>) </span>&#123;</span><br><span class="line">  Reaction.start(handler) <span class="comment">// 先保存函数，搜集依赖，设置Reaction中的nowFn</span></span><br><span class="line">  handler() <span class="comment">// 调用该方法会触发 get 属性</span></span><br><span class="line">  Reaction.end() <span class="comment">// 清除nowFn</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> autorun</span><br></pre></td></tr></table></figure><p>Reaction 类</p><p><code>./mobx/Reaction.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nowFn = <span class="literal">null</span> <span class="comment">// 表示当前的 autorun 中的 handler 方法</span></span><br><span class="line"><span class="keyword">let</span> counter = <span class="number">0</span> <span class="comment">// 记录一个计数器值作为每个 observable 属性的 id 值进行和 nowFn 进行绑定</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reaction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.id = ++counter <span class="comment">// 每次对 observable 属性进行 Proxy 的时候，对 Proxy 进行标记</span></span><br><span class="line">    <span class="keyword">this</span>.store = &#123;&#125; <span class="comment">// 存储当前可观察对象的nowFn, &#123; id: [nowFn] &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行依赖搜集</span></span><br><span class="line">  collect() &#123;</span><br><span class="line">    <span class="comment">// 当前有需要绑定的函数才进行绑定</span></span><br><span class="line">    <span class="keyword">if</span> (nowFn) &#123;</span><br><span class="line">      <span class="keyword">this</span>.store[<span class="keyword">this</span>.id] = <span class="keyword">this</span>.store[<span class="keyword">this</span>.id] || []</span><br><span class="line">      <span class="keyword">this</span>.store[<span class="keyword">this</span>.id].push(nowFn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 运行依赖函数</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.store[<span class="keyword">this</span>.id]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.store[<span class="keyword">this</span>.id].forEach(<span class="function"><span class="params">w</span> =&gt;</span> &#123;</span><br><span class="line">        w()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于在调用 autorun 方法时候对 nowFn 进行设置和消除</span></span><br><span class="line">  <span class="keyword">static</span> start(handler) &#123;</span><br><span class="line">    nowFn = handler</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在注册绑定这个就要清空当前的 nowFn，用于之后进行搜集绑定</span></span><br><span class="line">  <span class="keyword">static</span> end() &#123;</span><br><span class="line">    nowFn = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Reaction</span><br></pre></td></tr></table></figure><p><code>./mobx/index.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> autorun <span class="keyword">from</span> <span class="string">'./autorun'</span></span><br><span class="line"><span class="keyword">import</span> observable <span class="keyword">from</span> <span class="string">'./observable'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; autorun, observable &#125;</span><br></pre></td></tr></table></figure><p>源码地址：<a href="https://github.com/Jacky-Summer/mini-mobx/tree/master" target="_blank" rel="noopener">mini-mobx</a></p>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>手写</tag>
        <tag>MobX</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建 Next.js + TS + Antd + Redux + Storybook 企业级项目脚手架</title>
    <url>/2020/12/25/%E6%90%AD%E5%BB%BA-Next-js-TS-Antd-Redux-Storybook-%E4%BC%81%E4%B8%9A%E7%BA%A7%E9%A1%B9%E7%9B%AE%E8%84%9A%E6%89%8B%E6%9E%B6/</url>
    <content><![CDATA[<p>⭐ <a href="https://github.com/Jacky-Summer/nextjs-ts-antd-redux-storybook-starter" target="_blank" rel="noopener">Nextjs-TS-Antd-Redux-Storybook-Jest-Starter</a></p><p>之所以有该项目呢，是因为日常可能自己需要练手其他 Next.js 项目，又不想每次都重新配置一遍，但基于强迫症正常企业级项目该有的配置觉得不能少了，于是就想开搞一个通用脚手架模板。</p><a id="more"></a><p>说起 Next.js，8 月份写了一篇文章<a href="https://juejin.cn/post/6863336367309455373" target="_blank" rel="noopener">手把手带你入门 NextJs（v9.5）</a>，主要是因为网上大部分 Next.js 是旧版本 v7.x 的教程，于是写个较新的 9.5 版，没想到 10 月就出了 Next.js 10，措手不及，不过更新部分主要是图片优化等，可以照样看。</p><p>该项目也是想把日常工作中我觉得实践比较好的点加进来，也打算根据该项目持续跟进良好规范和最新库版本。当然，到具体业务场景的话脚手架肯定多少需要改，但目标希望能降低修改的成本，起码基本配置得搞好。</p><p>该脚手架主要库和版本：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Next.js 10.x</span><br><span class="line">React 17.x</span><br><span class="line">TypeScript 4.x</span><br><span class="line">Ant Design 4.x</span><br><span class="line">Styled-components 5.x</span><br><span class="line">Storybook 6.x</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/facf99da9e1645db8b9b33e5cebff0af~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h2 id="初始化-Next-js-模板"><a href="#初始化-Next-js-模板" class="headerlink" title="初始化 Next.js 模板"></a>初始化 Next.js 模板</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx create-next-app nextjs-ts-redux-antd-starter</span><br></pre></td></tr></table></figure><h2 id="添加-TypeScript-支持"><a href="#添加-TypeScript-支持" class="headerlink" title="添加 TypeScript 支持"></a>添加 TypeScript 支持</h2><p>根目录下新建<code>tsconfig.json</code>文件，此时运行<code>yarn dev</code>，会看到它提示我们安装类型库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add --dev typescript @types&#x2F;react @types&#x2F;node</span><br></pre></td></tr></table></figure><p>顺便把<code>@types/react-dom</code>也装上</p><p>安装之后，再运行<code>yarn dev</code>, 会在根目录自动生成<code>next-env.d.ts</code>文件，且<code>tsconfig.json</code>有了默认配置，这里我再对配置稍加改动。</p><p>具体可以参考 TS 官网看<a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank" rel="noopener">配置项</a>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;baseUrl&quot;: &quot;.&quot;,</span><br><span class="line">    &quot;paths&quot;: &#123;</span><br><span class="line">      &quot;src&#x2F;*&quot;: [</span><br><span class="line">        &quot;src&#x2F;*&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;target&quot;: &quot;es5&quot;,</span><br><span class="line">    &quot;module&quot;: &quot;esnext&quot;,</span><br><span class="line">    &quot;strict&quot;: true,</span><br><span class="line">    &quot;allowJs&quot;: true, &#x2F;&#x2F; 允许编译js文件</span><br><span class="line">    &quot;jsx&quot;: &quot;preserve&quot;, &#x2F;&#x2F; 在 .tsx文件里支持JSX</span><br><span class="line">    &quot;noEmit&quot;: true, &#x2F;&#x2F; 不输出文件</span><br><span class="line">    &quot;lib&quot;: [</span><br><span class="line">      &quot;dom&quot;,</span><br><span class="line">      &quot;dom.iterable&quot;,</span><br><span class="line">      &quot;esnext&quot;</span><br><span class="line">    ], &#x2F;&#x2F; TS需要引用的库，即声明文件</span><br><span class="line">    &quot;esModuleInterop&quot;: true, &#x2F;&#x2F; 允许export&#x3D;导出，由import from导入</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;, &#x2F;&#x2F; 模块解析策略，ts默认用node的解析策略，即相对的方式导入</span><br><span class="line">    &quot;allowSyntheticDefaultImports&quot;: true, &#x2F;&#x2F; 允许从没有设置默认导出的模块中默认导入</span><br><span class="line">    &quot;isolatedModules&quot;: true, &#x2F;&#x2F; 将每个文件作为单独的模块</span><br><span class="line">    &quot;resolveJsonModule&quot;: true, &#x2F;&#x2F; 允许把json文件当做模块进行解析</span><br><span class="line">    &quot;skipLibCheck&quot;: true, &#x2F;&#x2F; 跳过所有声明文件的类型检查</span><br><span class="line">    &quot;forceConsistentCasingInFileNames&quot;: true &#x2F;&#x2F; 不允许对同一文件使用不一致大小写的引用</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;include&quot;: [</span><br><span class="line">    &quot;next-env.d.ts&quot;,</span><br><span class="line">    &quot;**&#x2F;*.ts&quot;,</span><br><span class="line">    &quot;**&#x2F;*.tsx&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;exclude&quot;: [</span><br><span class="line">    &quot;node_modules&quot;,</span><br><span class="line">    &quot;.next&quot;,</span><br><span class="line">    &quot;dist&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后清除干净目录，把<code>styles</code>, <code>pages</code>只留下一个<code>index.js</code>即可， 并将<code>index.js</code>重命名为<code>index.tsx</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; NextPage &#125; <span class="keyword">from</span> <span class="string">'next'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home: NextPage = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello nextjs-ts-redux-antd-starter<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure><h2 id="EditorConfig"><a href="#EditorConfig" class="headerlink" title="EditorConfig"></a>EditorConfig</h2><p>作为项目代码风格的统一规范，我们需要借助第三方工具来强制</p><p><code>.editorconfig</code> 是跨编辑器维护一致编码风格的配置文件，在 VSCode 中需要安装相应插件 EditorConfig for VS Code，安装完毕之后， 可以通过输入 <code>Generate .editorcofig</code> 即可快速生成 <code>.editorconfig</code> 文件，也可以自己新建文件。</p><p>在<code>.editorcofig</code>文件，就可以大家根据不同来设置文件了，比如我的是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># http:&#x2F;&#x2F;editorconfig.org</span><br><span class="line">root &#x3D; true</span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">indent_style &#x3D; space</span><br><span class="line">indent_size &#x3D; 2</span><br><span class="line">end_of_line &#x3D; lf</span><br><span class="line">charset &#x3D; utf-8</span><br><span class="line">trim_trailing_whitespace &#x3D; true</span><br><span class="line">insert_final_newline &#x3D; true</span><br><span class="line"></span><br><span class="line">[*.md]</span><br><span class="line">trim_trailing_whitespace &#x3D; false</span><br><span class="line"></span><br><span class="line">[Makefile]</span><br><span class="line">indent_style &#x3D; tab</span><br></pre></td></tr></table></figure><h2 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add prettier -D</span><br></pre></td></tr></table></figure><p>同样也需要安装 VSCode 插件<code>Prettier - Code formatter</code></p><p>新建文件<code>.prettierrc</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;singleQuote&quot;: true,</span><br><span class="line">  &quot;tabWidth&quot;: 2,</span><br><span class="line">  &quot;endOfLine&quot;: &quot;lf&quot;,</span><br><span class="line">  &quot;trailingComma&quot;: &quot;all&quot;,</span><br><span class="line">  &quot;printWidth&quot;: 100,</span><br><span class="line">  &quot;arrowParens&quot;: &quot;avoid&quot;,</span><br><span class="line">  &quot;semi&quot;: false,</span><br><span class="line">  &quot;bracketSpacing&quot;: true,</span><br><span class="line">  &quot;overrides&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;files&quot;: &quot;.prettierrc&quot;,</span><br><span class="line">      &quot;options&quot;: &#123; &quot;parser&quot;: &quot;json&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再添加忽略文件<code>.prettierignore</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**&#x2F;*.png</span><br><span class="line">**&#x2F;*.svg</span><br><span class="line">**&#x2F;*.ico</span><br><span class="line">package.json</span><br><span class="line">lib&#x2F;</span><br><span class="line">es&#x2F;</span><br><span class="line">dist&#x2F;</span><br><span class="line">.next&#x2F;</span><br><span class="line">coverage&#x2F;</span><br><span class="line">LICENSE</span><br><span class="line">yarn.lock</span><br><span class="line">yarn-error.log</span><br><span class="line">*.sh</span><br><span class="line">.gitignore</span><br><span class="line">.npmignore</span><br><span class="line">.prettierignore</span><br><span class="line">.DS_Store</span><br><span class="line">.editorconfig</span><br><span class="line">.eslintignore</span><br><span class="line">**&#x2F;*.yml</span><br></pre></td></tr></table></figure><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add eslint -D</span><br></pre></td></tr></table></figure><p>安装完后运行 <code>npx eslint --init</code>，运行后有选项，选择如下（自行根据需要）：</p><ul><li>To check syntax, find problems, and enforce code style</li><li>JavaScript modules (import/export)</li><li>React</li><li>TypeScript Yes</li><li>Browser Node</li><li>Use a popular style guide</li><li>Airbnb: <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">https://github.com/airbnb/javascript</a></li><li>JavaScript</li><li>Would you like to install them now with npm (Yes)</li></ul><p>npm 安装后会出现<code>package-lock.json</code>，如果你默认想用<code>yarn.lock</code>，为了避免冲突就删掉它。</p><p>安装自动生成<code>.eslintrc</code>文件，还没完，为了写出来的代码更好更符合社区规范，我们再加一些不错的 eslint 插件</p><ul><li><code>eslint-plugin-unicorn</code>：提供了循环依赖检测，文件名大小写风格约束等非常实用的规则集合。</li><li><code>eslint-config-prettier</code>：eslint 和 prettier 混合使用时候，需要修改规则，以防止重复或冲突；该插件即为解决此问题的存在，可以使用它关闭所有可能引起冲突的规则。</li><li><code>eslint-plugin-import</code>：能够正确解析 <code>.tsx, .ts, .js, .json</code> 后缀名（还需指定允许的后缀名，添加到 setttings 字段）</li><li><code>eslint-import-resolver-alias</code>: eslint 能识别 alias 别名自定义路径</li><li><code>eslint-import-resolver-typescript</code>：让 <code>eslint-plugin-import</code> 能够正确解析 <code>tsconfig.json</code> 中的 <code>paths</code> 映射，需要安装它。</li></ul><p>我的配置如下，<code>rules</code>忽略规则自己添加因人而异</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    es2021: <span class="literal">true</span>,</span><br><span class="line">    node: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  extends: [</span><br><span class="line">    <span class="string">'airbnb'</span>,</span><br><span class="line">    <span class="string">'plugin:react/recommended'</span>,</span><br><span class="line">    <span class="string">'plugin:import/typescript'</span>,</span><br><span class="line">    <span class="string">'plugin:@typescript-eslint/recommended'</span>,</span><br><span class="line">    <span class="string">'prettier/react'</span>,</span><br><span class="line">  ],</span><br><span class="line">  settings: &#123;</span><br><span class="line">    <span class="string">'import/resolver'</span>: &#123;</span><br><span class="line">      node: &#123;</span><br><span class="line">        extensions: [<span class="string">'.tsx'</span>, <span class="string">'.ts'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      alias: [[<span class="string">'src'</span>, <span class="string">'./src'</span>]],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  parser: <span class="string">'@typescript-eslint/parser'</span>,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaFeatures: &#123;</span><br><span class="line">      jsx: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ecmaVersion: <span class="number">12</span>,</span><br><span class="line">    sourceType: <span class="string">'module'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="string">'react'</span>, <span class="string">'@typescript-eslint'</span>, <span class="string">'react-hooks'</span>, <span class="string">'unicorn'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    semi: <span class="number">0</span>,</span><br><span class="line">    indent: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'react/jsx-filename-extension'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'react/prop-types'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'react/jsx-props-no-spreading'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'jsx-a11y/click-events-have-key-events'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'jsx-a11y/no-static-element-interactions'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'jsx-a11y/no-noninteractive-element-interactions'</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">'no-use-before-define'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'no-unused-vars'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'implicit-arrow-linebreak'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'consistent-return'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'arrow-parens'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'object-curly-newline'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'operator-linebreak'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'import/no-extraneous-dependencies'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'import/extensions'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'import/no-unresolved'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'import/prefer-default-export'</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建文件<code>.eslintignore</code>，忽略一些文件的检查</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;node_modules</span><br><span class="line">&#x2F;public</span><br><span class="line">&#x2F;dist</span><br><span class="line">&#x2F;.next</span><br><span class="line">&#x2F;coverage</span><br></pre></td></tr></table></figure><h2 id="StyleLint"><a href="#StyleLint" class="headerlink" title="StyleLint"></a>StyleLint</h2><h3 id="sass-less-css"><a href="#sass-less-css" class="headerlink" title="sass/less/css"></a>sass/less/css</h3><ul><li><code>eslint-config-prettier</code>: 利用插件禁用与 Prettier 起冲突的规则</li><li><code>stylelint-config-rational-order</code>: 对关联属性进行分组和排序</li><li><code>stylelint-declaration-block-no-ignored-properties</code>: 矛盾样式忽略</li><li><code>stylelint-order</code>：强制你按照某个顺序编写 css</li></ul><p>.stylelintrc</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  extends: [</span><br><span class="line">    &#39;stylelint-config-standard&#39;,</span><br><span class="line">    &#39;stylelint-config-rational-order&#39;,</span><br><span class="line">    &#39;stylelint-config-prettier&#39;,</span><br><span class="line">  ],</span><br><span class="line">  plugins: [&#39;stylelint-order&#39;, &#39;stylelint-declaration-block-no-ignored-properties&#39;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="styled-components"><a href="#styled-components" class="headerlink" title="styled-components"></a>styled-components</h3><p>以上是使用 sass 或 less 可以完全照搬配置的，至于该脚手架我决定采用的 CSS 方案为<code>styled-components</code>，stylelint 配置 styled-components 目前有关库尚未实现自动修复，所以<code>--fix</code>目前是无效的，且需要安装另外的 stylelint 规则插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add styled-components</span><br><span class="line">yarn add -D @types&#x2F;styled-components stylelint-processor-styled-components stylelint-config-styled-components</span><br></pre></td></tr></table></figure><p>.stylelintrc</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;processors&quot;: [</span><br><span class="line">    &quot;stylelint-processor-styled-components&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    &quot;stylelint-order&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;extends&quot;: [</span><br><span class="line">    &quot;stylelint-config-standard&quot;,</span><br><span class="line">    &quot;stylelint-config-styled-components&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再新建文件<code>babel.config.js</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;next&#x2F;babel&quot;],</span><br><span class="line">  &quot;plugins&quot;: [[&quot;styled-components&quot;, &#123; &quot;ssr&quot;: true &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以分<code>development</code>,<code>test</code>,<code>production</code>,对 styled-components 进行区分设置，比如<a href="https://github.com/Jacky-Summer/nextjs-ts-antd-redux-storybook-starter/blob/master/babel.config.js" target="_blank" rel="noopener">babel.config.js</a></p><p>新建文件<code>pages/_document.tsx</code>，来自定义 Document 的方式来改写代码。它只有在服务器端渲染的时候才会被调用，主要用来修改服务器端渲染的文档内容，一般用来配合第三方 css-in-js 方案使用。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">import Document, &#123; DocumentContext &#125; from &#39;next&#x2F;document&#39;</span><br><span class="line">import &#123; ServerStyleSheet &#125; from &#39;styled-components&#39;</span><br><span class="line"></span><br><span class="line">class MyDocument extends Document &#123;</span><br><span class="line">  static async getInitialProps(ctx: DocumentContext) &#123;</span><br><span class="line">    const sheet &#x3D; new ServerStyleSheet()</span><br><span class="line">    const originalRenderPage &#x3D; ctx.renderPage</span><br><span class="line">    try &#123;</span><br><span class="line">      const initialProps &#x3D; await Document.getInitialProps(ctx)</span><br><span class="line"></span><br><span class="line">      ctx.renderPage &#x3D; () &#x3D;&gt;</span><br><span class="line">        originalRenderPage(&#123;</span><br><span class="line">          enhanceApp: App &#x3D;&gt; props &#x3D;&gt; sheet.collectStyles(&lt;App &#123;...props&#125; &#x2F;&gt;),</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">      return &#123;</span><br><span class="line">        ...initialProps,</span><br><span class="line">        styles: (</span><br><span class="line">          &lt;&gt;</span><br><span class="line">            &#123;initialProps.styles&#125;</span><br><span class="line">            &#123;sheet.getStyleElement()&#125;</span><br><span class="line">          &lt;&#x2F;&gt;</span><br><span class="line">        ),</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      sheet.seal()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default MyDocument</span><br></pre></td></tr></table></figure><h2 id="vscode"><a href="#vscode" class="headerlink" title=".vscode"></a>.vscode</h2><p>在根目录下新建文件夹<code>.vscode</code>，在该文件夹下新建文件 settings.json,该文件的配置优先于你自己 VSCode 全局的配置，不会因为团队不同成员的 VSCode 全局配置不同而导致格式化不同。</p><p><code>settings.json</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;search.exclude&quot;: &#123;</span><br><span class="line">    &quot;**&#x2F;node_modules&quot;: true,</span><br><span class="line">    &quot;dist&quot;: true,</span><br><span class="line">    &quot;.next&quot;: true,</span><br><span class="line">    &quot;yarn.lock&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;editor.formatOnSave&quot;: true,</span><br><span class="line">  &quot;editor.tabSize&quot;: 2,</span><br><span class="line">  &quot;eslint.validate&quot;: [&quot;javascript&quot;, &quot;javascriptreact&quot;, &quot;typescript&quot;, &quot;typescriptreact&quot;],</span><br><span class="line">  &quot;editor.codeActionsOnSave&quot;: &#123;</span><br><span class="line">    &quot;source.fixAll.eslint&quot;: true,</span><br><span class="line">    &quot;source.fixAll.stylelint&quot;: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="husky-与-lint-staged"><a href="#husky-与-lint-staged" class="headerlink" title="husky 与 lint-staged"></a>husky 与 lint-staged</h2><p>每次提交代码都要对代码先进行 lint 和格式化，确保代码风格统一。于是我们安装<code>husky</code>来解决这个事情，可我们想每次 lint 格式化的时候，只处理我们修改的代码（暂存区），可以选择<code>lint-staged</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add -D husky lint-staged</span><br></pre></td></tr></table></figure><p>在<code>package.json</code>配置 git commit 钩子操作：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;husky&quot;: &#123;</span><br><span class="line">   &quot;hooks&quot;: &#123;</span><br><span class="line">     &quot;commit-msg&quot;: &quot;commitlint --config .commitlintrc.js -E HUSKY_GIT_PARAMS&quot;,</span><br><span class="line">     &quot;pre-commit&quot;: &quot;lint-staged &amp;&amp; yarn tsc&quot;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> &quot;lint-staged&quot;: &#123;</span><br><span class="line">   &quot;*.&#123;tsx,ts,js,jsx&#125;&quot;: [</span><br><span class="line">     &quot;stylelint&quot;,</span><br><span class="line">     &quot;prettier --write&quot;,</span><br><span class="line">     &quot;eslint --fix&quot;</span><br><span class="line">   ],</span><br><span class="line">   &quot;*.&#123;css,less,scss&#125;&quot;: [</span><br><span class="line">     &quot;stylelint&quot;,</span><br><span class="line">     &quot;prettier --write&quot;</span><br><span class="line">   ],</span><br><span class="line">   &quot;*.&#123;md,json,yaml,yml&#125;&quot;: [</span><br><span class="line">     &quot;prettier --write&quot;</span><br><span class="line">   ]</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p><code>prettier --write</code>中的<code>--write</code>表示将格式化后的代码写到源文件，不加的话会输出文件。</p><p>上面<code>&quot;pre-commit&quot;: &quot;lint-staged &amp;&amp; yarn tsc&quot;</code>我还加了<code>yarn tsc</code>，ts 检查类型有问题，那当然不给你提交，及早发现错误。</p><p>另外需不需要强制<code>--fix</code>看个人，因为有人会顾虑强制的话相当于黑盒，你不知道它对你代码做了什么。</p><h2 id="commitlint"><a href="#commitlint" class="headerlink" title="commitlint"></a>commitlint</h2><p>我们提交的前文件已经会自动格式化了，接下来要搞搞 commit 提交规范问题。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add @commitlint&#x2F;cli @commitlint&#x2F;config-conventional -D</span><br></pre></td></tr></table></figure><p>默认类型 git commit 类型有如下几种，这是 angular 风格的 commitlint 配置，我自己平时习惯这一套规则。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#39;build&#39;,</span><br><span class="line">  &#39;ci&#39;,</span><br><span class="line">  &#39;chore&#39;,</span><br><span class="line">  &#39;docs&#39;,</span><br><span class="line">  &#39;feat&#39;,</span><br><span class="line">  &#39;fix&#39;,</span><br><span class="line">  &#39;perf&#39;,</span><br><span class="line">  &#39;refactor&#39;,</span><br><span class="line">  &#39;revert&#39;,</span><br><span class="line">  &#39;style&#39;,</span><br><span class="line">  &#39;test&#39;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>在根目录新建<code>.commitlintrc.js</code>：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  extends: [&#39;@commitlint&#x2F;config-conventional&#39;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如果团队刚来的人没用过也记不住上面那些开头单词怎么办，于是我们弄个命令可以让他自己选择，安装插件</p><ul><li><code>cz-conventional-changelog</code>：是一个适配器，一个符合 Angular 团队规范的 preset</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add cz-conventional-changelog -D</span><br></pre></td></tr></table></figure><p>在<code>package.json</code>中配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;commit&quot;: &quot;git-cz&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;config&quot;: &#123;</span><br><span class="line">        &quot;commitizen&quot;: &#123;</span><br><span class="line">          &quot;path&quot;: &quot;node_modules&#x2F;cz-conventional-changelog&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>yarn commit</code>，即出现该页面，供我们选择</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34ecb85ac98b4bf6b17c7fda0edfb659~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>基本项目规范配置就差不多了，接下来是做项目的状态管理工具，我这里选择了最经典的 Redux，异步处理选择<code>redux-saga</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add redux react-redux redux-saga</span><br><span class="line">yarn add -D @types&#x2F;react-redux @types&#x2F;redux-saga redux-devtools-extension next-redux-wrapper</span><br></pre></td></tr></table></figure><p>社区还有其他 redux 简化方案，比如使用 <a href="https://github.com/redux-utilities/redux-actions" target="_blank" rel="noopener">redux-actions</a>,但该项目维护似乎出现困难，就不加入使用了；还有 dva 等等或者采用其他状态管理库例如 mobx，各位可以自行考虑替换，这里只是给个常用方案。</p><p><code>src/redux/index.ts</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createWrapper, MakeStore &#125; <span class="keyword">from</span> <span class="string">'next-redux-wrapper'</span></span><br><span class="line"><span class="keyword">import</span> &#123; applyMiddleware, createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">'redux-saga'</span></span><br><span class="line"><span class="keyword">import</span> &#123; composeWithDevTools &#125; <span class="keyword">from</span> <span class="string">'redux-devtools-extension/developmentOnly'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'src/redux/rootReducers'</span></span><br><span class="line"><span class="keyword">import</span> rootSaga <span class="keyword">from</span> <span class="string">'src/redux/rootSagas'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> makeStore: MakeStore&lt;Store.RootState&gt; = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> sagaMiddleware = createSagaMiddleware()</span><br><span class="line">  <span class="keyword">const</span> store = createStore(rootReducer, composeWithDevTools(applyMiddleware(sagaMiddleware)))</span><br><span class="line">  sagaMiddleware.run(rootSaga)</span><br><span class="line">  <span class="keyword">return</span> store</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> wrapper = createWrapper &lt; Store.RootState &gt; makeStore</span><br></pre></td></tr></table></figure><p>再新建文件<code>pages/_app.tsx</code>引入 redux，覆盖 Next.js 默认的 App</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; FC &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; AppProps &#125; <span class="keyword">from</span> <span class="string">'next/app'</span></span><br><span class="line"><span class="keyword">import</span> &#123; wrapper &#125; <span class="keyword">from</span> <span class="string">'src/redux'</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'src/components/Layout'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> WrappedApp: FC&lt;AppProps&gt; = <span class="function">(<span class="params">&#123; Component, pageProps &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;Layout&gt;</span><br><span class="line">    &lt;Component &#123;...pageProps&#125; /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Layout&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default wrapper.withRedux(WrappedApp)</span></span><br></pre></td></tr></table></figure><p>其他代码及例子演示请看<a href="https://github.com/Jacky-Summer/nextjs-ts-antd-redux-starter/tree/master/src/redux" target="_blank" rel="noopener">源代码</a></p><p>redux 的项目结构有几种，哪种好视乎项目大小和复杂程度选择，该脚手架只是展示一种，按模块来划分 redux 数据结构，并不是说此种方式有多好，具体还是依据项目来调整目录结构。</p><p>我做个小 demo 是 saga 请求用户数据，返回并展示在页面上，关于 redux <code>State</code>的类型定义，我放在了根目录<code>types</code>文件夹里。</p><p>当然这也只是一种参照方式，也可以在 redux 目录模块里新建<code>types</code>文件放置<code>State</code>类型定义。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/50d165eeeda34712885de2c32c6e5a6a~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h2 id="Ant-Desgin-支持"><a href="#Ant-Desgin-支持" class="headerlink" title="Ant Desgin 支持"></a>Ant Desgin 支持</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add antd</span><br><span class="line">yarn add -D babel-plugin-import</span><br></pre></td></tr></table></figure><p><code>babel.config.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'import'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        libraryName: <span class="string">'antd'</span>,</span><br><span class="line">        libraryDirectory: <span class="string">'lib'</span>,</span><br><span class="line">        style: <span class="string">'index.css'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>src/_app.tsx</code>中引入 antd 样式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;antd&#x2F;dist&#x2F;antd.css&#39;</span><br></pre></td></tr></table></figure><h2 id="Travis-自动化部署"><a href="#Travis-自动化部署" class="headerlink" title="Travis 自动化部署"></a>Travis 自动化部署</h2><p>默认先这样设置了（后面加了 Jest 后再加入脚本<code>yarn test</code>）。不解释，不懂的看我这篇文章 <a href="https://juejin.cn/post/6895508265304915982" target="_blank" rel="noopener">手把手带你入门 Travis 自动化部署</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: node_js</span><br><span class="line"></span><br><span class="line">node_js:</span><br><span class="line">  - &quot;stable&quot;</span><br><span class="line"></span><br><span class="line">cache: yarn</span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">  - yarn</span><br><span class="line">script:</span><br><span class="line">  - yarn build</span><br></pre></td></tr></table></figure><h2 id="Storybook-搭建组件文档"><a href="#Storybook-搭建组件文档" class="headerlink" title="Storybook 搭建组件文档"></a>Storybook 搭建组件文档</h2><blockquote><p>Storybook 是在开发模式下与应用程序一起运行的. 它可以帮助您构建 UI 组件,并与应用程序的业务逻辑和上下文隔离开来</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npx -p @storybook&#x2F;cli sb init</span><br></pre></td></tr></table></figure><p>安装完毕，运行即开启</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn storybook</span><br></pre></td></tr></table></figure><p>然后会有初始一些组件例子，看看就可以删了。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53fa250176a84173a05177a461176da9~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p><a href="https://storybook.js.org/docs/react/writing-stories/introduction" target="_blank" rel="noopener">How to write stories</a> 通过给组件写 stories，可以让我们对整个项目用到的组件有大致了解，比如长什么样等等，还有包括是否 UI 改变，下面会写。</p><h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add react-i18next i18next</span><br></pre></td></tr></table></figure><p>当然也可以直接使用 <a href="https://github.com/isaachinman/next-i18next" target="_blank" rel="noopener">next-i18next</a></p><p><code>src/i18n/index.ts</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> i18n <span class="keyword">from</span> <span class="string">'i18next'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initReactI18next &#125; <span class="keyword">from</span> <span class="string">'react-i18next'</span></span><br><span class="line"><span class="keyword">import</span> zhCN <span class="keyword">from</span> <span class="string">'./locales/zh_CN.json'</span></span><br><span class="line"><span class="keyword">import</span> enUS <span class="keyword">from</span> <span class="string">'./locales/en_US.json'</span></span><br><span class="line"></span><br><span class="line">i18n.use(initReactI18next).init(&#123;</span><br><span class="line">  lng: <span class="string">'zh_CN'</span>,</span><br><span class="line">  fallbackLng: <span class="string">'zh_CN'</span>,</span><br><span class="line">  resources: &#123;</span><br><span class="line">    zh_CN: &#123;</span><br><span class="line">      translation: zhCN,</span><br><span class="line">    &#125;,</span><br><span class="line">    en_US: &#123;</span><br><span class="line">      translation: enUS,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  debug: <span class="literal">false</span>,</span><br><span class="line">  interpolation: &#123;</span><br><span class="line">    escapeValue: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> i18n</span><br></pre></td></tr></table></figure><p>具体还是直接看代码了，这里就介绍这么多；然后就可以切换语言，把项目用到的一些词语句子都集中到<code>zh_CN.json</code>和<code>en_US.json</code>等等写。</p><h2 id="Jest-单元测试"><a href="#Jest-单元测试" class="headerlink" title="Jest 单元测试"></a>Jest 单元测试</h2><p>为了代码的健壮性，当然是加入单元测试。如果不懂单元测试，请先看我这篇 <a href="https://juejin.cn/post/6891625768184070152" target="_blank" rel="noopener">一文带你了解 Jest 单元测试</a></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add -D jest @types&#x2F;jest eslint-plugin-jest babel-jest @storybook&#x2F;addon-storyshots</span><br></pre></td></tr></table></figure><p>配置<code>.eslintrc.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [<span class="string">'plugin:jest/recommended'</span>],</span><br><span class="line">  plugins: [<span class="string">'jest'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在根目录下新建文件<code>jest.config.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  moduleFileExtensions: [<span class="string">'ts'</span>, <span class="string">'tsx'</span>, <span class="string">'js'</span>, <span class="string">'json'</span>],</span><br><span class="line">  testPathIgnorePatterns: [<span class="string">'&lt;rootDir&gt;/dist/'</span>, <span class="string">'&lt;rootDir&gt;/node_modules/'</span>, <span class="string">'&lt;rootDir&gt;/.next/'</span>],</span><br><span class="line">  moduleNameMapper: &#123;</span><br><span class="line">    <span class="string">'^src(.*)$'</span>: <span class="string">'&lt;rootDir&gt;/src$1'</span>,</span><br><span class="line">    <span class="string">'^server(.*)$'</span>: <span class="string">'&lt;rootDir&gt;/server$1'</span>,</span><br><span class="line">    <span class="string">'^pages(.*)$'</span>: <span class="string">'&lt;rootDir&gt;/pages$1'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  collectCoverageFrom: [</span><br><span class="line">    <span class="string">'./&#123;src,server&#125;/**/*.&#123;ts,tsx,js,jsx&#125;'</span>,</span><br><span class="line">    <span class="string">'!**/node_modules/**'</span>,</span><br><span class="line">    <span class="string">'!**/dist/**'</span>,</span><br><span class="line">    <span class="string">'!**/coverage/**'</span>,</span><br><span class="line">    <span class="string">'!**/*.stories.&#123;ts,tsx,js,jsx&#125;'</span>,</span><br><span class="line">    <span class="string">'!**/&#123;config,constants,styles,types,__fixtures__&#125;/**'</span>,</span><br><span class="line">  ],</span><br><span class="line">  watchPathIgnorePatterns: [<span class="string">'dist'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Storybook-和-Jest-的-Snapshots-结合"><a href="#Storybook-和-Jest-的-Snapshots-结合" class="headerlink" title="Storybook 和 Jest 的 Snapshots 结合"></a>Storybook 和 Jest 的 Snapshots 结合</h3><p>Jest 可以生成快照测试（Snapshot），通过 snapshot 变化给我们判断页面元素是否异常，缺失或增加或配置文件是否更改等等。上面安装了 storybook，如果是 react 组件的 snapshot，需要借助其他插件，这里我们转为依靠 storybook 的 stories 生成。</p><p>针对 react，Jest 将为虚拟 DOM 拍摄快照，将其转化为 json 数据，在下一次运行时比对两张快照是否有偏差。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add -D @storybook&#x2F;addon-storyshots</span><br></pre></td></tr></table></figure><p>在根目录新建<code>jest.config.js</code>,针对 snapshot 的配置如下，其它配置按项目配置了，参考 <a href="https://github.com/Jacky-Summer/nextjs-ts-antd-redux-storybook-starter/blob/master/jest.config.js" target="_blank" rel="noopener">jest.config.js</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  transform: &#123;</span><br><span class="line">    <span class="string">'^.+\\.stories\\.[tj]sx?$'</span>: <span class="string">'@storybook/addon-storyshots/injectFileName'</span>,</span><br><span class="line">    <span class="string">'^.+\\.[tj]sx?$'</span>: <span class="string">'babel-jest'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建文件<code>src/__tests__/storyshot.test.ts</code></p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> initStoryshots, &#123; multiSnapshotWithOptions &#125; <span class="keyword">from</span> <span class="string">'@storybook/addon-storyshots'</span></span><br><span class="line"></span><br><span class="line">initStoryshots(&#123;</span><br><span class="line">  test: multiSnapshotWithOptions(),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之后组件中有写<code>stories</code>的地方，使用<code>yarn jest</code>，除了运行测试，也会自动为<code>*.stories.tsx</code>比对/生成 snapshot。</p><p>对于生成的 snapshot 你会看到<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35bdab0b215b44b492fa58d36e0f7200~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>比如我写了<code>Footer</code>组件的，只有 HTML 标签和对应属性，这样检测还不够，因为不知道 css 类的属性做了什么改变，由于我用的 css 方案是<code>styled-components</code>，所以需要再进行配置:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add -D jest-specific-snapshot jest-styled-components</span><br></pre></td></tr></table></figure><p>配置<code>src/__tests__/storyshot.test.ts</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> initStoryshots, &#123; multiSnapshotWithOptions &#125; <span class="keyword">from</span> <span class="string">'@storybook/addon-storyshots'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'jest-styled-components'</span></span><br><span class="line"><span class="keyword">import</span> &#123; addSerializer &#125; <span class="keyword">from</span> <span class="string">'jest-specific-snapshot'</span></span><br><span class="line"><span class="keyword">import</span> styleSheetSerializer <span class="keyword">from</span> <span class="string">'jest-styled-components/src/styleSheetSerializer'</span></span><br><span class="line"></span><br><span class="line">addSerializer(styleSheetSerializer)</span><br><span class="line"></span><br><span class="line">initStoryshots(&#123;</span><br><span class="line">  test: multiSnapshotWithOptions(),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>再来看现在的 snapshot，已经有了一堆样式可以参考对比了，这样细微组件样式修改都可以被捕捉到了；<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65ec364160d047ee919968fdeade6024~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h3 id="Enzyme"><a href="#Enzyme" class="headerlink" title="Enzyme"></a>Enzyme</h3><p>Jest 可以对函数，类等等有充足的 API 来测试，但对于 React 组件，想详细进行测试，则需要安装其他插件来支持，如<code>react-test-library</code>和<code>enzyme</code>，这里我就选我用过相对多一点的 <a href="https://enzymejs.github.io/enzyme/" target="_blank" rel="noopener">enzyme</a> （出自 Airbnb 公司），同时需要安装它的适配器。</p><p>这里由于 React 已经升级到 17 版本了，但是 enzyme 官方适配器还没有升级到对应 17 版本的，有些测试方法可能会报错，所以暂时使用目前 Github 使用较多的代替版本的这个库<code>@wojtekmaj/enzyme-adapter-react-17</code>，等官方更新了再替换。这个只是供测试用，不会影响到线上环境，只要 enzyme 自带所有方法能按预期运行不报错就行，这样就能好好写我们的测试用例了。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add enzyme @wojtekmaj&#x2F;enzyme-adapter-react-17 -D</span><br></pre></td></tr></table></figure><p>在根目录新建文件<code>jest.setup.ts</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Enzyme from &#39;enzyme&#39;</span><br><span class="line">import Adapter from &#39;@wojtekmaj&#x2F;enzyme-adapter-react-17&#39;</span><br><span class="line"></span><br><span class="line">Enzyme.configure(&#123; adapter: new Adapter() &#125;)</span><br></pre></td></tr></table></figure><p>同时在<code>jest.config.js</code>中导入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  setupFiles: [&#39;&lt;rootDir&gt;&#x2F;jest.setup.ts&#39;],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常情况，测试 React 组件是意义不大的，比较需要测试的就是比如 UI 组件，用得较多的通用组件，还有一些组件如一改动全身的容易有 bug 行为的来针对测试。</p><h2 id="生成-CHANGELOG-和自动化版本管理"><a href="#生成-CHANGELOG-和自动化版本管理" class="headerlink" title="生成 CHANGELOG 和自动化版本管理"></a>生成 CHANGELOG 和自动化版本管理</h2><p>这里我使用<code>standard-version</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add -D standard-version</span><br></pre></td></tr></table></figure><blockquote><p>standard-version 是一款遵循语义化版本（ semver）和 commit message 标准规范 的版本和 changlog 自动化工具。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;bump-version&quot;: &quot;standard-version --skip.commit --skip.tag&quot;</span><br></pre></td></tr></table></figure><p>运行<code>yarn bump-version</code>后，会发现 package.json 的版本号变了（前提你有了 feat 或 fix 等等 commit 的改动），还有自动生成 CAHNGEALOG.md，这些都可以自定义配置</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e6493286d5c444e88f11320dfc747e0~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h2 id="Github-打-tag-版本"><a href="#Github-打-tag-版本" class="headerlink" title="Github 打 tag 版本"></a>Github 打 tag 版本</h2><p>点击 Github 项目页面右边创建 release<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0c6529a09bd4eeb8b90e7172054ffec~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>然后填入版本号，详细信息我把 CHANGELOG.md 的内容直接搬过来，然后按<code>Publish release</code>就可以了。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/768d72503b254cf5b2b8b1d33d472c5a~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h2 id="完善-script-命令"><a href="#完善-script-命令" class="headerlink" title="完善 script 命令"></a>完善 script 命令</h2><p>在<code>package.json</code>中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;next dev&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;next start&quot;,</span><br><span class="line">  &quot;commit&quot;: &quot;git-cz&quot;,</span><br><span class="line">  &quot;test&quot;: &quot;jest&quot;,</span><br><span class="line">  &quot;coverage&quot;: &quot;yarn jest --coverage&quot;,</span><br><span class="line">  &quot;lint&quot;: &quot;yarn lint:eslint &amp;&amp; yarn lint:css&quot;,</span><br><span class="line">  &quot;lint:eslint&quot;: &quot;eslint --ext js,jsx,ts,tsx .&quot;,</span><br><span class="line">  &quot;lint:css&quot;: &quot;stylelint **&#x2F;*.&#123;ts,tsx&#125;&quot;,</span><br><span class="line">  &quot;prettier&quot;: &quot;prettier --write \&quot;**&#x2F;*.&#123;js,jsx,tsx,ts,less,md,json&#125;\&quot;&quot;,</span><br><span class="line">  &quot;tsc:client&quot;: &quot;tsc --noEmit -p tsconfig.json&quot;,</span><br><span class="line">  &quot;storybook&quot;: &quot;start-storybook -p 6006&quot;,</span><br><span class="line">  &quot;build-storybook&quot;: &quot;build-storybook -o .&#x2F;dist_storybook&quot;,</span><br><span class="line">  &quot;bump-version&quot;: &quot;standard-version --skip.commit --skip.tag&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="LICENSE"><a href="#LICENSE" class="headerlink" title="LICENSE"></a>LICENSE</h2><p>添加个开源协议，我选择宽松的 MIT 协议</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MIT License</span><br><span class="line"></span><br><span class="line">Copyright (c) 2020 nextjs-ts-redux-antd-starter</span><br><span class="line"></span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy</span><br><span class="line">of this software and associated documentation files (the &quot;Software&quot;), to deal</span><br><span class="line">in the Software without restriction, including without limitation the rights</span><br><span class="line">to use, copy, modify, merge, publish, distribute, sublicense, and&#x2F;or sell</span><br><span class="line">copies of the Software, and to permit persons to whom the Software is</span><br><span class="line">furnished to do so, subject to the following conditions:</span><br><span class="line"></span><br><span class="line">The above copyright notice and this permission notice shall be included in all</span><br><span class="line">copies or substantial portions of the Software.</span><br><span class="line"></span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span><br><span class="line">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span><br><span class="line">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span><br><span class="line">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span><br><span class="line">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span><br><span class="line">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span><br><span class="line">SOFTWARE.</span><br></pre></td></tr></table></figure><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>如上演示还略过一些细节其他配置，需要详细的就看<a href="https://github.com/Jacky-Summer/nextjs-ts-antd-redux-storybook-starter" target="_blank" rel="noopener">源码</a>吧。</p><p>整个脚手架我是不打算加入太多东西的，如下图所示，毕竟做为模板脚手架，加太多功能反而要用的时候要删除一大堆麻烦，因为做的不是某类型业务网站，有一些只能尽量有个 Demo 参考就行。所以我会尽量保持简洁，之后维护我会倾向于 Next.js 配置和前端工程化及性能优化的角度进行完善，然后就是一些通用的函数和功能。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8071fa608e01412c878c3dcc3e07a021~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>脚手架到这里就完了？还没有，还有很多没加，比如整理 Next.js 的 config 配置，优化 SEO，发布到线上网站和 npm，一些兼容，特殊页面处理，响应式等等。</p><p>当然，在我写这篇文章时的脚手架多少也有写的不好或不完善的地方，因为刚起步，所以该脚手架会持续维护，把工作实践和学习到的最佳实践运行到该项目里，不断保持更新，敬请关注，欢迎 star 🌟🌟🌟 <a href="https://github.com/Jacky-Summer/nextjs-ts-antd-redux-storybook-starter" target="_blank" rel="noopener">https://github.com/Jacky-Summer/nextjs-ts-antd-redux-storybook-starter</a></p><br><ul><li>ps：<ul><li><a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a></li><li><a href="https://github.com/Jacky-Summer/monki-ui" target="_blank" rel="noopener">monki-ui</a>：基于 React + TypeScript + Dumi + Jest + Enzyme 开发 UI 组件库，未来会写相关文章</li></ul></li></ul><p>觉得不错的话赏个 star，给我持续创作的动力吧！下次继续…</p>]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
        <tag>NextJS</tag>
        <tag>Ant Design</tag>
        <tag>TypeScript</tag>
        <tag>Jest</tag>
        <tag>redux-saga</tag>
        <tag>Storybook</tag>
        <tag>Styled-components</tag>
        <tag>Enzyme</tag>
      </tags>
  </entry>
  <entry>
    <title>回顾 HTTP1.0-HTTP1.1-HTTP2.0区别</title>
    <url>/2020/12/10/%E5%9B%9E%E9%A1%BE-HTTP1-0-HTTP1-1-HTTP2-0%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>回顾 HTTP1 HTTP1.1 HTTP2.0 区别</p><a id="more"></a><h2 id="HTTP1-0-和-HTTP1-1-的一些区别"><a href="#HTTP1-0-和-HTTP1-1-的一些区别" class="headerlink" title="HTTP1.0 和 HTTP1.1 的一些区别"></a>HTTP1.0 和 HTTP1.1 的一些区别</h2><h3 id="缓存处理"><a href="#缓存处理" class="headerlink" title="缓存处理"></a>缓存处理</h3><p>在 HTTP1.0 中主要使用 header 里的 <code>If-Modified-Since</code>（比较资源最后的更新时间是否一致）,<code>Expires</code>（资源的过期时间（取决于客户端本地时间）） 来做为缓存判断的标准。</p><p>HTTP1.1 则引入了更多的缓存控制策略：</p><ul><li><code>Entity tag</code>：资源的匹配信息</li><li><code>If-Unmodified-Since</code>：比较资源最后的更新时间是否不一致</li><li><code>If-Match</code>：比较 ETag 是否一致</li><li><code>If-None-Match</code>：比较 ETag 是否不一致</li></ul><p>等更多可供选择的缓存头来控制缓存策略。</p><h3 id="带宽优化"><a href="#带宽优化" class="headerlink" title="带宽优化"></a>带宽优化</h3><p>HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。</p><p>HTTP 1.1默认支持断点续传。</p><h3 id="Host-头处理"><a href="#Host-头处理" class="headerlink" title="Host 头处理"></a>Host 头处理</h3><p>在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。</p><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP1.0 需要使用<code>keep-alive</code>参数来告知服务器端要建立一个长连接，而 HTTP1.1 默认支持长连接，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。</p><p>HTTP 是基于 TCP/IP 协议的，创建一个 TCP 连接是需要经过三次握手的,有一定的开销，如果每次通讯都要重新建立连接的话，对性能有影响。因此最好能维持一个长连接，可以用个长连接来发多个请求。</p><p>HTTP1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p><h3 id="错误通知的管理"><a href="#错误通知的管理" class="headerlink" title="错误通知的管理"></a>错误通知的管理</h3><p>在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</p><h3 id="新增请求方式"><a href="#新增请求方式" class="headerlink" title="新增请求方式"></a>新增请求方式</h3><ul><li>PUT：请求服务器存储一个资源</li><li>DELETE：请求服务器删除标识的资源</li><li>OPTIONS：请求查询服务器的性能，或者查询与资源相关的选项和需求</li><li>CONNECT：保留请求以供将来使用</li><li>TRACE：请求服务器回送收到的请求信息，主要用于测试或诊断</li></ul><h2 id="HTTP2-0-与-HTTP1-X-的区别"><a href="#HTTP2-0-与-HTTP1-X-的区别" class="headerlink" title="HTTP2.0 与 HTTP1.X 的区别"></a>HTTP2.0 与 HTTP1.X 的区别</h2><p>HTTP1.X 版本的缺陷概括来说是：线程阻塞，在同一时间，同一域名的请求有一定的数量限制，超过限制数目的请求会被阻塞。</p><h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>HTTP1.x 的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认 0 和 1 的组合。基于这种考虑 HTTP2.0 的协议解析决定采用二进制格式，实现方便且健壮。</p><p>HTTP2.0 在 应用层(HTTP2.0)和传输层(TCP/UDP)之间增加一个二进制分帧层。在不改动 HTTP1.X 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了 HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层中，HTTP2.0 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.X 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。</p><ul><li><p>帧：HTTP2.0 数据通信的最小单位消息：指 HTTP2.0 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。</p></li><li><p>流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数 ID。</p></li></ul><h3 id="多路复用（MultiPlexing）"><a href="#多路复用（MultiPlexing）" class="headerlink" title="多路复用（MultiPlexing）"></a>多路复用（MultiPlexing）</h3><p>多路复用允许同时通过单一的 HTTP2.0 连接发起多重的请求-响应消息。即是连接共享，提高了连接的利用率，降低延迟。即每一个 request 都是是用作连接共享机制的。一个 request 对应一个 id，这样一个连接上可以有多个 request，每个连接的 request 可以随机的混杂在一起，接收方可以根据 request 的 id 将 request 再归属到各自不同的服务端请求里面。</p><p>在 HTTP1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一。</p><p>当然 HTTP1.1 也可以多建立几个 TCP 连接，来支持处理更多并发的请求，但是创建 TCP 连接本身也是有开销的。</p><p>TCP 连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。</p><p>HTTP2.0 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，同个域名只需要占用一个 TCP 连接，消除了因多个 TCP 连接而带来的延时和内存消耗。HTTP2.0 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。</p><h3 id="header-压缩"><a href="#header-压缩" class="headerlink" title="header 压缩"></a>header 压缩</h3><p>HTTP1.x 的 header 带有大量信息，而且每次都要重复发送，HTTP2.0 使用 HPACK 算法对 header 的数据进行压缩，减少需要传输的 header 大小，通讯双方各自 cache 一份 header fields 表，差量更新 HTTP 头部，既避免了重复 header 的传输，又减小了需要传输的大小。</p><p>header 采取的压缩策略：</p><ul><li>HTTP2.0 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送；</li><li>首部表在 HTTP2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新;</li><li>每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。</li></ul><h3 id="服务端推送（server-push）"><a href="#服务端推送（server-push）" class="headerlink" title="服务端推送（server push）"></a>服务端推送（server push）</h3><p>服务端推送是一种在客户端请求之前发送数据的机制。</p><p>服务端可以在发送页面 HTML 时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 时再发送这些请求。</p><p>服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。</p><p>参考文章：</p><ul><li><a href="https://juejin.cn/post/6844903824390537230" target="_blank" rel="noopener">HTTP1.0，HTTP1.1，HTTPS 和 HTTP2.0 的区别</a></li><li><a href="https://zhuanlan.zhihu.com/p/26559480" target="_blank" rel="noopener">一文读懂 HTTP/2 特性</a></li></ul><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>HTTP系列</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>前端安全-XSS和CSRF</title>
    <url>/2020/12/03/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8-XSS%E5%92%8CCSRF/</url>
    <content><![CDATA[<p>本篇主要讲下关于前端安全——XSS 和 CSRF</p><a id="more"></a><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>XSS（Cross Site Script），指<strong>跨站脚本攻击</strong>。原本缩写为 CSS，但因为与层叠样式表缩写（CSS）重名要做区分，所以改为 XSS。</p><h3 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>攻击者通过向网站页面注入恶意脚本（一般是 JavaScript），通过恶意脚本对客户端网页进行篡改，达到窃取信息等目的，本质是数据被当作程序执行。</p><h3 id="XSS-的注入点"><a href="#XSS-的注入点" class="headerlink" title="XSS 的注入点"></a>XSS 的注入点</h3><ul><li>HTML 的节点内容或属性，存在读取可输入数据</li><li>javascript 代码，存在由后台注入的变量或用户输入的信息</li><li>富文本</li></ul><h3 id="XSS-危害"><a href="#XSS-危害" class="headerlink" title="XSS 危害"></a>XSS 危害</h3><ul><li>通过 document.cookie 盗取 cookie</li><li>使用 js 或 css 破坏页面正常的结构与样式</li><li>流量劫持（通过访问某段具有 window.location.href 定位到其他页面:<code>&lt;script&gt;window.location.href=&quot;www.baidu.com&quot;;&lt;/script&gt;</code>）</li><li>Dos 攻击：利用合理的客户端请求来占用过多的服务器资源，从而使合法用户无法得到服务器响应</li><li>利用 iframe、frame、XMLHttpRequest 或上述 Flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作</li><li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动</li><li>偷取网站任意数据、用户资料等等</li></ul><h3 id="XSS-的类型"><a href="#XSS-的类型" class="headerlink" title="XSS 的类型"></a>XSS 的类型</h3><h4 id="反射型（非持久）"><a href="#反射型（非持久）" class="headerlink" title="反射型（非持久）"></a>反射型（非持久）</h4><p>反射型 XSS，也叫非持久型 XSS，是指发生请求时，XSS 代码出现在请求 URL 中，作为参数提交到服务器，服务器解析并响应。响应内容包含 XSS 代码，返回给浏览器解析并执行，这个过程就像一次反射，所以叫反射型 XSS。</p><p>这种攻击方式通常需要攻击者诱使用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。</p><p>该方式只会经过服务器，不会经过数据库。</p><p>例子：<br>比如用户进行搜索时，点击搜索按钮访问到如下链接</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;xxx.com&#x2F;search?keyword&#x3D;&quot;&gt;&lt;script&gt;alert(&#39;XSS攻击&#39;);&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>当浏览器请求时，服务器解析参数 keyword，得到<code>&quot;&gt;&lt;script&gt;alert(&#39;XSS攻击&#39;);&lt;/script&gt;</code>，拼接到 HTML 中返回给浏览器，如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  alert(<span class="string">'XSS攻击'</span>)</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">"&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  您搜索的关键词是："&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    alert(<span class="string">'XSS攻击'</span>)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因此将其执行了。</p><h4 id="存储型（持久）"><a href="#存储型（持久）" class="headerlink" title="存储型（持久）"></a>存储型（持久）</h4><p>存储型 XSS，也叫持久型 XSS，主要是将 XSS 代码发送到服务器，当浏览器请求数据时，脚本从服务器上传回并执行。与反射型 XSS 的差别在于，提交的代码会存储在服务器端，下次请求时目标页面时不用再提交 XSS 代码。</p><p>比较常见的场景就是网页的留言板，攻击者在留言板写下包含攻击性的脚本代码，发表之后所有访问该留言的用户，留言内容从服务器解析之后发现有 XSS 代码于是当做正常的 HTML 和 JS 解析执行，就发生了 XSS 攻击。</p><p>该方式会经过服务器，也会经过数据库。</p><h4 id="DOM-型"><a href="#DOM-型" class="headerlink" title="DOM 型"></a>DOM 型</h4><p>基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，将攻击脚本写在 URL 中，诱导用户点击该 URL，如果 URL 被解析，那么攻击脚本就会被运行，和前两者 XSS 攻击区别是：取出和执行恶意代码由浏览器端完成，不经过服务端，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞主要在于 DOM 型攻击。</p><p>例子引用自：<a href="https://juejin.im/post/6844904090019840007#heading-5" target="_blank" rel="noopener">DOM 型攻击例子</a></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>XSS:<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"input"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> div = <span class="built_in">document</span>.getElementById(<span class="string">'div'</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> val</span></span><br><span class="line"></span><br><span class="line">  input.addEventListener(</span><br><span class="line"><span class="actionscript">    <span class="string">'change'</span>,</span></span><br><span class="line">    e =&gt; &#123;</span><br><span class="line">      val = e.target.value</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  btn.addEventListener(</span><br><span class="line"><span class="actionscript">    <span class="string">'click'</span>,</span></span><br><span class="line">    () =&gt; &#123;</span><br><span class="line"><span class="handlebars"><span class="xml">      div.innerHTML = `<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">$&#123;val&#125;</span>&gt;</span>testLink<span class="tag">&lt;/<span class="name">a</span>&gt;</span>`</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  )</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击 Submit 按钮后，会在当前页面插入一个链接，其地址为用户的输入内容。如果用户在输入时构造了如下内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&#39; onclick&#x3D;alert(&#x2F;xss&#x2F;)</span><br></pre></td></tr></table></figure><p>用户提交之后，页面代码就变成了：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> <span class="attr">onlick</span>=<span class="string">"alert(/xss/)"</span>&gt;</span>testLink<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时，用户点击生成的链接，就会执行对应的脚本。</p><h3 id="如何防范-XSS"><a href="#如何防范-XSS" class="headerlink" title="如何防范 XSS"></a>如何防范 XSS</h3><p>总体就是<strong>不能将用户的输入直接存到服务器，需要对一些数据进行特殊处理</strong></p><h4 id="设置-HttpOnly"><a href="#设置-HttpOnly" class="headerlink" title="设置 HttpOnly"></a>设置 HttpOnly</h4><p>HttpOnly 是一个设置 cookie 是否可以被 javasript 脚本读取的属性，浏览器会禁止页面的 Javascript 访问带有 HttpOnly 属性的 Cookie。</p><p>严格来说，这种方式不是防御 XSS，而是在用户被 XSS 攻击之后，不被获取 Cookie 数据。</p><h4 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP 内容安全策略"></a>CSP 内容安全策略</h4><p>CSP(content security policy)，是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。</p><p>CSP 可以通过 HTTP 头部（Content-Security-Policy）或</p><meta>元素配置页面的内容安全策略，以控制浏览器可以为该页面获取哪些资源。比如一个可以上传文件和显示图片页面，应该允许图片来自任何地方，但限制表单的 action 属性只可以赋值为指定的端点。<p></p><p>现在主流的浏览器内置了防范 XSS 的措施，开启 CSP，即开启白名单，可阻止白名单以外的资源加载和运行</p><h4 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h4><p>对于用户的任何输入要进行编码、解码和过滤：</p><ul><li>编码：不能对用户输入的内容都保持原样，对用户输入的数据进行字符实体编码转义</li><li>解码：原样显示内容的时候必须解码，不然显示不到内容了</li><li>过滤：把输入的一些不合法的东西都过滤掉，从而保证安全性。如移除用户上传的 DOM 属性，如 onerror，移除用户上传的 Style 节点、iframe、script 节点等</li></ul><p>对用户输入所包含的特殊字符或标签进行编码或过滤，如 <code>&lt;</code>，<code>&gt;</code>，<code>script</code>，防止 XSS 攻击</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escHTML</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!str) <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">  <span class="keyword">return</span> str</span><br><span class="line">    .replace(<span class="regexp">/&amp;/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/x27/g</span>, <span class="string">'&amp;#039;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/x22/g</span>, <span class="string">'&amp;quto;'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h4><p>用户的输入会存在问题，服务端的输出也会存在问题。一般来说，除富文本的输出外，在变量输出到 HTML 页面时，可以使用编码或转义的方式来防御 XSS 攻击。例如利用 <a href="https://github.com/apostrophecms/sanitize-html" target="_blank" rel="noopener">sanitize-html</a> 对输出内容进行有规则的过滤之后再输出到页面中。</p><h4 id="输入内容长度控制"><a href="#输入内容长度控制" class="headerlink" title="输入内容长度控制"></a>输入内容长度控制</h4><p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p><h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>防止脚本冒充用户提交危险操作。</p><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>CSRF(Cross Site Request Forgery)指的是<strong>跨站请求伪造</strong>，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。跨域指的是请求来源于其他网站，伪造指的是非用户自身的意愿。</p><h3 id="攻击方式-1"><a href="#攻击方式-1" class="headerlink" title="攻击方式"></a>攻击方式</h3><p>攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p>与 XSS 攻击不同的是：XSS 是攻击者直接对我们的网站 A 进行注入攻击，CSRF 是通过网站 B 对我们的网站 A 进行伪造请求。</p><p>例子：你登录购物网站 A 之后点击一个恶意链接 B，B 请求了网站 A 的下单接口，结果是在网站 A 的帐号生成一个订单。其背后的原理是：网站 B 通过表单、get 请求来伪造网站 A 的请求，这时候请求会带上网站 A 的 cookies，若登录态是保存在 cookies 中，则实现了伪造攻击。</p><p>跨站请求可以用各种方式：图片 URL、超链接、CORS、Form 提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中。</p><h3 id="CSRF-危害"><a href="#CSRF-危害" class="headerlink" title="CSRF 危害"></a>CSRF 危害</h3><ul><li>用户的登录态被盗用</li><li>冒充用户完成操作或修改数据</li></ul><h3 id="CSRF-的类型"><a href="#CSRF-的类型" class="headerlink" title="CSRF 的类型"></a>CSRF 的类型</h3><h4 id="GET-类型的-CSRF"><a href="#GET-类型的-CSRF" class="headerlink" title="GET 类型的 CSRF"></a>GET 类型的 CSRF</h4><p>例子引入自：<a href="https://juejin.im/post/6844903904585449479#heading-1" target="_blank" rel="noopener">GET CSRF 例子</a></p><p>假设有这样一个场景：目标网站 A(<code>www.a.com</code>)，恶意网站 B(<code>www.b.com</code>)</p><p>两个网站的域名不一样，目标网站 A 上有一个删除文章的功能，通常是用户单击’删除文章’链接时才会删除指定的文章。这个链接是<code>www.a.com/blog/del?id=1</code>, id 代表不同的文章。实际上就是发起一个 GET 请求</p><ul><li>无法使用 Ajax 发起 GET 请求。因为 CSRF 请求是跨域的，而 Ajax 有同源策略的限制</li><li>可以通过在恶意网站 B 上静态或者动态创建 img,script 等标签发起 GET 请求。将其 src 属性指向<code>www.a.com/blog/del?id=1</code>。通过标签的方式发起的请求不受同源策略的限制</li><li>最后欺骗已经登录目标网站 A 的用户访问恶意网站 B，那么就会携带网站 A 源的登录凭证向网站 A 后台发起请求，这样攻击就发生了</li></ul><p>CSRF 攻击有以下几个关键点：</p><ul><li>请求是跨域的，可以看出请求是从恶意网站 B 上发出的</li><li>通过 img, script 等标签来发起一个 GET 请求，因为这些标签不受同源策略的限制</li><li>发出的请求是身份认证后的</li></ul><h4 id="POST-类型的-CSRF"><a href="#POST-类型的-CSRF" class="headerlink" title="POST 类型的 CSRF"></a>POST 类型的 CSRF</h4><p>假如目标网站 A 上有发表文章的功能，那么我们就可以动态创建 form 标签，然后修改文章的题目。</p><p>在网站 B 中：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setForm</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> form = <span class="built_in">document</span>.createElement(<span class="string">'form'</span>)</span><br><span class="line">  form.action = <span class="string">'www.a.com/blog/article/update'</span></span><br><span class="line">  form.methods = <span class="string">'POST'</span></span><br><span class="line">  <span class="keyword">var</span> input = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>)</span><br><span class="line">  input.type = <span class="string">'text'</span></span><br><span class="line">  input.value = <span class="string">'csfr攻击啦！'</span></span><br><span class="line">  input.id = <span class="string">'title'</span></span><br><span class="line">  form.appendChild(input)</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(form)</span><br><span class="line">  form.submit()</span><br><span class="line">&#125;</span><br><span class="line">setForm()</span><br></pre></td></tr></table></figure><p>上面代码可以看出，动态创建了 form 表单，然后调用 submit 方法，就可以通过跨域的伪造请求来实现修改目标网站 A 的某篇文章的标题了。</p><p>通常是利用自动提交的表单</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://xxx.com/money"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"account"</span> <span class="attr">value</span>=<span class="string">"jacky"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"amount"</span> <span class="attr">value</span>=<span class="string">"10000"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.forms[<span class="number">0</span>].submit()</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="链接类型的-CSRF"><a href="#链接类型的-CSRF" class="headerlink" title="链接类型的 CSRF"></a>链接类型的 CSRF</h4><p>链接类型的 CSRF 并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker"</span> <span class="attr">taget</span>=<span class="string">"_blank"</span>&gt;</span> 重磅消息！！ <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="如何防范-CSRF"><a href="#如何防范-CSRF" class="headerlink" title="如何防范 CSRF"></a>如何防范 CSRF</h3><h4 id="验证码-1"><a href="#验证码-1" class="headerlink" title="验证码"></a>验证码</h4><p>由于 CSRF 攻击伪造请求不会经过受攻击的网站，所以我们可以在网站加入验证码，这样必须通过验证码之后才能进行请求，有效的遏制了 CSRF 请求。</p><p>但是，这种方式不是万能的，并不是每个请求都加验证码，那样用户体验会非常不好，只能在部分请求添加，作为一种辅助的防御手段。</p><h4 id="验证-Referer"><a href="#验证-Referer" class="headerlink" title="验证 Referer"></a>验证 Referer</h4><p>在 HTTP 协议中，头部有个 Referer 字段，他记录了该 HTTP 请求的来源地址，在服务端设置该字段的检验，通过检查该字段，就可以知道该请求是否合法，不过请求头也容易伪造。</p><h4 id="cookie-设置-SameSite"><a href="#cookie-设置-SameSite" class="headerlink" title="cookie 设置 SameSite"></a>cookie 设置 SameSite</h4><p>设置 SameSite：设置 cookie 的 SameSite 值为 strict，这样只有同源网站的请求才会带上 cookie。这样 cookies 就不能被其他域名网站使用，达到了防御的目的。</p><h4 id="添加-token-验证"><a href="#添加-token-验证" class="headerlink" title="添加 token 验证"></a>添加 token 验证</h4><p>浏览器请求服务器时，服务器返回一个 token，每个请求都需要同时带上 token 和 cookie 才会被认为是合法请求</p><p>这是一种相对成熟的解决方案。要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。在服务端随机生成 token，在 HTTP 请求中以参数的形式加入这个 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><h4 id="更换登录态方案"><a href="#更换登录态方案" class="headerlink" title="更换登录态方案"></a>更换登录态方案</h4><p>因为 CSRF 本质是伪造请求携带了保存在 cookies 中的信息，所以对 session 机制的登录态比较不利，如果更换 JWT（JSON Web Token）方案，其 token 信息一般设置到 HTTP 头部的，所以可以防御 CSRF 攻击。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://juejin.im/post/6844903876106125319" target="_blank" rel="noopener">WEB 前端安全——XSS 和 CSRF</a></p><br></li><li><p>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，欢迎 star</p></li></ul>]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>XSS</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈对 React 新旧生命周期的理解</title>
    <url>/2020/11/30/%E8%B0%88%E8%B0%88%E5%AF%B9-React-%E6%96%B0%E6%97%A7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>在写这篇文章的时候，React 已经出了 17.0.1 版本了，虽说还来讨论目前 React 新旧生命周期有点晚了，React 两个新生命周期虽然出了很久，但实际开发我却没有用过，因为 React 16 版本后我们直接 React Hook 起飞开发项目。</p><p>但对新旧生命周期的探索，还是有助于我们更好理解 React 团队一些思想和做法，于是今天就要回顾下这个问题和理解总结。</p><a id="more"></a><p>本文只讨论 React17 版本前的。</p><h2 id="React-16-版本后做了什么"><a href="#React-16-版本后做了什么" class="headerlink" title="React 16 版本后做了什么"></a>React 16 版本后做了什么</h2><p>首先是给三个生命周期函数加上了 UNSAFE：</p><ul><li>UNSAFE_componentWillMount</li><li>UNSAFE_componentWillReceiveProps</li><li>UNSAFE_componentWillUpdate</li></ul><p>这里并不是表示不安全的意思，它只是不建议继续使用，并表示使用这些生命周期的代码可能在未来的 React 版本（目前 React17 还没有完全废除）存在缺陷，如 React Fiber 异步渲染的出现。</p><p>同时新增了两个生命周期函数：</p><ul><li>getDerivedStateFromProps</li><li>getSnapshotBeforeUpdate</li></ul><h2 id="UNSAFE-componentWillReceiveProps"><a href="#UNSAFE-componentWillReceiveProps" class="headerlink" title="UNSAFE_componentWillReceiveProps"></a>UNSAFE_componentWillReceiveProps</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UNSAFE_componentWillReceiveProps(nextProps)</span><br></pre></td></tr></table></figure><p>先来说说这个函数，<code>componentWillReceiveProps</code></p><p>该子组件方法并不是父组件 props 改变才触发，官方回答是：</p><blockquote><p>如果父组件导致组件重新渲染，即使 props 没有更改，也会调用此方法。如果只想处理更改，请确保进行当前值与变更值的比较。</p></blockquote><p>先来说说 React 为什么废除该函数，废除肯定有它不好的地方。</p><p><code>componentWillReceiveProps</code>函数的一般使用场景是：</p><ul><li>如果组件自身的某个 state 跟父组件传入的 props 密切相关的话，那么可以在该方法中判断前后两个 props 是否相同，如果不同就根据 props 来更新组件自身的 state。<br>类似的业务需求比如：一个可以横向滑动的列表，当前高亮的 Tab 显然隶属于列表自身的状态，但很多情况下，业务需求会要求从外部跳转至列表时，根据传入的某个值，直接定位到某个 Tab。</li></ul><p>但该方法缺点是会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。</p><p>而在新版本中，官方将更新 state 与触发回调重新分配到了 <code>getDerivedStateFromProps</code> 与 <code>componentDidUpdate</code> 中，使得组件整体的更新逻辑更为清晰。</p><p>新生命周期方法<code>static getDerivedStateFromProps(props, state)</code>怎么用呢？</p><blockquote><p>getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。</p></blockquote><p>从函数名字就可以看出大概意思：使用 props 来派生/更新 state。这就是重点了，但凡你想使用该函数，都必须出于该目的，使用它才是正确且符合规范的。</p><p>跟<code>getDerivedStateFromProps</code>不同的是，它在挂载和更新阶段都会执行（<code>componentWillReceiveProps</code>挂载阶段不会执行），因为更新 state 这种需求不仅在 props 更新时存在，在 props 初始化时也是存在的。</p><p>而且<code>getDerivedStateFromProps</code>在组件自身 state 更新也会执行而<code>componentWillReceiveProps</code>方法执行则取决于父组件的是否触发重新渲染，也可以看出<code>getDerivedStateFromProps</code>并不是 <code>componentWillReceiveProps</code>方法的替代品.</p><p>引起我们注意的是，这个生命周期方法是一个静态方法，静态方法不依赖组件实例而存在，故在该方法内部是无法访问 this 的。新版本生命周期方法能做的事情反而更少了，限制我们只能根据 props 来派生 state，官方是基于什么考量呢？</p><p>因为无法拿到组件实例的 this，这也导致我们无法在函数内部做 this.fetch()请求，或者不合理的 this.setState()操作导致可能的死循环或其他副作用。有没有发现，这都是不合理不规范的操作，但开发者们都有机会这样用。可如果加了个静态 static，间接强制我们都无法做了，也从而避免对生命周期的滥用。</p><p>React 官方也是通过该限制，尽量保持生命周期行为的可控可预测，根源上帮助了我们避免不合理的编程方式，即一个 API 要保持单一性，做一件事的理念。</p><p>如下例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.isLogin !== <span class="keyword">this</span>.props.isLogin) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      isLogin: nextProps.isLogin,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.isLogin) &#123;</span><br><span class="line">    <span class="keyword">this</span>.handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.isLogin !== prevState.isLogin) &#123; <span class="comment">// 被对比的props会被保存一份在state里</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      isLogin: nextProps.isLogin, <span class="comment">// getDerivedStateFromProps 的返回值会自动 setState</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!prevState.isLogin &amp;&amp; <span class="keyword">this</span>.props.isLogin) &#123;</span><br><span class="line">    <span class="keyword">this</span>.handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UNSAVE-componentWillMount"><a href="#UNSAVE-componentWillMount" class="headerlink" title="UNSAVE_componentWillMount"></a>UNSAVE_componentWillMount</h2><blockquote><p>UNSAFE_componentWillMount() 在挂载之前被调用。它在 render() 之前调用，因此在此方法中同步调用 setState() 不会触发额外渲染。</p></blockquote><p>我们应该避免在此方法中引入任何副作用或事件订阅，而是选用<code>componentDidMount()</code>。</p><p>在 React 初学者刚接触的时候，可能有这样一个疑问：一般都是数据请求放在<code>componentDidMount</code>里面，但放在<code>componentWillMount</code>不是会更快获取数据吗？</p><p>因为理解是<code>componentWillMount</code>在 render 之前执行，早一点执行就早拿到请求结果；但是其实不管你请求多快，都赶不上首次 render，页面首次渲染依旧处于没有获取异步数据的状态。</p><p>还有一个原因，<code>componentWillMount</code>是服务端渲染唯一会调用的生命周期函数，如果你在此方法中请求数据，那么服务端渲染的时候，在服务端和客户端都会分别请求两次相同的数据，这显然也我们想看到的结果。</p><p>特别是有了 React Fiber，更有机会被调用多次，故请求不应该放在<code>componentWillMount</code>中。</p><p>还有一个错误的使用是在<code>componentWillMount</code>中订阅事件，并在<code>componentWillUnmount</code>中取消掉相应的事件订阅。事实上只有调用<code>componentDidMount</code>后，React 才能保证稍后调用<code>componentWillUnmount</code>进行清理。而且服务端渲染时不会调用<code>componentWillUnmount</code>，可能导致内存泄露。</p><p>还有人会将事件监听器（或订阅）添加到 <code>componentWillMount</code> 中，但这可能导致服务器渲染（永远不会调用 <code>componentWillUnmount</code>）和异步渲染（在渲染完成之前可能被中断，导致不调用 <code>componentWillUnmount</code>）的内存泄漏。</p><p>对于该函数，一般情况，如果项目有使用，则是通常把现有 <code>componentWillMount</code> 中的代码迁移至 <code>componentDidMount</code> 即可。</p><h2 id="UNSAFE-componentWillUpdate"><a href="#UNSAFE-componentWillUpdate" class="headerlink" title="UNSAFE_componentWillUpdate"></a>UNSAFE_componentWillUpdate</h2><blockquote><p>当组件收到新的 props 或 state 时，会在渲染之前调用 <code>UNSAFE_componentWillUpdate()</code>。使用此作为在更新发生之前执行准备更新的机会。初始渲染不会调用此方法。</p></blockquote><p>注意，不能在该方法中调用 this.setState()；在 <code>componentWillUpdate</code> 返回之前，你也不应该执行任何其他操作（例如，dispatch Redux 的 action）触发对 React 组件的更新。</p><p>首先跟上面两个函数一样，该函数也发生在 render 之前，也存在一次更新被调用多次的可能，从这一点上看就依然不可取了。</p><p>其次，该方法常见的用法是在组件更新前，读取当前某个 DOM 元素的状态，并在 <code>componentDidUpdate</code> 中进行相应的处理。但 React 16 版本后有 suspense、异步渲染机制等等，render 过程可以被分割成多次完成，还可以被暂停甚至回溯，这导致 <code>componentWillUpdate</code> 和 <code>componentDidUpdate</code> 执行前后可能会间隔很长时间，这导致 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。而且足够使用户进行交互操作更改当前组件的状态，这样可能会导致难以追踪的 BUG。</p><p>为了解决这个问题，于是就有了新的生命周期函数：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getSnapshotBeforeUpdate(prevProps, prevState)</span><br></pre></td></tr></table></figure><blockquote><p><code>getSnapshotBeforeUpdate</code> 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为第三个参数传入<code>componentDidUpdate(prevProps, prevState, snapshot)</code></p></blockquote><p>与 <code>componentWillUpdate</code> 不同，<code>getSnapshotBeforeUpdate</code> 会在最终的 render 之前被调用，也就是说在 <code>getSnapshotBeforeUpdate</code> 中读取到的 DOM 元素状态是可以保证与 <code>componentDidUpdate</code> 中一致的。</p><p>虽然 <code>getSnapshotBeforeUpdate</code> 不是一个静态方法，但我们也应该尽量使用它去返回一个值。这个值会随后被传入到 <code>componentDidUpdate</code> 中，然后我们就可以在 <code>componentDidUpdate</code> 中去更新组件的状态，而不是在 <code>getSnapshotBeforeUpdate</code> 中直接更新组件状态。避免了 <code>componentWillUpdate</code> 和 <code>componentDidUpdate</code> 配合使用时将组件临时的状态数据存在组件实例上浪费内存，<code>getSnapshotBeforeUpdate</code> 返回的数据在 <code>componentDidUpdate</code> 中用完即被销毁，效率更高。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8eb7f64f3f94a9f8038949001284385~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>来看官方的一个例子：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ScrollingList extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.listRef &#x3D; React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    &#x2F;&#x2F; 我们是否在 list 中添加新的 items？</span><br><span class="line">    &#x2F;&#x2F; 捕获滚动位置以便我们稍后调整滚动位置。</span><br><span class="line">    if (prevProps.list.length &lt; this.props.list.length) &#123;</span><br><span class="line">      const list &#x3D; this.listRef.current;</span><br><span class="line">      return list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span><br><span class="line">    &#x2F;&#x2F; 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span><br><span class="line">    &#x2F;&#x2F;（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span><br><span class="line">    if (snapshot !&#x3D;&#x3D; null) &#123;</span><br><span class="line">      const list &#x3D; this.listRef.current;</span><br><span class="line">      list.scrollTop &#x3D; list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div ref&#x3D;&#123;this.listRef&#125;&gt;&#123;&#x2F;* ...contents... *&#x2F;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果项目中有用到<code>componentWillUpdate</code>的话，升级方案就是将现有的 <code>componentWillUpdate</code> 中的回调函数迁移至 <code>componentDidUpdate</code>。如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 <code>getSnapshotBeforeUpdate</code>，然后在 <code>componentDidUpdate</code> 中统一触发回调或更新状态。</p><p>除了这些，React 16 版本的依然还有大改动，其中引人注目的就是 Fiber，之后我还会抽空写一篇关于 React Fiber 的文章，可以关注我的<a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</p><p>参考：</p><ul><li><a href="https://www.html.cn/qa/react/14367.html" target="_blank" rel="noopener">为什么废弃 react 生命周期函数</a></li><li><a href="https://juejin.cn/post/6844903600309665799" target="_blank" rel="noopener">React v16.3 版本新生命周期函数浅析及升级方案</a></li></ul>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 和 HTTPS 协议</title>
    <url>/2020/11/23/HTTP-%E5%92%8C-HTTPS-%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p>HTTP 是前端开发人员必须知道的知识，也是日常处理请求都会接触的，但如果要构成知识体系，则需要一点点填充知识，今天就要讲下 HTTP 和 HTTPS 协议。</p><a id="more"></a><h2 id="HTTP-协议是什么"><a href="#HTTP-协议是什么" class="headerlink" title="HTTP 协议是什么"></a>HTTP 协议是什么</h2><p>HTTP 协议是超文本传输协议的缩写，英文是<code>Hyper Text Transfer Protocol</code>。它是一个基于请求与响应，无状态的，应用层的协议，常基于<code>TCP/IP</code>协议传输数据，互联网上应用最为广泛的一种网络协议。设计 HTTP 的初衷是为了提供一种发布和接收 HTML 页面的方法。</p><p>HTTP 有多个版本，目前广泛使用的是<code>HTTP/1.1</code>版本。</p><h2 id="HTTP-特点"><a href="#HTTP-特点" class="headerlink" title="HTTP 特点"></a>HTTP 特点</h2><ul><li><strong>请求和响应</strong>：基本的特性，由客户端发起请求，服务端响应</li><li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。</li><li><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象。传输的类型由<code>Content-Type</code>以标记。</li><li><strong>无连接</strong>：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录 HTTP 状态的技术，一个叫做 Cookie,一个叫做 Session。</li><li><strong>无状态</strong>：无状态是指协议对于事务处理没有记忆，后续处理需要前面的信息，则必须重传。</li></ul><h2 id="常见的请求方法"><a href="#常见的请求方法" class="headerlink" title="常见的请求方法"></a>常见的请求方法</h2><ul><li>GET：请求指定的页面信息，并返回实体主体。</li><li>POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。</li><li>HEAD：类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</li><li>PUT：从客户端向服务器传送的数据取代指定的文档的内容。</li><li>DELETE：请求服务器删除指定的页面。</li></ul><h2 id="HTTP-的缺点"><a href="#HTTP-的缺点" class="headerlink" title="HTTP 的缺点"></a>HTTP 的缺点</h2><ul><li><p><strong>明文传输</strong>：数据完全肉眼可见，能够方便地研究和分析，但也容易被窃听</p></li><li><p>HTTP 是不安全的，<strong>无法验证通信双方的身份</strong>，也不能判断报文是否被修改</p></li></ul><h2 id="为什么要用-HTTPS"><a href="#为什么要用-HTTPS" class="headerlink" title="为什么要用 HTTPS"></a>为什么要用 HTTPS</h2><p>HTTP 协议以明文方式传递信息，不提供任何方式的数据加密，不适合传输一些敏感信息，比如：各种账号、密码等信息，使用 HTTP 协议传输隐私信息非常不安全。</p><p>为了解决上述 HTTP 存在的问题，就出现了 HTTPS。</p><p>HTTPS 协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性；解决了 HTTP 存在的缺点问题。</p><h2 id="什么是-HTTPS"><a href="#什么是-HTTPS" class="headerlink" title="什么是 HTTPS?"></a>什么是 HTTPS?</h2><p>HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为<code>HTTP</code>+<code>SSL/TLS</code>，通过 SSL 证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。</p><p>HTTPS 是一种通过计算机网络进行安全通信的传输协议，经由 HTTP 进行通信，利用<code>SSL/TLS</code>建立全信道，加密数据包。HTTPS 使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。</p><h3 id="SSL-是什么？"><a href="#SSL-是什么？" class="headerlink" title="SSL 是什么？"></a>SSL 是什么？</h3><p>SSL（Secure Socket Layer，安全套接字层）：SSL 协议位于 <code>TCP/IP</code> 协议与各种应用层协议之间，为数据通讯提供安全支持。</p><p>TLS（Transport Layer Security，传输层安全）：其前身是 SSL，它最初的几个版本（SSL 1.0、SSL 2.0、SSL 3.0）由网景公司开发，目前使用最广泛的是<code>TLS 1.1</code>、<code>TLS 1.2</code>。</p><h2 id="浏览器在使用-HTTPS-传输数据的流程是什么？"><a href="#浏览器在使用-HTTPS-传输数据的流程是什么？" class="headerlink" title="浏览器在使用 HTTPS 传输数据的流程是什么？"></a>浏览器在使用 HTTPS 传输数据的流程是什么？</h2><ul><li>首先客户端通过 URL 访问服务器建立 SSL 连接。</li><li>服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。</li><li>客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。</li><li>客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</li><li>服务器利用自己的私钥解密出会话密钥。</li><li>服务器利用会话密钥加密与客户端之间的通信。</li></ul><h2 id="HTTPS-的特点"><a href="#HTTPS-的特点" class="headerlink" title="HTTPS 的特点"></a>HTTPS 的特点</h2><ol><li><strong>内容加密</strong>：采用混合加密技术，中间者无法直接查看明文内容</li><li><strong>验证身份</strong>：通过证书认证客户端访问的是自己的服务器（确认网站的真实性）</li><li><strong>保护数据完整性</strong>：防止传输的内容被中间人冒充或者篡改</li></ol><p><strong>对称加密</strong></p><p>也叫做共享密钥加密。通信的双方使用同一个密钥对信息进行加密和解密，优点是加解密速度快。运用对称加密有一个前提就是在发送信息前双方都必须知道加密的规则，但是在互联网的环境下我们每天可能跟不同人发送信息，很多人我们之前根本没认识过，这种情况下我们根本不可能事先就约定好加密规则，那么我们就只能通过信息把加密规则（密钥）发送给对方，然后我们再根据加密规则来加密聊天信息，很显然这肯定是不可取的，不经过加密的数据在网络传输是没有任何安全性可言的。</p><p><strong>非对称加密</strong></p><p>又称作公开密钥加密。使用一对非对称的密钥，私钥保存在本地，公钥可以公开。发送密文的一方使用对方的公钥进行加密，接收方收到后，使用自己的私钥进行解密。优点是解密的私钥不需要进行分发。缺点是加解密速度慢，同时公钥可能被替换。</p><p><strong>混合加密</strong></p><p>使用混合加密的原因：非对称秘钥加密会比较慢，但是私钥不用传输安全，而对称秘钥方式则相反，为了充分利用两者优缺点，产生了混合加密机制<br>解决方案：即通信建立之初采用公开加密的方式传输对称秘钥方式中的同一秘钥，这样确保了共享秘钥的安全性，然后以后的通信均采用对称加密方式，这样提升了通信速度。</p><p><strong>数字摘要</strong></p><p>一段信息，经过摘要算法得到一串哈希值，就是摘要。通过单向 hash 函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如 128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。</p><p><strong>数字签名</strong></p><p>数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。摘要经过私钥的加密后，便有了一个新的名字 —— 数字签名。</p><p><strong>数字证书</strong></p><p>非对称加密过程需要用到公钥进行加密，那么公钥从何而来？其实公钥就被包含在数字证书中，数字证书通常来说是由受信任的数字证书颁发机构 CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书（<br>实际就是一个 <code>.crt</code> 文件）被放到服务端，具有服务器身份验证和数据传输加密功能。</p><h2 id="HTTPS-的缺点"><a href="#HTTPS-的缺点" class="headerlink" title="HTTPS 的缺点"></a>HTTPS 的缺点</h2><ul><li>HTTPS 协议多次握手，导致页面的加载时间延长近 50%；</li><li>HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗；</li><li>申请 SSL 证书需要钱，功能越强大的证书费用越高。</li><li>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗。</li><li>SSL 涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。</li></ul><h2 id="总结-HTTPS-和-HTTP-的区别"><a href="#总结-HTTPS-和-HTTP-的区别" class="headerlink" title="总结 HTTPS 和 HTTP 的区别"></a>总结 HTTPS 和 HTTP 的区别</h2><ul><li><strong>安全性</strong>：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li><li><strong>连接端口</strong>：HTTP 标准端口是 80，而 HTTPS 的标准端口是 443。</li><li><strong>费用</strong>：HTTPS 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用</li><li><strong>传输方式</strong>：HTTP 是超文本传输协议，信息是明文传输，而 HTTPS 是 SSL 加密传输协议。</li><li><strong>工作层</strong>：在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层。</li><li><strong>工作耗时</strong>：HTTP 耗时=TCP 握手，而 HTTPS 耗时=TCP 握手+SSL 握手。</li><li><strong>显示形式</strong>：HTTP 的 URL 以<code>http://</code>开头，而 HTTPS 的 URL 以<code>https://</code>开头。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/72616216" target="_blank" rel="noopener">十分钟搞懂 HTTP 和 HTTPS 协议？</a></li></ul>]]></content>
      <categories>
        <category>HTTP系列</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手带你入门 Travis 自动化部署</title>
    <url>/2020/11/16/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-Travis-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>本文主要讲如何用 Travis 来实现自动化部署，并参照 Github 真实项目开发简单场景来介绍。</p><a id="more"></a><h2 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h2><p>在说 Travis 之前，先了解一下 CI/CD 的概念。</p><h3 id="CI"><a href="#CI" class="headerlink" title="CI"></a>CI</h3><p><strong>CI（Continuous integration）—— 持续集成</strong>。持续集成是指频繁地（一天多次）将代码集成到主干，注重将各个开发者的工作集合到一个代码仓库中，在源代码变更后会自动检测、拉取、构建和进行单元测试，其目的在于让产品快速迭代，同时保证高质量。</p><p>比如日常工作中，向<code>development</code>分支提交一个 PR，配置好 Travis 就会进行自动测试等等工作，通过并被 review 后才能允许合并到开发分支。一旦自动测试脚本有错误，则不允许合并。</p><h3 id="CD"><a href="#CD" class="headerlink" title="CD"></a>CD</h3><p>CD 可对应多个英文名称，一个是<strong>持续交付（Continuous delivery）</strong>，一个是<strong>持续部署（Continuous deployment）</strong>。</p><p><strong>持续交付</strong>指频繁地将软件的新版本交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。<br>目标是拥有一个可随时部署到生产环境的代码库。好处在于，每次代码的小幅变更，就能看到运行结果，从而不断累积小的变更，而不是在开发周期结束时，一下子合并一大块代码。</p><p><strong>持续部署</strong>指持续交付的下一步，指的是代码通过评审以后，自动部署到生产环境。目标是代码在任何时刻都是可部署的，可以进入生产阶段。</p><p>持续交付并不是指软件每一个改动都要尽快部署到产品环境中，它指的是任何的代码修改都可以在任何时候实施部署。</p><p>持续交付表示的是一种能力，而持续部署表示的则一种方式。持续部署是持续交付的最高阶段</p><h2 id="Travis-是什么"><a href="#Travis-是什么" class="headerlink" title="Travis 是什么"></a>Travis 是什么</h2><p><strong>Travis CI</strong> 提供的是持续集成服务，它可以绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。当然这只是其中一种 CI 工具，另外还有<code>Jenkins</code>等。</p><p>本文仅仅做的抛砖引玉，让你对这些概念和 Travis 有初步了解和使用，不再陌生，剩余的就靠你自己去学习了。也许你觉得这是公司企业级项目才配上的东西，但其实 Travis 是免费的，个人开发者也可以进行使用，而且是挺好用。</p><h2 id="注册-Travis"><a href="#注册-Travis" class="headerlink" title="注册 Travis"></a>注册 Travis</h2><p>进入<a href="https://travis-ci.com" target="_blank" rel="noopener">https://travis-ci.com</a>，</p><p>比如我选择 Github 方式登录</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/787b470e99dd429d80bf261034d8eaaa~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>登录之后 Github 的 repo 授权给 travis，我直接选 All，开启对项目的监控<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f1404af30c57487096695a447cdaa0d3~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>选完之后回到主页就能看到你的仓库页面了，可以看到有一个项目我是配置了 travis 的，所以显示绿色状态。<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da48d7d8418748a9b137354a27ecfe27~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>这项目是最近在自己动手做的 React 组件库项目 <a href="https://github.com/Jacky-Summer/monki-ui" target="_blank" rel="noopener">monki-ui</a>，尽量参照企业级标准搭建的，技术栈是<code>React + TypeScript + Dumi + Jest</code>，觉得不错可供借鉴学习的话可以 ✨ star 一下哦…</p><h2 id="获取-Github-Access-Token"><a href="#获取-Github-Access-Token" class="headerlink" title="获取 Github Access Token"></a>获取 Github Access Token</h2><p>接着进入 <code>Github -&gt; Developer settings -&gt; Personal access tokens -&gt; Generate new token</code></p><p>勾选<code>repo</code>下的所有项，以及<code>user</code>下的<code>user:email</code>后，会生成一个 token，然后记得复制保存好，因为生成后以后就不会再显示了，如果忘记那必须重新生成<code>token</code>才可以</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/469af906c946480fad3312c9fe2d3e53~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h2 id="配置-Travis"><a href="#配置-Travis" class="headerlink" title="配置 Travis"></a>配置 Travis</h2><p>我自己用 create-react-app 初始化了一个 Github 项目 <a href="https://github.com/Jacky-Summer/travis-demo" target="_blank" rel="noopener">travis-demo</a>，删除文件到最简单的项目结构。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/302028aa4f9746e78173be6f04195f29~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>然后模拟一下日常开发场景，让大家体会工作中的应用，我先是从<code>master</code>分支 checkout 出<code>development</code>分支，并把<code>development</code>分支设置为<code>default</code>分支，这个就当做我们开发中的 dev 分支，日常 PR 都会合并到该分支上。</p><p>然后从<code>development</code>分支 checkout 出一条分支<code>docs/update-readme</code>，接着修改 readme 的内容，git add 和 git commit 后就待 push 了。</p><p>我们上面生成的 token 已经说了要先保存好的，接着去<a href="https://travis-ci.com/" target="_blank" rel="noopener">travis-ci 官网</a>，找到刚才创建的项目<code>Jacky-Summer/travis-demo</code>，点进去选择<code>Settings</code></p><ul><li>设置全局变量(Environment Variables)</li></ul><p><code>NAME</code>一般规范是大写和下划线来命名，这里我取为<code>GITHUB_TOKEN</code>，<code>VALUE</code>为我们保存的 token，然后选择<code>Add</code>添加</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b3d10cde4aa425d9cc1f717bd737074~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h2 id="项目新建配置文件"><a href="#项目新建配置文件" class="headerlink" title="项目新建配置文件"></a>项目新建配置文件</h2><p>在项目根目录配置<code>.travis.yml</code>配置文件（当前在<code>docs/udpate-readne</code>）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: node_js  # 设置语言</span><br><span class="line"></span><br><span class="line">node_js:</span><br><span class="line">  - 12 # 指定node.js版本</span><br><span class="line"></span><br><span class="line">cache: yarn # 开启缓存</span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">  - yarn</span><br><span class="line">script:</span><br><span class="line">  - yarn build</span><br></pre></td></tr></table></figure><p>接着就 push 到远程分支，此时打开 github 项目仓库，点击<code>Create pull request</code>，</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a1d39c8f3814549bd5197da825d2d2f~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>就会看到此时 Travis 正在运行了，它在干什么事，可以点进<code>Details</code>去看看，它就是从头来一遍我们项目，<code>git clone</code>开始，然后<code>yarn install</code>，<code>yarn build</code>，整个过程没有错误，那就通过了，通过之后看到此时 PR 这样显示的：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e83b62a55c34480a2e79724fa7a3f7f~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>通过说明我们可以 Merge 了，这里我选择<code>Squash and merge</code>合并，合并后会再次跑一次 Travis（但日常开发我司是要先有其他同事 review 通过才能 merge 的）。此时我们的 PR 就合并到<code>development</code>分支上了，你的邮箱整个过程中也会有邮件通知你。</p><p>但其实你会发现你不用等它 Travis 运行完成，我们就可以点<code>Merge</code>按钮，按道理它应该暂时禁用才对，等到 Travis 通过才允许按。这个在<code>Github该项目目录 -&gt; Settings -&gt; Branches -&gt; Add rules</code>，这里只是简单举个例子如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a631937cc8e54619a5cf48577b2fdc01~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>仅仅这样可能并感受不到什么作用，现在我们切换回<code>development</code>分支，<code>git pull</code>最新代码，再 checkout 一条新分支<code>test/test-case-example</code>，添加个测试文件<code>src/index.test.js</code></p><p>如果不知道什么是单元测试的可以看我这篇文章：<a href="https://juejin.im/post/6891625768184070152" target="_blank" rel="noopener">一文带你了解 Jest 单元测试</a></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'单元测试'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'测试用例'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="literal">true</span></span><br><span class="line">    expect(foo).toBeTruthy() <span class="comment">// 期望 foo 变量的值为 true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然这是个白痴没有意义的测试，运行<code>yarn test</code>，测试用例通过，如果我们修改代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">describe(<span class="string">'单元测试'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'测试用例'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> foo = <span class="literal">true</span></span><br><span class="line">    expect(foo).toBeFalsy() <span class="comment">// 测试不会通过</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时<code>yarn test</code>不会通过，这就对应我们日常修改代码后，假设你没有重新运行测试（但测试用例实际是运行错误的），你却 push 上去了，又合并了就麻烦了，因为测试不过说明你代码可能存在问题。</p><p>接着需要 Travis 帮忙了，修改<code>.travis.yml</code>文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: node_js</span><br><span class="line"></span><br><span class="line">node_js:</span><br><span class="line">  - 12</span><br><span class="line"></span><br><span class="line">cache: yarn</span><br><span class="line"></span><br><span class="line">install:</span><br><span class="line">  - yarn</span><br><span class="line">script:</span><br><span class="line">  - yarn test # 运行测试</span><br><span class="line">  - yarn build</span><br></pre></td></tr></table></figure><ul><li>接着同上步骤，开个 PR，此时显示如下，此时就看到 Travis 显示<code>Required</code>，但因为我是项目唯一拥有者兼管理员，所以依然可以直接 merge，但如果其他人 PR 上来，则是不行的要等 Travis 通过才允许按 merge 按钮</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/105f64f7f1aa47a9861bbc4b069ff912~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>等一会你会发现它挂了，这里就显示<code>×</code>号了，此时失败不能合并（非管理员）。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be5e913ce34f4fd2a7ca1d6dd3898bfe~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>我们去<code>Details</code>里面看看哪里出错了，看到是测试用例出错导致 Travis 无法通过：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4836319529964437b806bbc19a0820a2~tplv-k3u1fbpfcp-watermark.image" alt=""></p><ul><li><p>于是此时我们应该是去修改代码，再提交，这就是 Travis 的其中一个常见的作用了。</p></li><li><p>其后它还有很多其它可以玩的，比如自动化部署到 Github page 页面，在我现在的 React 开源组件库 <a href="https://github.com/Jacky-Summer/monki-ui/blob/development/.travis.yml" target="_blank" rel="noopener">monki-ui - travis 配置</a> 作为例子</p></li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  provider: pages  # 指定部署到Github Pages，即 gh-pages分支</span><br><span class="line">  github_token: $GITHUB_TOKEN # 名字对应我们上方的 token</span><br><span class="line">  skip_cleanup: true # 指定保留构建后的文件</span><br><span class="line">  keep-history: true # 指定每次部署会新增一个提交记录再推送，而不是使用 git push --force</span><br><span class="line">  local_dir: docs-dist # 指定构建后要部署的目录</span><br><span class="line">  on:</span><br><span class="line">    branch: master # 指定 master 分支有提交行为时，将触发构建后部署</span><br></pre></td></tr></table></figure><ul><li><p>本文介绍到这里就结束了，Travis 还有很多其他有用的配置，就需要日常开发自己去了解了。</p></li><li><p>本文案例代码地址<a href="https://github.com/Jacky-Summer/travis-demo" target="_blank" rel="noopener">travis-demo</a><br>参考文章：</p></li><li><p><a href="http://www.ruanyifeng.com/blog/2017/12/travis_ci_tutorial.html" target="_blank" rel="noopener">持续集成服务 Travis CI 教程</a></p></li></ul><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>Travis</tag>
      </tags>
  </entry>
  <entry>
    <title>escape、encodeURI、encodeURIComponent区别</title>
    <url>/2020/11/11/escape%E3%80%81encodeURI%E3%80%81encodeURIComponent%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>JS 中有三个可以对字符串编码的函数，分别是： escape,encodeURI,encodeURIComponent</p><a id="more"></a><h2 id="escape"><a href="#escape" class="headerlink" title="escape()"></a>escape()</h2><p>通常用于对字符串编码，不适用于对 URL 编码</p><p>除了 ASCII 字母、数字和特定的符号外，对传进来的字符串全部进行转义编码，因此如果想对 URL 编码，最好不要使用此方法。</p><p>escape 不会编码的字符有 69 个：<code>* + - . / @ _ 0-9 a-z A-Z</code></p><p>当然如果没有必要，不要使用 escape。</p><h2 id="encodeURI"><a href="#encodeURI" class="headerlink" title="encodeURI()"></a>encodeURI()</h2><p><code>encodeURI()</code>不会进行编码的字符有 82 个 ：<code>; , / ? : @ &amp; = + $ - _ . ! ~ * &#39; ( ) # 0-9 a-z A-Z</code></p><p>使用<code>encodeURI()</code>编码后的结果是除了空格之外的其他字符都原封不动，只有空格被替换成了<code>%20</code>,<code>encodeURI</code>主要用于直接赋值给地址栏。</p><h2 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent()"></a>encodeURIComponent()</h2><p><code>encodeURIComponent</code>:不会进行编码的字符有 71 个：<code>! &#39; ( ) * - . _ ~ 0-9 a-z A-Z</code></p><p><code>encodeURIComponent</code>比<code>encodeURI</code>编码的范围更大，如<code>encodeURIComponent</code>会把 <code>http://</code> 编码成 <code>http%3A%2F%2F</code> 而<code>encodeURI</code>不解码维持<code>http://</code></p><p><code>encodeURIComponent()</code> 方法在编码单个 URIComponent（指请求参数）应当是最常用的，它可以将参数中的中文、特殊字符进行转义，而不会影响整个 URL</p><h2 id="如何选择和使用三个函数"><a href="#如何选择和使用三个函数" class="headerlink" title="如何选择和使用三个函数"></a>如何选择和使用三个函数</h2><ul><li>如果只是编码<strong>字符串</strong>，和 URL 没有关系，才可以用<code>escape</code>。（但它已经被废弃，尽量避免使用，应用<code>encodeURI</code> 或 <code>encodeURIComponent</code>）</li><li>如果需要编码<strong>整个 URL</strong>，然后需要使用这个 URL，那么用<code>encodeURI</code></li><li>如果需要编码 <strong>URL 中的参数</strong>的时候，那么<code>encodeURIComponent</code>是最好方法。</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">encodeURI(&quot;https:&#x2F;&#x2F;github.com&#x2F;Jacky-Summer&#x2F;test params&quot;);</span><br></pre></td></tr></table></figure><p>编码后变成</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;Jacky-Summer&#x2F;test%20params</span><br></pre></td></tr></table></figure><p>其中空格被编码成了<code>%20</code>，而如果是用<code>encodeURIComponent</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https%3A%2F%2Fgithub.com%2FJacky-Summer%2Ftest%20params</span><br></pre></td></tr></table></figure><p>连 <code>/</code> 都被编码了，整个 URL 已经没法用了。</p><p>当编码 URL 的特殊参数时：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 参数的 &#x2F; 是需要编码的，而如果是 encodeURI 编码则不编码 &#x2F; 就会出问题</span><br><span class="line">let param &#x3D; &quot;https:&#x2F;&#x2F;github.com&#x2F;Jacky-Summer&#x2F;&quot;;</span><br><span class="line">param &#x3D; encodeURIComponent(param);</span><br><span class="line">const url &#x3D; &quot;https:&#x2F;&#x2F;github.com?param&#x3D;&quot; + param;</span><br><span class="line">console.log(url) &#x2F;&#x2F; &quot;https:&#x2F;&#x2F;github.com?param&#x3D;https%3A%2F%2Fgithub.com%2FJacky-Summer%2F&quot;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.zhihu.com/question/21861899" target="_blank" rel="noopener">https://www.zhihu.com/question/21861899</a></p><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>encodeURIComponent</tag>
      </tags>
  </entry>
  <entry>
    <title>一文带你了解 Jest 单元测试</title>
    <url>/2020/11/05/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3-Jest-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<p>前端测试普及度虽然不算高，但对项目代码质量以及后期维护项目上却有很大的作用。本文会抛砖引玉的讲下 Jest 单元测试，因为很多 API 具体看官网就可以了。</p><a id="more"></a><h2 id="什么是-Jest"><a href="#什么是-Jest" class="headerlink" title="什么是 Jest"></a>什么是 Jest</h2><p>Jest 是用来创建、执行和构建测试用例的一个 JavaScript 测试<br>库。可以在任何项目中安装使用它，如 Vue/React/Angular/Node/TypeScript 等。</p><h2 id="使用-Jest-的好处"><a href="#使用-Jest-的好处" class="headerlink" title="使用 Jest 的好处"></a>使用 Jest 的好处</h2><p>目前前端测试在开发应用场景主要是 UI 组件库，但其实不止是组件库，日常项目开发也可以加入单元测试，保证项目的稳定。</p><p>它的好处有哪些呢？</p><ul><li>速度快，使用简单和容易配置</li><li>通过编写测试，让代码出现 bug 的概率更小</li><li>有利于写出健壮性更好的代码，项目的可维护性增强</li><li>好的测试，就具有文档解释的作用</li><li>减少回归测试中的 bug</li></ul><h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>比如写一个加法和减法函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function minus(a, b) &#123;</span><br><span class="line">  return a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从最简单的函数开始入手讲起来，假设要对改函数进行测试，我们测试的到底是什么，即是他的功能，调用函数时传入两个参数，返回结果为他们相加的值。比如传入<code>add(1, 1)</code>，我们期望结果是返回相加结果<code>2</code><br>写成代码可以这样<code>expect(add(1, 1)) === 2</code>，再封装得语义化一点的话，<code>expect(add(1, 1)).toBe(2)</code>为我们期望的测试函数，来实现这个函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expect</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    toBe(actual) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result !== actual) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`与预期结果不相等。实际结果：<span class="subst">$&#123;actual&#125;</span>，期望结果：<span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">expect(add(<span class="number">1</span>, <span class="number">1</span>)).toBe(<span class="number">2</span>)</span><br><span class="line">expect(minus(<span class="number">2</span>, <span class="number">1</span>)).toBe(<span class="number">1</span>)</span><br><span class="line">expect(add(<span class="number">2</span>, <span class="number">2</span>)).toBe(<span class="number">3</span>) <span class="comment">// Error: 与预期结果不相等。实际结果：3，期望结果：4</span></span><br></pre></td></tr></table></figure><p>测试不通过我们就让它抛出错误</p><p>这样写的话实际有点混乱，因为一眼看下去不知道在测试啥，于是，我们多封装一个函数，代表我们正在做什么测试</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; desc 用来描述测试行为， fn则为我们执行测试的函数</span><br><span class="line">function test(desc, fn) &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    fn()</span><br><span class="line">    console.log(&#96;$&#123;desc&#125;通过测试&#96;)</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(&#96;$&#123;desc&#125;测试不通过 $&#123;e&#125;&#96;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(&#39;加法测试&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  expect(add(1, 1)).toBe(2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(&#39;减法测试&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  expect(minus(2, 1)).toBe(1)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行代码，输出</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加法测试通过测试</span><br><span class="line">减法测试通过测试</span><br></pre></td></tr></table></figure><p>这就是我们动手的最简单的测试了，因为我们函数比较简单，所以你可能会觉得在做着啰嗦的工作。</p><p>从流程上看，一个简单的测试流程（输入 —— 预期输出 —— 验证结果）如下：</p><ol><li>引入要测试的函数</li><li>传入测试函数执行结果</li><li>定义预期输出</li><li>检查函数是否返回了预期的输出结果</li></ol><h2 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h2><p>创建一个空文件夹进入初始化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>安装 jest</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add --dev jest</span><br></pre></td></tr></table></figure><p>在<code>package.json</code>配置脚本命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建文件<code>babel.config.js</code>，安装依赖并配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add --dev babel-jest @babel&#x2F;core @babel&#x2F;preset-env</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// babel.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">'@babel/preset-env'</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: &#123;</span><br><span class="line">          node: <span class="string">'current'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们每段介绍都会采取<code>example.js</code>里面写代码，再到<code>*.test.js</code>文件引入<code>example.js</code>的函数并测试。</p><h2 id="匹配器-Matchers"><a href="#匹配器-Matchers" class="headerlink" title="匹配器 Matchers"></a>匹配器 Matchers</h2><p>使用 Matchers 让你可以用各种方式测试你的代码</p><p>跟我们上面写的代码一样，jest 提供了<code>test</code>,<code>expect</code>,<code>toBe</code>方法</p><p><code>example.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建文件<code>matcher.test.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; multiply &#125; <span class="keyword">from</span> <span class="string">'./example'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试乘法'</span>, () =&gt; &#123;</span><br><span class="line">  expect(multiply(<span class="number">4</span>, <span class="number">2</span>)).toBe(<span class="number">8</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>toBe</code> 使用 <code>Object.is</code> 来测试精确相等。 如果想要检查对象的值，使用 <code>toEqual</code> 代替。</p><p><code>matcher.test.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'测试对象是否相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">'jacky'</span> &#125;</span><br><span class="line">  data[<span class="string">'age'</span>] = <span class="number">23</span></span><br><span class="line">  expect(data).toEqual(&#123; <span class="attr">name</span>: <span class="string">'jacky'</span>, <span class="attr">age</span>: <span class="number">23</span> &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行<code>yarn test</code>，可看到控制台显示两个测试通过；如不通过控制台也会提示哪个测试用例出错。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/804c59a4689b4b2bb980115f77e7d29f~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>当运行该命令的时候，jest 会自动搜寻项目中有<code>.test.js</code>后缀的文件，并运行测试。</p><p>当然，也有其他匹配器</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'匹配器'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> n = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">const</span> isTrue = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> value = <span class="number">3</span></span><br><span class="line">  expect(n).toBeNull() <span class="comment">// 只匹配 null</span></span><br><span class="line">  expect(n).toBeDefined() <span class="comment">// 只匹配 undefined</span></span><br><span class="line">  expect(n).not.toBeUndefined() <span class="comment">// 与 toBeUndefined 相反</span></span><br><span class="line">  expect(isTrue).toBeTruthy() <span class="comment">// 匹配任何 if 语句为真</span></span><br><span class="line"></span><br><span class="line">  expect(value).toBeGreaterThan(<span class="number">2</span>)</span><br><span class="line">  expect(value).toBeLessThan(<span class="number">5</span>)</span><br><span class="line">  expect(value).toBeLessThanOrEqual(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="测试异步代码"><a href="#测试异步代码" class="headerlink" title="测试异步代码"></a>测试异步代码</h2><p><code>example.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">'https://jsonplaceholder.typicode.com/todos/1'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>async.test.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; fetchData &#125; <span class="keyword">from</span> <span class="string">'./example'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试 async await'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fetchData()</span><br><span class="line">  expect(data.data.id).toBe(<span class="number">1</span>) <span class="comment">// 请求api返回的id值是否为1</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试 Promise'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    expect(data.data.id).toBe(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="mock-函数"><a href="#mock-函数" class="headerlink" title="mock 函数"></a>mock 函数</h2><p>如果我们有很多异步请求的函数需要测试，会使测试变得缓慢，那么上述用真实接口请求的方式就不太适合了；或者想要捕获对函数的调用，这时就需要 Mock，它可以做到：</p><ol><li>捕获对函数的调用，以及 this 和调用顺序</li><li>它允许测试时配置返回值</li><li>改变函数的内部实现</li></ol><p>mock.test.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> &#123; fetchData &#125; <span class="keyword">from</span> <span class="string">'./example'</span></span><br><span class="line">jest.mock(<span class="string">'axios'</span>) <span class="comment">// 自动模拟 axios 模块。</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试请求接口'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  axios.get.mockResolvedValue(&#123; <span class="attr">data</span>: <span class="string">'hello'</span> &#125;) <span class="comment">// 返回假数据 &#123; data: 'hello' &#125; 用于测试</span></span><br><span class="line">  <span class="keyword">await</span> fetchData().then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    expect(data).toEqual(&#123; <span class="attr">data</span>: <span class="string">'hello'</span> &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可能你会想，这样测试有什么用，都是假数据，作为前端这边，我们只要确保函数被调用和正常返回结果就够了；当然这个例子是比较简单，涉及复杂接口测试的话还有其他 API 可用。其他更深入具体的接口请求测试是后端要做的。</p><p>在<code>example.js</code>增加一个函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行该函数需要传入一个回调函数，然后回调函数传递一个参数并执行</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runFn</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn(<span class="string">'函数执行了'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这是一个复杂的函数，我们并不想测试就让它执行，就可以用 mock 来测试</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">test(<span class="string">'函数被调用了'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn()</span><br><span class="line">  runFn(fn) <span class="comment">// 调用函数</span></span><br><span class="line"></span><br><span class="line">  expect(fn).toHaveBeenCalled() <span class="comment">// 期望fn被调用了</span></span><br><span class="line">  expect(fn).toHaveBeenLastCalledWith(<span class="string">'函数执行了'</span>) <span class="comment">// 函数fn被调用时的参数是否符合</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此外，还可以自定义设置返回参数，测试被执行次数等等，具体查官方文档。</p><h2 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h2><p>每当我们想要确保 UI（指 html css 等）或者配置文件不会改变时，可以使用快照测试。</p><p>这里只举例配置文件</p><p><code>example.test.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getConfig</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    url: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>snapshot.test.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getConfig &#125; <span class="keyword">from</span> <span class="string">'./example'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试配置文件有没有更改'</span>, () =&gt; &#123;</span><br><span class="line">  expect(getConfig()).toMatchSnapshot()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行<code>npm run test</code>，第一次运行，会发现文件所在位置生成一个文件夹<code>__snapshots__</code>,里面有个<code>snapshot.test.js.snap</code>文件，里面内容是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Jest Snapshot v1, https:&#x2F;&#x2F;goo.gl&#x2F;fbAQLP</span><br><span class="line"></span><br><span class="line">exports[&#96;测试配置文件有没有更改 1&#96;] &#x3D; &#96;</span><br><span class="line">Object &#123;</span><br><span class="line">  &quot;port&quot;: 8080,</span><br><span class="line">  &quot;url&quot;: &quot;http:&#x2F;&#x2F;localhost:3000&quot;,</span><br><span class="line">&#125;</span><br><span class="line">&#96;;</span><br></pre></td></tr></table></figure><p>里面保存了我们配置信息，如果你不小心改了配置信息的话，在执行测试就会报错，因为与这个文件的内容不符合；这时你就知道了你改到不应该改的位置了<br>比如把端口好改成<code>8081</code>，再运行<code>npm run test</code></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d398cf43a34149d69a0868bbcd8833de~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>但如果真的要改的话呢，那就按提示里面的信息做，更新快照，执行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm test -- -u</span><br></pre></td></tr></table></figure><p>执行后就会在终端看到：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Snapshots:   1 updated, 1 total</span><br></pre></td></tr></table></figure><p>这次再执行测试就不会报错了，就把配置信息更新了。</p><h2 id="Timers-Mocks"><a href="#Timers-Mocks" class="headerlink" title="Timers Mocks"></a>Timers Mocks</h2><p>当要测试有定时器的函数时，比如过 5 秒执行什么任务，对于我们来说并不是很方便，要真正等待它经过一定时间执行，这是可以模拟定时器函数。</p><p><code>example.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">timerGame</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Ready....go!'</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Time's up -- stop!"</span>)</span><br><span class="line">    callback &amp;&amp; callback()</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; timerGame &#125; <span class="keyword">from</span> <span class="string">'./example'</span></span><br><span class="line"></span><br><span class="line">jest.useFakeTimers()</span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试一定时间后执行函数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn()</span><br><span class="line">  timerGame(fn)</span><br><span class="line">  jest.advanceTimersByTime(<span class="number">3000</span>) <span class="comment">// 把时间提前了三秒</span></span><br><span class="line">  expect(fn).toBeCalled() <span class="comment">// 函数被调用了</span></span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">1</span>) <span class="comment">// 函数被执行了1次</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h2><p>增加一个脚本命令，将测试覆盖率信息输出为报告</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;coverage&quot;: &quot;jest --coverage&quot;</span><br></pre></td></tr></table></figure><p>执行该命令<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa658fe9b80540b9b9e5e8dee53af03c~tplv-k3u1fbpfcp-watermark.image" alt=""></p><p>可以在终端看到生成了报告，上述例子的代码测试覆盖率是 100%，这是因为测试的函数比较简单，所以轻易 100%。</p><p>同时项目根目录也成功了一个文件夹<code>coverage</code>，里面的<code>lcov-report</code>目录里生成 HTML 文件，可以通过浏览器打开查看。</p><p>如下：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d07e062bd224e21819cbd3118fec6ed~tplv-k3u1fbpfcp-watermark.image" alt=""></p><h2 id="TDD-与-BDD"><a href="#TDD-与-BDD" class="headerlink" title="TDD 与 BDD"></a>TDD 与 BDD</h2><p>现在流行的单元测试风格主要有 TDD（测试驱动开发）和 BDD（行为驱动开发）两种。比较明显的区别是一个是先写测试用例再写代码，一个是先写代码再写测试用例。</p><h3 id="TDD"><a href="#TDD" class="headerlink" title="TDD"></a>TDD</h3><p>TDD 的开发流程一般是先编写测试用例，再编写代码。</p><p>比如写一个 Todolist，我们一开始先想好它的功能和注意点，每一个功能都具备对应的测试用例，编写测试用例，没写代码之前肯定是通不过的；然后写完开始编写代码，使测试用例通过测试，再继续重复步骤，完成开发。这样写出来的代码质量和维护性也会更好。</p><p>所以 TDD 一般就是作为单元测试，即是单一组件功能上测试得较为完善，但几个组件加起来测试这种却不一定能测试完善。</p><p>单元测试应用比较多的是函数库，可对每个函数进行单独细致测试。</p><p>单元测试比较独立，但过于独立也会隐藏一些潜在问题无法测到，这个时候就有集成测试辅助了。</p><h3 id="BDD"><a href="#BDD" class="headerlink" title="BDD"></a>BDD</h3><p>BDD 的开发流程一般是先编写代码，再写测试用例。</p><p>这个就比较符合我们以往的开发模式，不过 BDD 更关注的是整体的行为是否符合预期，一般结合集成测试，也就是说整体好多个组件整体业务测试这种。</p><p>集成测试重点关心的是结果，而不是代码，更适合业务开发。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>两种测试风格都有它自己的优缺点，这里只是举例一部分；整体简单理解下来，前端测试能让我们写出更好的代码，减少 bug 的产生；而且，在维护一些老项目方面，也是有优势，比如你在改动旧项目代码的时候，可能怕影响其他组件或功能但你无法知晓，但如果有测试，直接改完运行所有测试代码就知道有没有影响到其他的功能代码了；而如果老项目没有写单元/集成测试，为了更好的维护，你也可以加入测试代码。</p><p>如果要学习更多有关 Jest 测试的内容，当然是直接去 <a href="https://jestjs.io/" target="_blank" rel="noopener">Jest 官网</a> 看了，然后在实际开发运用中才会逐渐体会到它带来的好处。</p><p><a href="https://github.com/Jacky-Summer/jest-tutorial" target="_blank" rel="noopener">本文代码地址</a></p><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>Jest</tag>
        <tag>前端测试</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之手写浅拷贝和深拷贝</title>
    <url>/2020/11/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E6%89%8B%E5%86%99%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<p>深拷贝与浅拷贝是经常见到的一个前端 JS 热门话题了，今天就来写下手写浅拷贝和深拷贝</p><a id="more"></a><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>自己创建一个新的对象，来接受你要重新复制或引用的对象值。如果对象属性是基本的数据类型，复制的就是基本类型的值给新对象；但如果属性是引用数据类型，复制的就是内存中的地址，如果其中一个对象改变了这个内存中的地址，肯定会影响到另一个对象。</p><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h3><p>Object.assign 循环遍历原对象的属性，通过复制的方式将其赋值给目标对象的相应属性</p><ul><li>它不会拷贝对象的继承属性；</li><li>它不会拷贝对象的不可枚举的属性；</li><li>可以拷贝 Symbol 类型的属性。</li></ul><h3 id="扩展运算符方式"><a href="#扩展运算符方式" class="headerlink" title="扩展运算符方式"></a>扩展运算符方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> cloneObj = &#123; ...obj &#125;</span><br></pre></td></tr></table></figure><h3 id="concat-拷贝数组"><a href="#concat-拷贝数组" class="headerlink" title="concat 拷贝数组"></a>concat 拷贝数组</h3><p>数组的 concat 方法其实也是浅拷贝，所以连接一个含有引用类型的数组时，需要注意修改原数组中的元素的属性，因为它会影响拷贝之后连接的数组。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.concat()</span><br><span class="line">newArr[<span class="number">1</span>] = <span class="number">100</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [ 1, 2, 3 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(newArr) <span class="comment">// [ 1, 100, 3 ]</span></span><br></pre></td></tr></table></figure><h3 id="slice-拷贝数组"><a href="#slice-拷贝数组" class="headerlink" title="slice 拷贝数组"></a>slice 拷贝数组</h3><p>slice 方法会返回一个新的数组对象，这一对象由该方法的前两个参数来决定原数组截取的开始和结束时间，是不会影响和改变原始数组的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, &#123; <span class="attr">val</span>: <span class="number">4</span> &#125;]</span><br><span class="line"><span class="keyword">let</span> newArr = arr.slice()</span><br><span class="line">newArr[<span class="number">2</span>].val = <span class="number">1000</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">//[ 1, 2, &#123; val: 1000 &#125; ]</span></span><br></pre></td></tr></table></figure><h3 id="手写浅拷贝"><a href="#手写浅拷贝" class="headerlink" title="手写浅拷贝"></a>手写浅拷贝</h3><ol><li>对基础类型做一个最基本的一个拷贝；</li><li>对引用类型开辟一个新的存储，并且拷贝一层对象属性。</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowClone = <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span> &amp;&amp; target !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">if</span> (target.hasOwnProperty(prop)) &#123;</span><br><span class="line">        cloneTarget[prop] = target[prop]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>将一个对象从内存中完整地拷贝出来一份给目标对象，并从堆内存中开辟一个全新的空间存放新对象，且新对象的修改并不会改变原对象，二者实现真正的分离。</p><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><p>JSON.stringify() 是目前开发过程中最简单的深拷贝方法，其实就是把一个对象序列化成为 JSON 的字符串，并将对象里面的内容转换成字符串，最后再用 JSON.parse() 的方法将 JSON 字符串生成一个新的对象。</p><ol><li>拷贝的对象的值中如果有函数、undefined、symbol 这几种类型，经过 JSON.stringify 序列化之后的字符串中这个键值对会消失；</li><li>拷贝 Date 引用类型会变成字符串；</li><li>无法拷贝不可枚举的属性；</li><li>无法拷贝对象的原型链；</li><li>拷贝 RegExp 引用类型会变成空对象；</li><li>对象中含有 NaN、Infinity 以及 -Infinity，JSON 序列化的结果会变成 null；</li><li>无法拷贝对象的循环应用，即对象成环 (obj[key] = obj)。</li></ol><h3 id="手写深拷贝"><a href="#手写深拷贝" class="headerlink" title="手写深拷贝"></a>手写深拷贝</h3><ol><li><p>针对能够遍历对象的不可枚举属性以及 Symbol 类型，我们可以使用 Reflect.ownKeys 方法； Reflect.ownKeys 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受 enumerable 影响，且能包含 Symbol 属性)</p></li><li><p>当参数为 Date、RegExp 类型，则直接生成一个新的实例返回；</p></li><li><p>利用 Object 的 getOwnPropertyDescriptors 方法可以获得对象的所有属性，以及对应的特性，顺便结合 Object 的 create 方法创建一个新对象，并继承传入原对象的原型链；</p><blockquote><p>Object.create(object, [,propertiesObject])创建一个新对象，继承 object 的属性，可添加 propertiesObject 添加属性，并对属性作出详细解释(此详细解释类似于 defineProperty 第二个参数的结构)</p></blockquote></li><li><p>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝，这样就巧妙化解的循环引用的问题。这个存储空间，需要可以存储 key-value 形式的数据，且 key 可以是一个引用类型，我们可以选择 Map 这种数据结构：</p></li></ol><ul><li>检查 map 中有无克隆过的对象</li><li>有 - 直接返回</li><li>没有 - 将当前对象作为 key，克隆对象作为 value 进行存储</li><li>继续克隆</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isComplexDataType = <span class="function"><span class="params">obj</span> =&gt;</span> (<span class="keyword">typeof</span> obj === <span class="string">'object'</span> || <span class="keyword">typeof</span> obj === <span class="string">'function'</span>) &amp;&amp; obj !== <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> deepClone = <span class="function"><span class="keyword">function</span> (<span class="params">target, hash = new Map(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(target) <span class="comment">// 日期对象直接返回一个新的日期对象</span></span><br><span class="line">  <span class="keyword">if</span> (target <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(target) <span class="comment">// 正则对象直接返回一个新的正则对象</span></span><br><span class="line">  <span class="comment">// 循环引用</span></span><br><span class="line">  <span class="keyword">if</span> (hash.has(target)) <span class="keyword">return</span> hash.get(target)</span><br><span class="line">  <span class="comment">// 遍历传入参数所有键的特性</span></span><br><span class="line">  <span class="keyword">let</span> allDesc = <span class="built_in">Object</span>.getOwnPropertyDescriptors(target)</span><br><span class="line">  <span class="comment">// 继承原型链</span></span><br><span class="line">  <span class="keyword">let</span> cloneTarget = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(target), allDesc)</span><br><span class="line"></span><br><span class="line">  hash.set(target, cloneTarget)</span><br><span class="line">  <span class="comment">// Reflect.ownKeys：返回一个包含所有自身属性（不包含继承属性）的数组，能包含enumerable(false)、Symbol属性</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(target)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hash'</span>, hash)</span><br><span class="line">    cloneTarget[key] =</span><br><span class="line">      isComplexDataType(target[key]) &amp;&amp; <span class="keyword">typeof</span> target[key] !== <span class="string">'function'</span> ? deepClone(target[key], hash) : target[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>手写模拟实现 React Hooks</title>
    <url>/2020/10/26/%E6%89%8B%E5%86%99%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-React-Hooks/</url>
    <content><![CDATA[<p>会使用 React Hook，还要学会简单手写 React Hook</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先使用<code>create-react-app</code>新建个项目，然后在<code>index.js</code>写我们的代码，阅读本文前需要知道常用 React Hooks 的基本用法。</p><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> memorizedState</span><br><span class="line"><span class="keyword">const</span> useState = <span class="function"><span class="params">initialState</span> =&gt;</span> &#123;</span><br><span class="line">  memorizedState = memorizedState || initialState <span class="comment">// 初始化</span></span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function"><span class="params">newState</span> =&gt;</span> &#123;</span><br><span class="line">    memorizedState = newState</span><br><span class="line">    render() <span class="comment">// setState 之后触发重新渲染</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [memorizedState, setState]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count1, setCount1] = useState(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;useState： &#123;count1&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            setCount1(count1 + 1)</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          添加count1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br><span class="line">&#125;</span><br><span class="line">render()</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd76376f5288400697f3b2b6f29c2034~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>但到这里会有一个问题，就是当增加第二个 useState 的时候会发现改变两个 state 都是改同一个值，同步变化，于是，我们通过使用数组的方式下标来方式来区分。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> memorizedState = [] <span class="comment">// 通过数组形式存储有关使用hook的值</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span> <span class="comment">// 通过下标记录 state 的值</span></span><br><span class="line"><span class="keyword">const</span> useState = <span class="function"><span class="params">initialState</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> currentIndex = index</span><br><span class="line">  memorizedState[currentIndex] = memorizedState[index] || initialState</span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function"><span class="params">newState</span> =&gt;</span> &#123;</span><br><span class="line">    memorizedState[currentIndex] = newState</span><br><span class="line">    render() <span class="comment">// setState 之后触发重新渲染</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [memorizedState[index++], setState]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count1, setCount1] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [count2, setCount2] = useState(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          useState： &#123;count1&#125;--&#123;count2&#125;</span><br><span class="line">        &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            setCount1(count1 + 1)</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          添加count1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;() =&gt; &#123;</span><br><span class="line">            setCount2(count2 + <span class="number">10</span>)</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          添加count2</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const render = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  index = 0</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br><span class="line">&#125;</span><br><span class="line">render()</span><br></pre></td></tr></table></figure><p>这样就实现效果了：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f9fd70c764d4b16874dc4f36cd0663a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>分析：</p><ul><li>第一次页面渲染的时候，根据 <code>useState</code> 顺序，声明了 count1 和 count2 两个 state，并按下标顺序依次存入数组中</li><li>当调用<code>setState</code>的时候，更新 count1/count2 的值，触发重新渲染的时候，index 被重置为 0。然后又重新按 <code>useState</code> 的声明顺序，依次拿出最新 state 的值；由此也可见为什么当我们使用 hook 时，要注意点 hook 不能在循环、判断语句内部使用，要声明在组件顶部。</li></ul><p><code>memorizedState</code>这个数组我们下面实现部分 hook 都会用到，现在<code>memorizedState</code>数组长度为 2，依次存放着两个使用<code>useState</code>后返回的 state 值；</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: 0</span><br><span class="line">1: 10</span><br></pre></td></tr></table></figure><p>每次更改数据后，调用<code>render</code>方法，<code>App</code>函数组件重新渲染，又重新调用<code>useState</code>，但外部变量<code>memorizedState</code>之前已经依次下标记录下了 state 的值，故重新渲染是直接赋值之前的 state 值做初始值。知道这个做法，下面的<code>useEffect</code>,<code>useCallback</code>,<code>useMemo</code>也是这个原理。</p><p>当然实际源码，<code>useState</code>是用链表记录顺序的，这里我们只是模拟效果。</p><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><p>useReducer 接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的 dispatch 函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reducerState</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useReducer = <span class="function">(<span class="params">reducer, initialArg, init</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> initialState</span><br><span class="line">  <span class="keyword">if</span> (init !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    initialState = init(initialArg) <span class="comment">// 初始化函数赋值</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    initialState = initialArg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    reducerState = reducer(reducerState, action)</span><br><span class="line">    render()</span><br><span class="line">  &#125;</span><br><span class="line">  reducerState = reducerState || initialState</span><br><span class="line">  <span class="keyword">return</span> [reducerState, dispatch]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = <span class="function"><span class="params">initialNum</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">num</span>: initialNum &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">num</span>: state.num + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">num</span>: state.num - <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, <span class="number">20</span>, init)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;useReducer：&#123;state.num&#125;&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'decrement' &#125;)&#125;&gt;-&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; dispatch(&#123; <span class="attr">type</span>: <span class="string">'increment'</span> &#125;)&#125;&gt;+&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>对于 useEffect 钩子，当没有依赖值的时候，很容易想到雏形代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useEffect = <span class="function">(<span class="params">callback, dependencies</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!dependencies) &#123;</span><br><span class="line">    <span class="comment">// 没有添加依赖项则每次执行，添加依赖项为空数组</span></span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果有依赖 state 值，即是我们使用 useState 后返回的值，这部分我们就需要用上方定义的数组 memorizedState 来记录</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> memorizedState = [] <span class="comment">// 存放 hook</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span> <span class="comment">// hook 数组下标位置</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * useState 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useState = <span class="function"><span class="params">initialState</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> currentIndex = index</span><br><span class="line">  memorizedState[currentIndex] = memorizedState[index] || initialState</span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function"><span class="params">newState</span> =&gt;</span> &#123;</span><br><span class="line">    memorizedState[currentIndex] = newState</span><br><span class="line">    render() <span class="comment">// setState 之后触发重新渲染</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [memorizedState[index++], setState]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * useEffect 实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> useEffect = <span class="function">(<span class="params">callback, dependencies</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (memorizedState[index]) &#123;</span><br><span class="line">    <span class="comment">// 不是第一次执行</span></span><br><span class="line">    <span class="keyword">let</span> lastDependencies = memorizedState[index] <span class="comment">// 依赖项数组</span></span><br><span class="line">    <span class="keyword">let</span> hasChanged = !dependencies.every(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item === lastDependencies[index]) <span class="comment">// 循环遍历依赖项是否与上次的值相同</span></span><br><span class="line">    <span class="keyword">if</span> (hasChanged) &#123;</span><br><span class="line">      <span class="comment">// 依赖项有改变就执行 callback 函数</span></span><br><span class="line">      memorizedState[index++] = dependencies</span><br><span class="line">      setTimeout(callback) <span class="comment">// 设置宏任务，在组件render之后再执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      index++ <span class="comment">// 每个hook占据一个下标位置，防止顺序错乱</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次执行</span></span><br><span class="line">    memorizedState[index++] = dependencies</span><br><span class="line">    setTimeout(callback)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [count1, setCount1] = useState(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> [count2, setCount2] = useState(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useEffect1'</span>)</span><br><span class="line">  &#125;, [count1, count2])</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useEffect2'</span>)</span><br><span class="line">  &#125;, [count1])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          useState： &#123;count1&#125;--&#123;count2&#125;</span><br><span class="line">        &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button</span></span><br><span class="line"><span class="regexp">          onClick=&#123;() =&gt; &#123;</span></span><br><span class="line"><span class="regexp">            setCount1(count1 + 1)</span></span><br><span class="line"><span class="regexp">          &#125;&#125;</span></span><br><span class="line"><span class="regexp">        &gt;</span></span><br><span class="line"><span class="regexp">          添加count1</span></span><br><span class="line"><span class="regexp">        &lt;/</span>button&gt;</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;() =&gt; &#123;</span><br><span class="line">            setCount2(count2 + <span class="number">10</span>)</span><br><span class="line">          &#125;&#125;</span><br><span class="line">        &gt;</span><br><span class="line">          添加count2</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const render = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  index = 0</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br><span class="line">&#125;</span><br><span class="line">render()</span><br></pre></td></tr></table></figure><p>程序第一次执行完毕后，memorizedState 数组值如下</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: 0</span><br><span class="line">1: 10</span><br><span class="line">2: [0, 10]</span><br><span class="line">3: [0]</span><br></pre></td></tr></table></figure><p>上述代码回调函数执行，本来我们可以用<code>callback()</code>执行即可，但因为<code>useEffect</code>在渲染时是异步执行，并且要等到浏览器将所有变化渲染到屏幕后才会被执行；</p><p>因为是异步且等页面渲染完毕才执行，根据对 JS 事件循环的理解，我们想要它异步执行任务，就在此创建一个宏任务<code>setTimeout(callback)</code>让它进入宏任务队列等待执行，当然这其中具体的渲染过程我这里就不细说了。</p><p>还有一个 hook 是<code>useLayoutEffect</code>，除了执行回调的两处地方代码实现不同，其他代码相同，<code>callback</code>这里我用微任务<code>Promise.resolve().then(callback)</code>，把函数执行加入微任务队列。</p><p>因为<code>useLayoutEffect</code>在渲染时是同步执行，会在所有的 DOM 变更之后同步调用，一般可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，<code>useLayoutEffect</code> 将被同步刷新。</p><p>怎么证明呢？如果你在<code>useLayoutEffect</code>加了死循环，然后重新打开网页，你会发现看不到页面渲染的内容就进入死循环了；而如果是<code>useEffect</code>的话，会看到页面渲染完成后才进入死循环。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;, [])</span><br></pre></td></tr></table></figure><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p><code>useCallback</code>和<code>useMemo</code>会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个 hooks 都返回缓存的值，useMemo 返回缓存计算数据的值，<code>useCallback</code>返回缓存函数的引用。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useCallback = <span class="function">(<span class="params">callback, dependencies</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (memorizedState[index]) &#123;</span><br><span class="line">    <span class="comment">// 不是第一次执行</span></span><br><span class="line">    <span class="keyword">let</span> [lastCallback, lastDependencies] = memorizedState[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hasChanged = !dependencies.every(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item === lastDependencies[index]) <span class="comment">// 判断依赖值是否发生改变</span></span><br><span class="line">    <span class="keyword">if</span> (hasChanged) &#123;</span><br><span class="line">      memorizedState[index++] = [callback, dependencies]</span><br><span class="line">      <span class="keyword">return</span> callback</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      index++</span><br><span class="line">      <span class="keyword">return</span> lastCallback <span class="comment">// 依赖值不变，返回上次缓存的函数</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次执行</span></span><br><span class="line">    memorizedState[index++] = [callback, dependencies]</span><br><span class="line">    <span class="keyword">return</span> callback</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>而<code>useMemo</code>实现与<code>useCallback</code>也很类似，只不过它返回的函数执行后的计算返回值，直接把函数执行了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useMemo = <span class="function">(<span class="params">memoFn, dependencies</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (memorizedState[index]) &#123;</span><br><span class="line">    <span class="comment">// 不是第一次执行</span></span><br><span class="line">    <span class="keyword">let</span> [lastMemo, lastDependencies] = memorizedState[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hasChanged = !dependencies.every(<span class="function">(<span class="params">item, index</span>) =&gt;</span> item === lastDependencies[index])</span><br><span class="line">    <span class="keyword">if</span> (hasChanged) &#123;</span><br><span class="line">      memorizedState[index++] = [memoFn(), dependencies]</span><br><span class="line">      <span class="keyword">return</span> memoFn()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      index++</span><br><span class="line">      <span class="keyword">return</span> lastMemo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次执行</span></span><br><span class="line">    memorizedState[index++] = [memoFn(), dependencies]</span><br><span class="line">    <span class="keyword">return</span> memoFn()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><p>代码出乎意料的少吧…</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const useContext &#x3D; context &#x3D;&gt; &#123;</span><br><span class="line">  return context._currentValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><p><code>useRef</code> 返回一个可变的 <code>ref</code> 对象，其 <code>.current</code> 属性被初始化为传入的参数（initialValue）。返回的 <code>ref</code> 对象在组件的整个生命周期内保持不变。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lastRef</span><br><span class="line"><span class="keyword">const</span> useRef = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  lastRef = lastRef || &#123; <span class="attr">current</span>: value &#125;</span><br><span class="line">  <span class="keyword">return</span> lastRef</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面几个例子我就没展示出 Demo 了，附上 Github 地址：<a href="https://github.com/Jacky-Summer/mini-react-hooks" target="_blank" rel="noopener">上述 hooks 实现和案例</a><br><br></p><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>手写</tag>
        <tag>React</tag>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript 入门知识点总结</title>
    <url>/2020/10/21/TypeScript-%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>TypeScript 已经逐渐成为前端必备技能了，随着 TS 4.0 和 Vue 3 的发布，TS 准备迎接大流行的趋势了，这篇文章，让你对 TS 有基本的认识和入门。</p><a id="more"></a><h2 id="TypeScript-介绍"><a href="#TypeScript-介绍" class="headerlink" title="TypeScript 介绍"></a>TypeScript 介绍</h2><h3 id="什么是-TypeScript"><a href="#什么是-TypeScript" class="headerlink" title="什么是 TypeScript"></a>什么是 TypeScript</h3><p>是 JavaScript 的一个超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上，主要提供了<strong>类型系统</strong>和<strong>对 ES6 的支持</strong>。</p><h3 id="为什么选择-TypeScript"><a href="#为什么选择-TypeScript" class="headerlink" title="为什么选择 TypeScript"></a>为什么选择 TypeScript</h3><ul><li>增加了代码的可维护性</li><li>包容性强，支持 ES6 语法，<code>.js</code>文件直接重命名为<code>.ts</code>即可</li><li>兼容第三方库，即使第三方库不是 TypeScript 写的，也可以通过单独编写类型文件供识别读取</li><li>社区活跃，目前三大框架还有越来越多的库都支持 TypeScript 了</li></ul><p>TypeScript 只会在编译的时候对类型进行静态检查，如果发现有错误，编译的时候就会报错。</p><h3 id="安装-TypeScript"><a href="#安装-TypeScript" class="headerlink" title="安装 TypeScript"></a>安装 TypeScript</h3><ol><li>全局安装 TS</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure><ol start="2"><li>查看 TypeScript 版本号</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc -v</span><br></pre></td></tr></table></figure><p>我当前版本为 Version 4.0.2</p><ol start="3"><li>初始化生成 tsconfig.json 文件</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><ol start="4"><li>在 tsconfig.json 中设置源代码目录和编译生成 js 文件的目录</li></ol><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"outDir": "./dist",</span><br><span class="line">"rootDir": "./src"</span><br></pre></td></tr></table></figure><ol start="5"><li>监听 ts 文件的变化，每当文件发生改变就自动编译</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc -w</span><br></pre></td></tr></table></figure><p>之后你写的 ts 文件编译错误都会直接提示，如果想运行文件，就到 <code>/dist</code>目录下找相应的 js 文件，使用 node 运行即可</p><h2 id="ts-node-安装"><a href="#ts-node-安装" class="headerlink" title="ts-node 安装"></a>ts-node 安装</h2><p>当然这样其实也挺麻烦，我们想直接运行 TS 文件, 这时可以借助<code>ts-node</code>插件</p><p>全局安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g ts-node</span><br></pre></td></tr></table></figure><p>找到文件路径，运行即可</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ts-node demo.ts</span><br></pre></td></tr></table></figure><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isShow: <span class="built_in">boolean</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="built_in">string</span> = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure><h3 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="Any-类型"><a href="#Any-类型" class="headerlink" title="Any 类型"></a>Any 类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo: <span class="built_in">any</span> = <span class="string">'hello'</span></span><br><span class="line">foo = <span class="number">12</span></span><br><span class="line">foo = <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="Null-和-Undefined-类型"><a href="#Null-和-Undefined-类型" class="headerlink" title="Null 和 Undefined 类型"></a>Null 和 Undefined 类型</h3><p>null 和 undefined 可以赋值给任意类型的变量</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test1: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> test2: <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> test3: <span class="built_in">number</span></span><br><span class="line"><span class="keyword">let</span> test4: <span class="built_in">string</span></span><br><span class="line">test3 = <span class="literal">null</span></span><br><span class="line">test4 = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><h3 id="Void-类型"><a href="#Void-类型" class="headerlink" title="Void 类型"></a>Void 类型</h3><p>void 类型像是与 any 类型相反，它表示没有任何类型。当一个函数没有返回值时，其返回值类型是 void</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test5: <span class="built_in">void</span> = <span class="literal">undefined</span> <span class="comment">// 声明一个 void 类型的变量没有什么用，因为它的值只能为 undefined 或 null</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFunc</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;&#125; <span class="comment">// 函数没有返回值</span></span><br></pre></td></tr></table></figure><h3 id="Never-类型"><a href="#Never-类型" class="headerlink" title="Never 类型"></a>Never 类型</h3><p>never 类型表示的是那些永不存在的值的类型。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'never reach'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Unknown-类型"><a href="#Unknown-类型" class="headerlink" title="Unknown 类型"></a>Unknown 类型</h3><p>所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value: unknown</span><br><span class="line">value = <span class="number">123</span></span><br><span class="line">value = <span class="string">'Hello'</span></span><br><span class="line">value = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> value1: unknown = value</span><br><span class="line"><span class="keyword">let</span> value2: <span class="built_in">any</span> = value</span><br><span class="line"><span class="keyword">let</span> value3: <span class="built_in">boolean</span> = value <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value4: <span class="built_in">number</span> = value <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value5: <span class="built_in">string</span> = value <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value6: object = value <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value7: <span class="built_in">any</span>[] = value <span class="comment">// Error</span></span><br><span class="line"><span class="keyword">let</span> value8: <span class="built_in">Function</span> = value <span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p>unknown 类型只能被赋值给 any 类型和 unknown 类型本身。</p><h3 id="Tuple-类型"><a href="#Tuple-类型" class="headerlink" title="Tuple 类型"></a>Tuple 类型</h3><p>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。元组表示一个数量和类型都已知的数组</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tupleArr1: [<span class="built_in">string</span>, <span class="built_in">number</span>] = [<span class="string">'hello'</span>, <span class="number">10</span>]</span><br><span class="line"><span class="comment">// let tupleArr2: [string, number] = [10, 'hello'] // Error</span></span><br></pre></td></tr></table></figure><h3 id="Enum-类型"><a href="#Enum-类型" class="headerlink" title="Enum 类型"></a>Enum 类型</h3><p>使用枚举可以定义一些带名字的常量。 TypeScript 支持数字的和基于字符串的枚举。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">enum</span> Season &#123;</span><br><span class="line">    Spring,</span><br><span class="line">    Summer,</span><br><span class="line">    Autumn,</span><br><span class="line">    Winter,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a: Season = Season.Spring</span><br><span class="line">  <span class="keyword">let</span> b: Season = Season.Summer</span><br><span class="line">  <span class="keyword">let</span> c: Season = Season.Autumn</span><br><span class="line">  <span class="keyword">let</span> d: Season = Season.Winter</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c, d) <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TS</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>在 TypeScript 的类型定义中，<code>=&gt;</code> 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="keyword">let</span> func3 = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TS 第一种方式</span></span><br><span class="line"><span class="keyword">let</span> func4 = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TS 第二种方式</span></span><br><span class="line"><span class="comment">// =&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。</span></span><br><span class="line"><span class="keyword">let</span> func5: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口定义函数的形状"><a href="#接口定义函数的形状" class="headerlink" title="接口定义函数的形状"></a>接口定义函数的形状</h3><p>采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数、参数类型、返回值类型不变。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">  (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span> (<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.search(subString) !== <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p>对于 TS 的函数，输入多余的（或者少于要求的）参数，是不允许的，那么该怎么设置可选参数呢？，我们可以在声明之后加一个问号</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName1</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 可选参数必须接在必需参数后面</span></span><br><span class="line">  <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> name1 = getName1(<span class="string">'jacky'</span>)</span><br><span class="line"><span class="keyword">let</span> name2 = getName1(<span class="string">'jacky'</span>, <span class="string">'lin'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(name1, name2)</span><br></pre></td></tr></table></figure><h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName2</span>(<span class="params">firstName: <span class="built_in">string</span> = 'monkey', lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getName2(<span class="string">'jacky'</span>, <span class="string">'Lin'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(getName2(<span class="literal">undefined</span>, <span class="string">'Lin'</span>)) <span class="comment">// monkey Lin</span></span><br></pre></td></tr></table></figure><h3 id="void-和-never-类型"><a href="#void-和-never-类型" class="headerlink" title="void 和 never 类型"></a>void 和 never 类型</h3><p>当函数没有返回值时，可以用 void 来表示。</p><p>当一个函数永远不会返回时，我们可以声明返回值类型为 never</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func6</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// return null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func7</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'never reach'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push1</span>(<span class="params">arr, ...items</span>) </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    arr.push(item)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a: <span class="built_in">any</span>[] = []</span><br><span class="line">push1(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push2</span>(<span class="params">arr: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    arr.push(item)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">any</span>[] = []</span><br><span class="line">push1(b, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'5'</span>)</span><br></pre></td></tr></table></figure><h3 id="函数参数为对象（解构）时"><a href="#函数参数为对象（解构）时" class="headerlink" title="函数参数为对象（解构）时"></a>函数参数为对象（解构）时</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">&#123; one, two &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> one + two</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = add(&#123; one: <span class="number">1</span>, two: <span class="number">2</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts 写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">&#123; one, two &#125;: &#123; one: <span class="built_in">number</span>; two: <span class="built_in">number</span> &#125;</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> one + two</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> three = add1(&#123; one: <span class="number">1</span>, two: <span class="number">2</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span> // 函数定义</span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span> // 函数定义</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  // 函数实现</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> x === '<span class="built_in">number</span>'</span>) </span>&#123;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> <span class="title">Number</span>(<span class="params">x.toString().split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span>)</span></span><br><span class="line"><span class="function">  &#125; <span class="title">else</span> <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> x === '<span class="built_in">string</span>'</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>TypeScript 允许你覆盖它的推断，并且能以你任何你想要的方式分析它，这种机制被称为「类型断言」。</p><p>TypeScript 类型断言用来告诉编译器你比它更了解这个类型，你知道你自己在干什么，并且它不应该再发出错误。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  run(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  swim(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能访问共有的属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">animal: Cat | Fish</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> animal.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 animal 断言成 Fish 就可以解决访问 animal.swim 时报错的问题</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">animal: Cat | Fish</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> (animal <span class="keyword">as</span> Fish).swim === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任何类型都可以被断言为 any</span></span><br><span class="line">;(<span class="built_in">window</span> <span class="keyword">as</span> <span class="built_in">any</span>).randomFoo = <span class="number">1</span></span><br></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型断言第一种方式："尖括号"语法</span></span><br><span class="line"><span class="keyword">let</span> value1: <span class="built_in">any</span> = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">let</span> value1Length: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;value1).length</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型断言第二种方式：as</span></span><br><span class="line"><span class="keyword">let</span> value2: <span class="built_in">any</span> = <span class="string">'world'</span></span><br><span class="line"><span class="keyword">let</span> value2Length: <span class="built_in">number</span> = (value2 <span class="keyword">as</span> <span class="built_in">string</span>).length</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  <span class="keyword">get</span> name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'名字'</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// setter</span></span><br><span class="line">  <span class="keyword">set</span> name(value: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span> + value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">'monkey'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(animal.name) <span class="comment">// monkey</span></span><br><span class="line">animal.name = <span class="string">'mk'</span> <span class="comment">// setter: mk</span></span><br></pre></td></tr></table></figure><h3 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h3><ul><li>public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的</li><li>private 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li><li>protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">public</span> name</span><br><span class="line">  <span class="keyword">private</span> age</span><br><span class="line">  <span class="keyword">protected</span> sex</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, sex: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="keyword">this</span>.sex = sex</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> Person(<span class="string">'jacky'</span>, <span class="number">22</span>, <span class="string">'man'</span>)</span><br><span class="line">person1.name = <span class="string">'monkey'</span> <span class="comment">// name值可以访问且修改</span></span><br><span class="line"><span class="comment">// person1.age // Property 'age' is private and only accessible within class 'Person'.</span></span><br><span class="line"><span class="comment">// person1.sex // Property 'sex' is private and only accessible within class 'Person'.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person1 <span class="keyword">extends</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span>, sex: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age, sex)</span><br><span class="line">    <span class="comment">// console.log(this.name, this.age, this.sex) // Property 'age' is private and only accessible within class 'Person'.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>同时给类中定义属性的同时赋值</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal3 &#123;</span><br><span class="line">  <span class="keyword">public</span> name</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Animal3(<span class="string">'animal3'</span>).name) <span class="comment">// animal3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Animal2 &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125; <span class="comment">// 简洁形式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Animal2(<span class="string">'animal2'</span>).name) <span class="comment">// animal2</span></span><br></pre></td></tr></table></figure><ul><li>readonly 只读属性</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal4 &#123;</span><br><span class="line">  readonly name</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> animal4 = <span class="keyword">new</span> Animal4(<span class="string">'animal4'</span>)</span><br><span class="line"><span class="comment">// animal4.name = '5' // Cannot assign to 'name' because it is a read-only property</span></span><br></pre></td></tr></table></figure><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类是行为的抽象，一般来封装公共属性的方法的，不能被实例化</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> CommonAnimal &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">abstract</span> speak(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal5 &#123;</span><br><span class="line">  <span class="keyword">static</span> sayHi() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello Animal5'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Animal5.sayHi()</span><br></pre></td></tr></table></figure><h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型（Union Types）表示取值可以为多种类型中的一种。使用一个<code>|</code>分割符来分割多种类型</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span><br><span class="line">foo = <span class="string">'test'</span></span><br><span class="line">foo = <span class="number">3</span></span><br><span class="line">foo = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">  id: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IWorker &#123;</span><br><span class="line">  companyId: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IStaff = IPerson &amp; IWorker</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> staff: IStaff = &#123; id: <span class="string">'007'</span>, age: <span class="number">24</span>, companyId: <span class="string">'1'</span> &#125;</span><br></pre></td></tr></table></figure><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Message = <span class="built_in">string</span> | <span class="built_in">string</span>[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> getMsg = <span class="function">(<span class="params">message: Message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> message</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Weather = <span class="string">'SPRING'</span> | <span class="string">'SUMMER'</span> | <span class="string">'AUTUMN'</span> | <span class="string">'WINTER'</span></span><br><span class="line"><span class="keyword">let</span> weather1: Weather = <span class="string">'SPRING'</span></span><br><span class="line"><span class="keyword">let</span> weather2: Weather = <span class="string">'AUTUMN'</span></span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="对象的形状"><a href="#对象的形状" class="headerlink" title="对象的形状"></a>对象的形状</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person1 &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1: Person1 = &#123;</span><br><span class="line">  name: <span class="string">'jacky'</span>,</span><br><span class="line">  age: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="描述行为的抽象"><a href="#描述行为的抽象" class="headerlink" title="描述行为的抽象"></a>描述行为的抽象</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> AnimalLike &#123;</span><br><span class="line">  eat(): <span class="built_in">void</span></span><br><span class="line">  move(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PersonLike <span class="keyword">extends</span> AnimalLike &#123;</span><br><span class="line">  speak(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Human <span class="keyword">implements</span> PersonLike &#123;</span><br><span class="line">  speak() &#123;&#125;</span><br><span class="line">  eat() &#123;&#125;</span><br><span class="line">  move() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="含构建函数作参数的写法"><a href="#含构建函数作参数的写法" class="headerlink" title="含构建函数作参数的写法"></a>含构建函数作参数的写法</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal1 &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Animal2 &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> WithNameClass &#123;</span><br><span class="line">  <span class="keyword">new</span> (name: <span class="built_in">string</span>): Animal1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClass</span>(<span class="params">classname: WithNameClass, name: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> classname(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance1 = createClass(Animal1, <span class="string">'monkey'</span>)</span><br><span class="line"><span class="comment">// let instance2 = createClass(Animal2, 'monkey') // 没有name属性则报错</span></span><br></pre></td></tr></table></figure><h3 id="其它任意属性"><a href="#其它任意属性" class="headerlink" title="其它任意属性"></a>其它任意属性</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person2 &#123;</span><br><span class="line">  readonly id: <span class="built_in">number</span></span><br><span class="line">  [propName: <span class="built_in">string</span>]: <span class="built_in">any</span> <span class="comment">//任意属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型是指定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性；通常用 T 表示，但不是必须使用改字母，只是常规，通常还有其他常用字母：</p><ul><li>T（Type）：表示一个 TypeScript 类型</li><li>K（Key）：表示对象中的键类型</li><li>V（Value）：表示对象中的值类型</li><li>E（Element）：表示元素类型</li></ul><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class="line">  name: T</span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generic = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">generic.name = <span class="number">123</span></span><br></pre></td></tr></table></figure><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><ul><li>写法一</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>&lt;<span class="title">T</span>&gt;(<span class="params">params: T[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> params</span><br><span class="line">&#125;</span><br><span class="line">func&lt;<span class="built_in">string</span>&gt;([<span class="string">'1'</span>, <span class="string">'2'</span>])</span><br><span class="line">func&lt;<span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure><ul><li>写法二</li></ul><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>&lt;<span class="title">T</span>&gt;(<span class="params">params: <span class="built_in">Array</span>&lt;T&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> params</span><br><span class="line">&#125;</span><br><span class="line">func1&lt;<span class="built_in">string</span>&gt;([<span class="string">'1'</span>, <span class="string">'2'</span>])</span><br><span class="line">func1&lt;<span class="built_in">number</span>&gt;([<span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>可以用来约束函数</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Cart&lt;T&gt; &#123;</span><br><span class="line">  list: T[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cart: Cart&lt;<span class="built_in">number</span>&gt; = &#123; list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;</span><br></pre></td></tr></table></figure><h3 id="泛型别名"><a href="#泛型别名" class="headerlink" title="泛型别名"></a>泛型别名</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cart2&lt;T&gt; = &#123; list: T[] &#125; | T[]</span><br><span class="line"><span class="keyword">let</span> c1: Cart2&lt;<span class="built_in">number</span>&gt; = &#123; list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] &#125;</span><br><span class="line"><span class="keyword">let</span> c2: Cart2&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>泛型接口 VS 泛型别名</p><ul><li>接口创建了一个新的名字，它可以在其他任意地方被调用。而类型别名并不创建新的名字</li><li>类型别名不能被 extends 和 implements，这时我们应该尽量使用接口代替类型别名</li><li>当我们需要使用联合类型或者元组类型的时候，类型别名会更合适</li></ul><h3 id="多个泛型"><a href="#多个泛型" class="headerlink" title="多个泛型"></a>多个泛型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不借助中间变量交换两个变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>&lt;<span class="title">T</span>, <span class="title">P</span>&gt;(<span class="params">tuple: [T, P]</span>): [<span class="title">P</span>, <span class="title">T</span>] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [tuple[<span class="number">1</span>], tuple[<span class="number">0</span>]]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ret = swap([<span class="number">1</span>, <span class="string">'a'</span>])</span><br><span class="line">ret[<span class="number">0</span>].toLowerCase()</span><br><span class="line">ret[<span class="number">1</span>].toFixed(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="默认泛型"><a href="#默认泛型" class="headerlink" title="默认泛型"></a>默认泛型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArray</span>&lt;<span class="title">T</span> = <span class="title">number</span>&gt;(<span class="params">length: <span class="built_in">number</span>, value: T</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr: T[] = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    arr[i] = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr = createArray(<span class="number">3</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure><h3 id="泛型约束-继承"><a href="#泛型约束-继承" class="headerlink" title="泛型约束(继承)"></a>泛型约束(继承)</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> WithLength &#123;</span><br><span class="line">  length: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// extends 来继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">WithLength</span>&gt;(<span class="params">val: T</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val.length)</span><br><span class="line">&#125;</span><br><span class="line">logger(<span class="string">'hello'</span>)</span><br><span class="line">logger([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// logger(true) // error 没有length属性</span></span><br></pre></td></tr></table></figure><h3 id="泛型工具类型"><a href="#泛型工具类型" class="headerlink" title="泛型工具类型"></a>泛型工具类型</h3><p>为了方便开发者 TypeScript 内置了一些常用的工具类型，比如 Partial、Required、Readonly、Pick 等。它们都是使用 keyof 实现。</p><p>keyof 操作符可以用来一个对象中的所有 key 值。</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person1 &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  age: <span class="built_in">number</span></span><br><span class="line">  sex?: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> PersonKey = keyof Person1 <span class="comment">// 限制 key 值的取值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValueByKey</span>(<span class="params">p: Person1, key: PersonKey</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> p[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内置的工具类型"><a href="#内置的工具类型" class="headerlink" title="内置的工具类型"></a>内置的工具类型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// type Partial&lt;T&gt; = &#123;[P in keyof T]?: T[P]&#125;</span></span><br><span class="line"><span class="keyword">type</span> PersonSearch = Partial&lt;Person&gt; <span class="comment">// 全部变可选</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type Required&lt;T&gt; = &#123; [P in keyof T]-?: T[P] &#125;</span></span><br><span class="line"><span class="keyword">type</span> PersonRequired = Required&lt;Person&gt; <span class="comment">// 全部变必选</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type ReadOnly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P] &#125;</span></span><br><span class="line"><span class="keyword">type</span> PersonReadOnly = Readonly&lt;Person&gt; <span class="comment">// 全部变只读</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type Pick&lt;T, K extends keyof T&gt;  = &#123;[P in K]: T[P]&#125;</span></span><br><span class="line"><span class="keyword">type</span> PersonSub = Pick&lt;Person, <span class="string">'name'</span>&gt; <span class="comment">// 通过从Type中选择属性Keys的集合来构造类型。</span></span><br></pre></td></tr></table></figure><h3 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> root = <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line"><span class="keyword">let</span> children: HTMLCollection = root!.children <span class="comment">// ! 代表非空断言操作符</span></span><br><span class="line"><span class="keyword">let</span> childNodes: NodeListOf&lt;ChildNode&gt; = root!.childNodes</span><br></pre></td></tr></table></figure><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p>更明确的判断某个分支作用域中的类型，主要尝试检测属性、方法或原型，以确定如何处理值。</p><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">double</span>(<span class="params">input: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">boolean</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 基本数据类型的类型保护</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> input.length</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> input === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> input</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Monkey &#123;</span><br><span class="line">  climb: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  sports: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAnimalName</span>(<span class="params">animal: Monkey | Person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (animal <span class="keyword">instanceof</span> Monkey) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.climb)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animal.sports)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="in"><a href="#in" class="headerlink" title="in"></a>in</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Student &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  play: <span class="built_in">string</span>[]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Teacher &#123;</span><br><span class="line">  name: <span class="built_in">string</span></span><br><span class="line">  teach: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> SchoolRole = Student | Teacher</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRoleInformation</span>(<span class="params">role: SchoolRole</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'play'</span> <span class="keyword">in</span> role) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(role.play)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'teach'</span> <span class="keyword">in</span> role) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(role.teach)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义类型保护"><a href="#自定义类型保护" class="headerlink" title="自定义类型保护"></a>自定义类型保护</h3><p>比如有时两个类型有不同的取值，也没有其他可以区分的属性</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  leg: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">  leg: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBird</span>(<span class="params">x: Bird | Dog</span>): <span class="title">x</span> <span class="title">is</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.leg === <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAnimal</span>(<span class="params">x: Bird | Dog</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isBird(x)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'bird'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'dog'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述完整代码示例：<a href="https://github.com/Jacky-Summer/typescript-tutorial" target="_blank" rel="noopener">typescript-tutorial</a></p><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>TypeScript系列</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编写一个 Webpack Plugin</title>
    <url>/2020/10/18/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-Webpack-Plugin/</url>
    <content><![CDATA[<p>上次写了 <a href="https://juejin.im/post/6882895689773383694" target="_blank" rel="noopener">如何编写一个 Webpack Loader</a>，今天来说说如何编写一个 Webpack Plugin。</p><a id="more"></a><h2 id="webpack-内部执行流程"><a href="#webpack-内部执行流程" class="headerlink" title="webpack 内部执行流程"></a>webpack 内部执行流程</h2><p>一次完整的 webpack 打包大致是这样的过程：</p><ul><li>将命令行参数与 webpack 配置文件 合并、解析得到参数对象。</li><li>参数对象传给 webpack 执行得到 Compiler 对象。</li><li>执行 Compiler 的 run 方法开始编译。每次执行 run 编译都会生成一个 Compilation 对象。</li><li>触发 Compiler 的 make 方法分析入口文件，调用 compilation 的 buildModule 方法创建主模块对象。</li><li>生成入口文件 AST(抽象语法树)，通过 AST 分析和递归加载依赖模块。</li><li>所有模块分析完成后，执行 compilation 的 seal 方法对每个 chunk 进行整理、优化、封装。</li><li>最后执行 Compiler 的 emitAssets 方法把生成的文件输出到 output 的目录中。</li></ul><h2 id="Plugin-作用"><a href="#Plugin-作用" class="headerlink" title="Plugin 作用"></a>Plugin 作用</h2><p>按我的理解，Webpack 插件的作用就是在 webpack 运行到某个时刻的时候，帮我们做一些事情。</p><p>在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p><p>官方解释是：</p><blockquote><p>插件向第三方开发者提供了 webpack 引擎中完整的能力。使用阶段式的构建回调，开发者可以引入它们自己的行为到 webpack 构建流程中。</p></blockquote><h2 id="编写-Plugin"><a href="#编写-Plugin" class="headerlink" title="编写 Plugin"></a>编写 Plugin</h2><p>webpack 插件的组成：</p><ul><li>一个 JS 命名函数或一个类（可以想下我们平时使用插件就是 <code>new XXXPlugin()</code>的方式）</li><li>在插件类/函数的 (prototype) 上定义一个 apply 方法。</li><li>通过 apply 函数中传入 compiler 并插入指定的事件钩子，在钩子回调中取到 compilation 对象</li><li>通过 compilation 处理 webpack 内部特定的实例数据</li><li>如果是插件是异步的，在插件的逻辑编写完后调用 webpack 提供的 callback</li></ul><p>比如我们写一个插件，生成一个版权的文件。</p><h3 id="基本雏形"><a href="#基本雏形" class="headerlink" title="基本雏形"></a>基本雏形</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CopyrightWebpackPlugin</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">CopyrightWebpackPlugin.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">compiler</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = CopyrightWebpackPlugin</span><br></pre></td></tr></table></figure><p>也可以写成类的形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CopyrightWebpackPlugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(compiler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = CopyrightWebpackPlugin</span><br></pre></td></tr></table></figure><p>webpack 在启动之后，在读取配置的过程中会先执行<code>new CopyrightWebpackPlugin(options)</code>操作，初始化一个<code>CopyrightWebpackPlugin</code>实例对象。在初始化 compiler 对象之后，会调用上述实例对象的<code>apply</code>方法并将<code>compiler</code>对象传入。</p><p>在<code>apply</code>方法中，通过<code>compiler</code>对象来监听 webpack 生命周期中广播出来的事件，我们也可以通过 compiler 对象来操作 webpack 的输出。</p><h3 id="Compiler-和-Compilation"><a href="#Compiler-和-Compilation" class="headerlink" title="Compiler 和 Compilation"></a>Compiler 和 Compilation</h3><p>在插件开发中最重要的两个对象是 <code>compiler</code> 和 <code>compilation</code> 对象。</p><blockquote><p>compiler 对象代表了完整的 webpack 环境配置，在初始化 compiler 对象之后，通过调用插件实例的 apply 方法，作为其参数传入。这个对象在启动 webpack 时被一次性建立，并包含了 webpack 环境的所有的配置信息，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。</p></blockquote><blockquote><p>compilation 对象会作为 plugin 内置事件回调函数的参数，一个 compilation 对象包含了当前的模块资源、编译生成资源、变化的文件以及被跟踪依赖的状态信息。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 compilation 将被创建。compilation 对象也提供了很多事件回调供插件做扩展。通过 compilation 也能读取到 compiler 对象。</p></blockquote><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>下面代码为生成一个版权 txt 文件，新建文件<code>src/plugins/copyright-webpack-plugin.js</code>：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CopyrightWebpackPlugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// emit 钩子是生成资源到 output 目录之前执行，emit 是一个异步串行钩子，需要用 tapAsync 来注册</span></span><br><span class="line">    compiler.hooks.emit.tapAsync(<span class="string">'CopyrightWebpackPlugin'</span>, (compilation, callback) =&gt; &#123;</span><br><span class="line">      <span class="comment">// 回调方式注册异步钩子</span></span><br><span class="line">      <span class="keyword">const</span> copyrightText = <span class="string">'版权归 JackySummer 所有'</span></span><br><span class="line">      <span class="comment">// compilation存放了这次打包的所有内容</span></span><br><span class="line">      <span class="comment">// 所有待生成的文件都在它的 assets 属性上</span></span><br><span class="line">      compilation.assets[<span class="string">'copyright.txt'</span>] = &#123;</span><br><span class="line">        <span class="comment">// 添加copyright.txt</span></span><br><span class="line">        source: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> copyrightText</span><br><span class="line">        &#125;,</span><br><span class="line">        size: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 文件大小</span></span><br><span class="line">          <span class="keyword">return</span> copyrightText.length</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">      callback() <span class="comment">// 必须调用</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = CopyrightWebpackPlugin</span><br></pre></td></tr></table></figure><p>webpack 中许多对象扩展自 Tapable 类。这个类暴露 tap, tapAsync 和 tapPromise 方法，可以使用这些方法，注入自定义的构建步骤，这些步骤将在整个编译过程中不同时机触发。</p><p>使用 tapAsync 方法来访问插件时，需要调用作为最后一个参数提供的回调函数。</p><p>在 webpack.config.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> CopyrightWebpackPlugin = <span class="built_in">require</span>(<span class="string">'./src/plugins/copyright-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> CopyrightWebpackPlugin()],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 webpack 命令，就会看到 dist 目录下生成<code>copyright.txt</code>文件</p><p>如果在配置文件使用 plugin 时传入参数该怎么获得呢，可以在插件类添加构造函数拿到：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> plugins: [</span><br><span class="line">  <span class="keyword">new</span> CopyrightWebpackPlugin(&#123;</span><br><span class="line">    name: <span class="string">'jacky'</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>在<code>copyright-webpack-plugin.js</code>中</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CopyrightWebpackPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'options'</span>, options) <span class="comment">// options &#123; name: 'jacky' &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章： <a href="https://www.jianshu.com/p/8e92f36e52da" target="_blank" rel="noopener">揭秘 webpack plugin</a></p><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编写一个 Webpack Loader</title>
    <url>/2020/10/13/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-Webpack-Loader/</url>
    <content><![CDATA[<p>在平时自己由零搭建项目时，虽然基础配置都比较熟悉，比如配置 file-loader, url-loader, css-loader 等，配置不难，但究竟是怎么起作用的呢，今天就来说说如何编写一个 Webpack Loader。</p><a id="more"></a><h2 id="Loader-作用"><a href="#Loader-作用" class="headerlink" title="Loader 作用"></a>Loader 作用</h2><p>按我自己的简单理解，loader 通常指打包的方案，即按什么方式来处理打包，打包的时候它可以拿到模块源代码，经过特定 loader 的转换后返回新的结果。</p><p>比如 sass-loader 可以把 SCSS 代码转换成 CSS 代码</p><h2 id="编写-Loader"><a href="#编写-Loader" class="headerlink" title="编写 Loader"></a>编写 Loader</h2><h3 id="保持功能单一"><a href="#保持功能单一" class="headerlink" title="保持功能单一"></a>保持功能单一</h3><p>我们项目中可能会配置很多，但要记住，要保持一个 Loader 的功能单一，避免做多种功能，只需完成一种功能转换即可。</p><p>所以如 less 文件转换成 css 文件，也不是一步到位，而是 less-loader, css-loader, style-loader 几个 loader 的链式调用才能完成转换。</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>因为 Webpack 本身是运行在 Node.js 之上的，一个 loader 其实就是一个 node 模块，这个模块导出的是一个函数，即：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// source 为 compiler 传递给 Loader 的一个文件的原内容</span></span><br><span class="line">  <span class="comment">// 处理...</span></span><br><span class="line">  <span class="keyword">return</span> source <span class="comment">// 需要返回处理后的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个导出的函数的工作就是获得处理前的原内容，对原内容执行处理后，返回处理后的内容。</p><h3 id="替换字符串的-loader"><a href="#替换字符串的-loader" class="headerlink" title="替换字符串的 loader"></a>替换字符串的 loader</h3><p>比如我们打包时，想要替换源文件的字符串，这时可以考虑使用 Loader，因为 loader 就是获得源文件内容然后对其进行处理，再返回。</p><p>比如 src 目录下有三个文件：</p><p>src/msg1.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> msg1 = <span class="string">'学习框架'</span></span><br></pre></td></tr></table></figure><p>src/msg2.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> msg2 = <span class="string">'深入理解JS'</span></span><br></pre></td></tr></table></figure><p>src/index.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; msg1 &#125; <span class="keyword">from</span> <span class="string">'./msg1'</span></span><br><span class="line"><span class="keyword">import</span> &#123; msg2 &#125; <span class="keyword">from</span> <span class="string">'./msg2'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`输出：<span class="subst">$&#123;msg1&#125;</span>, <span class="subst">$&#123;msg2&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print()</span><br></pre></td></tr></table></figure><p>做的事情则是把 msg1 和 msg2 两个文件导入，然后输出两个字符串。</p><p>我们要做的事也很简单，把”框架”转为”React 框架”， “JS”转为”JavaScript”。</p><p>新建 <code>src/loaders/replaceLoader.js</code>文件，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handleContent = source.replace(<span class="string">'框架'</span>, <span class="string">'React框架'</span>).replace(<span class="string">'JS'</span>, <span class="string">'JavaScript'</span>)</span><br><span class="line">  <span class="keyword">return</span> handleContent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样，loader 写完了！！！</p><p>上面我们讲到，source 是源文件内容，如果打印的话，则是：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad0aa5b46ede404eb4d1c2602e609ccb~tplv-k3u1fbpfcp-watermark.webp" alt=""></p><h3 id="使用-Loader"><a href="#使用-Loader" class="headerlink" title="使用 Loader"></a>使用 Loader</h3><p>接下来，我们要来使用它，在根目录下新建文件 webpack.config.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'./src/loaders/replaceLoader.js'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>npx webpack</code>,<br>查看打包结果<code>dist/main.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">;<span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="meta">  'use strict'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'输出：学习React框架, 深入理解JavaScript'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>替换成功！</p><p>需要注意的是，<code>use</code>里面填写的 loader 是去<code>node_modules</code>目录里面找的，由于我们是自定义的 loader，所以不能直接写<code>use: &#39;replaceLoader&#39;</code>，但直接写路径的方式未免难看点，我们可以通过 webpack 来配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">    modules: [<span class="string">'node_modules'</span>, <span class="string">'./src/loaders'</span>], <span class="comment">// node_modules找不到，就去./src/loaders找</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">'replaceLoader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取-loader-的-options"><a href="#获取-loader-的-options" class="headerlink" title="获取 loader 的 options"></a>获取 loader 的 options</h3><p>写完之后，让我们来想想，其实就是写一个功能函数嘛。</p><p>当然，这只是最简单的例子，如果 loader 可以传入参数呢，比如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'replaceLoader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          params: <span class="string">'replaceString'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>这个时候可以使用<code>this.query</code>来获取，通过<code>this.query.params</code>就能拿到，这里需要注意的是，this 上下文是有用的，所以这个 loader 导出函数不能是箭头函数。</p><p>但 webpack 更推荐<code>loader-utils</code>模块来获取，它提供了许多有用的工具，最常用的一种工具是获取传递给 loader 的选项。</p><p>首先要安装</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -D loader-utils</span><br></pre></td></tr></table></figure><p>修改<code>src/loaders/replaceLoader.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; getOptions &#125; = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(getOptions(<span class="keyword">this</span>)) <span class="comment">// &#123; params: 'replaceString' &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.query.params) <span class="comment">// replaceString</span></span><br><span class="line">  <span class="keyword">const</span> handleContent = source.replace(<span class="string">'框架'</span>, <span class="string">'React框架'</span>).replace(<span class="string">'JS'</span>, <span class="string">'JavaScript'</span>)</span><br><span class="line">  <span class="keyword">return</span> handleContent</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是，<code>getOptions(this)</code>参数传入的是 this，也就是说</p><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; params: &#39;replaceString&#39; &#125;</span><br><span class="line">&#123; params: &#39;replaceString&#39; &#125;</span><br><span class="line">&#123; params: &#39;replaceString&#39; &#125;</span><br></pre></td></tr></table></figure><h3 id="this-callback"><a href="#this-callback" class="headerlink" title="this.callback()"></a>this.callback()</h3><p>上面都是返回原来内容转换后的内容，但有些场景下还需要返回其他东西比如 sourceMap</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 告诉 Webpack 返回的结果</span></span><br><span class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, source, sourceMaps)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外也不需要 return 了，所以也可使用此 API 替代 return</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; getOptions &#125; = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> handleContent = source.replace(<span class="string">'框架'</span>, <span class="string">'React框架'</span>).replace(<span class="string">'JS'</span>, <span class="string">'JavaScript'</span>)</span><br><span class="line">  <span class="keyword">this</span>.callback(<span class="literal">null</span>, handleContent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义-loader-应用场景"><a href="#自定义-loader-应用场景" class="headerlink" title="自定义 loader 应用场景"></a>自定义 loader 应用场景</h3><ol><li>在所有 function 外面加一层 try catch 代码块捕获错误，避免手动繁琐添加。</li><li>实现中英文替换：可以将文字用占位符如<code>如何编写一个 Webpack Loader</code>包裹，检测到占位符则根据环境变量替换为中英文。</li></ol><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
        <tag>Loader</tag>
      </tags>
  </entry>
  <entry>
    <title>手写简易的 Vue Router</title>
    <url>/2020/10/10/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93%E7%9A%84-Vue-Router/</url>
    <content><![CDATA[<p>还是那样，懂得如何使用一个常用库，还得了解其原理或者怎么模拟实现，今天实现一下 <code>vue-router</code>。</p><p>有一些知识我这篇文章提到了，这里就不详细一步步写，请看我 <a href="https://github.com/Jacky-Summer/mini-vuex" target="_blank" rel="noopener">手写一个简易的 Vuex</a></p><a id="more"></a><h2 id="基本骨架"><a href="#基本骨架" class="headerlink" title="基本骨架"></a>基本骨架</h2><ul><li>Vue 里面使用插件的方式是<code>Vue.use(plugin)</code>，这里贴出它的用法：</li></ul><blockquote><p>安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象。</p></blockquote><ul><li>全局混入</li></ul><p>使用 <code>Vue.mixin(mixin)</code></p><blockquote><p>全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。可以使用混入向组件注入自定义的行为，它将影响每一个之后创建的 Vue 实例。</p></blockquote><ul><li>路由用法</li></ul><p>比如简单的:</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 路由数组</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    name: <span class="string">'Page1'</span>,</span><br><span class="line">    component: Page1,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/page2'</span>,</span><br><span class="line">    name: <span class="string">'Page2'</span>,</span><br><span class="line">    component: Page2,</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>, <span class="comment">// 模式</span></span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>它是传入了<code>mode</code>和<code>routes</code>，我们实现的时候需要在<code>VueRouter</code>构造函数中接收。</p><p>在使用路由标题的时候是这样：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 使用 router-link 组件来导航. --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/page1"</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">"/page2"</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br></pre></td></tr></table></figure><p>故我们需要使用<code>Vue.component(id, [definition])</code>注册一个全局组件。</p><p>了解了大概，我们就可以写出一个基本骨架</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="string">'hash'</span></span><br><span class="line">    <span class="keyword">this</span>.routes = options.routes || []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VueRouter.install = <span class="function"><span class="keyword">function</span> (<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  Vue = _Vue</span><br><span class="line"></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="comment">// 根组件</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.$options &amp;&amp; <span class="keyword">this</span>.$options.router) &#123;</span><br><span class="line">        <span class="keyword">this</span>._root = <span class="keyword">this</span> <span class="comment">// 把当前vue实例保存到_root上</span></span><br><span class="line">        <span class="keyword">this</span>._router = <span class="keyword">this</span>.$options.router <span class="comment">// 把router的实例挂载在_router上</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.$parent &amp;&amp; <span class="keyword">this</span>.$parent._root) &#123;</span><br><span class="line">        <span class="comment">// 子组件的话就去继承父组件的实例，让所有组件共享一个router实例</span></span><br><span class="line">        <span class="keyword">this</span>._root = <span class="keyword">this</span>.$parent &amp;&amp; <span class="keyword">this</span>.$parent._root</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Vue.component(<span class="string">'router-link'</span>, &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      to: &#123;</span><br><span class="line">        type: [<span class="built_in">String</span>, <span class="built_in">Object</span>],</span><br><span class="line">        required: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      tag: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">'a'</span>, <span class="comment">// router-link 默认渲染成 a 标签</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">let</span> tag = <span class="keyword">this</span>.tag || <span class="string">'a'</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">tag</span> <span class="attr">href</span>=<span class="string">&#123;this.to&#125;</span>&gt;</span>&#123;this.$slots.default&#125;<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Vue.component(<span class="string">'router-view'</span>, &#123;</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">return</span> h(<span class="string">'h1'</span>, &#123;&#125;, <span class="string">'视图显示的地方'</span>) <span class="comment">// 暂时置为h1标签，下面会改</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VueRouter</span><br></pre></td></tr></table></figure><h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p><code>vue-router</code>有两种模式，默认为 hash 模式。</p><h3 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h3><p>通过<code>window.history.pushState</code>API 来添加浏览器历史记录，然后通过监听<code>popState</code>事件，也就是监听历史记录的改变，来加载相应的内容。</p><ul><li>popstate 事件</li></ul><blockquote><p>当活动历史记录条目更改时，将触发 popstate 事件。如果被激活的历史记录条目是通过对 history.pushState()的调用创建的，或者受到对 history.replaceState()的调用的影响，popstate 事件的 state 属性包含历史条目的状态对象的副本。</p></blockquote><ul><li>History.pushState()方法</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.history.pushState(state, title, url)</span><br></pre></td></tr></table></figure><p>该方法用于在历史中添加一条记录，接收三个参数，依次为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">state：一个与添加的记录相关联的状态对象，主要用于popstate事件。该事件触发时，该对象会传入回调函数。也就是说，浏览器会将这个对象序列化以后保留在本地，重新载入这个页面的时候，可以拿到这个对象。如果不需要这个对象，此处可以填null。</span><br><span class="line">title：新页面的标题。但是，现在所有浏览器都忽视这个参数，所以这里可以填空字符串。</span><br><span class="line">url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。</span><br></pre></td></tr></table></figure><h3 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h3><p>使用 URL 的 hash 来模拟一个完整的 URL。，通过监听<code>hashchange</code>事件，然后根据<code>hash</code>值（可通过 window.location.hash 属性读取）去加载对应的内容的。</p><p>继续增加代码，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HistoryRoute</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.current = <span class="literal">null</span> <span class="comment">// 当前路径</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VueRouter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.mode = options.mode || <span class="string">'hash'</span></span><br><span class="line">    <span class="keyword">this</span>.routes = options.routes || []</span><br><span class="line">    <span class="keyword">this</span>.routesMap = <span class="keyword">this</span>.createMap(<span class="keyword">this</span>.routes)</span><br><span class="line">    <span class="keyword">this</span>.history = <span class="keyword">new</span> HistoryRoute() <span class="comment">// 当前路由</span></span><br><span class="line">    <span class="keyword">this</span>.initRoute() <span class="comment">// 初始化路由函数</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createMap(routes) &#123;</span><br><span class="line">    <span class="keyword">return</span> routes.reduce(<span class="function">(<span class="params">pre, current</span>) =&gt;</span> &#123;</span><br><span class="line">      pre[current.path] = current.component</span><br><span class="line">      <span class="keyword">return</span> pre</span><br><span class="line">    &#125;, &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  initRoute() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.mode === <span class="string">'hash'</span>) &#123;</span><br><span class="line">      <span class="comment">// 先判断用户打开时有没有hash值，没有的话跳转到 #/</span></span><br><span class="line">      location.hash ? <span class="string">''</span> : (location.hash = <span class="string">'/'</span>)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.history.current = location.hash.slice(<span class="number">1</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.history.current = location.hash.slice(<span class="number">1</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// history模式</span></span><br><span class="line">      location.pathname ? <span class="string">''</span> : (location.pathname = <span class="string">'/'</span>)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.history.current = location.pathname</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, () =&gt; &#123;</span><br><span class="line">        <span class="keyword">this</span>.history.current = location.pathname</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VueRouter.install = <span class="function"><span class="keyword">function</span> (<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  Vue = _Vue</span><br><span class="line"></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.$options &amp;&amp; <span class="keyword">this</span>.$options.router) &#123;</span><br><span class="line">        <span class="keyword">this</span>._root = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">this</span>._router = <span class="keyword">this</span>.$options.router</span><br><span class="line">        Vue.util.defineReactive(<span class="keyword">this</span>, <span class="string">'_route'</span>, <span class="keyword">this</span>._router.history) <span class="comment">// 监听history路径变化</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.$parent &amp;&amp; <span class="keyword">this</span>.$parent._root) &#123;</span><br><span class="line">        <span class="keyword">this</span>._root = <span class="keyword">this</span>.$parent &amp;&amp; <span class="keyword">this</span>.$parent._root</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当访问this.$router时即返回router实例</span></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'$router'</span>, &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>._root._router</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 当访问this.$route时即返回当前页面路由信息</span></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, <span class="string">'$route'</span>, &#123;</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>._root._router.history.current</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> VueRouter</span><br></pre></td></tr></table></figure><h2 id="router-link-和-router-view-组件"><a href="#router-link-和-router-view-组件" class="headerlink" title="router-link 和 router-view 组件"></a>router-link 和 router-view 组件</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">VueRouter.install = <span class="function"><span class="keyword">function</span> (<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  Vue = _Vue</span><br><span class="line"></span><br><span class="line">  Vue.component(<span class="string">'router-link'</span>, &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      to: &#123;</span><br><span class="line">        type: [<span class="built_in">String</span>, <span class="built_in">Object</span>],</span><br><span class="line">        required: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      tag: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        <span class="keyword">default</span>: <span class="string">'a'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      handleClick(event) &#123;</span><br><span class="line">        <span class="comment">// 阻止a标签默认跳转</span></span><br><span class="line">        event &amp;&amp; event.preventDefault &amp;&amp; event.preventDefault()</span><br><span class="line">        <span class="keyword">let</span> mode = <span class="keyword">this</span>._self._root._router.mode</span><br><span class="line">        <span class="keyword">let</span> path = <span class="keyword">this</span>.to</span><br><span class="line">        <span class="keyword">this</span>._self._root._router.history.current = path</span><br><span class="line">        <span class="keyword">if</span> (mode === <span class="string">'hash'</span>) &#123;</span><br><span class="line">          <span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="string">''</span>, <span class="string">'#/'</span> + path.slice(<span class="number">1</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="string">''</span>, path.slice(<span class="number">1</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    render(h) &#123;</span><br><span class="line">      <span class="keyword">let</span> mode = <span class="keyword">this</span>._self._root._router.mode</span><br><span class="line">      <span class="keyword">let</span> tag = <span class="keyword">this</span>.tag || <span class="string">'a'</span></span><br><span class="line">      <span class="keyword">let</span> to = mode === <span class="string">'hash'</span> ? <span class="string">'#'</span> + <span class="keyword">this</span>.to : <span class="keyword">this</span>.to</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'render'</span>, <span class="keyword">this</span>.to)</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;tag on-click=&#123;<span class="keyword">this</span>.handleClick&#125; href=&#123;to&#125;&gt;</span><br><span class="line">          &#123;<span class="keyword">this</span>.$slots.default&#125;</span><br><span class="line">        &lt;<span class="regexp">/tag&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ return h(tag, &#123; attrs: &#123; href: to &#125;, on: &#123; click: this.handleClick &#125; &#125;, this.$slots.default)</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  Vue.component('router-view', &#123;</span></span><br><span class="line"><span class="regexp">    render(h) &#123;</span></span><br><span class="line"><span class="regexp">      let current = this._self._root._router.history.current /</span><span class="regexp">/ current已经是动态响应</span></span><br><span class="line"><span class="regexp">      let routesMap = this._self._root._router.routesMap</span></span><br><span class="line"><span class="regexp">      return h(routesMap[current]) /</span><span class="regexp">/ 动态渲染对应组件</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>至此，一个简易的<code>vue-router</code>就实现完了，案例完整代码附上：<a href="https://github.com/Jacky-Summer/mini-vue-router/blob/master/src/myrouter.js" target="_blank" rel="noopener">mini-vue-router</a></p><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>Vue 系列</category>
      </categories>
      <tags>
        <tag>手写</tag>
        <tag>Vue</tag>
        <tag>Vue Router</tag>
      </tags>
  </entry>
  <entry>
    <title>手写简易的 Vuex</title>
    <url>/2020/10/08/%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93%E7%9A%84-Vuex/</url>
    <content><![CDATA[<p>本文适合使用过 Vuex 的人阅读，来了解下怎么自己实现一个 Vuex。</p><a id="more"></a><h2 id="基本骨架"><a href="#基本骨架" class="headerlink" title="基本骨架"></a>基本骨架</h2><p>这是本项目的<code>src/store/index.js</code>文件，看看一般 vuex 的使用</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'./myvuex'</span> <span class="comment">// 引入自己写的 vuex</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> getters <span class="keyword">from</span> <span class="string">'./getters'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">'./state'</span></span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex) <span class="comment">// Vue.use(plugin)方法使用vuex插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vuex 导出一个类叫Store，并传入对象作为参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions,</span><br><span class="line">  getters,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Vue.use</code>的用法：</p><blockquote><p>安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象。</p></blockquote><ul><li>该方法需要在调用 new Vue() 之前被调用。</li><li>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</li></ul><p>即是我们需要在<code>./myvuex.js</code>中导出 <code>install</code>方法，同时导出一个类<code>Store</code>，于是第一步可以写出代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  Vue = _Vue <span class="comment">// 上面Store类需要能获取到Vue</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="install-方法"><a href="#install-方法" class="headerlink" title="install 方法"></a>install 方法</h2><p>当我们使用 vuex 的时候，每一个组件上面都有一个<code>this.$store</code>属性，里面包含了 state，mutations， actions， getters 等，所以我们也需要在每个组件上都挂载一个$store 属性,要让每一个组件都能获取到，这里我们使用<code>Vue.mixin(mixin)</code>，用法介绍如下：</p><blockquote><p>全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。可以使用混入向组件注入自定义的行为，它将影响每一个之后创建的 Vue 实例。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  Vue = _Vue <span class="comment">// install方法调用时，会将Vue作为参数传入（上面Store类需要用到Vue）</span></span><br><span class="line">  <span class="comment">// 实现每一个组件，都能通过this调用$store</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="comment">// 通过this.$options可以获取new Vue(&#123;参数&#125;) 传递的参数</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.$options &amp;&amp; <span class="keyword">this</span>.$options.store) &#123;</span><br><span class="line">        <span class="comment">// 证明这个this是根实例，也就是new Vue产生的那个实例</span></span><br><span class="line">        <span class="keyword">this</span>.$store = <span class="keyword">this</span>.$options.store</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.$parent &amp;&amp; <span class="keyword">this</span>.$parent.$store) &#123;</span><br><span class="line">        <span class="comment">// 子组件获取父组件的$store属性</span></span><br><span class="line">        <span class="keyword">this</span>.$store = <span class="keyword">this</span>.$parent.$store</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>由于 Vuex 是基于 Vue 的响应式原理基础，所以我们要让数据改变可刷新视图，则需要创建一个 vue 实例<br>由于</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="comment">// options 即是 Vuex.Store(&#123;&#125;)传入的参数</span></span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// vuex 的核心就是借用了vue的实例，因为vue的实例数据变化，会刷新视图</span></span><br><span class="line">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        state: options.state,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// state</span></span><br><span class="line">    <span class="keyword">this</span>.state = vm.state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>我们使用 vuex 改变数据时，是触发 commit 方法，即是这样使用的：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.$store.commit(&#39;eventName&#39;, &#39;参数&#39; );</span><br></pre></td></tr></table></figure><p>所以我们要实现一个<code>commit</code>方法，把 Store 构造函数传入的 mutations 做下处理</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// 实现 state ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// mutations</span></span><br><span class="line">    <span class="keyword">this</span>.mutations = &#123;&#125; <span class="comment">// 存储传进来的mutations</span></span><br><span class="line">    <span class="keyword">let</span> mutations = options.mutations || &#123;&#125;</span><br><span class="line">    <span class="comment">// 循环取出事件名进行处理（mutations[事件名]: 执行方法）</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(mutations).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.mutations[key] = <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">        mutations[key].call(<span class="keyword">this</span>, <span class="keyword">this</span>.state, params) <span class="comment">// 修正this指向</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  commit = <span class="function">(<span class="params">key, params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// key为要触发的事件名</span></span><br><span class="line">    <span class="keyword">this</span>.mutations[key](params)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch"></a>dispatch</h2><p>跟上面的 commit 流程同理</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// actions</span></span><br><span class="line">    <span class="keyword">this</span>.actions = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> actions = options.actions || &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(actions).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.actions[key] = <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">        actions[key].call(<span class="keyword">this</span>, <span class="keyword">this</span>, params)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dispatch = <span class="function">(<span class="params">type, payload</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.actions[type](payload)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h2><p>getters 实际就是返回 state 的值，在使用的时候是放在 computed 属性，每一个 getter 都是函数形式；</p><p>getters 是需要双向绑定的。但不需要双向绑定所有的 getters，只需要绑定项目中事件使用的 getters。</p><p>这里使用<code>Object.defineProperty()</code>方法，它会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters</span></span><br><span class="line">    <span class="keyword">this</span>.getters = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> getters = options.getters || &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(getters).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.getters, key, &#123;</span><br><span class="line">        <span class="keyword">get</span>: () =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> getters[key].call(<span class="keyword">this</span>, <span class="keyword">this</span>.state)</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，已经可以使用我们自己写的 vuex 做一些基本操作了，但只能通过<code>this.$store.xx</code>的形式调用，故需要再实现方法。</p><h2 id="map-辅助函数"><a href="#map-辅助函数" class="headerlink" title="map 辅助函数"></a>map 辅助函数</h2><p>先来说说 mapState</p><p>没有 map 辅助函数之前这样使用：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  count () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当映射的计算属性的名称与 state 的子节点名称相同时，给 mapState 传一个字符串数组。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class="line">  ...mapState([<span class="string">'count'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这里简单就只实现数组的情况</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapState = <span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  args.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    obj[item] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state[item]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后几个 map 辅助函数都是类似</p><ul><li>mapGetters</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapGetters = <span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  args.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    obj[item] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters[item]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mapMutations</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapMutations = <span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  args.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    obj[item] = <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.commit(item, params)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mapActions</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapActions = <span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  args.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    obj[item] = <span class="function"><span class="keyword">function</span> (<span class="params">payload</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.dispatch(item, payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Store</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="comment">// vuex 的核心就是借用了vue的实例，因为vue的实例数据变化，会刷新视图</span></span><br><span class="line">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">      data: &#123;</span><br><span class="line">        state: options.state,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// state</span></span><br><span class="line">    <span class="keyword">this</span>.state = vm.state</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mutations</span></span><br><span class="line">    <span class="keyword">this</span>.mutations = &#123;&#125; <span class="comment">// 存储传进来的mutations</span></span><br><span class="line">    <span class="keyword">let</span> mutations = options.mutations || &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(mutations).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.mutations[key] = <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">        mutations[key].call(<span class="keyword">this</span>, <span class="keyword">this</span>.state, params)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// actions</span></span><br><span class="line">    <span class="keyword">this</span>.actions = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> actions = options.actions || &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(actions).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.actions[key] = <span class="function"><span class="params">params</span> =&gt;</span> &#123;</span><br><span class="line">        actions[key].call(<span class="keyword">this</span>, <span class="keyword">this</span>, params)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getters</span></span><br><span class="line">    <span class="keyword">this</span>.getters = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> getters = options.getters || &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(getters).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>.getters, key, &#123;</span><br><span class="line">        <span class="keyword">get</span>: () =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> getters[key].call(<span class="keyword">this</span>, <span class="keyword">this</span>.state)</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  commit = <span class="function">(<span class="params">key, params</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.mutations[key](params)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dispatch = <span class="function">(<span class="params">type, payload</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.actions[type](payload)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapState = <span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  args.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    obj[item] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state[item]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapGetters = <span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  args.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    obj[item] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters[item]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapMutations = <span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  args.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    obj[item] = <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.commit(item, params)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapActions = <span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  args.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    obj[item] = <span class="function"><span class="keyword">function</span> (<span class="params">payload</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.dispatch(item, payload)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">_Vue</span>) </span>&#123;</span><br><span class="line">  Vue = _Vue <span class="comment">// install方法调用时，会将Vue作为参数传入（上面Store类需要用到Vue）</span></span><br><span class="line">  <span class="comment">// 实现每一个组件，都能通过this调用$store</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">      <span class="comment">// 通过this.$options可以获取new Vue(&#123;参数&#125;) 传递的参数</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.$options &amp;&amp; <span class="keyword">this</span>.$options.store) &#123;</span><br><span class="line">        <span class="comment">// 证明这个this是根实例，也就是new Vue产生的那个实例</span></span><br><span class="line">        <span class="keyword">this</span>.$store = <span class="keyword">this</span>.$options.store</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.$parent &amp;&amp; <span class="keyword">this</span>.$parent.$store) &#123;</span><br><span class="line">        <span class="comment">// 子组件获取父组件的$store属性</span></span><br><span class="line">        <span class="keyword">this</span>.$store = <span class="keyword">this</span>.$parent.$store</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  Store,</span><br><span class="line">  install,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个项目的源码地址：<a href="https://github.com/Jacky-Summer/mini-vuex" target="_blank" rel="noopener">mini-vuex</a></p><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>Vue 系列</category>
      </categories>
      <tags>
        <tag>手写</tag>
        <tag>Vue</tag>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title>实现Vue中EventBus通信方式</title>
    <url>/2020/10/07/%E5%AE%9E%E7%8E%B0Vue%E4%B8%ADEventBus%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>Vue 非父子组件可以用 Event Bus 通信，用起来很简单但要不只是会使用 api，还要懂大致原理，于是自己实现了一下。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>._events = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册事件</span></span><br><span class="line">  on(name, fn) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="keyword">this</span>._events.get(name)</span><br><span class="line">    <span class="keyword">if</span> (!handler) &#123;</span><br><span class="line">      <span class="keyword">this</span>._events.set(name, [])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._events.get(name).push(fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 触发事件</span></span><br><span class="line"><span class="comment">   * 可以用apply与call两种方法,在少数参数时call的性能更好,多个参数时apply性能更好</span></span><br><span class="line"><span class="comment">   * Node的Event模块就在三个参数以下用call否则用apply.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  emit(name, ...args) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="keyword">this</span>._events.get(name)</span><br><span class="line">    <span class="keyword">if</span> (!handler) <span class="keyword">return</span></span><br><span class="line">    handler.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (args.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        cb.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cb.call(<span class="keyword">this</span>, ...args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只被触发一次的事件</span></span><br><span class="line">  once(name, fn) &#123;</span><br><span class="line">    <span class="keyword">const</span> cb = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (args.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fn.call(<span class="keyword">this</span>, ...args)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.off(name, cb)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.on(name, cb)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消事件</span></span><br><span class="line">  off(name, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      <span class="comment">// 没有传指定函数就移除所有同名事件</span></span><br><span class="line">      <span class="keyword">this</span>._events.delete(name)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="keyword">this</span>._events.get(name)</span><br><span class="line">    <span class="keyword">if</span> (!handler) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> fnIndex = handler.findIndex(<span class="function"><span class="params">cb</span> =&gt;</span> cb === fn)</span><br><span class="line">    handler.splice(fnIndex, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>._events.get(name).length) &#123;</span><br><span class="line">      <span class="keyword">this</span>._events.delete(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue 系列</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>JavaScript</tag>
        <tag>组件通信</tag>
      </tags>
  </entry>
  <entry>
    <title>手写防抖与节流函数</title>
    <url>/2020/09/28/%E6%89%8B%E5%86%99%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>函数防抖与节流算是前端性能优化的一个细节点，可能开发大多数是用着 JS 库顺带的防抖节流函数，但我们必须会自己写因为没有必要因为一个函数引入一个库。</p><a id="more"></a><h2 id="防抖与节流效果"><a href="#防抖与节流效果" class="headerlink" title="防抖与节流效果"></a>防抖与节流效果</h2><p>这是别人做的一个动画，很容易就能理解区别：<a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener">防抖与节流</a></p><h2 id="函数防抖-debounce"><a href="#函数防抖-debounce" class="headerlink" title="函数防抖(debounce)"></a>函数防抖(debounce)</h2><blockquote><p>在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">debounced</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (timeout) clearTimeout(timeout) <span class="comment">// 每次调用debounce函数都会将前一次的timer清空，确保只执行一次</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">      <span class="keyword">const</span> callNow = !timeout</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 这里只有在 wait 时长之后，timeout 为 null，然后触发防抖函数才能立即执行，</span></span><br><span class="line">        <span class="comment">// 否则 callNow 为 false，不会立即执行，计时器会重新计时</span></span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">      <span class="keyword">if</span> (callNow) func.apply(ctx, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        func.apply(ctx, args)</span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  debounced.cancel = <span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 取消功能</span></span><br><span class="line">    clearTimeout(timeout)</span><br><span class="line">    timeout = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> debounced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>适合多次事件一次响应的情况</p><ul><li>search 搜索联想，用户在不断输入值进行 AJAX 验证时时，用防抖来节约请求资源。</li><li>按钮点击事件/input 事件，防止用户多次重复提交</li><li>电话号码输入的验证， 只需停止输入后进行一次。</li></ul><h2 id="函数节流-throttle"><a href="#函数节流-throttle" class="headerlink" title="函数节流(throttle)"></a>函数节流(throttle)</h2><blockquote><p>规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</p></blockquote><h3 id="定时器版"><a href="#定时器版" class="headerlink" title="定时器版"></a>定时器版</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">throttled</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        func.apply(ctx, args)</span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间戳节流"><a href="#时间戳节流" class="headerlink" title="时间戳节流"></a>时间戳节流</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">throttled</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> now = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">const</span> remain = wait - (now - previous)</span><br><span class="line">    <span class="keyword">if</span> (remain &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      func.apply(ctx, args)</span><br><span class="line">      previous = now</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>适合大量事件按时间做平均分配触发。</p><ul><li>监听滚动或 resize 事件，比如是否滑到底部自动加载更多，调整窗口大小用 throttle 来判断</li><li>DOM 元素拖拽</li><li>自动保存草稿功能，当用户在输入的时候(一直触发事件),单位时间内只保存一次草稿</li><li>Canvas 画笔功能</li><li>游戏中的刷新率</li></ul>]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>手写</tag>
        <tag>JavaScript</tag>
        <tag>debounce</tag>
        <tag>throttle</tag>
      </tags>
  </entry>
  <entry>
    <title>动手搞懂 HTTP 缓存机制</title>
    <url>/2020/09/27/%E5%8A%A8%E6%89%8B%E6%90%9E%E6%87%82-HTTP-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>HTTP 缓存策略相信大家都有一定的了解，但自己讲的话也是大概模糊的理解。于是，又回到重新归纳的环节了，这次，搞懂它！</p>
<a id="more"></a>

<h2 id="浏览器缓存的作用"><a href="#浏览器缓存的作用" class="headerlink" title="浏览器缓存的作用"></a>浏览器缓存的作用</h2><ol>
<li>缓存可以减少冗余的数据传输，节省了网络带宽，从而更快的加载页面以及减少用户的流量消耗</li>
<li>缓存降低了服务器的要求，从而让服务器更快的响应。</li>
</ol>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>浏览器缓存策略分为两种：<strong>强缓存</strong>和<strong>协商缓存</strong>。一看到强缓存，就可能联想到”弱缓存”，这个”强”实际形容得不太恰当，其实强缓存指的是新鲜的响应，而协商缓存指的是陈旧的响应（已过期），而要复用陈旧的响应就得使用条件请求（If-xxx）进行缓存验证，我们下面会讲。</p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><ol>
<li>浏览器在加载资源时，根据请求头的 Expires 和 Cache-Control 判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。</li>
<li>如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过 Last-Modified 和 ETag 验证资源是否命中协商缓存，如果命中，则返回 304 读取缓存资源</li>
<li>如果前面两者都没有命中，直接从服务器请求加载资源</li>
</ol>
<h2 id="缓存的文件到哪里去"><a href="#缓存的文件到哪里去" class="headerlink" title="缓存的文件到哪里去"></a>缓存的文件到哪里去</h2><p>一般看到的两种：memory cache（内存缓存） 和 disk cache（硬盘缓存）</p>
<ul>
<li><p><strong>200 from memory cache</strong>：它是将资源文件缓存到内存中，而是直接从内存中读取数据。但该方式退出进程时数据会被清除，如关闭浏览器；一般会将将脚本、字体、图片会存储到内存缓存中。</p>
</li>
<li><p><strong>200 from disk cache</strong>：它是将资源文件缓存到硬盘中。关闭浏览器后，数据依然存在；一般会将非脚本的存放在硬盘中，比如 css。</p>
</li>
</ul>
<p>优先访问 memory cache，其次是 disk cache，最后是请求网络资源；且内存读取速度比硬盘读取速度快，但也不能把所有数据放在内存中，因为内存也是有限的。</p>
<h2 id="通过-express-搭建服务模拟演示"><a href="#通过-express-搭建服务模拟演示" class="headerlink" title="通过 express 搭建服务模拟演示"></a>通过 express 搭建服务模拟演示</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.send(<span class="string">`&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">  &lt;html lang="en"&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta charset="UTF-8"&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Init Demo&lt;/title&gt;</span></span><br><span class="line"><span class="string">  &lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    Hello Init Demo</span></span><br><span class="line"><span class="string">    &lt;script src="/test.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/html&gt;`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/test.js'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> sourcePath = path.resolve(__dirname, <span class="string">'../public/test.js'</span>)</span><br><span class="line">  <span class="keyword">let</span> result = fs.readFileSync(sourcePath)</span><br><span class="line">  res.end(result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on 3000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如上代码，当进入<code>http://localhost:3000/</code>，请求过程如下：</p>
<ul>
<li>浏览器请求静态资源 <code>test.js</code></li>
<li>服务器读取磁盘文件 <code>test.js</code>，返回给浏览器</li>
<li>浏览器再次请求，服务器又重新读取磁盘文件 <code>test.js</code>，返给浏览器。</li>
</ul>
<p>多次刷新网页，重新进入，可以看到每次都重新发了<code>test.js</code>的请求，这种方式下没有进行任何缓存。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa0b4111b21043629107fb09c50533d8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>强缓存通过 Expires 和 Cache-Control 两种响应头实现</p>
<p>原理：</p>
<blockquote>
<p>浏览器在加载资源的时候，会先根据本地缓存资源的 header 中的信息(Expires 和 Cache-Control)来判断是否需要强制缓存。如果命中的话，则会直接使用缓存中的资源。否则的话，会继续向服务器发送请求。</p>
</blockquote>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires 是 HTTP1.0 的规范，表示该资源过期时间，它描述的是一个绝对时间（值为 GMT 时间，即格林尼治时间），由服务器返回。</p>
<p>如果浏览器端当前时间小于过期时间，则直接使用缓存数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/test.js'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> sourcePath = path.resolve(__dirname, <span class="string">'../public/test.js'</span>)</span><br><span class="line">  <span class="keyword">let</span> result = fs.readFileSync(sourcePath)</span><br><span class="line">  res.setHeader(</span><br><span class="line">    <span class="string">'Expires'</span>,</span><br><span class="line">    moment().utc().add(<span class="number">1</span>, <span class="string">'m'</span>).format(<span class="string">'ddd, DD MMM YYYY HH:mm:ss'</span>) + <span class="string">' GMT'</span> <span class="comment">// 设置1分钟后过期</span></span><br><span class="line">  )</span><br><span class="line">  res.end(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码我们添加了 Expires 响应头，第一次向服务器发起请求后，同时返回过期时间和文件；当再次刷新时，就会看到文件是直接从缓存(memory cache)中读取的；当 1 分钟过后过期了，又会重新请求了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/184fe17b6c1444b58214d8d20e33b1e5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>这种方式受限于本地时间，服务器的时间和客户端的时间不一样的情况下（比如浏览器设置了很后的时间，则一直处于过期状态），可能会造成缓存失效。而且过期后，不管文件有没有发生变化，服务器都会再次读取文件返回给浏览器。</p>
<p>Expires 是 HTTP 1.0 的东西，现在默认浏览器大部分使用 HTTP 1.1，它的作用基本忽略，因为会靠<code>Cache-Control</code>作为主要判断依据。</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>知道了 <code>Expires</code>的缺点后，在 HTTP 1.1 版开始，就加入了<code>Cache-Control</code>来替代，它是利用<code>max-age</code>判断缓存时间的，以秒为单位，它的优先级高于 <code>Expires</code>，表示的是相对时间。也就是说，如果<code>max-age</code>和<code>Expires</code>同时存在，则被 Cache-Control 的 max-age 覆盖。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/test.js'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> sourcePath = path.resolve(__dirname, <span class="string">'../public/test.js'</span>)</span><br><span class="line">  <span class="keyword">let</span> result = fs.readFileSync(sourcePath)</span><br><span class="line">  res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=60'</span>) <span class="comment">// 设置相对时间-60秒过期</span></span><br><span class="line">  res.end(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>同样第一次请求后再次请求，就可以看到是命中协商缓存了。<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60cdeeb8bdd34665975bfe90f0a8cd0a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>除了该字段，还有其他字段可设置：</p>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p>表示可以被浏览器和代理服务器缓存，代理服务器一般可用 nginx 来做</p>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>只让客户端可以缓存该资源；代理服务器不缓存</p>
<h4 id="no-cache"><a href="#no-cache" class="headerlink" title="no-cache"></a>no-cache</h4><p>跳过设置强缓存，但是不妨碍设置协商缓存；一般如果你做了强缓存，只有在强缓存失效了才走协商缓存的，设置了 no-cache 就不会走强缓存了，每次请求都回询问服务端。</p>
<h4 id="no-store"><a href="#no-store" class="headerlink" title="no-store"></a>no-store</h4><p>禁止使用缓存，每一次都要重新请求数据。</p>
<p>比如我设置禁止缓存，再重复上面操作，就每次都向服务器请求了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'no-store, max-age=60'</span>) <span class="comment">// 禁止缓存</span></span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c6b694c980734c649458db32c5966846~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>强缓存的缺点就是每次都根据时间来判断是否过期，但如果到了过期时间后，文件没有改动，再次去获取就有点浪费服务器的资源了，因此有了协商缓存。</p>
<p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的 http 状态为 304 告诉浏览器读取换出，并且会显示一个 Not Modified 的字符串；如果未命中，则返回请求的资源。</p>
<p>协商缓存是利用的是<code>Last-Modified/If-Modified-Since</code>和<code>ETag/If-None-Match</code>这两对标识来管理的</p>
<p>原理：</p>
<blockquote>
<p>客户端向服务器端发出请求，服务端会检测是否有对应的标识，如果没有对应的标识，服务器端会返回一个对应的标识给客户端，客户端下次再次请求的时候，把该标识带过去，然后服务器端会验证该标识，如果验证通过了，则会响应 304，告诉浏览器读取缓存。如果标识没有通过，则返回请求的资源。</p>
</blockquote>
<h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>过程如下：</p>
<ul>
<li>浏览器请求资源，服务器每次返回文件的同时，返回<code>Last-Modified</code>(最后的修改时间)到 Header 中</li>
<li>当浏览器的缓存文件过期后，浏览器带上请求头<code>If-Modified-Since</code>（值为上一次的<code>Last-Modified</code>）请求服务器</li>
<li>服务器比较请求头的<code>If-Modified-Since</code>和文件上次修改时间一样，则命中缓存返回 304；如果不一致就返回 200 响应和文件的内容还有更新<code>Last-Modified</code>的值，以此往复。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/test.js'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> sourcePath = path.resolve(__dirname, <span class="string">'../public/test.js'</span>)</span><br><span class="line">  <span class="keyword">let</span> result = fs.readFileSync(sourcePath)</span><br><span class="line">  <span class="keyword">let</span> status = fs.statSync(sourcePath)</span><br><span class="line">  <span class="keyword">let</span> lastModified = status.mtime.toUTCString()</span><br><span class="line">  <span class="keyword">if</span> (lastModified === req.headers[<span class="string">'if-modified-since'</span>]) &#123;</span><br><span class="line">    res.writeHead(<span class="number">304</span>, <span class="string">'Not Modified'</span>)</span><br><span class="line">    res.end()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.setHeader(<span class="string">'Cache-Control'</span>, <span class="string">'max-age=1'</span>) <span class="comment">// 设置1秒后过期以方便我们马上能用Last-Modified判断</span></span><br><span class="line">    res.setHeader(<span class="string">'Last-Modified'</span>, lastModified)</span><br><span class="line">    res.writeHead(<span class="number">200</span>, <span class="string">'OK'</span>)</span><br><span class="line">    res.end(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>第一次请求如下：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/387b188f62744390a631aecb9cb96aa9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>1 秒过期后，再次进行多次请求，发现返回的都是 304，命中协商缓存：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ae57f2487a241d799dcb136b16854cc~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>在当中我遇到了个小问题，还是报的 200 响应，请求头里有条警告信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Provisional headers are shown. Disable cache to see full headers.</span><br></pre></td></tr></table></figure>

<p>可能是插件原因导致，于是我开了无痕模式就解决了（如果各位有其他原因解释和解决方法可以留言告诉我）</p>
<h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p><code>Last-Modified</code> 也有它的缺点，比如修改时间是 GMT 时间，只能精确到秒，如果文件在 1 秒内有多次改动，服务器并不知道文件有改动，浏览器拿不到最新的文件。而且如果文件被修改后又撤销修改了，内容还是保持原样，但是最后修改时间变了，也要重新请求。也有可能存在服务器没有准确获取文件修改时间，或与代理服务器时间不一致的情况。</p>
<p>为了解决文件修改时间不精确带来的问题，服务器和浏览器再次协商，这次不返回时间，返回文件的唯一标识<code>ETag</code>。只有当文件内容改变时，<code>ETag</code>才改变。<code>ETag</code>的优先级高于<code>Last-Modified</code>。</p>
<p>过程如下:</p>
<ul>
<li>浏览器请求资源，服务器每次返回文件的同时带上文件的唯一标识 ETag</li>
<li>当浏览器的缓存文件过期后，浏览器带上请求头<code>If-None-Match</code>（值为上一次的<code>ETag</code>）请求服务器</li>
<li>服务器比较请求头的<code>If-None-Match</code>和文件的 ETag 一样，则命中缓存返回 304；如果不一致就返回 200 响应和文件的内容还有更新<code>ETag</code>的值，以此往复。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> md5 = <span class="built_in">require</span>(<span class="string">'md5'</span>)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/test.js'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> sourcePath = path.resolve(__dirname, <span class="string">'../public/test.js'</span>)</span><br><span class="line">  <span class="keyword">let</span> result = fs.readFileSync(sourcePath)</span><br><span class="line">  <span class="keyword">let</span> etag = md5(result)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (req.headers[<span class="string">'if-none-match'</span>] === etag) &#123;</span><br><span class="line">    res.writeHead(<span class="number">304</span>, <span class="string">'Not Modified'</span>)</span><br><span class="line">    res.end()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.setHeader(<span class="string">'ETag'</span>, etag)</span><br><span class="line">    res.writeHead(<span class="number">200</span>, <span class="string">'OK'</span>)</span><br><span class="line">    res.end(result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06e9be1e391a48a9841242a0fdc3a4e6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>再次请求时：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8a2199d885748ee88b6023b7c4f8b5b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<ul>
<li>HTTP 中并没有指定如何生成<code>ETag</code>, 实际项目中生成哈希(hash)是比较常见的做法。</li>
</ul>
<p>不过<code>ETag</code>每次服务端生成都需要进行读写操作，而<code>Last-Modified</code>只需要读取操作，<code>ETag</code>生成计算的消耗更大些。</p>
<h2 id="缓存的优先级"><a href="#缓存的优先级" class="headerlink" title="缓存的优先级"></a>缓存的优先级</h2><p>首先明确的是强缓存的优先级高于协商缓存</p>
<p>在 HTTP1.0 的时候还有个<code>Pragma</code>字段，也属于强缓存，当该字段值为 no-cache 的时候，会告诉浏览器不要对该资源缓存，即每次都得向服务器发一次请求才行，它的优先级高于<code>Cache-Control</code></p>
<p>一般我们现在就不会用它了，如果想见到<code>Pragma</code>的话，在 Chrome 的 devtools 中启用 disable cache 时或者按 <code>Ctrl + F5</code>强制刷新，就会在请求的 Request Header 上看到。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78b4c599e5894dcd8b2505cc410de2f5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>最后优先级为：</p>
<blockquote>
<p>Pragma &gt; Cache-Control &gt; Expires &gt; ETag &gt; Last-Modified</p>
</blockquote>
<h2 id="如何清除缓存"><a href="#如何清除缓存" class="headerlink" title="如何清除缓存"></a>如何清除缓存</h2><p>浏览器默认会缓存图片，css 和 js 等静态资源，有时在开发环境下可能会因为强缓存导致资源没有及时更新而看不到最新的效果，可以用如下几种方式：</p>
<ol>
<li>直接 Ctrl+F5 强制刷新（直接 F5 的话会跳过强缓存规则，直接走协商缓存）</li>
<li>谷歌浏览器可以在 Network 里面选中<code>Disable cache</code></li>
<li>给资源文件加一个时间戳</li>
<li>其他方式设置如 webpack</li>
</ol>
<br>

<p>案例 github 代码：<a href="https://github.com/Jacky-Summer/http-cache-demo" target="_blank" rel="noopener">http-cache-demo</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/tugenhua0707/p/10807289.html" target="_blank" rel="noopener">理解 http 浏览器的协商缓存和强制缓存</a></li>
<li><a href="https://juejin.im/post/6844903655619969038" target="_blank" rel="noopener">前端也要懂 Http 缓存机制</a></li>
</ul>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，鼓励我继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>HTTP系列</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>手写call,apply,bind方法</title>
    <url>/2020/09/26/%E6%89%8B%E5%86%99call-apply-bind%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>这是老生常谈的手写了，今天想自己试着实现一下，做个笔记。</p>
<a id="more"></a>

<h2 id="call-方法"><a href="#call-方法" class="headerlink" title="call 方法"></a>call 方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">undefined</span> || context === <span class="literal">null</span>) &#123;</span><br><span class="line">    context = <span class="built_in">window</span> <span class="comment">// 指定为 null 和 undefined 的 this 值会自动指向全局对象</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context = <span class="built_in">Object</span>(context) <span class="comment">// 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">'uniqueFn'</span>) <span class="comment">// 用 Symbol 是防止跟上下文的原属性冲突</span></span><br><span class="line">  context[fn] = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> arg = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> result = context[fn](...arg)</span><br><span class="line">  <span class="keyword">delete</span> context[fn]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断函数上下文网上也有写法是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">context = context ? <span class="built_in">Object</span>(context) : <span class="built_in">window</span></span><br><span class="line">context = context || <span class="built_in">window</span></span><br></pre></td></tr></table></figure>

<p>但不是很严谨，因为遇到空字符串，<code>0</code>，<code>false</code>时，<code>context</code>也会被判断为<code>window</code>。</p>
<h2 id="apply-方法"><a href="#apply-方法" class="headerlink" title="apply 方法"></a>apply 方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context === <span class="literal">undefined</span> || context === <span class="literal">null</span>) &#123;</span><br><span class="line">    context = <span class="built_in">window</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context = <span class="built_in">Object</span>(context)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否为类数组对象</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      o &amp;&amp; <span class="comment">// o 不是null、undefined等</span></span><br><span class="line">      <span class="keyword">typeof</span> o === <span class="string">'object'</span> &amp;&amp; <span class="comment">// o是对象</span></span><br><span class="line">      <span class="built_in">isFinite</span>(o.length) &amp;&amp; <span class="comment">// o.length是有限数值</span></span><br><span class="line">      o.length &gt;= <span class="number">0</span> &amp;&amp; <span class="comment">// o.length为非负值</span></span><br><span class="line">      o.length === <span class="built_in">Math</span>.floor(o.length) &amp;&amp; <span class="comment">// o.length是整数</span></span><br><span class="line">      o.length &lt; <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">32</span>)</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">'uniqueFn'</span>)</span><br><span class="line">  context[fn] = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">let</span> result</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(args) &amp;&amp; !isArrayLike(args)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'CreateListFromArrayLike called on non-object'</span>) <span class="comment">// 第二个参数不为数组且不为类对象数组</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    args = <span class="built_in">Array</span>.from(args) <span class="comment">// 转为数组</span></span><br><span class="line">    result = context[fn](...args)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context[fn]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h2><p>实现 bind 要额外考虑一个问题：方法一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected this is a function'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">...innerArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isNew = <span class="keyword">this</span> <span class="keyword">instanceof</span> fn <span class="comment">// 返回的fn是否通过new调用</span></span><br><span class="line">    <span class="keyword">return</span> self.apply(isNew ? <span class="keyword">this</span> : <span class="built_in">Object</span>(context), args.concat(innerArg)) <span class="comment">// new调用就绑定到this上,否则就绑定到传入的context上</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 复制原函数的prototype给fn，一些情况下函数没有prototype，比如箭头函数</span></span><br><span class="line">  <span class="keyword">if</span> (self.prototype) &#123;</span><br><span class="line">    fn.prototype = <span class="built_in">Object</span>.create(self.prototype)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fn <span class="comment">// 返回拷贝的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，你的鼓励是我创作的动力~</li>
</ul>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>手写</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之手写Promise</title>
    <url>/2020/09/21/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%89%8B%E5%86%99Promise/</url>
    <content><![CDATA[<p>Promise 在开发中我们经常用到，它解决了回调地狱问题，对错误的处理也非常方便。本文我将通过一步步完善 Promise，从简单到复杂的过程来说。</p><p>本文适合熟练运用 Promise 的人阅读。</p><a id="more"></a><h2 id="极简版"><a href="#极简版" class="headerlink" title="极简版"></a>极简版</h2><p>首先<code>Promise</code>是一个类，类中的构造函数需要接收一个执行函数<code>executor</code>默认就会执行，它有两个参数：<code>resolve</code>和<code>reject</code>，这两个参数是<code>Promise</code>内部定义的两个函数，用来改变状态并执行对应回调函数。</p><p>默认创建一个<code>Promise</code>状态就是<code>pending</code>，<code>promise</code>只有三种状态：<code>pending</code>,<code>fulfilled</code>,<code>rejected</code>，调用成功<code>resolve</code>和失败<code>reject</code>方法时，需要传递一个成功的原因/值<code>value</code>和失败的原因<code>reason</code>。每一个<code>promise</code>实例都有一个 then 方法。</p><p><code>Promise</code>状态一经改变就不能再改变，故我们限制只能在状态为<code>pending</code>才改变，这样就保证状态只能改变一次。</p><p>如果抛出异常按照失败来处理。</p><p>按照以上<code>Promise</code>的基本要求，就有个基本结构：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const STATUS &#x3D; &#123;</span><br><span class="line">  PENDING: &#39;PENDING&#39;,</span><br><span class="line">  FULFILLED: &#39;FULFILLED&#39;,</span><br><span class="line">  REJECTED: &#39;REJECTED&#39;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Promise &#123;</span><br><span class="line">  constructor(executor) &#123;</span><br><span class="line">    this.status &#x3D; STATUS.PENDING</span><br><span class="line">    this.value &#x3D; undefined &#x2F;&#x2F; 成功的值</span><br><span class="line">    this.reason &#x3D; undefined &#x2F;&#x2F; 失败原因</span><br><span class="line">    this.onResolvedCallbacks &#x3D; [] &#x2F;&#x2F; 存放成功的回调</span><br><span class="line">    this.onRejectedCallbacks &#x3D; [] &#x2F;&#x2F; 存放失败的回调</span><br><span class="line"></span><br><span class="line">    const resolve &#x3D; val &#x3D;&gt; &#123;</span><br><span class="line">      if (this.status &#x3D;&#x3D;&#x3D; STATUS.PENDING) &#123;</span><br><span class="line">        this.status &#x3D; STATUS.FULFILLED</span><br><span class="line">        this.value &#x3D; val</span><br><span class="line">        this.onResolvedCallbacks.forEach(fn &#x3D;&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const reject &#x3D; reason &#x3D;&gt; &#123;</span><br><span class="line">      if (this.status &#x3D;&#x3D;&#x3D; STATUS.PENDING) &#123;</span><br><span class="line">        this.status &#x3D; STATUS.REJECTED</span><br><span class="line">        this.reason &#x3D; reason</span><br><span class="line">        this.onRejectedCallbacks.forEach(fn &#x3D;&gt; fn())</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      executor(resolve, reject)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      console.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; STATUS.FULFILLED) &#123;</span><br><span class="line">      onFulfilled(this.value)</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; STATUS.REJECTED) &#123;</span><br><span class="line">      onRejected(this.reason)</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.status &#x3D;&#x3D;&#x3D; STATUS.PENDING) &#123;</span><br><span class="line">      this.onResolvedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">        onFulfilled(this.value)</span><br><span class="line">      &#125;)</span><br><span class="line">      this.onRejectedCallbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">        onRejected(this.reason)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，为什么不直接执行回调还要存储呢？因为如果当<code>resolve(3)</code>被延迟执行时，此时常理写代码来说 then 是会被执行的，但此时没有<code>resolve</code>，故<code>p</code>的状态应为<code>pending</code>，不应立即执行成功调用的函数，需要把它存起来，直到执行<code>resolve</code>再执行成功调用的函数。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'then1'</span>, res)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>链式调用想必大家多少有点了解，在 jQuery 里面的链式调用则是返回 this，而 Promise 里面的链接调用则是返回一个新的 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'then1'</span>, res) <span class="comment">// then1 3</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 链式调用</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'then2'</span>, res) <span class="comment">// then2 2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>修改<code>then</code>方法和增加<code>catch</code>方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  <span class="keyword">let</span> nextPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.FULFILLED) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> res = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.REJECTED) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> res = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">          resolve(res)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.PENDING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">            resolve(res)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">            resolve(res)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> nextPromise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span>(err) &#123;</span><br><span class="line">  <span class="comment">// 默认没有成功，只有失败</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此次修改我们是在最外层包了新的<code>Promise</code>，然后加了个 setTimeout 模拟微任务（因为这里用的 setTimeout 模拟微任务，所以 JS 事件循环执行顺序上和原生 Promise 有区别），把回调放入，等待确保异步执行。</p><h2 id="链式调用进阶版"><a href="#链式调用进阶版" class="headerlink" title="链式调用进阶版"></a>链式调用进阶版</h2><p>上面的<code>Promise</code>依旧没有过关，因为如果链式调用中<code>Promise</code>返回的是普通值，就应该把值包装成新的<code>Promise</code>对象</p><ul><li>每个 then 方法都返回一个新的 Promise 对象（重点）</li><li>如果 then 方法返回了一个 Promise 对象，则需要查看它的状态，如果状态是成功，则调用<code>resolve</code>方法，把成功的状态传递给它；如果是失败的，则把失败的状态传递给下一个<code>Promise</code>对象。</li><li>如果 then 方法中返回的是一个原始数据类型值（如 Number、String 等）就使用此值包装成一个新的 Promise 对象返回。</li><li>如果 then 方法中没有 return 语句，则返回一个用 undefined 包装的 Promise 对象</li><li>如果 then 方法没有传入任何回调，则继续向下传递（值的传递特性）。</li><li>如果是循环引用则需要抛出错误</li></ul><p>修改<code>then</code>方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">x</span> =&gt;</span> x</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> err</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">let</span> nextPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.FULFILLED) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> res = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">          resolvePromise(res, nextPromise, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.REJECTED) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> res = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">          resolvePromise(res, nextPromise, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.PENDING) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onFulfilled(<span class="keyword">this</span>.value)</span><br><span class="line">            resolvePromise(res, nextPromise, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onRejected(<span class="keyword">this</span>.reason)</span><br><span class="line">            resolve(res)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> nextPromise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面增加了一个<code>resolvePromise</code>函数，处理调用<code>then</code>方法后不同返回值的情况 ，实现如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">x, nextPromise, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === nextPromise) &#123;</span><br><span class="line">    <span class="comment">// x 和 nextPromise 指向同一对象，循环引用抛出错误</span></span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">    <span class="comment">// x 是对象或者函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span> <span class="comment">// 避免多次调用</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = x.then <span class="comment">// 判断对象是否有 then 方法</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// then 是函数，就断定 x 是一个 Promise（根据Promise A+规范）</span></span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 调用返回的promise，用它的结果作为下一次then的结果</span></span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            resolvePromise(y, nextPromise, resolve, reject) <span class="comment">// 递归解析成功后的值，直到它是一个普通值为止</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            reject(r) <span class="comment">// 取then时发生错误了</span></span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x) <span class="comment">// 此时 x 就是一个普通对象</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// x 是原始数据类型 / 没有返回值，这里即是undefined</span></span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-resolve-实现"><a href="#Promise-resolve-实现" class="headerlink" title="Promise.resolve() 实现"></a>Promise.resolve() 实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">static</span> resolve(val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(val)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-reject-实现"><a href="#Promise-reject-实现" class="headerlink" title="Promise.reject() 实现"></a>Promise.reject() 实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">static</span> reject(reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-prototype-finally-实现"><a href="#Promise-prototype-finally-实现" class="headerlink" title="Promise.prototype.finally 实现"></a>Promise.prototype.finally 实现</h2><p>该方法主要有两大重点</p><ul><li>无论当前这个 Promise 对象最终的状态是成功还是失败 ,finally 方法里的回调函数都会执行一次</li><li>在 finally 方法后面可以继续链式调用 then 方法，拿到当前这个 Promise 对象最终返回的结果</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    data =&gt; &#123;</span><br><span class="line">      <span class="comment">// 让函数执行，内部会调用方法，如果方法是promise需要等待它完成</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> data)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-all-实现"><a href="#Promise-all-实现" class="headerlink" title="Promise.all() 实现"></a>Promise.all() 实现</h2><p>Promise.all 可以将多个 Promise 实例包装成一个新的 Promise 实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被 reject 失败状态的值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPromise</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val &amp;&amp; <span class="keyword">typeof</span> val.then === <span class="string">'function'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(promises)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not a array'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> times = <span class="number">0</span> <span class="comment">// 计数器</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">processData</span>(<span class="params">index, val</span>) </span>&#123;</span><br><span class="line">      result[index] = val</span><br><span class="line">      <span class="keyword">if</span> (++times === promises.length) &#123;</span><br><span class="line">        resolve(result)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> p = promises[i]</span><br><span class="line">      <span class="keyword">if</span> (isPromise(p)) &#123;</span><br><span class="line">        <span class="comment">// Promise对象</span></span><br><span class="line">        p.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">          processData(i, data)</span><br><span class="line">        &#125;, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processData(i, p) <span class="comment">// 普通值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise-race-实现"><a href="#Promise-race-实现" class="headerlink" title="Promise.race() 实现"></a>Promise.race() 实现</h2><p>在执行多个异步操作中，只保留取第一个执行完成的异步操作的结果，即是哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。其他的方法仍在执行，不过执行结果会被抛弃。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(promises)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Not a array'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> promises) &#123;</span><br><span class="line">        p.then(</span><br><span class="line">          value =&gt; &#123;</span><br><span class="line">            resolve(value)</span><br><span class="line">          &#125;,</span><br><span class="line">          reason =&gt; &#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，Promise 就实现完成了。</p><p><a href="https://github.com/Jacky-Summer/handwriting-source-code/blob/master/src/Promise/mini-promise.js" target="_blank" rel="noopener">完整源码地址</a></p><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，鼓励我继续写作吧~</li></ul>]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
        <tag>手写</tag>
      </tags>
  </entry>
  <entry>
    <title>搞懂浏览器渲染原理（重排与重绘）</title>
    <url>/2020/09/17/%E6%90%9E%E6%87%82%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%EF%BC%88%E9%87%8D%E6%8E%92%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%89/</url>
    <content><![CDATA[<p>前端巩固基础，终于写到了浏览器篇，虽然浏览器渲染原理大概答得出来，但还是想根据以前的笔记整理一下。</p>
<a id="more"></a>

<h2 id="浏览器渲染过程"><a href="#浏览器渲染过程" class="headerlink" title="浏览器渲染过程"></a>浏览器渲染过程</h2><p>我们以 Webkit 渲染引擎为例，讲一下浏览器是怎么渲染一个网页的：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32c524d3f8804d1eb02f2a550b69bd94~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<ul>
<li>浏览器的渲染过程：</li>
</ul>
<ol>
<li>解析 HTML 构建 DOM 树，并行请求 css/image/js</li>
<li>CSS 文件下载完成后被 CSS 解析器解析成 CSSOM 树</li>
<li>结合 DOM 和 CSSOM 树，生成一棵渲染树(Render Tree)</li>
<li>布局(Layout)，计算出每个节点在屏幕中的位置</li>
<li>将布局显示(Painting)在屏幕上</li>
</ol>
<p>在用户访问页面过程中，还会不断重新渲染页面，重新渲染通常是指第 4 步+第 5 步，或者只有第 5 步。</p>
<p>在关于前端性能优化里面，就有一点：<strong>减少重排与重绘</strong>，因为重排和重绘次数多的话，可能会影响到网页显示速度，给用户带来不流畅甚至卡顿的效果。</p>
<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>重绘即是指当一个元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程。</p>
<h3 id="触发重绘的属性"><a href="#触发重绘的属性" class="headerlink" title="触发重绘的属性"></a>触发重绘的属性</h3><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f9e68749268c42c19559c32cdc52e344~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="重排-回流"><a href="#重排-回流" class="headerlink" title="重排(回流)"></a>重排(回流)</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>当 DOM 的变化影响了元素的几何信息(DOM 对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</p>
<p>当网页重新布局的时候，也会将元素重新绘制，比如改变元素的宽度，这个元素乃至周边的 DOM 都需要重新绘制。<br>所以，<strong>重排一定会触发重绘，而重绘不一定会重排</strong>。</p>
<h3 id="触发重排的属性"><a href="#触发重排的属性" class="headerlink" title="触发重排的属性"></a>触发重排的属性</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d780c2f281334431938eb1feb04581be~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>大致可分为：</p>
<ul>
<li>盒模型相关的属性：width, height, margin, display, border 等</li>
<li>定位属性及浮动相关的属性：position, top, float 等</li>
<li>改变节点内部文字结构：text-align, overflow, font-size, line-height, vertical-align 等</li>
<li>进行获取布局信息的操作：offsetWidth, clientHeight, width, scrollTop, getComputedStyle 等</li>
</ul>
<p>触发重排时会对周围 DOM 重新排列，影响的范围有两种：</p>
<ul>
<li>全局范围：从根节点 html 开始对整个渲染树进行重新布局。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>大标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当 p 节点上发生 reflow 时，h1 和 body 也会重新渲染，甚至影响全局。<br>局部范围重排</p>
<ul>
<li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li>
</ul>
<p>一个 dom 的宽高之类的几何信息定死，然后在 dom 内部触发重排，就只会重新渲染该 dom 内部的元素，而不会影响到外界。</p>
<h2 id="浏览器的渲染队列"><a href="#浏览器的渲染队列" class="headerlink" title="浏览器的渲染队列"></a>浏览器的渲染队列</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.style.left = <span class="string">'5px'</span></span><br><span class="line">div.style.top = <span class="string">'5px'</span></span><br><span class="line">div.style.width = <span class="string">'5px'</span></span><br><span class="line">div.style.height = <span class="string">'5px'</span></span><br></pre></td></tr></table></figure>

<p>按我们上面说的，上面的代码理论上应该触发 4 次重排+重绘，但实际是只触发了一次重排，这得益于浏览器的渲染队列机制：当我们修改了元素的几何属性，导致浏览器触发重排或重绘时。它会把该操作放进渲染队列，等到队列中的操作到了一定的数量或者到了一定的时间间隔时，浏览器就会批量执行这些操作。</p>
<h2 id="强制刷新队列"><a href="#强制刷新队列" class="headerlink" title="强制刷新队列"></a>强制刷新队列</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.style.top = <span class="string">'5px'</span></span><br><span class="line"><span class="built_in">console</span>.log(div.offsetTop)</span><br><span class="line">div.style.left = <span class="string">'5px'</span></span><br><span class="line"><span class="built_in">console</span>.log(div.offsetLeft)</span><br><span class="line">div.style.width = <span class="string">'5px'</span></span><br><span class="line"><span class="built_in">console</span>.log(div.offsetWidth)</span><br><span class="line">div.style.height = <span class="string">'5px'</span></span><br><span class="line"><span class="built_in">console</span>.log(div.offsetHeight)</span><br></pre></td></tr></table></figure>

<p>上面代码会触发 4 次重排+重绘，因为在 console 中请求的这几个样式信息，无论何时浏览器都会立即执行渲染队列的任务，即使该值与你操作中修改的值没关联。</p>
<p>因为队列中，可能会有影响到这些值的操作，为了给我们最精确的值，浏览器会立即重排+重绘。在开发中应该尽量避免一行代码一个重排，即是做好分离读写操作，减少性能损耗。</p>
<ul>
<li>强制刷新队列的 style 样式请求：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">offsetTop, offsetLeft, offsetWidth, offsetHeight</span><br><span class="line">scrollTop, scrollLeft, scrollWidth, scrollHeight</span><br><span class="line">clientTop, clientLeft, clientWidth, clientHeight</span><br><span class="line">width, height</span><br><span class="line">getComputedStyle(), 或者 IE的 currentStyle</span><br></pre></td></tr></table></figure>

<h2 id="如何减少重绘与重排"><a href="#如何减少重绘与重排" class="headerlink" title="如何减少重绘与重排"></a>如何减少重绘与重排</h2><h3 id="1-分离读写操作"><a href="#1-分离读写操作" class="headerlink" title="1. 分离读写操作"></a>1. 分离读写操作</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.style.top = <span class="string">'5px'</span></span><br><span class="line">div.style.left = <span class="string">'5px'</span></span><br><span class="line">div.style.width = <span class="string">'5px'</span></span><br><span class="line">div.style.height = <span class="string">'5px'</span></span><br><span class="line"><span class="built_in">console</span>.log(div.offsetTop)</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetLeft)</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetWidth)</span><br><span class="line"><span class="built_in">console</span>.log(div.offsetHeight)</span><br></pre></td></tr></table></figure>

<p>像上面的代码，我们对它进行分离操作，从 4 次重排变成 1 次重排。</p>
<blockquote>
<p>在第一个 console 的时候，浏览器把之前上面四个写操作的渲染队列都给清空了。剩下的 console，因为渲染队列本来就是空的，所以并没有触发重排，仅仅拿值而已。</p>
</blockquote>
<h3 id="2-将样式修改合并成一次操作"><a href="#2-将样式修改合并成一次操作" class="headerlink" title="2. 将样式修改合并成一次操作"></a>2. 将样式修改合并成一次操作</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">div.style.left = <span class="string">'5px'</span></span><br><span class="line">div.style.top = <span class="string">'5px'</span></span><br><span class="line">div.style.width = <span class="string">'5px'</span></span><br><span class="line">div.style.height = <span class="string">'5px'</span></span><br></pre></td></tr></table></figure>

<p>虽然大部分浏览器都做了渲染队列优化，但不排除老版本浏览器效率仍然地下，故我们最好还是做更好的处理，比如可以把样式集中合并一次修改，通过 class 或者 cssText 属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> left = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> top = <span class="number">5</span></span><br><span class="line">el.style.left = left + <span class="string">'px'</span></span><br><span class="line">el.style.top = top + <span class="string">'px'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.className += <span class="string">' the classname'</span></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.style.cssText += <span class="string">'; left: '</span> + left + <span class="string">'px; top: '</span> + top + <span class="string">'px;'</span></span><br></pre></td></tr></table></figure>

<h3 id="3-缓存布局信息"><a href="#3-缓存布局信息" class="headerlink" title="3. 缓存布局信息"></a>3. 缓存布局信息</h3><p>避免强制刷新队列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">box.style.width = box.clientWidth + <span class="number">10</span> + <span class="string">'px'</span></span><br><span class="line">box.style.height = box.clientHeight + <span class="number">10</span> + <span class="string">'px'</span></span><br></pre></td></tr></table></figure>

<p>按浏览器渲染队列机制，按道理回流一次。但遇到 box.clientWidth，重新渲染，所以全部是两次回流</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = box.clientWidth</span><br><span class="line"><span class="keyword">let</span> b = box.clientHeight</span><br><span class="line">box.style.width = box.clientWidth + <span class="number">10</span> + <span class="string">'px'</span></span><br><span class="line">box.style.height = box.clientHeight + <span class="number">10</span> + <span class="string">'px'</span></span><br></pre></td></tr></table></figure>

<h3 id="4-离线改变-DOM"><a href="#4-离线改变-DOM" class="headerlink" title="4. 离线改变 DOM"></a>4. 离线改变 DOM</h3><ol>
<li>隐藏要操作的 DOM</li>
</ol>
<p>在要操作 dom 之前，通过 display 隐藏 dom，然后尽量的进行多次修改操作，当操作完成之后，才将元素的 display 属性为可见，因为不可见的元素不会触发重排和重绘。</p>
<ol start="2">
<li><p>通过使用 DocumentFragment 创建一个文档碎片,在它上面批量操作 dom，操作完成之后，再添加到文档中，这样只会触发一次重排。</p>
</li>
<li><p>复制节点，在副本上工作，然后再替换原来的元素</p>
</li>
</ol>
<h3 id="5-使用-resize-事件时，做防抖和节流处理"><a href="#5-使用-resize-事件时，做防抖和节流处理" class="headerlink" title="5. 使用 resize 事件时，做防抖和节流处理"></a>5. 使用 resize 事件时，做防抖和节流处理</h3><h3 id="6-对动画元素使用-absolute-fixed-属性。"><a href="#6-对动画元素使用-absolute-fixed-属性。" class="headerlink" title="6. 对动画元素使用 absolute / fixed 属性。"></a>6. 对动画元素使用 absolute / fixed 属性。</h3><p>position 属性为 absolute 或 fixed 的元素，重排开销比较小，不用考虑它对其他元素的影响</p>
<h3 id="7-CSS3-属性优化动画"><a href="#7-CSS3-属性优化动画" class="headerlink" title="7. CSS3 属性优化动画"></a>7. CSS3 属性优化动画</h3><p>比如使用 CSS 的 transform 来实现动画效果，避免了回流跟重绘，直接在非主线程中执行合成动画操作。这样子的效率更高，毕竟这个是在非主线程上合成的，没有占用主线程资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。那为什么能避免呢，主要是因为它创建了一个新图层。</p>
<ul>
<li>图层创建的条件：<br>Chrome 浏览器满足以下任意情况就会创建图层：</li>
</ul>
<ol>
<li>拥有具有 3D 变换的 CSS 属性</li>
<li>使用加速视频解码的<code>&lt;video&gt;</code>节点</li>
<li><code>&lt;canvas&gt;</code>节点</li>
<li>CSS3 动画的节点</li>
<li>拥有 CSS 加速属性的元素(<code>will-change</code>)</li>
</ol>
<p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能，但也不能生成过多的图层。</p>
<ul>
<li>利用合成的好处：</li>
</ul>
<ol>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快。<strong>GPU 硬件加速</strong>（规避了回流）是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，因为 GPU 是专门为处理图形而设计，所以它在速度和能耗上更有效率。</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ol>
<p>当然也要注意，如果为太多元素使用 css3 硬件加速，会导致内存占用较大，同样也会有性能问题。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* transform为3D，则可开启GPU加速，提高动画性能 */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate3d</span>(<span class="number">10px</span>, <span class="number">10px</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://blog.fundebug.com/2019/01/03/understand-browser-rendering/" target="_blank" rel="noopener">深入浅出浏览器渲染原理</a></li>
</ul>
<br>

<blockquote>
<p>欢迎关注我掘金账号和 Github 技术博客：</p>
<ul>
<li>掘金：<a href="https://juejin.im/user/1257497033714477" target="_blank" rel="noopener">https://juejin.im/user/1257497033714477</a></li>
<li>Github：<a href="https://github.com/Jacky-Summer" target="_blank" rel="noopener">https://github.com/Jacky-Summer</a></li>
<li>觉得对你有帮助或有启发的话欢迎 star，你的鼓励是我持续创作的动力~</li>
<li>如需在微信公众号平台转载请联系作者授权同意，其它途径转载请在文章开头注明作者和文章出处。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之Promise题合集</title>
    <url>/2020/09/10/ES6%E7%B3%BB%E5%88%97%E4%B9%8BPromise%E9%A2%98%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<p>关于 Promise 的讲解文章实在太多了，在此我就不写讲解了，直接实战检测自己对 Promise 的理解，下面是我做过的众多 Promise 题里面挑出来的 13 道题，我觉得容易错或者值得考究知识点的题，如果你想考察自己对 Promise 的掌握程度，可以做做看。</p>
<a id="more"></a>

<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目 1"></a>题目 1</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  resolve(<span class="string">'resolve1'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, promise1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'2'</span>, promise2)</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>先遇到<code>new Promise</code>，执行该构造函数中的代码输出 <code>promise1</code></li>
<li>遇到<code>resolve</code>函数, 将<code>promise1</code>的状态改变为<code>fulfilled</code>, 并将结果保存下来</li>
<li>碰到<code>promise1.then</code>这个微任务，返回的是<code>Promise</code>的<code>pending</code>状态，将它放入微任务队列</li>
<li>故<code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code></li>
<li>继续执行同步代码输出<code>promise1</code>的状态是<code>fulfilled</code>，输出<code>promise2</code>的状态是<code>pending</code></li>
<li>宏任务执行完毕，查找微任务队列，发现<code>promise1.then</code>这个微任务且状态为<code>fulfilled</code>，执行它。</li>
</ul>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise1</span><br><span class="line">1 Promise&#123;&lt;fulfilled&gt;: &#39;resolve1&#39;&#125;</span><br><span class="line">2 Promise&#123;&lt;pending&gt;&#125;</span><br><span class="line">resolve1</span><br></pre></td></tr></table></figure>

<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目 2"></a>题目 2</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timerStart'</span>)</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timerEnd'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>执行<code>new Promsise</code>，输出<code>1</code>，<code>setTimeout</code>宏任务加到宏任务队列，继续执行同步代码输出<code>2</code></li>
<li>遇到<code>promise.then</code>，但其状态还是 pending，这里理解为先不执行；然后输出同步代码<code>4</code></li>
<li>一轮循环过后，进入第二次宏任务，发现延迟队列中有<code>setTimeout</code>定时器，执行它</li>
<li>输出<code>timerStart</code>，遇到<code>resolve</code>，将<code>promise</code>的状态改为<code>fulfilled</code>且保存结果并将之前的<code>promise.then</code>推入微任务队列</li>
<li>继续执行同步代码<code>timerEnd</code></li>
<li>宏任务全部执行完毕，查找微任务队列，发现<code>promise.then</code>这个微任务，执行它。</li>
</ul>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">timerStart</span><br><span class="line">timerEnd</span><br><span class="line">success</span><br></pre></td></tr></table></figure>

<h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目 3"></a>题目 3</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">'success'</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> promise2 = promise1.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>, promise1)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>, promise2)</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>从上至下，先执行第一个<code>new Promise</code>中的函数，碰到<code>setTimeout</code>将它加入下一个宏任务列表</li>
<li>跳出<code>new Promise</code>，碰到<code>promise1.then</code>这个微任务，但其状态还是为<code>pending</code>，这里理解为先不执行；故<code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code></li>
<li>执行同步代码<code>console.log(&#39;promise1&#39;)</code>，输出<code>promise1</code>的状态为<code>pending</code></li>
<li>执行同步代<code>console.log(&#39;promise2&#39;)</code>，输出<code>promise2</code>的状态为<code>pending</code></li>
<li>碰到第二个<code>setTimeout</code>，将其放入下一个宏任务列表</li>
<li>第一轮宏任务执行结束，并且没有微任务需要执行，因此执行第二轮宏任务</li>
<li>先执行第一个定时器里的内容，将<code>promise1</code>的状态改为<code>fulfilled</code>且保存结果并将之前的<code>promise1.then</code>推入微任务队列</li>
<li>该定时器中没有其它的同步代码可执行，因此执行本轮的微任务队列，也就是<code>promise1.then</code>，它抛出了一个错误，且将<code>promise2</code>的状态设置为了<code>rejected</code></li>
<li>第一个定时器执行完毕，开始执行第二个定时器中的内容</li>
<li>打印出<code>promise1</code>，且此时<code>promise1</code>的状态为<code>fulfilled</code></li>
<li>打印出<code>promise2</code>，且此时<code>promise2</code>的状态为<code>rejected</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise1 <span class="built_in">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line">promise2 <span class="built_in">Promise</span> &#123;&lt;pending&gt;&#125;</span><br><span class="line">Uncaught (<span class="keyword">in</span> promise) <span class="built_in">Error</span>: error!!! at &lt;anonymous&gt;:<span class="number">7</span>:<span class="number">9</span></span><br><span class="line">promise1 <span class="built_in">Promise</span> &#123;&lt;fulfilled&gt;: <span class="string">"success"</span>&#125;</span><br><span class="line">promise2 <span class="built_in">Promise</span> &#123;&lt;rejected&gt;: <span class="built_in">Error</span>: error!!! at &lt;anonymous&gt;:<span class="number">7</span>:<span class="number">9</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目 4"></a>题目 4</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="string">'error'</span>)</span><br><span class="line">  resolve(<span class="string">'success2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then1: '</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then2: '</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch: '</span>, err)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then3: '</span>, res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><code>catch</code>不管被连接到哪里，都能捕获上层未捕捉过的错误。</li>
<li>由于 <code>catch()</code>也会返回一个<code>Promise</code>，且由于这个<code>Promise</code>没有返回值，所以打印出来的是<code>undefined</code>。</li>
</ul>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">catch:  error</span><br><span class="line">then3:  undefined</span><br></pre></td></tr></table></figure>

<h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目 5"></a>题目 5</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then: '</span>, res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch: '</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>在<code>Promise</code>中，返回任意一个非<code>promise</code>的值都会被包裹成<code>promise</code>对象，例如<code>return new Error(&#39;error!!!&#39;)</code>会被包装为<code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code></li>
<li><code>.then</code>或者 <code>.catch</code> 中 <code>return</code> 一个 <code>error</code> 对象并不会抛出错误，所以不会被后续的 <code>.catch</code> 捕获。</li>
</ul>
<p>当然如果你抛出一个错误的话，可以用下面任意一种：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>))</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error!!!'</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">then:  Error: error!!!</span><br></pre></td></tr></table></figure>

<h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目 6"></a>题目 6</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;)</span><br><span class="line">promise.catch(<span class="built_in">console</span>.err)</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><code>.then</code> 或 <code>.catch</code> 返回的值不能是 <code>promise</code> 本身，否则会造成死循环。</li>
</ul>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise &#123;&lt;rejected&gt;: TypeError: Chaining cycle detected for promise #&lt;Promise&gt;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目 7"></a>题目 7</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="number">2</span>).then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>)).then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><code>.then</code> 或者 <code>.catch</code> 的参数期望是函数，传入非函数则会发生值透传。</li>
<li>第一个<code>then</code>和第二个<code>then</code>中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将<code>resolve(1)</code> 的值直接传到最后一个<code>then</code>里。</li>
</ul>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目 8"></a>题目 8</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="string">'err!!!'</span>)</span><br><span class="line">  .then(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'success'</span>, res)</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'error'</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch'</span>, err)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><code>.then</code>函数的第一个参数是用来处理<code>Promise</code>成功的函数，第二个则是处理失败的函数。</li>
<li><code>Promise.resolve(&#39;err!!!&#39;)</code>的值会进入成功的函数，<code>Promise.reject(&#39;err!!!&#39;)</code>的值会进入失败的函数。</li>
<li>如果去掉第二个参数，就会进入<code>catch()</code>中</li>
</ul>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;error&#39; &#39;error!!!&#39;</span><br></pre></td></tr></table></figure>

<h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目 9"></a>题目 9</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'1'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finally'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'2'</span>)</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finally2'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'我是finally2返回的值'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'finally2后面的then函数'</span>, res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><code>.finally()</code>方法不管<code>Promise</code>对象最后的状态如何都会执行</li>
<li>它最终返回的默认会是一个上一次的<code>Promise</code>对象值，不过如果抛出的是一个异常则返回异常的<code>Promise</code>对象。</li>
<li>第一行代码遇到<code>Promise.resolve(&#39;1&#39;)</code>,再把<code>.then()</code>加入微任务，这时候要注意，代码并不会接着往链式调用的下面走，也就是不会先将<code>.finally</code>加入微任务列表，那是因为<code>.then</code>本身就是一个微任务，它链式后面的内容必须得等当前这个微任务执行完才会执行，因此这里我们先不管<code>.finally()</code></li>
<li>执行<code>Promise.resolve(&#39;2&#39;)</code>，把<code>.finally</code>加入微任务队列，且链式调用后面的内容得等该任务执行完后才执行</li>
<li>本轮宏任务执行完，执行微任务列表第一个微任务输出<code>1</code>，遇到<code>.finally()</code>，将它加入微任务列表（第三个）待执行；再执行第二个微任务输出<code>finally2</code>，遇到<code>.then</code>，把它加入到微任务（第四个）列表待执行</li>
<li>本轮执行完两个微任务后，检索微任务列表发现还有两个微任务，故执行，输出<code>finally</code>和<code>finally2后面的then函数 2</code></li>
</ul>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">finally2</span><br><span class="line">finally</span><br><span class="line">finally2后面的then函数 2</span><br></pre></td></tr></table></figure>

<h3 id="题目-10"><a href="#题目-10" class="headerlink" title="题目 10"></a>题目 10</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 success'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 end'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt start'</span>)</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'srcipt end'</span>)</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>在<code>async1</code>中<code>await</code>后面的<code>Promise</code>是没有返回值的，也就是它的初始状态是<code>pending</code>状态，因此相当于一直在<code>await</code></li>
<li>所以在<code>await</code>之后的内容是不会执行的，也包括<code>async1</code>后面的<code>.then</code>。</li>
</ul>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">srcipt start</span><br><span class="line">async1 start</span><br><span class="line">promise1</span><br><span class="line">srcipt end</span><br></pre></td></tr></table></figure>

<h3 id="题目-11"><a href="#题目-11" class="headerlink" title="题目 11"></a>题目 11</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'async1 success'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">    reject(<span class="string">'error'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async1().then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li><code>await</code>后面跟着的是一个状态为<code>rejected</code>的<code>promise</code>。</li>
<li>如果在<code>async</code>函数中抛出了错误，则终止错误结果，不会继续向下执行。</li>
</ul>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async2</span><br><span class="line">Uncaught (in promise) error</span><br></pre></td></tr></table></figure>

<h3 id="题目-12"><a href="#题目-12" class="headerlink" title="题目 12"></a>题目 12</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  foo.bar()</span><br><span class="line">  resolve(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then value: '</span> + value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then err: '</span> + err)</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then value: '</span> + value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p1 then then err: '</span> + err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then value: '</span> + value)</span><br><span class="line">    foo.bar()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'p2 then err: '</span> + err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">  .then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'p2 then then value: '</span> + value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'p2 then then err: '</span> + err)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'p2 then then then value: '</span> + value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'p2 then then then err: '</span> + err)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>Promise 中的异常由 then 参数中第二个回调函数（Promise 执行失败的回调）处理，异常信息将作为 Promise 的值。异常一旦得到处理，then 返回的后续 Promise 对象将恢复正常，并会被 Promise 执行成功的回调函数处理。另外，需要注意 p1、p2 多级 then 的回调函数是交替执行的 ，这正是由 Promise then 回调的异步性决定的。</p>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p1 then err: ReferenceError: foo is not defined</span><br><span class="line">p2 then value: 2</span><br><span class="line">p1 then then value: undefined</span><br><span class="line">p2 then then err: ReferenceError: foo is not defined</span><br><span class="line">p2 then then then value: 1</span><br></pre></td></tr></table></figure>

<h3 id="题目-13"><a href="#题目-13" class="headerlink" title="题目 13"></a>题目 13</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="built_in">Promise</span>.reject(<span class="string">'reject'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="built_in">Promise</span>.resolve(<span class="string">'resolve'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">p2.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">p3.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fulfilled</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fulfilled: '</span> + value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'rejected: '</span> + err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>Promise 回调函数中的第一个参数 resolve，会对 Promise 执行”拆箱”动作。即当 resolve 的参数是一个 Promise 对象时，resolve 会”拆箱”获取这个 Promise 对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到 Promise 对象的状态是 resolved，因此 fulfilled 回调被执行；p2”拆箱”后，获取到 Promise 对象的状态是 rejected，因此 rejected 回调被执行。但 Promise 回调函数中的第二个参数 reject 不具备”拆箱“的能力，reject 的参数会直接传递给 then 方法中的 rejected 回调。因此，即使 p3 reject 接收了一个 resolved 状态的 Promise，then 方法中被调用的依然是 rejected，并且参数就是 reject 接收到的 Promise 对象。</p>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p3 rejected: [object Promise]</span><br><span class="line">p1 fulfilled: resolve</span><br><span class="line">p2 rejected: reject</span><br></pre></td></tr></table></figure>

<h2 id="特别鸣谢"><a href="#特别鸣谢" class="headerlink" title="特别鸣谢"></a>特别鸣谢</h2><p>这些题是我从下面两个链接的题目又选出来的，仅作为自己的错题集/笔记题来记录，方便以后我自己检验回顾。如果你想更全面学，建议直接去做下面两篇的题。</p>
<ul>
<li><p><a href="https://juejin.im/post/6844904077537574919" target="_blank" rel="noopener">【建议星星】要就来 45 道 Promise 面试题一次爽到底(1.1w 字用心整理)</a></p>
</li>
<li><p><a href="https://juejin.im/post/6844903488695042062" target="_blank" rel="noopener">八段代码彻底掌握 Promise</a></p>
</li>
<li><p>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</p>
</li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title>由零开始使用 Webpack 来搭建 React 项目</title>
    <url>/2020/09/05/%E7%94%B1%E9%9B%B6%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8-Webpack-%E6%9D%A5%E6%90%AD%E5%BB%BA-React-%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>今天动动手回顾下 Webpack 基本配置，搭了个 react 项目脚手架，做下笔记。</p><p>本文适合有了解过 webpack 基础配置的人阅读，因为有些基础配置和流程我就不做详细解释了。</p><a id="more"></a><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>新建文件夹<code>react-cli</code>，初始化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><ul><li>安装 webpack</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add webpack webpack-cli -D</span><br></pre></td></tr></table></figure><p>我们知道 webpack 主要是帮我们打包构建，我们新建个文件<code>src/index.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello webpack'</span>)</span><br></pre></td></tr></table></figure><ul><li>新建 webpack.config.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'app.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再到<code>package.json</code>设置打包命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;npx webpack --config webpack.config.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>因为我没有全局安装 webpack，这里使用 npx（npm5.2 开始自带 npx 命令）<br>关于 npx 的使用可以看阮一峰大神这篇博客：<a href="https://www.ruanyifeng.com/blog/2019/02/npx.html" target="_blank" rel="noopener">npx 使用教程</a></p><ul><li>执行打包命令</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>就会看到生成了<code>dist</code>文件夹和打包生成的文件<code>app.js</code></p><h2 id="引入-Html-模板"><a href="#引入-Html-模板" class="headerlink" title="引入 Html 模板"></a>引入 Html 模板</h2><blockquote><p><code>html-webpack-plugin</code>简化了 HTML 文件的创建，该插件将为你生成一个 HTML5 文件， 其中包括使用 script 标签的 body 中的所有 webpack 包。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add html-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>新建模板 HTML 文件<code>public/index.html</code></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在<code>webpack.config.js</code>配置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再执行<code>npm run build</code>，会看到生成了一个<code>index.html</code>文件，打开它会发现<code>app.js</code>也被引入到文件且能正常运行</p><h2 id="编译-JS-文件"><a href="#编译-JS-文件" class="headerlink" title="编译 JS 文件"></a>编译 JS 文件</h2><p>ES6 或以上版本的语法有些浏览器还是不识别语法的，所以我们需要用 babel 对它进行编译，编译成 ES5 代码<br>在<code>src/index.js</code>写一个 ES6 的箭头函数</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const func &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  return 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装 babel 插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add babel-loader @babel&#x2F;core @babel&#x2F;preset-env -D</span><br></pre></td></tr></table></figure><ul><li><strong>babel-loader</strong>：使用 Babel 和 webpack 来转译 JavaScript 文件。</li><li><strong>@babel/preset-env</strong>：将语法翻译成 es5 语法</li><li><strong>@babel/core</strong>：babel 的核心模块</li></ul><p>在根目录下新建<code>.babelrc</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;@babel&#x2F;preset-env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>webpack.config.js</code>中配置解析 js 的规则</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>npm run build</code>，查看<code>app.js</code>已经把箭头函数编译成 ES5 语法了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***/</span> ;(<span class="function"><span class="keyword">function</span> (<span class="params">module, exports</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">eval</span>(</span><br><span class="line">    <span class="string">"console.log('hello webpack');\n\nvar func = function func() &#123;\n  return 100;\n&#125;;\n\n//# sourceURL=webpack:///./src/index.js?"</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">/***/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="处理浏览器没有的新特性"><a href="#处理浏览器没有的新特性" class="headerlink" title="处理浏览器没有的新特性"></a>处理浏览器没有的新特性</h2><p>有些浏览器没有 Promise、Symbol、Map 等一些新特性，就需要使用 polyfill 来实现；</p><p>首先来理解下 babel 和 babel polyfill 的关系：</p><ol><li>babel 解决<strong>语法</strong>层面的问题，比如将 ES6+语法转为 ES5 语法。</li><li>babel polyfill 解决<strong>API</strong>层面的问题，需要使用垫片，比如下面三种：</li></ol><ul><li><p><strong>@babel/polyfill</strong>：通过向全局对象和内置对象的 prototype 上添加方法来实现的，从而解决了低版本浏览器无法实现的一些 es6+语法；但污染了全局空间和内置对象也是个缺点。</p></li><li><p><strong>@babel/runtime</strong>：不会污染全局空间和内置对象原型，但如果使用的特性非常多，就会导致这种按需引入非常繁琐。由于它是 polyfill 的包，适合在组件，类库中使用，所以需要添加到生产环境中。</p></li><li><p><strong>@babel/plugin-transform-runtime</strong>：将 helper 和 polyfill 都改为从一个统一的地方引入，解决了全局空间和内置对象的问题；需要用到两个依赖包 <code>@babel/runtime</code>和<code>@babel/runtime-corejs3</code>——加载 ES6+ 新的 API（corejs 根据你的版本）</p></li><li><p>babel-runtime 适合在组件，类库项目中使用，而 babel-polyfill 适合在业务项目中使用。</p></li></ul><p>polyfill 用到的 core-js 是可以指定版本的，比如使用 <code>core-js@3</code> <code>core-js@2</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add @babel&#x2F;polyfill core-js@3</span><br><span class="line">yarn add @babel&#x2F;plugin-transform-runtime -D</span><br><span class="line">yarn add @babel&#x2F;runtime @babel&#x2F;runtime-corejs3</span><br></pre></td></tr></table></figure><p>安装完毕后，在 <code>.babelrc</code>进行配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel&#x2F;preset-env&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;, &#x2F;&#x2F; 按需引入，它能自动给每个文件添加其需要的polyfill</span><br><span class="line">        &quot;corejs&quot;: 3 &#x2F;&#x2F; 根据你的版本来写</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel&#x2F;plugin-transform-runtime&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;corejs&quot;: 3,</span><br><span class="line">        &quot;helpers&quot;: true, &#x2F;&#x2F; 开启内联的babel helpers(即babel或者环境本来的存在的垫片或者某些对象方法函数)</span><br><span class="line">        &quot;regenerator&quot;: true, &#x2F;&#x2F; 开启generator函数转换成使用regenerator runtime来避免污染全局域</span><br><span class="line">        &quot;useESModules&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译-React"><a href="#编译-React" class="headerlink" title="编译 React"></a>编译 React</h2><p>安装 react 有关包和编译 React 的 babel 插件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add react react-dom</span><br><span class="line">yarn add @babel&#x2F;preset-react -D</span><br></pre></td></tr></table></figure><p>重写<code>src/index.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.jsx'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure><p>新建文件<code>src/App.jsx</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>App<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure><p>修改<code>.babelrc</code>文件（presets 的顺序从右向左）</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;@babel&#x2F;preset-env&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;useBuiltIns&quot;: &quot;usage&quot;, &#x2F;&#x2F; 按需引入，它能自动给每个文件添加其需要的polyfill</span><br><span class="line">        &quot;corejs&quot;: 3 &#x2F;&#x2F; 根据你的版本来写</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;@babel&#x2F;preset-react&quot;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行打包命令，成功编译</p><h2 id="devServer-配置"><a href="#devServer-配置" class="headerlink" title="devServer 配置"></a>devServer 配置</h2><p>安装 devServer，在开发中实时检测文件的变化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add webpack-dev-server -D</span><br></pre></td></tr></table></figure><p>在``package.json`中设置启动命令</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;webpack-dev-server&quot;,</span><br></pre></td></tr></table></figure><p>webpack.config.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    host: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">    compress: <span class="literal">true</span>, <span class="comment">// 使用gzip压缩</span></span><br><span class="line">    port: <span class="number">8080</span>, <span class="comment">// 监听的端口号</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    overlay: <span class="literal">true</span>, <span class="comment">// 代码出错弹出浮动层</span></span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">// 开启热更新</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启服务器<code>yarn dev</code>，打开<code>http://localhost:8080</code>，就可以 React 组件正常编译运行了。</p><h2 id="开发环境热更新"><a href="#开发环境热更新" class="headerlink" title="开发环境热更新"></a>开发环境热更新</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add -D react-hot-loader</span><br></pre></td></tr></table></figure><p>在<code>webpack.config.js</code>配置，devServer 上面已经开启<code>hot:true</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.HotModuleReplacementPlugin(),</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>在<code>src/index.js</code>中添加</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.hot) &#123;</span><br><span class="line">  <span class="built_in">module</span>.hot.accept()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure><p>重新运行<code>yarn dev</code>，热更新生效</p><h2 id="省略文件后缀和设置别名"><a href="#省略文件后缀和设置别名" class="headerlink" title="省略文件后缀和设置别名"></a>省略文件后缀和设置别名</h2><p>上面引入 App 组件我们是<code>import App from &#39;./App.jsx&#39;</code>加了后缀，如果省略的话会报错；我们可以在 webpack 配置文件的<code>resolve</code>设置可以省略后缀；</p><p>还有一个问题，如果项目较大，组件层级关系多的时候，我们可以给路径设置别名</p><p>新建<code>src/components/Header/index.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Header = <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 进行配置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'app.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.jsx'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'@components'</span>: path.resolve(__dirname, <span class="string">'src/components'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>修改<code>App.jsx</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'@components/Header'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Header /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure><h2 id="加载-Css"><a href="#加载-Css" class="headerlink" title="加载 Css"></a>加载 Css</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add style-loader css-loader -D</span><br></pre></td></tr></table></figure><p>给 Header 组件添加样式，新建文件<code>src/components/Header/index.css</code>，再到 Header 组件中引入<code>import &#39;./index.css&#39;</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>css-loader 的作用是处理 css 文件中 @import，url 之类的语句（将 CSS 转化成 CommonJS 模块）</li><li>style-loader 则是将 css 文件内容放在 style 标签内并插入 head 中</li></ul><p><code>webpack.config.js</code>配置（loader 执行顺序从右到左）</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="支持-Sass"><a href="#支持-Sass" class="headerlink" title="支持 Sass"></a>支持 Sass</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add sass sass-loader -D</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(sass|scss)$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        <span class="string">'css-loader'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            implementation: <span class="built_in">require</span>(<span class="string">'sass'</span>), <span class="comment">// 使用dart-sass代替node-sass</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>把<code>src/components/Header/index.css</code>改为<code>.scss</code>文件，Header 组件<code>index.js</code>的引入也修改一下引入 css 文件名，然后执行打包命令，OK。</p><p>less 就不写了，毕竟一个项目选一种就行了。</p><h2 id="集成-Postcss"><a href="#集成-Postcss" class="headerlink" title="集成 Postcss"></a>集成 Postcss</h2><p>postcss-loader 作用：</p><ul><li>把 css 解析为一个抽象语法树</li><li>调用插件处理抽象语法树并添加功能，如处理 CSS 兼容添加一些新特性的厂商前缀</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add postcss-loader autoprefixer -D</span><br></pre></td></tr></table></figure><p>在根目录下新建<code>postcss.config.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">      <span class="comment">// 自动在样式中添加浏览器厂商前缀</span></span><br><span class="line">      overrideBrowserslist: [<span class="string">'last 2 versions'</span>, <span class="string">'&gt;1%'</span>],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webpack.config.js</code>中配置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(sass|scss)$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        <span class="string">'css-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            implementation: <span class="built_in">require</span>(<span class="string">'sass'</span>), <span class="comment">// 使用dart-sass代替node-sass</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在样式文件添加 CSS3 一些新特性，就能看到被自动添加了兼容处理了。</p><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add file-loader url-loader -D</span><br></pre></td></tr></table></figure><p>加入一张图片<code>src/components/Header/img/fe-house-qrcode.jpg</code>，在<code>src/components/Header/index.js</code>中引入</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#39;.&#x2F;img&#x2F;fe-house-qrcode.jpg&#39;</span><br></pre></td></tr></table></figure><p>在<code>webpack.config.js</code>中进行配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(png|jpe?g|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>, <span class="comment">// 打包图片到dist目录下的images文件夹</span></span><br><span class="line">          limit: <span class="number">102400</span>, <span class="comment">// 图片超过100KB就使用file-loader打包，否则图片以base64格式存在</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析字体图标"><a href="#解析字体图标" class="headerlink" title="解析字体图标"></a>解析字体图标</h2><p>这里就不演示了，直接上配置</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff|woff2)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'fonts/'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区分生产环境和开发环境"><a href="#区分生产环境和开发环境" class="headerlink" title="区分生产环境和开发环境"></a>区分生产环境和开发环境</h2><p>到这里，最基本配置差不多可以用了，接下来需要做一些细节或优化的配置。</p><p>安装<code>webpack-merge</code>整合</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add webpack-merge -D</span><br></pre></td></tr></table></figure><p>提炼出三个文件：</p><ul><li>webpack.common.js 公共配置</li><li>webpack.dev.js 开发环境配置</li><li>webpack.prod.js 生产环境配置</li></ul><p>将<code>webpack.config.js</code>的东西提炼出来分三个文件</p><ul><li>webpack.common.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'app.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.jsx'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'@components'</span>: path.resolve(__dirname, <span class="string">'src/components'</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(sass|scss)$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          <span class="string">'css-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'sass-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              implementation: <span class="built_in">require</span>(<span class="string">'sass'</span>), <span class="comment">// 使用dart-sass代替node-sass</span></span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpe?g|gif)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'url-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">            outputPath: <span class="string">'images/'</span>, <span class="comment">// 打包图片到dist目录下的images文件夹</span></span><br><span class="line">            limit: <span class="number">102400</span>, <span class="comment">// 图片超过100KB就使用file-loader打包，否则图片以base64格式存在</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(eot|ttf|svg|woff|woff2)$/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: <span class="string">'file-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">            outputPath: <span class="string">'fonts/'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    host: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">    compress: <span class="literal">true</span>, <span class="comment">// 使用gzip压缩</span></span><br><span class="line">    port: <span class="number">8080</span>, <span class="comment">// 监听的端口号</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    overlay: <span class="literal">true</span>, <span class="comment">// 代码出错弹出浮动层</span></span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">// 开启热更新</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>webpack.dev.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common'</span>)</span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>, <span class="comment">// 帮助我们定位到错误信息位置的源代码文件</span></span><br><span class="line">  plugins: [<span class="keyword">new</span> webpack.HotModuleReplacementPlugin()],</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    host: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">    compress: <span class="literal">true</span>, <span class="comment">// 使用gzip压缩</span></span><br><span class="line">    port: <span class="number">8080</span>, <span class="comment">// 监听的端口号</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    overlay: <span class="literal">true</span>, <span class="comment">// 代码出错弹出浮动层</span></span><br><span class="line">    hot: <span class="literal">true</span>, <span class="comment">// 开启热更新</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig, devConfig)</span><br></pre></td></tr></table></figure><ul><li>webpack.prod.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; merge &#125; = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>)</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common'</span>)</span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'none'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig, devConfig)</span><br></pre></td></tr></table></figure><p>修改<code>package.json</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;webpack-dev-server --config webpack.dev.js&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;npx webpack --config webpack.prod.js&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>大功告成。</p><h2 id="打包前清理-dist-目录"><a href="#打包前清理-dist-目录" class="headerlink" title="打包前清理 dist 目录"></a>打包前清理 dist 目录</h2><p>在你调试打包的过程可能会多出一些遗留文件，我们想要最新打包编译的文件，就需要先清除 dist 目录</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>加到<code>webpack.common.js</code>文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [<span class="keyword">new</span> CleanWebpackPlugin()],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="项目规范"><a href="#项目规范" class="headerlink" title="项目规范"></a>项目规范</h2><p>作为项目代码风格的统一规范，我们需要借助第三方工具来强制，让团队成员的代码风格更趋于一致。</p><h3 id="EditorConfig"><a href="#EditorConfig" class="headerlink" title="EditorConfig"></a>EditorConfig</h3><p><code>.editorconfig</code> 是跨编辑器维护一致编码风格的配置文件，在 VSCode 中需要安装相应插件<code>EditorConfig for VS Code</code>，安装完毕之后，<br>使用快捷键<code>ctrl+shift+p</code>打开命令台，输入 <code>Generate .editorcofig</code> 即可快速生成 <code>.editorconfig</code> 文件。</p><p>在<code>.editorcofig</code>文件，就可以大家根据不同来设置文件了，比如我的是这样：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root &#x3D; true</span><br><span class="line"></span><br><span class="line">[*]</span><br><span class="line">indent_style &#x3D; space</span><br><span class="line">indent_size &#x3D; 2</span><br><span class="line">charset &#x3D; utf-8</span><br><span class="line">trim_trailing_whitespace &#x3D; true</span><br><span class="line">insert_final_newline &#x3D; true</span><br><span class="line">end_of_line &#x3D; lf</span><br></pre></td></tr></table></figure><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add prettier -D</span><br></pre></td></tr></table></figure><p>同样也需要安装 VSCode 插件<code>Prettier - Code formatter</code></p><p>安装完成后在根目录下新建文件夹<code>.vscode</code>，在该文件夹下新建文件<code>settings.json</code>,该文件的配置优先于你自己 VSCode 全局的配置，不会因为团队不同成员的 VSCode 全局配置不同而导致格式化不同。</p><p>settings.json</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 指定哪些文件不参与搜索</span><br><span class="line">  &quot;search.exclude&quot;: &#123;</span><br><span class="line">    &quot;**&#x2F;node_modules&quot;: true,</span><br><span class="line">    &quot;dist&quot;: true,</span><br><span class="line">    &quot;yarn.lock&quot;: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;editor.formatOnSave&quot;: true,</span><br><span class="line">  &quot;eslint.validate&quot;: [&quot;javascript&quot;, &quot;javascriptreact&quot;],</span><br><span class="line">  &quot;editor.codeActionsOnSave&quot;: &#123;</span><br><span class="line">    &quot;source.fixAll.eslint&quot;: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;[javascript]&quot;: &#123;</span><br><span class="line">    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;[javascriptreact]&quot;: &#123;</span><br><span class="line">    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;[json]&quot;: &#123;</span><br><span class="line">    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;[html]&quot;: &#123;</span><br><span class="line">    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;[markdown]&quot;: &#123;</span><br><span class="line">    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;[css]&quot;: &#123;</span><br><span class="line">    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;[less]&quot;: &#123;</span><br><span class="line">    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;[scss]&quot;: &#123;</span><br><span class="line">    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装完后新建文件<code>.prettierrc</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;trailingComma&quot;: &quot;all&quot;,</span><br><span class="line">  &quot;tabWidth&quot;: 2,</span><br><span class="line">  &quot;semi&quot;: false,</span><br><span class="line">  &quot;singleQuote&quot;: true,</span><br><span class="line">  &quot;endOfLine&quot;: &quot;lf&quot;,</span><br><span class="line">  &quot;printWidth&quot;: 120,</span><br><span class="line">  &quot;bracketSpacing&quot;: true,</span><br><span class="line">  &quot;arrowParens&quot;: &quot;avoid&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add eslint -D</span><br></pre></td></tr></table></figure><p>安装完后运行<code>npx eslint --init</code>，运行后有选项，选择如下（自行根据需要）：</p><blockquote></blockquote><ul><li>To check syntax, find problems, and enforce code style</li><li>JavaScript modules (import/export)</li><li>React</li><li>No（这里我们没使用 TS 就不必了）</li><li>Browser Node</li><li>Use a popular style guide</li><li>Airbnb: <a href="https://github.com/airbnb/javascript" target="_blank" rel="noopener">https://github.com/airbnb/javascript</a></li><li>JavaScript</li><li>Would you like to install them now with npm（Yes）直接安装</li></ul><p>完毕后会发现已经自动安装了 ESLint 相关的包，也自动生成了<code>.eslintrc.js</code>文件，里面的<code>rules</code>默认是空，这个就需要团队自己的额外配置了。注：VSCode 需要安装<code>ESLint</code>插件</p><p>新建文件<code>.eslintignore</code>，忽略一些文件的检查</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;node_modules</span><br><span class="line">&#x2F;public</span><br><span class="line">&#x2F;dist</span><br></pre></td></tr></table></figure><h3 id="StyleLint"><a href="#StyleLint" class="headerlink" title="StyleLint"></a>StyleLint</h3><p>上面是针对规范 JS 代码的，接下来规范 CSS 代码，同样需要安装 VSCode 插件<code>stylelint</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add stylelint stylelint-config-standard -D</span><br></pre></td></tr></table></figure><p>新建文件<code>.stylelintrc.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [<span class="string">'stylelint-config-standard'</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">'comment-empty-line-before'</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'declaration-empty-line-before'</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'function-name-case'</span>: <span class="string">'lower'</span>,</span><br><span class="line">    <span class="string">'no-descending-specificity'</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'no-invalid-double-slash-comments'</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">'rule-empty-line-before'</span>: <span class="string">'always'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  ignoreFiles: [<span class="string">'node_modules/**/*'</span>, <span class="string">'dist/**/*'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Prettier、ESLint、Stylelint-冲突解决"><a href="#Prettier、ESLint、Stylelint-冲突解决" class="headerlink" title="Prettier、ESLint、Stylelint 冲突解决"></a>Prettier、ESLint、Stylelint 冲突解决</h3><p>上面一顿操作后，可能发现 ESLint 给文件飘红，但保存后格式变了又好像恢复原样，这个就是冲突问题，一般解决就是利用插件禁用与 Prettier 起冲突的规则。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add eslint-config-prettier -D</span><br></pre></td></tr></table></figure><p>修改<code>.eslintrc.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="string">'prettier'</span>,</span><br><span class="line">    <span class="string">'prettier/react'</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果代码还因为 ESLint 飘红，可以看情况添加忽略的规则。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yarn add stylelint-config-prettier -D</span><br></pre></td></tr></table></figure><p>修改<code>.stylelintrc.js</code>文件中增加一个 extend</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">extends: [<span class="string">'stylelint-config-prettier'</span>],</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>写到这里就停了，当然要继续往下做的话还有很多，比如用 husky 代码提交，还有很多像 webpack 压缩分离 JS 和 CSS 等一些，这些留到以后写一篇 webpack 性能优化再来一起总结。</p><p><a href="https://github.com/Jacky-Summer/react-cli" target="_blank" rel="noopener">react-cli Github 地址</a></p><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Webpack</tag>
        <tag>工程化</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解 JavaScript 之事件循环(Event Loop)</title>
    <url>/2020/09/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-JavaScript-%E4%B9%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF-Event-Loop/</url>
    <content><![CDATA[<p>这次继续一步步回顾 JS 基础知识点，今天讲的是 JS 中的事件循环。</p>
<a id="more"></a>

<p>深入理解 JavaScript 系列已经很久没更新了，之前的系列文章如下：</p>
<ul>
<li><a href="https://juejin.im/post/6844903976765227016" target="_blank" rel="noopener">深入理解 JavaScript 之变量提升</a></li>
<li><a href="https://juejin.im/post/6844903977511829517" target="_blank" rel="noopener">深入理解 JavaScript 之由一道题来思考闭包</a></li>
<li><a href="https://juejin.im/post/6844904006179913741" target="_blank" rel="noopener">深入理解 JavaScript 之执行上下文和执行栈</a></li>
<li><a href="https://juejin.im/post/6844904006901301255" target="_blank" rel="noopener">深入理解 JavaScript 之执行上下文和变量对象</a></li>
<li><a href="https://juejin.im/post/6844904079051718664" target="_blank" rel="noopener">深入理解 JavaScript 之作用域链与闭包</a></li>
<li><a href="https://juejin.im/post/6844904065785315341" target="_blank" rel="noopener">深入理解 JavaScript 之原型与原型链</a></li>
<li><a href="https://juejin.im/post/6844904070113656839" target="_blank" rel="noopener">深入理解 JavaScript 之 new 原理及模拟实现</a></li>
<li><a href="https://juejin.im/post/6844903978438754318" target="_blank" rel="noopener">深入理解 JavaScript 之获取数组中的最大值方法（this,apply）</a></li>
<li><a href="https://juejin.im/post/6844904003277455368" target="_blank" rel="noopener">深入理解 JavaScript 之实现继承的 7 种方式</a></li>
</ul>
<p>更多前端内容可以看我 <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人博客</a></p>
<h2 id="JavaScript-是单线程的"><a href="#JavaScript-是单线程的" class="headerlink" title="JavaScript 是单线程的"></a>JavaScript 是单线程的</h2><p>JS 是一门单线程的非阻塞的脚本语言，这表示在同一时刻最多也只有一个代码段执行。</p>
<h2 id="为什么-JavaScript-是单线程的"><a href="#为什么-JavaScript-是单线程的" class="headerlink" title="为什么 JavaScript 是单线程的"></a>为什么 JavaScript 是单线程的</h2><p>如果 JS 是多线程的，因为 JS 有 DOM API 可以操作 DOM，如果同时开了两个线程同时操作 DOM 的话，一个线程删除了当前的 DOM 节点，另一个线程要操作当前的 DOM，那么就会有矛盾到底以哪个线程为主。为了避免这种情况出现，JS 就被设计为单线程，而且单线程执行效率高。现在虽然也有 web worker 标准的出现，但它也有很多限制，受主线程控制，是主线程的子线程。</p>
<h2 id="JS-如何处理异步任务"><a href="#JS-如何处理异步任务" class="headerlink" title="JS 如何处理异步任务"></a>JS 如何处理异步任务</h2><p>JS 是单线程，那么非阻塞怎么体现呢？如果 JS 是阻塞的，那么 JS 发起一个异步 IO 请求，在等待结果返回的这个时间段，后面的代码就无法执行了，而 JS 主线程和渲染进程是互斥的，因此可能造成浏览器假死的状态。事实 JS 是非阻塞的，那它要怎么实现异步任务呢，靠的就是事件循环。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>事件循环就是通过异步执行任务的方法来解决单线程的弊端的。</p>
<ol>
<li>一开始整个脚本作为一个宏任务执行</li>
<li>执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列</li>
<li>当前宏任务执行完出队，读取微任务列表，有则依次执行，直到全部执行完</li>
<li>执行浏览器 UI 线程的渲染工作</li>
<li>检查是否有 Web Worker 任务，有则执行</li>
<li>执行完本轮的宏任务，回到第 2 步，继续依此循环，直到宏任务和微任务队列都为空</li>
</ol>
<h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h2><p>JS 引擎把所有任务分成两类，一类叫宏任务(macroTask)，一类叫微任务(microTask)</p>
<h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><ul>
<li>script(整体代码)</li>
<li>setTimeout/setInterval</li>
<li>I/O</li>
<li>UI 渲染</li>
<li>postMessage</li>
<li>MessageChannel</li>
<li>requestAnimationFrame</li>
<li>setImmediate(Node.js 环境)</li>
</ul>
<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><ul>
<li>new Promise().then()</li>
<li>MutaionObserver</li>
<li>process.nextTick(Node.js 环境）</li>
</ul>
<h2 id="经典题目-1"><a href="#经典题目-1" class="headerlink" title="经典题目 1"></a>经典题目 1</h2><p>关于更细节的描述我就不写了，因为有更好的文章可以参考学习：</p>
<ul>
<li><a href="https://juejin.im/post/6844903512845860872" target="_blank" rel="noopener">这一次，彻底弄懂 JavaScript 执行机制</a></li>
</ul>
<p>简单介绍后，接下来就来看几道经典题目：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>整体 script 作为第一个宏任务进入主线程，输出<code>script start</code></li>
<li>遇到 setTimeout，setTimeout 为宏任务，加入宏任务队列</li>
<li>遇到 Promise，其 then 回调函数加入到微任务队列；第二个 then 回调函数也加入到微任务队列</li>
<li>继续往下执行，输出<code>script end</code></li>
<li>检测微任务队列，输出<code>promise1</code>、<code>promise2</code></li>
<li>进入下一轮循环，执行 setTimeout 中的代码，输出<code>setTimeout</code></li>
</ol>
<p>最后执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">script end</span><br><span class="line">promise1</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<h2 id="经典题目-2"><a href="#经典题目-2" class="headerlink" title="经典题目 2"></a>经典题目 2</h2><p>来看一道面试的经典题目</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure>

<ol>
<li>整体 script 作为第一个宏任务进入主线程，代码自上而下执行，执行同步代码，输出 <code>script start</code></li>
<li>遇到 setTimeout，加入到宏任务队列</li>
<li>执行 async1()，输出<code>async1 start</code>；然后遇到<code>await async2()</code>,await 实际上是让出线程的标志，首先执行 async2()，输出<code>async2</code>；把 async2() 后面的代码<code>console.log(&#39;async1 end&#39;)</code>加入微任务队列中，跳出整个 async 函数。（async 和 await 本身就是 promise+generator 的语法糖。所以 await 后面的代码是微任务。）</li>
<li>继续执行，遇到 new Promise，输出<code>promise1</code>，把<code>.then()</code>之后的代码加入到微任务队列中</li>
<li>继续往下执行，输出<code>script end</code>。接着读取微任务队列，输出<code>async1 end</code>，<code>promise2</code>，执行完本轮的宏任务。继续执行下一轮宏任务的代码，输出<code>setTimeout</code></li>
</ol>
<p>最后执行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure>

<h2 id="经典题目-3"><a href="#经典题目-3" class="headerlink" title="经典题目 3"></a>经典题目 3</h2><p>我们来看下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">requestAnimationFrame(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'requestAnimationFrame'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise 1'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise 2'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise then'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>整体 script 代码执行，开局新增三个宏任务，两个 setTimeout 和一个 requestAnimationFrame</li>
<li>遇到 Promise，先输出<code>promise1</code>, <code>promise2</code>，加把 then 回调加入微任务队列。</li>
<li>继续往下执行，输出<code>end</code></li>
<li>执行 promise 的 then 回调，输出<code>promise then</code></li>
<li>接下来剩三个宏任务，我们可以知道的是<code>timer1</code>会比<code>timer2</code>先执行，那么<code>requestAnimationFrame</code>呢？</li>
</ul>
<p>当每一轮事件循环的微任务队列被清空后，有可能发生 UI 渲染，也就是说执行任务的耗时会影响视图渲染的时机。</p>
<p>通常浏览器以每秒 60 帧（60fps）的速率刷新页面，这个帧率最适合人眼交互，大概 <code>1000ms/60</code> 约等于 16.7ms 渲染一帧，如果要让用户看得顺畅，单个宏任务及它相应的微任务最好能在 16.7ms 内完成。</p>
<p>requestAnimationFrame 是什么？</p>
<blockquote>
<p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。<br>requestAnimationFrame 的基本思想是 让页面重绘的频率和刷新频率保持同步，相比 setTimeout,requestAnimationFrame 最大的优势是由系统来决定回调函数的执行时机。</p>
</blockquote>
<p>但这个也不是每轮事件循环都会执行 UI 渲染，不同浏览器有自己的优化策略，比如把几次的视图更新累积到一起重绘，重绘之前会通知 requestAnimationFrame 执行回调函数，也就是说 requestAnimationFrame 回调的执行时机是在一次或多次事件循环的 UI render 阶段。</p>
<p>在我的谷歌浏览器执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise 1</span><br><span class="line">promise 2</span><br><span class="line">end</span><br><span class="line">promise then</span><br><span class="line">requestAnimationFrame</span><br><span class="line">timer1</span><br><span class="line">timer2</span><br></pre></td></tr></table></figure>

<p>在我的火狐浏览器执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">promise 1</span><br><span class="line">promise 2</span><br><span class="line">end</span><br><span class="line">promise then</span><br><span class="line">timer1</span><br><span class="line">timer2</span><br><span class="line">requestAnimationFrame</span><br></pre></td></tr></table></figure>

<p>谷歌浏览器中的结果 requestAnimationFrame()是在一次事件循环后执行，火狐浏览器中的结果是在三次事件循环结束后执行。</p>
<p>可以知道，浏览器只保证 requestAnimationFrame 的回调在重绘之前执行，但没有确定的时间，何时重绘由浏览器决定。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://segmentfault.com/a/1190000022805523" target="_blank" rel="noopener">JavaScript 中的 Event Loop（事件循环）机制</a></li>
</ul>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title>基于SSR/SSG的前端SEO优化</title>
    <url>/2020/08/27/%E5%9F%BA%E4%BA%8ESSR-SSG%E7%9A%84%E5%89%8D%E7%AB%AFSEO%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>前段时间对项目做了 SEO 优化，到现在才来写总结。我们知道，常规用 Vue/React 开发的是 SPA 应用，但是天然的单页面应用 SEO 就是不好，虽然说现在也有各种技术可以改善了，比如使用预渲染，但也都存在各种缺点。但是即使这样，也抵不住 Vue/React 这类框架的潮流，很多产品也可以通过其他亮点而不依赖 SEO 普及开，也有需要登录才能用的使用 SEO 也没有什么意义。</p>
<p>如果项目中真的<strong>对 SEO 和首屏加载速度有刚性需求</strong>，又使用 Vue/React 这类技术，且想尽量减少代码开发附加的难度，有一种比较直接的方式，就是直接使用服务端渲染的框架，Vue 的 Nuxt.js，React 的 Next.js/Gatsby。</p>
<a id="more"></a>

<p>不过，其实学习一门新框架也是一项附加成本啊哈哈，但是 SSR 渲染不过实际开发用不用，起码都要了解一下。我当前以 React 技术栈为主，所以目前只了解的是关于 React 的 SSR 渲染框架，有兴趣的可以看下我这两篇文章：</p>
<ul>
<li><a href="https://juejin.im/post/6863336367309455373" target="_blank" rel="noopener">手把手带你入门 NextJs（v9.5）</a></li>
<li><a href="https://juejin.im/post/6850418110885789704" target="_blank" rel="noopener">手把手带你入门 Gatsby</a></li>
</ul>
<p>所以本文不讨论单页面应用的 SEO 优化，讲的是基于服务端渲染（SSR）/静态生成（SSG）网站 SEO 的优化。</p>
<p>本文会回顾传统的 SEO 的优化方式，以及基于 Gatsby SEO 的优化。</p>
<h2 id="服务端渲染-SSR-与静态网站渲染-SSG"><a href="#服务端渲染-SSR-与静态网站渲染-SSG" class="headerlink" title="服务端渲染 SSR 与静态网站渲染 SSG"></a>服务端渲染 SSR 与静态网站渲染 SSG</h2><p>服务端是指客户端向服务器发出请求，然后运行时动态生成 html 内容并返回给客户端。<br>静态站点的解析是在构建时执行的，当发出请求时，html 将静态存储，直接发送回客户端。</p>
<p>通常来说，静态站点在运行时会更快，因为不需要服务端做处理，但缺点是对数据的任何更改都需要在服务端进行完全重建；而服务端渲染则会动态处理数据，不需要进行完全重建。</p>
<p>对于 Vue/React 来说，对于它们的 SSR/SSG 框架出现的原因就是主要就是 SEO 和首屏加载速度。</p>
<h2 id="搜索引擎的工作原理"><a href="#搜索引擎的工作原理" class="headerlink" title="搜索引擎的工作原理"></a>搜索引擎的工作原理</h2><blockquote>
<p>在搜索引擎网站的后台会有一个非常庞大的数据库，里面存储了海量的关键词，而每个关键词又对应着很多网址，这些网址是被称之为“搜索引擎蜘蛛”或“网络爬虫”程序从互联网上收集而来的。</p>
</blockquote>
<p>这些”蜘蛛”在互联网上爬行，从一个链接到另一个链接，对内容进行分析，提炼关键词加入数据库中；如果蜘蛛认为是垃圾或重复信息，就舍弃继续爬行。当用户搜索时，就能检索出与关键字相关的网址显示给用户。</p>
<p>当用户在搜索引擎搜索时，比如搜索”前端”，则跳出来所有含有”前端”二字关键字的网页，然后根据特定算法给每个含有”前端”二字的网页一个评分排名返回搜索结果。而这些包含”前端”的内容，可以是文章标题、描述、关键字、内容甚至可以是链接。当然，也有可能是广告优先置顶，你懂的。</p>
<blockquote>
<p>一个关键词对用多个网址，因此就出现了排序的问题，相应的当与关键词最吻合的网址就会排在前面了。在“蜘蛛”抓取网页内容，提炼关键词的这个过程中，就存在一个问题：“蜘蛛”能否看懂。如果网站内容是 flash 和 js 等，那么它是看不懂的，会犯迷糊，即使关键字再贴切也没用。相应的，如果网站内容可以被搜索引擎能识别，那么搜索引擎就会提高该网站的权重，增加对该网站的友好度。这样一个过程我们称之为 SEO(Search Engine Optimization)，即搜索引擎优化。</p>
</blockquote>
<h2 id="SEO-目的"><a href="#SEO-目的" class="headerlink" title="SEO 目的"></a>SEO 目的</h2><p>让网站更利于各大搜索引擎抓取和收录，增加对搜索引擎的友好度，使得用户在搜索对应关键词时网站时能排在前面，增加产品的曝光率和流量。</p>
<h2 id="SEO-优化方式"><a href="#SEO-优化方式" class="headerlink" title="SEO 优化方式"></a>SEO 优化方式</h2><p>我们这里主要讲前端能参与和做的优化方式。比如很多 SEO 优化方式都有介绍：控制首页链接数量，扁平化目录层次，优化网站结构布局，分页导航写法这些等，但实际上，日常前端开发也充当不了网站整体设计的角色，只能是协调，这些大部分都是一开始就定好的东西。</p>
<p>比如新闻媒体类等网站比较重视 SEO 的，通常公司还会设有 SEO 部门或者是 SEO 优化工程师岗位，像上面说的，还有网页关键词、描述的就交给他们参与和提供，有些优化方式我们难以触及的就不细谈了，有兴趣的可以去了解。</p>
<h3 id="网页-TDK-标签"><a href="#网页-TDK-标签" class="headerlink" title="网页 TDK 标签"></a>网页 TDK 标签</h3><ul>
<li>title：当前页面的标题（强调重点即可，每个页面的 title 尽量不要相同）</li>
<li>description：当前页面的描述（列举几个关键词即可，不要过分堆积）</li>
<li>keywords：当前页面的关键词（高度概括网页内容）</li>
</ul>
<p>每个页面的 TDK 都不一样，这个需要根据产品业务提炼出核心关键词。</p>
<p>那么页面的 TDK 都不一样，我们就需要对它进行动态设置,react 的话有<a href="https://github.com/nfl/react-helmet" target="_blank" rel="noopener">react-helmet</a><br>插件，用于设置头部标签。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Helmet &#125; <span class="keyword">from</span> <span class="string">'react-helmet'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GoodsDetail = <span class="function">(<span class="params">&#123; title, description, keywords &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'application'</span>&gt;</span><br><span class="line">      &lt;Helmet&gt;</span><br><span class="line">        &lt;title&gt;&#123;title&#125;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">        &lt;meta name='description' content=&#123;`$&#123;description&#125;`&#125; /</span>&gt;</span><br><span class="line">        &lt;meta name=<span class="string">'keywords'</span> content=&#123;<span class="string">`<span class="subst">$&#123;keywords&#125;</span>`</span>&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Helmet&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;content...&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面是演示，实际项目做法还是会把 Helmet 里的内容单独抽离出来做组件。</p>
<p>在 Next.js 里面，是自带 Head 组件的：<code>import Head from &#39;next/head&#39;</code></p>
<h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><p>根据内容的结构化，选择合适的 HTML5 标签尽量让代码语义化，如使用 header，footer，section，aside，article，nav 等等语义化标签可以让爬虫更好的解析。</p>
<h3 id="合理使用-h1-h6-标签"><a href="#合理使用-h1-h6-标签" class="headerlink" title="合理使用 h1~h6 标签"></a>合理使用 h1~h6 标签</h3><p>一个页面中只能最多出现一次<code>h1</code>标签，<code>h2</code>标签通常作为二级标题或文章的小标题。其余<code>h3</code>-<code>h6</code>标签如要使用应按顺序层层嵌套下去，不可以断层或反序。</p>
<p>比如通常在首页的 logo 上加<code>h1</code>标签，但网站设计只展示 logo 图无文字的情况下，h1 的文字就可以设置<code>font-size</code>为零来隐藏</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"logo.png"</span> <span class="attr">alt</span>=<span class="string">"jacky"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>jacky的个人博客<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="图片的-alt-属性"><a href="#图片的-alt-属性" class="headerlink" title="图片的 alt 属性"></a>图片的 alt 属性</h3><p>一般来说，除非是图片仅仅是纯展示类没有任何实际信息的话，<code>alt</code>属性可以为空。否则使用<code>img</code>标签都要添加<code>alt</code>属性，使”蜘蛛”可以抓取到图片的信息。<br>当网络加载不出来或者图片地址失效时，<code>alt</code>属性的内容才会代替图片呈现出来，</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"dog.jpg"</span> <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"200"</span> <span class="attr">alt</span>=<span class="string">"哈士奇"</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="a-标签的-title"><a href="#a-标签的-title" class="headerlink" title="a 标签的 title"></a>a 标签的 title</h3><p>同理，a 标签的 title 属性其实就是提示文字作用，当鼠标移动到该超链接上时，就会有提示文字的出现。通过添加该属性也有微小的作用利于 SEO。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"https://github.com/Jacky-Summer/personal-blog"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">title</span>=<span class="string">"了解更多关于Jacky的个人博客"</span></span></span><br><span class="line"><span class="tag">  &gt;</span>了解更多<span class="tag">&lt;/<span class="name">a</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="404-页面"><a href="#404-页面" class="headerlink" title="404 页面"></a>404 页面</h3><p>404 页面首先是用户体验良好，不会莫名报一些其他提示。其次对蜘蛛也友好，不会因为页面错误而停止抓取，可以返回抓取网站其他页面。</p>
<h3 id="nofollow-忽略跟踪"><a href="#nofollow-忽略跟踪" class="headerlink" title="nofollow 忽略跟踪"></a>nofollow 忽略跟踪</h3><ul>
<li>nofollow 有两种用法：</li>
</ul>
<ol>
<li>用于 meta 元标签，告诉爬虫该页面上所有链接都无需追踪。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;meta name&#x3D;&quot;robots&quot; content&#x3D;&quot;nofollow&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用于 a 标签，告诉爬虫该页面无需追踪。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.xxxx?login&quot; rel&#x3D;&quot;nofollow&quot;&gt;登录&#x2F;注册&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>通常用在 a 标签比较多，它主要有三个作用：</p>
<ol>
<li>“蜘蛛”分配到每个页面的权重是一定的，为了集中网页权重并将权重分给其他必要的链接，就设置<code>rel=&#39;nofollow&#39;</code>告诉”蜘蛛”不要爬，来避免爬虫抓取一些无意义的页面，影响爬虫抓取的效率；而且一旦”蜘蛛”爬了外部链接，就不会再回来了。</li>
<li>付费链接：为了防止付费链接影响 Google 的搜索结果排名，Google 建议使用 nofollow 属性。</li>
<li>防止不可信的内容，最常见的是博客上的垃圾留言与评论中为了获取外链的垃圾链接，为了防止页面指向一些拉圾页面和站点。</li>
</ol>
<h3 id="建立-robots-txt-文件"><a href="#建立-robots-txt-文件" class="headerlink" title="建立 robots.txt 文件"></a>建立 robots.txt 文件</h3><blockquote>
<p>robots.txt 文件由一条或多条规则组成。每条规则可禁止（或允许）特定抓取工具抓取相应网站中的指定文件路径。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow:&#x2F;admin&#x2F;</span><br><span class="line">SiteMap: http:&#x2F;&#x2F;www.xxxx.com&#x2F;sitemap.xml</span><br></pre></td></tr></table></figure>

<p>关键词：</p>
<ol>
<li>User-agent 表示网页抓取工具的名称</li>
<li>Disallow 表示不应抓取的目录或网页</li>
<li>Allow 应抓取的目录或网页</li>
<li>Sitemap 网站的站点地图的位置</li>
</ol>
<ul>
<li><code>User-agent: *</code>表示对所有的搜索引擎有效</li>
<li><code>User-agent: Baiduspider</code> 表示百度搜索引擎，还有谷歌 Googlebot 等等搜索引擎名称，通过这些可以设置不同搜索引擎访问的内容</li>
</ul>
<p>参考例子的话比如百度的 <a href="https://www.baidu.com/robots.txt" target="_blank" rel="noopener">robots.txt</a>，京东的 <a href="https://www.jd.com/robots.txt" target="_blank" rel="noopener">robots.txt</a></p>
<p>robots 文件是搜索引擎访问网站时第一个访问的，然后根据文件里面设置的规则，进行网站内容的爬取。通过设置<code>Allow</code>和<code>Disallow</code>访问目录和文件，引导爬虫抓取网站的信息。</p>
<p>它主要用于使你的网站避免收到过多请求，告诉搜索引擎应该与不应抓取哪些页面。如果你不希望网站的某些页面被抓取，这些页面可能对用户无用，就通过<code>Disallow</code>设置。实现定向 SEO 优化，曝光有用的链接给爬虫，将敏感无用的文件保护起来。</p>
<p>即使网站上面所有内容都希望被搜索引擎抓取到，也要设置一个空的 robot 文件。因为当蜘蛛抓取网站内容时，第一个抓取的文件 robot 文件，如果该文件不存在，那么蜘蛛访问时，服务器上就会有一条 404 的错误日志，多个搜索引擎抓取页面信息时，就会产生多个的 404 错误，故一般都要创建一个 robots.txt 文件到网站根目录下。</p>
<p>空 robots.txt 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow:</span><br></pre></td></tr></table></figure>

<p>如果想要更详细的了解 robots.txt 文件，可以看下：</p>
<ul>
<li><a href="https://support.google.com/webmasters/answer/6062608?hl=en&ref_topic=6061961&visit_id=637337520313091593-2508183586&rd=1" target="_blank" rel="noopener">关于 robots.txt</a></li>
<li><a href="https://ahrefs.com/blog/zh/robots-txt/" target="_blank" rel="noopener">关于 Robots.txt 和 SEO: 你所需要知道的一切</a></li>
</ul>
<p>一般涉及目录比较多的话都会找网站工具动态生成 robots.txt，比如 <a href="https://tool.chinaz.com/robots/" target="_blank" rel="noopener">生成 robots.txt</a></p>
<h3 id="建立网站地图-sitemap"><a href="#建立网站地图-sitemap" class="headerlink" title="建立网站地图 sitemap"></a>建立网站地图 sitemap</h3><p>当网站刚刚上线的时候，连往该网站的外部链接并不多，爬虫可能找不到这些网页；或者该网站的网页之间没有较好的衔接关系，爬虫容易漏掉部分网页。这个时候，sitemap 就派上用场了。</p>
<p>sitemap 是一个将网站栏目和连接归类的一个文件，让搜索引擎全面收录站点网页地址，了解站点网页地址的权重分布以及站点内容更新情况，提高爬虫的爬取效率。Sitemap 文件包含的网址不可以超过 5 万个，且文件大小不得超过 10MB。</p>
<p>sitemap 地图文件包含 html(针对用户)和 xml(针对搜索引擎)两种，最常见的就是 xml 文件，XML 格式的 Sitemap 一共用到 6 个标签，其中关键标签包括链接地址(loc)、更新时间(lastmod)、更新频率(changefreq)和索引优先权(priority)。</p>
<p>爬虫怎么知道网站有没有提供 sitemap 文件呢，也就是上面说的路径放在了 robots.txt 里面。</p>
<p>先找网站的根目录里找 robots.txt，比如腾讯网下的 robots.txt 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User-agent: *</span><br><span class="line">Disallow:</span><br><span class="line">Sitemap: http:&#x2F;&#x2F;www.qq.com&#x2F;sitemap_index.xml</span><br></pre></td></tr></table></figure>

<p>就找到了 sitemap 路径（只列出一部分）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;sitemapindex xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.sitemaps.org&#x2F;schemas&#x2F;sitemap&#x2F;0.9&quot;&gt;</span><br><span class="line">  &lt;sitemap&gt;</span><br><span class="line">    &lt;loc&gt;http:&#x2F;&#x2F;news.qq.com&#x2F;news_sitemap.xml.gz&lt;&#x2F;loc&gt;</span><br><span class="line">    &lt;lastmod&gt;2011-11-15&lt;&#x2F;lastmod&gt;</span><br><span class="line">  &lt;&#x2F;sitemap&gt;</span><br><span class="line">  &lt;sitemap&gt;</span><br><span class="line">    &lt;loc&gt;http:&#x2F;&#x2F;finance.qq.com&#x2F;news_sitemap.xml.gz&lt;&#x2F;loc&gt;</span><br><span class="line">    &lt;lastmod&gt;2011-11-15&lt;&#x2F;lastmod&gt;</span><br><span class="line">  &lt;&#x2F;sitemap&gt;</span><br><span class="line">  &lt;sitemap&gt;</span><br><span class="line">    &lt;loc&gt;http:&#x2F;&#x2F;sports.qq.com&#x2F;news_sitemap.xml.gz&lt;&#x2F;loc&gt;</span><br><span class="line">    &lt;lastmod&gt;2011-11-15&lt;&#x2F;lastmod&gt;</span><br><span class="line">  &lt;&#x2F;sitemap&gt;</span><br><span class="line">  &lt;sitemap&gt;</span><br><span class="line">&lt;&#x2F;sitemapindex&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>loc：页面永久链接地址，可以是静态页面，也可是动态页面</li>
<li>lastmod：页面的最后修改时间，非必填项。搜索引擎根据此项与 changefreq 相结合，判断是否要重新抓取 loc 指向的内容</li>
</ul>
<p>一般网站开发完后，这个 sitemap 一般都是靠自动生成，比如 <a href="https://www.xml-sitemaps.com/" target="_blank" rel="noopener">sitemap 生成工具</a></p>
<h3 id="结构化数据"><a href="#结构化数据" class="headerlink" title="结构化数据"></a>结构化数据</h3><p>结构化数据(Structured data)是一种标准化格式，使用它向 Google 提供有关该网页含义的明确线索，从而帮助理解该网页。一般都 JSON-LD 格式，这格式长什么样呢，看谷歌官方的示例代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Party Coffee Cake<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/ld+json"</span>&gt;</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="actionscript">        <span class="string">"@context"</span>: <span class="string">"https://schema.org/"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">"@type"</span>: <span class="string">"Recipe"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">"name"</span>: <span class="string">"Party Coffee Cake"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">"author"</span>: &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="string">"@type"</span>: <span class="string">"Person"</span>,</span></span><br><span class="line"><span class="actionscript">          <span class="string">"name"</span>: <span class="string">"Mary Stone"</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="string">"nutrition"</span>: &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="string">"@type"</span>: <span class="string">"NutritionInformation"</span>,</span></span><br><span class="line"><span class="actionscript">          <span class="string">"calories"</span>: <span class="string">"512 calories"</span></span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="string">"datePublished"</span>: <span class="string">"2018-03-10"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">"description"</span>: <span class="string">"This coffee cake is awesome and perfect for parties."</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">"prepTime"</span>: <span class="string">"PT20M"</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Party coffee cake recipe<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>This coffee cake is awesome and perfect for parties.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>列明了网页页面种类属于”食谱”，作者和发布时间，描述和烹饪时间等等。这样谷歌搜索出来就有机会含有这些提示或者你带着关键信息去搜索更有利于找到结果。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ee7e3ae735049b1ba53e28600ed31fa~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>官方提供了各种字段用来描述”食谱”，你只要去查阅相关字段，就可以直接按格式来使用了。</p>
<p>因为该 SEO 优化针对谷歌搜索引擎特有的，所以有设置该方式的网站通常是用户是不限于国内的，不仅是结构化数据特有，还有一种 SEO 优化方式是 <strong>AMP 网页</strong>，感兴趣的可以了解看看 —— <a href="https://developers.google.com/search/docs/guides/about-amp" target="_blank" rel="noopener">AMP</a></p>
<p>谷歌还提供了测试工具 <a href="https://search.google.com/structured-data/testing-tool" target="_blank" rel="noopener">Structured Data Testing Tool</a>，可以输入测试网站网址来查看该网站有没有结构化数据设置。</p>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>比如减少 http 请求，控制页面大小，懒加载，利用缓存等等，这方式就很多了，都是为了提高网站的加载速度和良好用户体验，这个也不是专指 SEO 的问题，是开发中都要做的事情。</p>
<p>因为当网站速度很慢时，一旦超时，”蜘蛛”也会离开。</p>
<h2 id="Gatsby-下的-SEO-优化"><a href="#Gatsby-下的-SEO-优化" class="headerlink" title="Gatsby 下的 SEO 优化"></a>Gatsby 下的 SEO 优化</h2><p>本身 Gatsby 就采取静态生成的方式，SEO 已是可以，但依然还是要做 SEO 优化。</p>
<p>知道了上述的 SEO 优化方式后，Gatsby 该如何实战优化呢？这个，由于 Gatsby 社区比较强大，插件很多，所以上面几个依靠插件就可以快速配置生成。</p>
<h3 id="gatsby-plugin-robots-txt"><a href="#gatsby-plugin-robots-txt" class="headerlink" title="gatsby-plugin-robots-txt"></a>gatsby-plugin-robots-txt</h3><p>在 gatsby-config.js 里面配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  siteMetadata: &#123;</span><br><span class="line">    siteUrl: &#39;https:&#x2F;&#x2F;www.xxxxx.com&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [&#39;gatsby-plugin-robots-txt&#39;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="gatsby-plugin-sitemap"><a href="#gatsby-plugin-sitemap" class="headerlink" title="gatsby-plugin-sitemap"></a>gatsby-plugin-sitemap</h3><p>在 gatsby-config.js 里面配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  resolve: &#96;gatsby-plugin-sitemap&#96;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    sitemapSize: 5000,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="网页-TDK"><a href="#网页-TDK" class="headerlink" title="网页 TDK"></a>网页 TDK</h3><p>Gatsby 标准脚手架和有官方文档都有一个 SEO.js 文件，里面就是给我们设置 TDK 提供了方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Helmet &#125; <span class="keyword">from</span> <span class="string">'react-helmet'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useStaticQuery, graphql &#125; <span class="keyword">from</span> <span class="string">'gatsby'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SEO</span>(<span class="params">&#123; description, lang, meta, title &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; site &#125; = useStaticQuery(</span><br><span class="line">    graphql<span class="string">`</span></span><br><span class="line"><span class="string">      query &#123;</span></span><br><span class="line"><span class="string">        site &#123;</span></span><br><span class="line"><span class="string">          siteMetadata &#123;</span></span><br><span class="line"><span class="string">            title</span></span><br><span class="line"><span class="string">            description</span></span><br><span class="line"><span class="string">            author</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> metaDescription = description || site.siteMetadata.description</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Helmet</span><br><span class="line">      htmlAttributes=&#123;&#123;</span><br><span class="line">        lang,</span><br><span class="line">      &#125;&#125;</span><br><span class="line">      title=&#123;title&#125;</span><br><span class="line">      meta=&#123;[</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">`description`</span>,</span><br><span class="line">          content: metaDescription,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          property: <span class="string">`og:title`</span>,</span><br><span class="line">          content: title,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          property: <span class="string">`og:description`</span>,</span><br><span class="line">          content: metaDescription,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          property: <span class="string">`og:type`</span>,</span><br><span class="line">          content: <span class="string">`website`</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">`twitter:card`</span>,</span><br><span class="line">          content: <span class="string">`summary`</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">`twitter:creator`</span>,</span><br><span class="line">          content: site.siteMetadata.author,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">`twitter:title`</span>,</span><br><span class="line">          content: title,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          name: <span class="string">`twitter:description`</span>,</span><br><span class="line">          content: metaDescription,</span><br><span class="line">        &#125;,</span><br><span class="line">      ].concat(meta)&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEO.defaultProps = &#123;</span><br><span class="line">  lang: <span class="string">`en`</span>,</span><br><span class="line">  meta: [],</span><br><span class="line">  description: <span class="string">``</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SEO.propTypes = &#123;</span><br><span class="line">  description: PropTypes.string,</span><br><span class="line">  lang: PropTypes.string,</span><br><span class="line">  meta: PropTypes.arrayOf(PropTypes.object),</span><br><span class="line">  title: PropTypes.string.isRequired,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> SEO</span><br></pre></td></tr></table></figure>

<p>然后在页面模板文件中引入 SEO.js，并传入页面的变量参数，即可设置 TDK 等等头部信息。</p>
<h3 id="structured-data"><a href="#structured-data" class="headerlink" title="structured data"></a>structured data</h3><p>比如说项目是新闻文章展示的，可以设置三种结构化数据（数据类型和字段不是凭空捏造的，这个需要去 Google 查符合对应匹配的）——文章详情页，文章列表页，再加个公司的介绍。</p>
<p>在项目根目录下新建</p>
<ul>
<li><code>./src/components/Jsonld.js</code><br>封装外部包住的 script 标签作为组件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &#39;react&#39;</span><br><span class="line">import &#123; Helmet &#125; from &#39;react-helmet&#39;</span><br><span class="line"></span><br><span class="line">function JsonLd(&#123; children &#125;) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Helmet&gt;</span><br><span class="line">      &lt;script type&#x3D;&quot;application&#x2F;ld+json&quot;&gt;&#123;JSON.stringify(children)&#125;&lt;&#x2F;script&gt;</span><br><span class="line">    &lt;&#x2F;Helmet&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default JsonLd</span><br></pre></td></tr></table></figure>

<ul>
<li><code>./src/utils/json-ld/article.js</code> - 文章详情结构化数据描述</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> articleSchema = (&#123;</span><br><span class="line">  url,</span><br><span class="line">  headline,</span><br><span class="line">  image,</span><br><span class="line">  datePublished,</span><br><span class="line">  dateModified,</span><br><span class="line">  author,</span><br><span class="line">  publisher,</span><br><span class="line">&#125;) =&gt; (&#123;</span><br><span class="line">  <span class="string">'@context'</span>: <span class="string">'http://schema.org'</span>,</span><br><span class="line">  <span class="string">'@type'</span>: <span class="string">'Article'</span>,</span><br><span class="line">  mainEntityOfPage: &#123;</span><br><span class="line">    <span class="string">'@type'</span>: <span class="string">'WebPage'</span>,</span><br><span class="line">    <span class="string">'@id'</span>: url,</span><br><span class="line">  &#125;,</span><br><span class="line">  headline,</span><br><span class="line">  image,</span><br><span class="line">  datePublished,</span><br><span class="line">  dateModified,</span><br><span class="line">  author: &#123;</span><br><span class="line">    <span class="string">'@type'</span>: <span class="string">'Person'</span>,</span><br><span class="line">    name: author,</span><br><span class="line">  &#125;,</span><br><span class="line">  publisher: &#123;</span><br><span class="line">    <span class="string">'@type'</span>: <span class="string">'Organization'</span>,</span><br><span class="line">    name: publisher.name,</span><br><span class="line">    logo: &#123;</span><br><span class="line">      <span class="string">'@type'</span>: <span class="string">'ImageObject'</span>,</span><br><span class="line">      url: publisher.logo,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> articleSchema</span><br></pre></td></tr></table></figure>

<ul>
<li><code>./src/utils/json-ld/item-list.js</code> - 文章列表结构化数据描述</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> itemListSchema = <span class="function">(<span class="params">&#123; itemListElement &#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="string">'@context'</span>: <span class="string">'http://schema.org'</span>,</span><br><span class="line">  <span class="string">'@type'</span>: <span class="string">'ItemList'</span>,</span><br><span class="line">  itemListElement: itemListElement.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="string">'@type'</span>: <span class="string">'ListItem'</span>,</span><br><span class="line">    position: index + <span class="number">1</span>,</span><br><span class="line">    ...item,</span><br><span class="line">  &#125;)),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> itemListSchema</span><br></pre></td></tr></table></figure>

<ul>
<li><code>./src/utils/json-ld/organization.js</code> - 公司组织结构化数据描述</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> organizationSchema = <span class="function">(<span class="params">&#123; name, url &#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="string">'@context'</span>: <span class="string">'http://schema.org'</span>,</span><br><span class="line">  <span class="string">'@type'</span>: <span class="string">'Organization'</span>,</span><br><span class="line">  name,</span><br><span class="line">  url,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> organizationSchema</span><br></pre></td></tr></table></figure>

<p>然后再分别引入页面，比如我们在文章详情页面，引入对应类型文件，大概就是这么个用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> JsonLd <span class="keyword">from</span> <span class="string">'@components/JsonLd'</span></span><br><span class="line"><span class="keyword">import</span> SEO <span class="keyword">from</span> <span class="string">'@components/SEO'</span></span><br><span class="line"><span class="keyword">import</span> articleSchema <span class="keyword">from</span> <span class="string">'@utils/json-ld/article'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> DetailPage = <span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 处理 data，拆开相关字段</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;SEO</span><br><span class="line">        title=&#123;meta_title || title&#125;</span><br><span class="line">        description=&#123;meta_description&#125;</span><br><span class="line">        keywords=&#123;meta_keywords&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;JsonLd&gt;</span><br><span class="line">        &#123;articleSchema(&#123;</span><br><span class="line">          url,</span><br><span class="line">          headline: title,</span><br><span class="line">          datePublished: first_publication_date,</span><br><span class="line">          dateModified: last_publication_date,</span><br><span class="line">          author: siteMetadata.title,</span><br><span class="line">          publisher: &#123;</span><br><span class="line">            name: siteMetadata.title,</span><br><span class="line">            logo: <span class="string">'xxx'</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;<span class="regexp">/JsonLd&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Container&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;content...&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/Container&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Layout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码要是迷迷糊糊倒是正常，因为没有了解过结构化数据的内容，但看文档就大概可以了解清楚了。</p>
<h3 id="Lighthouse-性能优化工具"><a href="#Lighthouse-性能优化工具" class="headerlink" title="Lighthouse 性能优化工具"></a>Lighthouse 性能优化工具</h3><p>可以去谷歌商店安装<code>LightHouse</code>，打开 F12，进入你的网站，点击<code>Generate report</code>，就会生成网站对应的报告</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f758e6c497674256a516d3a357774826~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<ul>
<li>生成的 report：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d84656f6cce4800ab793feb73141e30~tplv-k3u1fbpfcp-zoom-1.image" alt=""></li>
</ul>
<p>在它下面有一些提示，针对性能和 SEO 等，你可以根据提示去改善你的代码。</p>
<p>文章的介绍到这里就结束了，希望对大家了解 SEO 有一点帮助。SEO 的摸索并不是以上举例完就差不多没了，其实有各种各样的方式可以优化。上面列举的是比较常见的，事实上，我觉得 SEO 优化无非是想吸引更多的用户点击和使用网站，但如果网站的内容优质用户体验良好，加性能好，那么有用户使用后就自带推广性，那么无疑比 SEO 简单的优化强多了。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://juejin.im/post/6844903824428105735" target="_blank" rel="noopener">前端 SEO 优化</a></li>
</ul>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>SSR</tag>
        <tag>Gatsby</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手带你入门 NextJS</title>
    <url>/2020/08/21/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8-NextJS/</url>
    <content><![CDATA[<p>Next.js 之前用过一次，这次是重新做个小回顾，现在最新版本已经到了 9.5.3，有些 API 也同以前有点不同了，网上大部分教程也都是旧版本 v7 的比较多，故打算写下简单的教程，绝对详细的带你入个小门。</p><a id="more"></a><h2 id="库版本"><a href="#库版本" class="headerlink" title="库版本"></a>库版本</h2><p>本文案例用的关键库版本如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;next&quot;: &quot;^9.5.2&quot;,</span><br><span class="line">&quot;react&quot;: &quot;^16.13.1&quot;,</span><br></pre></td></tr></table></figure><p>node 版本为 12.18.1（nodejs 版本 &gt;= 10.13 即可）</p><h2 id="初始化-Next-js-项目"><a href="#初始化-Next-js-项目" class="headerlink" title="初始化 Next.js 项目"></a>初始化 Next.js 项目</h2><ol><li>新建一个文件夹</li></ol><p>如<code>learn-nextjs-example</code>，先进行初始化</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i -y</span><br></pre></td></tr></table></figure><ol start="2"><li>安装所需要的依赖包</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i react react-dom next --save</span><br></pre></td></tr></table></figure><ol start="3"><li>添加 script 命令</li></ol><p>为了是开发输入 npm 命令更快捷，所以把常用的命令作为快捷命令设置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;next&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;next start&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ol start="4"><li>创建 pages 文件夹，运行第一个页面</li></ol><blockquote><p>pages 文件夹是放置页面的，这里边的文件会自动生成相应路由。</p></blockquote><ul><li>比如创建 <code>pages/about.js</code>，那么访问该页面地址就是 <code>http://localhost:3000/about</code>；</li><li>比如创建 <code>pages/about/about.js</code>，那么访问地址为<code>http://localhost:3000/about/about</code>。</li></ul><p>现在我们创建 <code>pages/index.js</code>，index.js 就是默认代表根路径了</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello Next.js!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure><p>此时运行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm rum dev</span><br></pre></td></tr></table></figure><p>打开<code>http://localhost:3000/</code>，可以看到页面成功运行了，也可以知道 Next.js 内置 React，因此不用我们再引入<br><code>import React from &#39;react&#39;</code>，就可以直接使用 React 的语法，当然你写了也不会报错，不过没必要。</p><h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><p>页面跳转有两种形式，一种是利用标签<code>Link</code>，一种是编程式路由跳转<code>router.push(&#39;/&#39;)</code>。路由跳转方式还是跟 React 很像的，只不过用的是 <code>next</code> 的包</p><h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><ol><li>先创建两个页面</li></ol><p><code>pages/about.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>About Page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> About</span><br></pre></td></tr></table></figure><p><code>pages/news.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> News = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>News Page<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> News</span><br></pre></td></tr></table></figure><ol start="2"><li>在首页<code>pages/index.js</code>编写路由跳转链接</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;Hello Next.js!&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Link href='/</span>about<span class="string">'&gt;</span></span><br><span class="line"><span class="string">          &lt;a&gt;关于&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;Link href='</span>/news<span class="string">'&gt;</span></span><br><span class="line"><span class="string">          &lt;a&gt;新闻&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">export default Home</span></span><br></pre></td></tr></table></figure><p>在这里要注意的是 a 标签不用添加 href 元素，添加了也不起作用。<br>如果<code>Link</code>里面换成其他标签如<code>span</code>，也依然能成功跳转到对应页面，可以知道<code>Link</code>是给里面的元素添加了点击绑定事件，而不是只会给 a 标签添加 href 而已。</p><p>此时 DOM 结构：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de05d989ca674288856386d286ad3052~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>还有要注意的是：<code>Link</code> 里面只能有一个根元素，要不然它不知要绑定谁会报错。</p><h3 id="编程式路由跳转"><a href="#编程式路由跳转" class="headerlink" title="编程式路由跳转"></a>编程式路由跳转</h3><p>这里主要用<code>useRouter</code>钩子进行跳转</p><p>修改<code>pages/index.js</code>，修改其中一个路由</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter()</span><br><span class="line">  <span class="keyword">const</span> gotoAbout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    router.push(<span class="string">'/news'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;Hello Next.js!&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Link href='/</span>about<span class="string">'&gt;</span></span><br><span class="line"><span class="string">          &lt;a&gt;关于&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;button onClick=&#123;gotoAbout&#125;&gt;新闻&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">export default Home</span></span><br></pre></td></tr></table></figure><h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><h3 id="query-形式传参"><a href="#query-形式传参" class="headerlink" title="query 形式传参"></a>query 形式传参</h3><p>在 Next.js 中只能通过 query（?name=jackylin）来传递参数，不能通过(path:name)的形式传递参数。<br>修改<code>pages/index.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter()</span><br><span class="line">  <span class="keyword">const</span> gotoAbout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    router.push(<span class="string">'/news'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;Hello Next.js!&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Link href='/</span>about?name=jackylin<span class="string">'&gt;</span></span><br><span class="line"><span class="string">          &lt;a&gt;关于&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;button onClick=&#123;gotoAbout&#125;&gt;新闻&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">export default Home</span></span><br></pre></td></tr></table></figure><p>也可以变换成这种方式传</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Link href&#x3D;&#123;&#123; pathname: &#39;&#x2F;about&#39;, query: &#123; name: &#39;jackylin&#39; &#125; &#125;&#125;&gt;</span><br></pre></td></tr></table></figure><p>传递了参数<code>name</code>后，接下来是接收参数。</p><p>打开<code>pages/about.js</code>添加代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = <span class="function">(<span class="params">&#123; router &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;About Page&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;接收到参数为：&#123;router.query.name&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(About)</span></span><br></pre></td></tr></table></figure><p>点击<code>关于</code>，跳转到 about 页面，页面内容为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">About Page</span><br><span class="line">接收到参数为：jackylin</span><br></pre></td></tr></table></figure><p>同时也可看到地址栏带有参数：<code>http://localhost:3000/about?name=jackylin</code></p><h3 id="编程式路由跳转传递参数"><a href="#编程式路由跳转传递参数" class="headerlink" title="编程式路由跳转传递参数"></a>编程式路由跳转传递参数</h3><p>修改<code>pages/index.js</code>中的 <code>gotoAbout</code>方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gotoAbout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  router.push(&#123;</span><br><span class="line">    pathname: <span class="string">'/news'</span>,</span><br><span class="line">    query: &#123;</span><br><span class="line">      info: <span class="string">'学习Next.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pages/news.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> News = <span class="function">(<span class="params">&#123; router &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;News Page&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;接收到参数为：&#123;router.query.info&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(News)</span></span><br></pre></td></tr></table></figure><h2 id="路由变化的钩子"><a href="#路由变化的钩子" class="headerlink" title="路由变化的钩子"></a>路由变化的钩子</h2><p>这里就不一个个细细展开了，直接代码说话：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter()</span><br><span class="line">  <span class="keyword">const</span> gotoAbout = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    router.push(&#123;</span><br><span class="line">      pathname: <span class="string">'/news'</span>,</span><br><span class="line">      query: &#123;</span><br><span class="line">        info: <span class="string">'学习Next.js'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> handleRouteChangeStart = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'routeChangeStart 路由开始变化，url:'</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRouteChangeComplete = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'routeChangeComplete 路由结束变化，url:'</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleBeforeHistoryChange = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'beforeHistoryChange 在改变浏览器 history之前触发，url:'</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRouteChangeError = <span class="function">(<span class="params">err, url</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`routeChangeError 跳转发生错误: <span class="subst">$&#123;err&#125;</span>, url:<span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleHashChangeStart = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hashChangeStart hash路由模式跳转开始时执行，url:'</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleHashChangeComplete = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'hashChangeComplete hash路由模式跳转完成时，url:'</span>, url)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    router.events.on(<span class="string">'routeChangeStart'</span>, handleRouteChangeStart)</span><br><span class="line">    router.events.on(<span class="string">'routeChangeComplete'</span>, handleRouteChangeComplete)</span><br><span class="line">    router.events.on(<span class="string">'beforeHistoryChange'</span>, handleBeforeHistoryChange)</span><br><span class="line">    router.events.on(<span class="string">'routeChangeError'</span>, handleRouteChangeError)</span><br><span class="line">    router.events.on(<span class="string">'hashChangeStart'</span>, handleHashChangeStart)</span><br><span class="line">    router.events.on(<span class="string">'hashChangeComplete'</span>, handleHashChangeComplete)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      router.events.off(<span class="string">'routeChangeStart'</span>, handleRouteChangeStart)</span><br><span class="line">      router.events.off(<span class="string">'routeChangeComplete'</span>, handleRouteChangeComplete)</span><br><span class="line">      router.events.off(<span class="string">'beforeHistoryChange'</span>, handleBeforeHistoryChange)</span><br><span class="line">      router.events.off(<span class="string">'routeChangeError'</span>, handleRouteChangeError)</span><br><span class="line">      router.events.off(<span class="string">'hashChangeStart'</span>, handleHashChangeStart)</span><br><span class="line">      router.events.off(<span class="string">'hashChangeComplete'</span>, handleHashChangeComplete)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;Hello Next.js!&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Link href='/</span>about?name=jackylin<span class="string">'&gt;</span></span><br><span class="line"><span class="string">          &lt;a&gt;关于&lt;/a&gt;</span></span><br><span class="line"><span class="string">        &lt;/Link&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">      &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;button onClick=&#123;gotoAbout&#125;&gt;新闻&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">export default Home</span></span><br></pre></td></tr></table></figure><h2 id="style-jsx-编写页面-CSS-样式"><a href="#style-jsx-编写页面-CSS-样式" class="headerlink" title="style-jsx 编写页面 CSS 样式"></a>style-jsx 编写页面 CSS 样式</h2><p>我们建立一个头部组件再引入<code>pages/index.js</code>，在根目录下新建<code>components/header.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Header = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div className=<span class="string">'header-bar'</span>&gt;Header&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header</span><br></pre></td></tr></table></figure><p><code>pages/index.js</code>引入 Header 组件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'../components/header'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>接着给 Header 写样式，Next.js 内置支持 style jsx 语法，这是其中一种 CSS-in-JS 的解决方案</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Header = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div className=<span class="string">'header-bar'</span>&gt;Header&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;style jsx&gt;</span></span><br><span class="line"><span class="regexp">        &#123;`</span></span><br><span class="line"><span class="regexp">          .header-bar &#123;</span></span><br><span class="line"><span class="regexp">            width: 100%;</span></span><br><span class="line"><span class="regexp">            height: 50px;</span></span><br><span class="line"><span class="regexp">            line-height: 50px;</span></span><br><span class="line"><span class="regexp">            background: lightblue;</span></span><br><span class="line"><span class="regexp">            text-align: center;</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        `&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>style&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Header</span></span><br></pre></td></tr></table></figure><p>运行样式生效<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27bcc345b1bf4fdcb50e582310abc0d7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>查看 DOM 结构，会发现 Next.js 会自动加入一个随机类名（jsx-xxxxxxx），这样就能防止 CSS 的全局污染。<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2de14d7f46694782a151d440ecb2626f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="添加全局-CSS-文件"><a href="#添加全局-CSS-文件" class="headerlink" title="添加全局 CSS 文件"></a>添加全局 CSS 文件</h2><p>新建文件夹 public，用于放置静态文件如图片和 css 文件等，注意只有名为<code>public</code>的目录能够存放静态资源并对外提供访问。新建文件<code>public/static/styles/common.css</code></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义 App</li></ul><p>Next.js 使用<code>App</code>组件来初始化页面，我们可以覆盖<code>App</code>组件来控制页面的初始化。该<code>App</code>作用一般如下：</p><ul><li>在页面切换之间保持布局的持久化</li><li>切换页面时保持状态</li><li>使用 componentDidCatch 自定义错误处理</li><li>向页面注入额外的数据</li><li>添加全局 CSS</li></ul><p>我们要做的就是添加全局 CSS 样式，所以需要覆盖原来默认的<code>App</code>，首先要创建<code>pages/_app.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'../public/static/styles/common.css'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Component 指当前页面，每次路由切换时，Component 都会更新</span></span><br><span class="line"><span class="comment"> * pageProps 是带有初始属性的对象，该初始属性由我们的某个数据获取方法预先加载到你的页面中，否则它将是一个空对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">MyApp</span>(<span class="params">&#123; Component, pageProps &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...pageProps</span>&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务，运行，全局样式添加成功。</p><h2 id="集成-style-components"><a href="#集成-style-components" class="headerlink" title="集成 style-components"></a>集成 style-components</h2><p>如果想要项目支持 style-components 的话，需要我们自己去配置。我们通过自定义 Document 的方式来改写代码，即是指<code>_document.js</code>文件，它只有在服务器端渲染的时候才会被调用，主要用来修改服务器端渲染的文档内容，一般用来配合第三方 css-in-js 方案使用。</p><ul><li>安装所需库</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i styled-components --save</span><br></pre></td></tr></table></figure><p>编译 styled-components</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i babel-plugin-styled-components --save-dev</span><br></pre></td></tr></table></figure><p>新建文件<code>.babelrc</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;next&#x2F;babel&quot;],</span><br><span class="line">  &quot;plugins&quot;: [[&quot;styled-components&quot;, &#123; &quot;ssr&quot;: true &#125;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新建 <code>_document.js</code>，改写覆盖它原来的写法。这里要注意的是，要一定要继承 <code>Document</code>，才来改写</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Document <span class="keyword">from</span> <span class="string">'next/document'</span></span><br><span class="line"><span class="keyword">import</span> &#123; ServerStyleSheet &#125; <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDocument</span> <span class="keyword">extends</span> <span class="title">Document</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">async</span> getInitialProps(ctx) &#123;</span><br><span class="line">    <span class="keyword">const</span> sheet = <span class="keyword">new</span> ServerStyleSheet()</span><br><span class="line">    <span class="keyword">const</span> originalRenderPage = ctx.renderPage</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ctx.renderPage = <span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">        originalRenderPage(&#123;</span><br><span class="line">          enhanceApp: <span class="function"><span class="params">App</span> =&gt;</span> <span class="function"><span class="params">props</span> =&gt;</span> sheet.collectStyles(<span class="xml"><span class="tag">&lt;<span class="name">App</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>),</span><br><span class="line">        &#125;)</span><br><span class="line">      <span class="keyword">const</span> initialProps = <span class="keyword">await</span> Document.getInitialProps(ctx)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...initialProps,</span><br><span class="line">        styles: (</span><br><span class="line">          &lt;&gt;</span><br><span class="line">            &#123;initialProps.styles&#125;</span><br><span class="line">            &#123;sheet.getStyleElement()&#125;</span><br><span class="line">          &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">        ),</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125; finally &#123;</span></span><br><span class="line"><span class="regexp">      sheet.seal()</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>这其中详细配置意思可以去官方文档找点线索了解：<a href="https://nextjs.org/docs/advanced-features/custom-document" target="_blank" rel="noopener">Next.js</a></p><p>接下来我们使用 styled-components 的方式添加样式，打开<code>pages/about.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'next/router'</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">'styled-components'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Title = styled.h1<span class="string">`</span></span><br><span class="line"><span class="string">  color: green;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = <span class="function">(<span class="params">&#123; router &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Title&gt;About Page&lt;<span class="regexp">/Title&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;接收到参数为：&#123;router.query.name&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default withRouter(About)</span></span><br></pre></td></tr></table></figure><p>运行，如下图：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e914adfd47af4564a3c06b641f514b8e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="获取数据的方式"><a href="#获取数据的方式" class="headerlink" title="获取数据的方式"></a>获取数据的方式</h2><p>四个 api 都只能在 pages 文件夹内的文件中使用</p><h3 id="getStaticProps"><a href="#getStaticProps" class="headerlink" title="getStaticProps"></a>getStaticProps</h3><p><strong>当页面内容取决于外部数据</strong></p><p>Next.js 推荐我们尽可能使用静态生成的方式，因为所有页面都可以只构建一次并托管到 CDN 上，这比让服务器根据每个页面请求来渲染页面快得多。</p><p>比如下列一些类型的页面：</p><ul><li>营销页面</li><li>个人博客</li><li>产品列表</li><li>静态文档</li></ul><p>如果一个页面使用了 静态生成（SSG），在构建时将生成此页面对应的 HTML 文件 。HTML 文件将在每个页面请求时被重用，还可以被 CDN 缓存。这个跟 hexo，Gatsby 类似的，生成静态文件还有 json 文件。</p><p>关于 Gatsby，它是基于 React 的上层框架，具体可以看我这篇博客了解：<a href="https://juejin.im/post/6850418110885789704" target="_blank" rel="noopener">手把手带你入门 Gatsby</a></p><p>Next.js 会尽可能地自动优化应用并输出静态 HTML，如果你在你的页面组件添加了<code>getInitialProps</code>方法才会禁用自动静态优化，<code>getInitialProps</code>方法下面会说到。</p><p>比如我们可以执行命令查看</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>打包默认是 SSG 模式：</p><p><code>● (SSG) automatically generated as static HTML + JSON (uses getStaticProps)</code></p><p>会发现<code>.next/server/pages/</code>下多出了几个 HTML 文件，这些就是静态构建出的 HTML 文件。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06f57ad8a7c046efbcbbbb90032f0396~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>新建文件<code>pages/blog.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Blog = <span class="function">(<span class="params">&#123; posts &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>title: &#123;posts.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数在构建时被调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStaticProps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用外部 API 获取内容</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">'https://jsonplaceholder.typicode.com/todos/1'</span>)</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> res.json()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在构建时将接收到 `posts` 参数</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      posts,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Blog</span><br></pre></td></tr></table></figure><p>进入<code>http://localhost:3000/blog</code>，发现页面能正常获取到请求结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: delectus aut autem</span><br></pre></td></tr></table></figure><h3 id="getStaticPaths"><a href="#getStaticPaths" class="headerlink" title="getStaticPaths"></a>getStaticPaths</h3><p><strong>当页面的路径取决于外部数据</strong></p><p>这种方式和上面就有些不同了，上面<code>http://localhost:3000/blog</code>访问路径时我们已经写了一个 js 页面文件，但如果我们想要根据获取的数据动态生成多篇文章路径的话，那就需要用到这个 API，通常用这个 API 会同时配合<code>getStaticProps</code>一起用。</p><p>新建文件<code>pages/posts/[id].js</code>，你没有看错，文件名就是<code>[id].js</code></p><p>用<code>id</code>标识单篇博文，比如你访问<code>http://localhost:3000/posts/1</code>就展示<code>id</code>为 1 的文章。</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Post = <span class="function">(<span class="params">&#123; post &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div&gt;文章id: &#123;post.id&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;博客标题: &#123;post.title&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 构建路由</span></span><br><span class="line"><span class="regexp">export async function getStaticPaths() &#123;</span></span><br><span class="line"><span class="regexp">  /</span><span class="regexp">/ 调用外部 API 获取博文列表</span></span><br><span class="line"><span class="regexp">  const res = await fetch('https:/</span><span class="regexp">/jsonplaceholder.typicode.com/</span>todos<span class="string">')</span></span><br><span class="line"><span class="string">  const posts = await res.json()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 根据博文列表生成所有需要预渲染的路径</span></span><br><span class="line"><span class="string">  const paths = posts.map(post =&gt; `/posts/$&#123;post.id&#125;`)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // fallback为false，表示任何不在 getStaticPaths 的路径的结果将是 404 页面。</span></span><br><span class="line"><span class="string">  return &#123; paths, fallback: false &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 获取单个页面博文数据</span></span><br><span class="line"><span class="string">export async function getStaticProps(&#123; params &#125;) &#123;</span></span><br><span class="line"><span class="string">  // 如果路由是 /posts/1，那么 params.id 就是 1</span></span><br><span class="line"><span class="string">  const res = await fetch(`https://jsonplaceholder.typicode.com/todos/$&#123;params.id&#125;`)</span></span><br><span class="line"><span class="string">  const post = await res.json()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  // 通过 props 参数向页面传递博文的数据</span></span><br><span class="line"><span class="string">  return &#123; props: &#123; post &#125; &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default Post</span></span><br></pre></td></tr></table></figure><p>拉取下来的数据全部有 200 条，也就是说动态构建了 200 个路由，现在我们访问第 50 篇博文的话，直接输入<code>http://localhost:3000/posts/50</code></p><p>页面显示：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文章id: 50</span><br><span class="line">博文标题: cupiditate necessitatibus ullam aut quis dolor voluptate</span><br></pre></td></tr></table></figure><p>接下来让我们再次打包，执行<code>npm run build</code>（如果打包发生错误很可能是网络差和请求链接有关，因为要请求很多页面，如果是网络问题多试几次就行），你会发现这次打包时间变长了，因为要构建的静态页面多了，我们请求返回来的数据有 200 条，所以应该生成 200 个静态 HTML 文件和相应的 json 数据文件。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/088770a941f1479fa15fc96d348f85a4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>我们来看 <code>1.json</code> 文件，就是请求后的数据</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;pageProps&quot;:&#123;&quot;post&quot;:&#123;&quot;userId&quot;:1,&quot;id&quot;:1,&quot;title&quot;:&quot;delectus aut autem&quot;,&quot;completed&quot;:false&#125;&#125;,&quot;__N_SSG&quot;:true&#125;</span><br></pre></td></tr></table></figure><h3 id="getServerSideProps"><a href="#getServerSideProps" class="headerlink" title="getServerSideProps"></a>getServerSideProps</h3><p><strong>每次页面请求时重新生成页面的 HTML</strong></p><p>如果无法在用户请求之前预渲染页面，那上面的”静态生成”就不太适用了，或者是页面数据需要频繁的更新，并且页面内容会随着每个请求而变化。这个时候，有两种方案：</p><ul><li>将“静态生成”与 客户端渲染 一起使用：你可以跳过页面某些部分的预渲染，然后使用客户端 JavaScript 来填充它们</li><li>使用 服务器端渲染： Next.js 针对每个页面的请求进行预渲染。由于 CDN 无法缓存该页面，因此速度会较慢，但是预渲染的页面将始终是最新的。</li></ul><p>由于服务器端渲染会导致性能比“静态生成”慢，因此仅在绝对必要时才使用此功能。</p><p>新建文件<code>pages/server-blog.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Blog = <span class="function">(<span class="params">&#123; posts &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>title: &#123;posts.title&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在每次页面请求时都会运行，而在构建时不运行。</span></span><br><span class="line"><span class="comment">// 要设置某个页面使用服务器端渲染，就需要导出 getServerSideProps 函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getServerSideProps</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用外部 API 获取内容</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">'https://jsonplaceholder.typicode.com/todos/1'</span>)</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> res.json()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在构建时将接收到 `posts` 参数</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      posts,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Blog</span><br></pre></td></tr></table></figure><p>运行<code>npm run build</code>，发现这次并没有生成对应的 html 文件——<code>server-blog.html</code>，因为我们指定了服务端渲染，请求构建时不会执行，不是静态生成。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2717dff8c6a0485d836091e87f9093c0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="getInitialProps"><a href="#getInitialProps" class="headerlink" title="getInitialProps"></a>getInitialProps</h3><p>getInitialProps 是在渲染页面之前就会运行的 API。 如果该路径下包含该请求，则执行该请求，并将所需的数据作为 props 传递给页面。当第一次访问直接页面，getInitialProps 就在服务器端运行，加载完毕后页面给客户端托管，使用客户端的路由跳转，之后页面的 getInitialProps 就在客户端执行了。</p><blockquote><p>推荐： getStaticProps 或 getServerSideProps。如果你使用的是 Next.js 9.3 或更高版本，我们建议你使用 getStaticProps 或 getServerSideProps 来替代 getInitialProps。这些新的获取数据的方法使你可以在静态生成（static generation）和服务器端渲染（server-side rendering）之间进行精细控制。</p></blockquote><p>新建文件<code>pages/initial-blog.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">'next/link'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> InitialBlog = <span class="function">(<span class="params">&#123; post &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;getInitialProps Demo Page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;获取到的title: &#123;post.title&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;Link href=<span class="string">'/'</span>&gt;</span><br><span class="line">        &lt;a&gt;返回首页&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Link&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">InitialBlog.getInitialProps = async ctx =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  const res = await fetch('https:/</span><span class="regexp">/jsonplaceholder.typicode.com/</span>todos/<span class="number">1</span><span class="string">')</span></span><br><span class="line"><span class="string">  const post = await res.json()</span></span><br><span class="line"><span class="string">  return &#123; post &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default InitialBlog</span></span><br></pre></td></tr></table></figure><p>再修改<code>pages/index.js</code>代码，增加一个<code>Link</code>标签可以跳转回该页面</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Link href=<span class="string">'/initial-blog'</span>&gt;</span><br><span class="line">    &lt;a&gt;进入Initial Blog&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Link&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure><p>接着直接地址栏输入<code>http://localhost:3000/initial-blog</code>，在渲染该页面内容前，先会执行<code>getInitialProps</code>方法，执行完的结果再传到页面组件，开始渲染页面。由于我们是第一次访问页面，首屏则为服务端渲染。</p><p>页面内容显示为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getInitialProps Demo Page</span><br><span class="line">获取到的title: delectus aut autem</span><br></pre></td></tr></table></figure><p>打开浏览器的 Network 面板，找到 Name 值为<code>initial-blog</code>的请求，会看到请求响应内容的正是该页面的 HTML。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4171887a1ccc44e88da72bd43266b35b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>点击<code>返回首页</code>，再从首页点击<code>进入Initial Blog</code>，重新进入该页面，注意的是此时已经不是我们浏览器通过地址栏访问该页面，而是通过前端路由进入该页面。</p><p>查看 Network 面板的请求，会看到此时返回的是<code>getInitialProps</code>请求回来的数据，而不是 HTML 页面内容，由此可知此时页面已经交由客户端渲染。这就是所谓 SSR 渲染，首屏交给服务端渲染返回，返回后页面跳转就是客户端渲染了。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2da317e74c0482ab58d19ee7bdc51a1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="自定义-Head"><a href="#自定义-Head" class="headerlink" title="自定义 Head"></a>自定义 Head</h2><p>之所以会选择 Next.js，相信一个非常重要的原因就是有利用 SEO，那么利于爬虫检索的方式，一种就是在页面写好 TDK（title、description、keyword），Next.js 可以自定义<code>Head</code>标签</p><p>修改<code>components/header.js</code>，在最外层 div 根元素里内添加代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Head&gt;</span><br><span class="line">  &lt;title&gt;Next.js 教程 -- JackyLin&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;meta name='viewport' content='initial-scale=1.0, width=device-width' /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/Head&gt;</span></span><br></pre></td></tr></table></figure><p>打开<code>http://localhost:3000/</code>，就会看到页面的头部标签 title 已经被我们改了。</p><h2 id="LazyLoding-实现模块-组件懒加载"><a href="#LazyLoding-实现模块-组件懒加载" class="headerlink" title="LazyLoding 实现模块/组件懒加载"></a>LazyLoding 实现模块/组件懒加载</h2><p>懒加载是指需要用到或该加载到某个组件/模块的时候，才加载那个组件/模块的 js 文件，也叫异步加载。</p><p>如果页面文件内容多过大，那么可能出现首次打开速度慢，这时就需要进行优化了，懒加载就是其中一种方式。</p><h3 id="懒加载模块"><a href="#懒加载模块" class="headerlink" title="懒加载模块"></a>懒加载模块</h3><p>先安装一个处理日期时间的库</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i moment --save</span><br></pre></td></tr></table></figure><p>新建<code>pages/time.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Time = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> getTime = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setNowTime(moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [nowTime, setNowTime] = useState(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;getTime&#125;&gt;获取当前时间&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;当前时间：&#123;nowTime&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Time</span></span><br></pre></td></tr></table></figure><p>假设我们这个页面内容很多，然后你进入该页面可能不需要点击获取时间，但<code>moment</code>模块依然加载了，这就有点资源浪费。<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b24abdbe08d64eb7ae5585dcede06dee~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>于是，我们想当我们点击按钮的时候，再来加载<code>moment</code>模块，即是实现异步加载，而不是页面一进入就加载。</p><p>此时点击按钮获取时间，可看到 Network 面板看到<code>moment</code>的代码被打包成了一个<code>1.js</code>文件，这样就实现了懒加载了，这样可以减少了主要 JavaScript 包的大小,带来了更快的加载速度。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94d858ae0d074bd4939864f6105d4f3b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Time = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> getTime = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> moment = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'moment'</span>)</span><br><span class="line">    setNowTime(moment.default().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>)) <span class="comment">// 注意这里使用 default，不能直接用 moment()</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> getTime = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setNowTime(moment().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [nowTime, setNowTime] = useState(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;getTime&#125;&gt;获取当前时间&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;当前时间：&#123;nowTime&#125;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Time</span></span><br></pre></td></tr></table></figure><h3 id="懒加载组件"><a href="#懒加载组件" class="headerlink" title="懒加载组件"></a>懒加载组件</h3><p>懒加载组件需要引入 <code>next/dynamic</code>模块</p><p>新建组件<code>components/content.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Content = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Content</span><br></pre></td></tr></table></figure><p>引入<code>pages/time.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> dynamic <span class="keyword">from</span> <span class="string">'next/dynamic'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载自定义组件</span></span><br><span class="line"><span class="keyword">const</span> Content = dynamic(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'../components/content'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Time = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> getTime = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> moment = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'moment'</span>)</span><br><span class="line">    setNowTime(moment.default().format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>)) <span class="comment">// 注意这里使用 default，不能直接用 moment()</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [nowTime, setNowTime] = useState(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;button onClick=&#123;getTime&#125;&gt;获取当前时间&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;当前时间：&#123;nowTime&#125;&lt;/</span>div&gt;</span><br><span class="line">      &lt;Content /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Time</span></span><br></pre></td></tr></table></figure><p>观察 Network 可以看到 Content 组件被新单独打包成一个 js 文件</p><h2 id="打包生产环境"><a href="#打包生产环境" class="headerlink" title="打包生产环境"></a>打包生产环境</h2><p>执行</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>打包完成后，运行服务器</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>然后查看页面，打包成功！</p><p>参考：</p><ul><li><a href="https://medium.com/swlh/server-side-rendering-styled-components-with-nextjs-1db1353e915e" target="_blank" rel="noopener">Server side rendering Styled-Components with NextJS</a></li></ul>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>SSR</tag>
        <tag>NextJS</tag>
      </tags>
  </entry>
  <entry>
    <title>前端跨域解决方案归纳整理</title>
    <url>/2020/08/16/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%BD%92%E7%BA%B3%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>前端跨域的各种文章其实已经很多了，但大部分还是不太符合我胃口的介绍跨域。看来看去，如果要让自己理解印象深刻，果然还是得自己敲一敲，并总结归纳整理一篇博客出来，以此记录。</p>
<a id="more"></a>

<h2 id="跨域的限制"><a href="#跨域的限制" class="headerlink" title="跨域的限制"></a>跨域的限制</h2><p>跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。</p>
<h2 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h2><p>除非特别说明，否则下方标记的 html 文件默认都运行在 <a href="http://127.0.0.1:5500" target="_blank" rel="noopener">http://127.0.0.1:5500</a> 服务下</p>
<h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>CORS 即是指跨域资源共享。它允许浏览器向非同源服务器，发出 Ajax 请求，从而克服了 Ajax 只能同源使用的限制。这种方式的跨域主要是在后端进行设置。</p>
<p>这种方式的关键是后端进行设置，即是后端开启 Access-Control-Allow-Origin 为<code>*</code>或对应的 <code>origin</code>就可以实现跨域。</p>
<p>浏览器将 CORS 请求分成两类：简单请求和非简单请求。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<ol>
<li>请求方法是以下是三种方法之一：</li>
</ol>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<ol start="2">
<li>HTTP 的头信息不超出以下几种字段：</li>
</ol>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p><strong>简单请求</strong></p>
<p>cors.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest() xhr.open(<span class="string">'GET'</span>, <span class="string">'http://localhost:8002/request'</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p>server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'http://127.0.0.1:5500'</span>) <span class="comment">// 设置允许哪个域访问</span></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">'server ok'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8002</span>)</span><br></pre></td></tr></table></figure>

<p><strong>非简单请求</strong></p>
<p>上面的是简单请求，如果我们用非简单请求的方式，比如请求方法是 PUT，也可以通过设置实现跨域。</p>
<p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求。</p>
<p>浏览器先询问服务器，服务器收到”预检”请求以后，检查了 Origin、Access-Control-Request-Method 和 Access-Control-Request-Headers 字段以后，确认允许跨源请求，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'PUT'</span>, <span class="string">'http://localhost:8002/request'</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p>server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> whileList = [<span class="string">'http://127.0.0.1:5500'</span>] <span class="comment">// 设置白名单</span></span><br><span class="line">app.use(<span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> origin = req.headers.origin</span><br><span class="line">  <span class="built_in">console</span>.log(whitList.includes(origin))</span><br><span class="line">  <span class="keyword">if</span> (whitList.includes(origin)) &#123;</span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Origin'</span>, origin) <span class="comment">// 设置允许哪个域访问</span></span><br><span class="line">    res.setHeader(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT'</span>) <span class="comment">// 设置允许哪种请求方法访问</span></span><br><span class="line">  &#125;</span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.put(<span class="string">'/request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">'server ok'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8002</span>)</span><br></pre></td></tr></table></figure>

<p>整个过程发送了两次请求，跨域成功。</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/414b7733753342dc84384053835ad883~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>当然，还可以设置其他参数：</p>
<ul>
<li><strong>Access-Control-Request-Headers</strong></li>
</ul>
<p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段</p>
<ul>
<li><strong>Access-Control-Allow-Credentials</strong></li>
</ul>
<p>表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。</p>
<ul>
<li><strong>Access-Control-Expose-Headers</strong></li>
</ul>
<p>CORS 请求时，XMLHttpRequest 对象的 getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在 Access-Control-Expose-Headers 里面指定。</p>
<ul>
<li><strong>Access-Control-Max-Age</strong></li>
</ul>
<p>用来指定本次预检请求的有效期，单位为秒。有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。</p>
<h3 id="Node-中间件代理"><a href="#Node-中间件代理" class="headerlink" title="Node 中间件代理"></a>Node 中间件代理</h3><p>实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就没有跨域一说。</p>
<p>代理服务器，需要做以下几个步骤：</p>
<ol>
<li>接受客户端请求 。</li>
<li>将请求转发给服务器。</li>
<li>拿到服务器响应数据。</li>
<li>将响应转发给客户端。</li>
</ol>
<p>这次我们使用 express 中间件 http-proxy-middleware 来代理跨域, 转发请求和响应</p>
<p>案例三个文件都在同一级目录下：</p>
<p>index.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'/api/request'</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'请求成功，结果是：'</span>, xhr.responseText) <span class="comment">// request success</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure>

<p>nodeMdServer.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置静态资源</span></span><br><span class="line">app.use(express.static(__dirname))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用代理</span></span><br><span class="line">app.use(</span><br><span class="line">  <span class="string">'/api'</span>,</span><br><span class="line">  createProxyMiddleware(&#123;</span><br><span class="line">    target: <span class="string">'http://localhost:8002'</span>,</span><br><span class="line">    pathRewrite: &#123;</span><br><span class="line">      <span class="string">'^/api'</span>: <span class="string">''</span>, <span class="comment">// 重写路径</span></span><br><span class="line">    &#125;,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8001</span>)</span><br></pre></td></tr></table></figure>

<p>nodeServer.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/request'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  res.end(<span class="string">'request success'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8002</span>)</span><br></pre></td></tr></table></figure>

<p>运行<code>http://localhost:8001/index.html</code>，跨域成功</p>
<p>平常 vue/react 项目配置 webpack-dev-server 的时候也是通过 Node proxy 代理的方式来解决的。</p>
<h3 id="Nginx-反向代理"><a href="#Nginx-反向代理" class="headerlink" title="Nginx 反向代理"></a>Nginx 反向代理</h3><p>实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。</p>
<p>这种方式只需修改 Nginx 的配置即可解决跨域问题，前端除了接口换成对应形式，然后前后端不需要修改作其他修改。</p>
<p>实现思路：通过 nginx 配置一个代理服务器（同域不同端口）做跳板机，反向代理要跨域的域名，这样可以修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。</p>
<p>nginx 目录下的 nginx.conf 修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass   http:&#x2F;&#x2F;www.domain2.com:8080;  # 反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; # 修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http:&#x2F;&#x2F;www.domain1.com;  # 当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动 Nginx</p>
<p>index.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 访问nginx中的代理服务器</span></span><br><span class="line">xhr.open(<span class="string">'get'</span>, <span class="string">'http://www.domain1.com:81/?user=admin'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>

<p>server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">var</span> server = http.createServer()</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">'querystring'</span>)</span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> params = qs.parse(req.url.substring(<span class="number">2</span>))</span><br><span class="line">  <span class="comment">// 向前台写cookie</span></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Set-Cookie'</span>: <span class="string">'l=123456;Path=/;Domain=www.domain2.com;HttpOnly'</span>, <span class="comment">// HttpOnly:脚本无法读取</span></span><br><span class="line">  &#125;)</span><br><span class="line">  res.write(<span class="built_in">JSON</span>.stringify(params))</span><br><span class="line">  res.end()</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">8080</span>)</span><br></pre></td></tr></table></figure>

<h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p>原理：利用了 script 标签可跨域的特性，在客户端定义一个回调函数（<strong>全局函数</strong>），请求服务端返回该回调函数的调用，并将服务端的数据以该回调函数参数的形式传递过来，然后该函数就被执行了。该方法需要服务端配合完成。</p>
<p>实现步骤：</p>
<ol>
<li>声明一个全局回调函数，参数为服务端返回的 data。</li>
<li>创建一个 script 标签，拼接整个请求 api 的地址（要传入回调函数名称如 ?callback=getInfo ），赋值给 script 的 src 属性</li>
<li>服务端接受到请求后处理数据，然后将函数名和需要返回的数据拼接成字符串，拼装完成是执行函数的形式。（getInfo(‘server data’)）</li>
<li>浏览器接收到服务端的返回结果，调用了声明的回调函数。</li>
</ol>
<p>jsonp.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">// 告诉你一声， jsonp跨域成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">script.src = <span class="string">'http://localhost:3000?callback=getInfo'</span> <span class="comment">//</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br></pre></td></tr></table></figure>

<p>server.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; callback &#125; = req.query</span><br><span class="line">  res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>('告诉你一声， jsonp跨域成功')`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>

<p>jQuery 的 $.ajax() 方法当中集成了 JSONP 的实现，在此就不写出来了。</p>
<p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，而且这种方式用起来也麻烦，故我们自己封装一个 jsonp 函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">    <span class="comment">// 定义全局回调函数</span></span><br><span class="line">    <span class="built_in">window</span>[callback] = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">      <span class="built_in">document</span>.body.removeChild(script) <span class="comment">// 调用完毕即删除</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    params = &#123; callback, ...params &#125; <span class="comment">// &#123;callback: "getInfo", name: "jacky"&#125;</span></span><br><span class="line">    <span class="keyword">let</span> paramsArr = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      paramsArr.push(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;paramsArr.join(<span class="string">'&amp;'</span>)&#125;</span>`</span> <span class="comment">// http://localhost:3000/?callback=getInfo&amp;name=jacky</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    name: <span class="string">'jacky'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  callback: <span class="string">'getInfo'</span>,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">// 告诉你一声， jsonp跨域成功</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>服务端解构的时候可以取出参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; callback, name &#125; = req.query</span><br><span class="line">  res.end(<span class="string">`<span class="subst">$&#123;callback&#125;</span>('告诉你一声， jsonp跨域成功')`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>优点：兼容性好</p>
<p>缺点：由于 script 本身的限制，该跨域方式仅支持 get 请求，且不安全可能遭受 XSS 攻击</p>
<h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><p>postMessage 是 HTML5 XMLHttpRequest Level 2 中的 API，且是为数不多可以跨域操作的 window 属性之一，它可用于解决以下方面的问题：</p>
<ol>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的 iframe 消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ol>
<p>总之，它可以允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。</p>
<blockquote>
<p>otherWindow.postMessage(message, targetOrigin, [transfer]);</p>
</blockquote>
<ul>
<li>otherWindow：其他窗口的一个引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象、或者是命名过或数值索引的 window.frames。</li>
<li>message: 将要发送到其他 window 的数据。</li>
<li>targetOrigin:通过窗口的 origin 属性来指定哪些窗口能接收到消息事件，其值可以是字符串”*“（表示无限制）或者一个 URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配 targetOrigin 提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。</li>
<li>transfer(可选)：是一串和 message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。</li>
</ul>
<p>这次我们把两个 html 文件挂到两个 server 下，采取 fs 读取的方式引入，运行两个 js 文件</p>
<p>postMessage1.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:8002"</span> <span class="attr">frameborder</span>=<span class="string">"0"</span> <span class="attr">id</span>=<span class="string">"frame"</span> <span class="attr">onLoad</span>=<span class="string">"load()"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> frame = <span class="built_in">document</span>.getElementById(<span class="string">'frame'</span>)</span></span><br><span class="line"><span class="actionscript">      frame.contentWindow.postMessage(<span class="string">'你好，我是postMessage1'</span>, <span class="string">'http://localhost:8002'</span>) <span class="comment">//发送数据</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">//接受返回数据</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.data) <span class="comment">// 你好，我是postMessage2</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>postMsgServer1.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> html = fs.readFileSync(<span class="string">'./postMessage1.html'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">  res.end(html)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8001</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server listening on 8001'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>postMessage2.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(e.data) <span class="comment">// 你好，我是postMessage1</span></span></span><br><span class="line"><span class="actionscript">      e.source.postMessage(<span class="string">'你好，我是postMessage2'</span>, e.origin)</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>postMsgServer2.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> html = fs.readFileSync(<span class="string">'./postMessage2.html'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">  res.end(html)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">8002</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server listening on 8002'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><p>WebSocket 是一种网络通信协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，长连接方式不受跨域影响。由于原生 WebSocket API 使用起来不太方便，我们一般都会使用第三方库如 ws。</p>
<p>Web 浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的 HTTP 连接不同，对服务器有重要的影响。</p>
<p>socket.html（<code>http://127.0.0.1:5500/socket.html</code>）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8001'</span>)</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  socket.send(<span class="string">'向服务端发送数据'</span>)</span><br><span class="line">&#125;</span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.data) <span class="comment">// 服务端传给你的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行<code>nodeServer.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>)</span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wsServer = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8001</span> &#125;)</span><br><span class="line">wsServer.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ws</span>) </span>&#123;</span><br><span class="line">  ws.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data) <span class="comment">// 向服务端发送数据</span></span><br><span class="line">    ws.send(<span class="string">'服务端传给你的数据'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="document-domain-iframe"><a href="#document-domain-iframe" class="headerlink" title="document.domain + iframe"></a>document.domain + iframe</h3><p>这种方式只能用于二级域名相同的情况下。</p>
<p>比如 a.test.com 和 b.test.com 就属于二级域名，它们都是 test.com 的子域</p>
<p>只需要给页面添加 document.domain =’test.com’ 表示二级域名都相同就可以实现跨域。</p>
<p>比如：页面 a.test.com:3000/test1.html 获取页面 b.test.com:3000/test2.html 中 a 的值</p>
<p>test1.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"http://b.test.com:3000/test2.html"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">frameborder</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onload</span>=<span class="string">"load()"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"iframe"</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'test.com'</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(iframe.contentWindow.a)</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>test2.html</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">'test.com'</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h3 id="window-name-iframe"><a href="#window-name-iframe" class="headerlink" title="window.name + iframe"></a>window.name + iframe</h3><p>浏览器具有这样一个特性：同一个标签页或者同一个 iframe 框架加载过的页面共享相同的 window.name 属性值。在同个标签页里，name 值在不同的页面加载后也依旧存在，这些页面上 window.name 属性值都是相同的。利用这些特性，就可以将这个属性作为在不同页面之间传递数据的介质。</p>
<blockquote>
<p>由于安全原因，浏览器始终会保持 window.name 是 string 类型。</p>
</blockquote>
<p>打开<code>http://localhost:8001/a.html</code></p>
<ul>
<li><a href="http://localhost:8001/a.html" target="_blank" rel="noopener">http://localhost:8001/a.html</a></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">"http://localhost:8002/c.html"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">frameborder</span>=<span class="string">"0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onload</span>=<span class="string">"load()"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">"iframe"</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> first = <span class="literal">true</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">      if (first) &#123;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">'iframe'</span>)</span></span><br><span class="line"><span class="actionscript">        iframe.src = <span class="string">'http://localhost:8001/b.html'</span></span></span><br><span class="line"><span class="actionscript">        first = <span class="literal">false</span></span></span><br><span class="line"><span class="actionscript">      &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 第2次onload(同域b.html页)成功后，读取同域window.name中数据</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(iframe.contentWindow.name) <span class="comment">// 我是c.html里的数据</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><a href="http://localhost:8001/b.html（不需要往html加内容，默认html结构模板即可）" target="_blank" rel="noopener">http://localhost:8001/b.html（不需要往html加内容，默认html结构模板即可）</a></p>
</li>
<li><p><a href="http://localhost:8002/c.html" target="_blank" rel="noopener">http://localhost:8002/c.html</a></p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.name = <span class="string">'我是c.html里的数据'</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>c 页面给 window.name 设置了值, 即便 c 页面销毁，但 name 值不会被销毁；a 页面依旧能够得到 window.name。</p>
<h3 id="location-hash-iframe"><a href="#location-hash-iframe" class="headerlink" title="location.hash + iframe"></a>location.hash + iframe</h3><p>实现原理： a.html 欲与 c.html 跨域相互通信，通过中间页 b.html 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。</p>
<p>具体实现步骤：一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。</p>
<p>同样的，a.html 和 b.html 是同域的，都是<a href="http://localhost:8001，也就是说">http://localhost:8001，也就是说</a> b 的 hash 值可以直接复制给 a 的 hash。c.html 为<a href="http://localhost:8002下的">http://localhost:8002下的</a></p>
<p>a.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"http://localhost:8002/c.html#jackylin"</span> <span class="attr">style</span>=<span class="string">"display: none;"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="comment">// 检测hash的变化</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="number">456</span>, location.hash) <span class="comment">// #monkey</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>b.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.parent.parent.location.hash = location.hash</span><br><span class="line"><span class="comment">// b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面</span></span><br></pre></td></tr></table></figure>

<p>c.html</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(location.hash) <span class="comment">//  #jackylin</span></span><br><span class="line"><span class="keyword">let</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">iframe.src = <span class="string">'http://localhost:8001/b.html#monkey'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe)</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>CORS 支持所有的 HTTP 请求，是跨域最主流的方案</li>
<li>日常工作中，用得比较多的跨域方案是 CORS 和 Node 中间件及 Nginx 反向代理</li>
<li>不管是 Node 中间件代理还是 Nginx 反向代理，主要是通过同源策略对服务器不加限制。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享 CORS 详解</a></li>
<li><a href="https://github.com/ljianshu/Blog/issues/55" target="_blank" rel="noopener">九种跨域方式实现原理（完整版）</a></li>
<li><a href="https://juejin.im/post/6844903992057659400" target="_blank" rel="noopener">可能是最好的跨域解决方案了</a></li>
</ul>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>解决使用输入法输入在 React input 框中的问题</title>
    <url>/2020/08/14/%E8%A7%A3%E5%86%B3%E4%BD%BF%E7%94%A8%E8%BE%93%E5%85%A5%E6%B3%95%E8%BE%93%E5%85%A5%E5%9C%A8-React-input-%E6%A1%86%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在使用 React 绑定 input 输入框的 onChange 方法时，如果使用中文输入法（或者其他输入法），会出现一个问题：还在输入拼音的时候，onChange 方法已经触发了，如下，即输入过程就已经触发了多次 onChange 方法。如果 onChange 方法有较为复杂的逻辑，就可能会带来一些用户体验或者逻辑的问题。</p>
<p>本文以此问题开始，逐步探索解决方案。</p>
<a id="more"></a>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26ab509fe10d46bc97f80ee6f8728336~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>只要有按下键盘的动作，就会触发 onChange 方法，如果输入英文就没什么问题，但使用中/日/韩等输入法的话，比如输入中文拼音已经开始在触发 onChange 事件了。</p>
<h2 id="需求及解决方案"><a href="#需求及解决方案" class="headerlink" title="需求及解决方案"></a>需求及解决方案</h2><ul>
<li><p>需求：等到选择确认输入中文后，才让它触发 onChange 方法的后续操作，如改变 value 的值。</p>
</li>
<li><p>解决方案：使用 compositionEvent 事件来解决。</p>
</li>
</ul>
<blockquote>
<p>DOM 接口 CompositionEvent 表示用户间接输入文本（如使用输入法）时发生的事件。此接口的常用事件有 compositionstart, compositionupdate 和 compositionend</p>
</blockquote>
<h2 id="CompositionEvent-事件介绍"><a href="#CompositionEvent-事件介绍" class="headerlink" title="CompositionEvent 事件介绍"></a>CompositionEvent 事件介绍</h2><ul>
<li>compositionstart</li>
</ul>
<p>当用户使用输入法如拼音输入汉字时，这个事件就会被触发，即是在用户开始非直接输入的时候触发，在非直接输入的时候结束，整个过程只触发了一次。</p>
<ul>
<li>compositionupdate</li>
</ul>
<p>事件触发于字符被输入到一段文字的时候，如在用户开始输入拼音到确定结束的过程都会触发该事件。</p>
<ul>
<li>compositionend</li>
</ul>
<p>当文本段落的组成完成或取消时, compositionend 事件将被触发 。如用户点击拼音输入法选词确定后，则触发了该事件，此时是直接输入了，整个过程只触发了一次。</p>
<p>可以知道这三个事件就把我们输入中文拼音的三个过程进行了拆分。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们通过监听输入法开始输入到结束的事件，即是去监听<code>compositionstart</code>和<code>compositionend</code>方法，通过设置一个变量，在两个方法里面设置 true/false，来判断是否处在中文输入拼音这个过程当中，如果是，则不触发 onChange 后续事件。</p>
<p>这个未必是优化。搜索框提示的一个很重要用处，不是帮助省出来那么一点打字的时间，而是为了提示打字人应该写什么。很多时候打字者只有一个模糊的需求，全靠搜索框提示才能明白自己真正想搜什么。而这时候对拼音进行搜索提示，不说提醒用户该拼音词也可以搜到结果，单说在某种可能的用况下会避免用户搜索整个输入法却找不到对应汉字（因为输入错误拼音）这点就非常好用了。</p>
<p>如下代码，我们通过设置个对照：value1 对应的为正常 onChange 操作，value2 对应的则是做了输入法处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isComposition = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestComposition</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value1: <span class="string">''</span>,</span><br><span class="line">      value2: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.handleChange1 = <span class="keyword">this</span>.handleChange1.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.handleChange2 = <span class="keyword">this</span>.handleChange2.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.handleComposition = <span class="keyword">this</span>.handleComposition.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange1 = <span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      value1: ev.target.value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange2 = <span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 未使用输入法或使用输入法完毕才能触发</span></span><br><span class="line">    <span class="keyword">if</span> (!isComposition) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value2: ev.target.value,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleComposition(ev) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.type === <span class="string">'compositionend'</span>) &#123;</span><br><span class="line">      isComposition = <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      isComposition = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">'text'</span> onChange=&#123;<span class="keyword">this</span>.handleChange1&#125; /&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.value1&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type='text'</span></span><br><span class="line"><span class="regexp">          onChange=&#123;this.handleChange2&#125;</span></span><br><span class="line"><span class="regexp">          onCompositionStart=&#123;this.handleComposition&#125;</span></span><br><span class="line"><span class="regexp">          onCompositionEnd=&#123;this.handleComposition&#125;</span></span><br><span class="line"><span class="regexp">          placeholder='使用了composition的input框'</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.value2&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TestComposition</span><br></pre></td></tr></table></figure>

<p>那么这样就能解决了吗？还不行。</p>
<p>其他浏览器不会有问题，但谷歌浏览器却不行。这里要注意的是谷歌浏览器跟其他浏览器的执行顺序不同：</p>
<blockquote>
<p>谷歌浏览器： compositionstart -&gt; onChange -&gt; compositionend</p>
</blockquote>
<blockquote>
<p>其他浏览器： compositionstart -&gt; compositionend -&gt; onChange</p>
</blockquote>
<p>所以上述代码运行在谷歌浏览器的话，一开始中文输入我们就将 isComposition 设置为 true，最后一步 compositionend 方法我们才将 isComposition 恢复为 true,而 onChange 已经执行完了， 按这个逻辑中文输入法打字都改不了 input 的 value 值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isComposition) &#123;</span><br><span class="line">  <span class="comment">// isComposition为false 才可以执行onChange后续逻辑</span></span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    value2: ev.target.value,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们需要对谷歌浏览器做一次特别处理：</p>
<ol>
<li>判断是否为谷歌浏览器</li>
<li>如果是，则在 compositionend 方法最后再执行一次 onChange 方法</li>
</ol>
<p>最后附上完整代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isComposition = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> isChrome = navigator.userAgent.indexOf(<span class="string">'Chrome'</span>) &gt; <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestComposition</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value1: <span class="string">''</span>,</span><br><span class="line">      value2: <span class="string">''</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.handleChange1 = <span class="keyword">this</span>.handleChange1.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.handleChange2 = <span class="keyword">this</span>.handleChange2.bind(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">this</span>.handleComposition = <span class="keyword">this</span>.handleComposition.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange1 = <span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      value1: ev.target.value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange2 = <span class="function"><span class="params">ev</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 未使用输入法或使用输入法完毕才能触发</span></span><br><span class="line">    <span class="keyword">if</span> (!isComposition) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value2: ev.target.value,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleComposition(ev) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ev.type === <span class="string">'compositionend'</span>) &#123;</span><br><span class="line">      isComposition = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">if</span> (!isComposition &amp;&amp; isChrome) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handleChange2(ev)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      isComposition = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=<span class="string">'text'</span> onChange=&#123;<span class="keyword">this</span>.handleChange1&#125; /&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.value1&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          type='text'</span></span><br><span class="line"><span class="regexp">          onChange=&#123;this.handleChange2&#125;</span></span><br><span class="line"><span class="regexp">          onCompositionStart=&#123;this.handleComposition&#125;</span></span><br><span class="line"><span class="regexp">          onCompositionEnd=&#123;this.handleComposition&#125;</span></span><br><span class="line"><span class="regexp">          placeholder='使用了composition的input框'</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &lt;span&gt;&#123;<span class="keyword">this</span>.state.value2&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TestComposition</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ac3e7f8896b4d608c1ae46ee22f0866~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>注：</p>
<ul>
<li>Vue 自带解决了上述问题，v-model 有用到 compositionEvent 事件</li>
<li>该做法视乎项目需求场景，因为如果有需要进行搜索中文拼音过程也要提示英文单词的来说，那就没必要了</li>
<li>也可以使用 ref 的方式进行绑定，上述只是其中一种解决方式</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/CompositionEvent" target="_blank" rel="noopener">MDN：CompositionEvent</a></li>
<li><a href="https://www.yukapril.com/2019/11/11/react-input-composition.html" target="_blank" rel="noopener">中文输入法在 React 文本输入框的特殊处理</a></li>
</ul>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，鼓励我继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>compositionEvent</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS水平垂直居中回顾总结</title>
    <url>/2020/08/09/CSS%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%9B%9E%E9%A1%BE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>用了一段时间的 material-ui，都很少自己动手写原生的样式了。但 html, css, js 始终是前端的三大基础，这周突然想到 CSS 水平居中方案，因为用多了 <code>flex</code> 和 <code>margin: auto</code>等这类方案解决，在回顾还有还有几种方案可以解决，于是打算温故知新，重新打下代码，写下该文作为笔记。</p>
<a id="more"></a>

<p>html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面代码基于上述代码增加，不会再重复写。要实现的效果是让子元素在父元素中水平垂直居中<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d9ccfcd90a64bd58de3cf3e972c5981~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="一、flex-布局"><a href="#一、flex-布局" class="headerlink" title="一、flex 布局"></a>一、flex 布局</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是最经典的用法了，不过，也可以有另一种写法实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    align-self: center;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、absolute-负-margin"><a href="#二、absolute-负-margin" class="headerlink" title="二、absolute + 负 margin"></a>二、absolute + 负 margin</h2><p>该方法适用于知道固定宽高的情况。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、absolute-transform"><a href="#三、absolute-transform" class="headerlink" title="三、absolute + transform"></a>三、absolute + transform</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、absolute-margin-auto"><a href="#四、absolute-margin-auto" class="headerlink" title="四、absolute + margin auto"></a>四、absolute + margin auto</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、absolute-calc"><a href="#五、absolute-calc" class="headerlink" title="五、absolute + calc"></a>五、absolute + calc</h2><p>该方法适用于知道固定宽高的情况。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="六、text-align-vertical-align"><a href="#六、text-align-vertical-align" class="headerlink" title="六、text-align + vertical-align"></a>六、text-align + vertical-align</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">300px</span>; <span class="comment">/* 等于 parent 的 height */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">line-height</span>: initial; <span class="comment">/* 这样 child 内的文字就不会超出跑到下面 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="七、table-cell"><a href="#七、table-cell" class="headerlink" title="七、table-cell"></a>七、table-cell</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、Grid"><a href="#八、Grid" class="headerlink" title="八、Grid"></a>八、Grid</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: center;</span><br><span class="line">  <span class="attribute">justify-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="九、writing-mode"><a href="#九、writing-mode" class="headerlink" title="九、writing-mode"></a>九、writing-mode</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">writing-mode</span>: vertical-lr;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">writing-mode</span>: horizontal-tb;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励吧~</li>
</ul>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>封装 axios 拦截器实现用户无感刷新 access_token</title>
    <url>/2020/07/26/%E5%B0%81%E8%A3%85-axios-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E6%97%A0%E6%84%9F%E5%88%B7%E6%96%B0-access-token/</url>
    <content><![CDATA[<p>最近做项目的时候，涉及到一个单点登录，即是项目的登录页面，用的是公司共用的一个登录页面，在该页面统一处理逻辑。最终实现用户只需登录一次，就可以以登录状态访问公司旗下的所有网站。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>单点登录( Single Sign On ，简称 SSO），是目前比较流行的企业业务整合的解决方案之一，用于多个应用系统间，用户只需要登录一次就可以访问所有相互信任的应用系统。</p>
</blockquote>
<p>其中本文讲的是在登录后如何管理<code>access_token</code>和<code>refresh_token</code>，主要就是封装 axios拦截器，在此记录。</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul>
<li>前置场景</li>
</ul>
<ol>
<li><p>进入该项目某个页面<code>http://xxxx.project.com/profile</code>需要登录，未登录就跳转至SSO登录平台，此时的登录网址 url为<code>http://xxxxx.com/login?app_id=project_name_id&amp;redirect_url=http://xxxx.project.com/profile</code>，其中<code>app_id</code>是后台那边约定定义好的，<code>redirect_url</code>是成功授权后指定的回调地址。</p>
</li>
<li><p>输入账号密码且正确后，就会重定向回刚开始进入的页面，并在地址栏带一个参数 <code>?code=XXXXX</code>，即是<code>http://xxxx.project.com/profile?code=XXXXXX</code>，code的值是使用一次后即无效，且10分钟内过期</p>
</li>
<li><p>立马获取这个code值再去请求一个api <code>/access_token/authenticate</code>，携带参数<code>{ verify_code: code }</code>，并且该api已经自带<code>app_id</code>和<code>app_secret</code>两个固定值参数，通过它去请求授权的api，请求成功后得到返回值<code>{ access_token: &quot;xxxxxxx&quot;, refresh_token: &quot;xxxxxxxx&quot;, expires_in: xxxxxxxx }</code>，存下<code>access_token</code>和<code>refresh_token</code>到cookie中（localStorage也可以），此时用户就算登录成功了。</p>
</li>
<li><p><code>access_token</code>为标准JWT格式，是授权令牌，可以理解就是验证用户身份的，是应用在调用api访问和修改用户数据必须传入的参数（放在请求头headers里），2小时后过期。也就是说，做完前三步后，你可以调用需要用户登录才能使用的api；但是假如你什么都不操作，静静过去两个小时后，再去请求这些api，就会报<code>access_token</code>过期，调用失败。</p>
</li>
<li><p>那么总不能2小时后就让用户退出登录吧，解决方法就是两小时后拿着过期的<code>access_token</code>和<code>refresh_token</code>（<code>refresh_token</code>过期时间一般长一些，比如一个月或更长）去请求<code>/refresh</code> api，返回结果为<code>{ access_token: &quot;xxxxx&quot;, expires_in: xxxxx }</code>，换取新的<code>access_token</code>，新的<code>access_token</code>过期时间也是2小时，并重新存到cookie，循环往复继续保持登录调用用户api了。<code>refresh_token</code>在限定过期时间内（比如一周或一个月等），下次就可以继续换取新的<code>access_token</code>，但过了限定时间，就算真正意义过期了，也就要重新输入账号密码来登录了。</p>
</li>
</ol>
<p>公司网站登录过期时间都只有两小时（token过期时间），但又想让一个月内经常活跃的用户不再次登录，于是才有这样需求，避免了用户再次输入账号密码登录。</p>
<p>为什么要专门用一个 <code>refresh_token</code> 去更新 <code>access_token</code> 呢？首先<code>access_token</code>会关联一定的用户权限，如果用户授权更改了，这个<code>access_token</code>也是需要被刷新以关联新的权限的，如果没有 <code>refresh_token</code>，也可以刷新 <code>access_token</code>，但每次刷新都要用户输入登录用户名与密码，多麻烦。有了 <code>refresh_ token</code>，可以减少这个麻烦，客户端直接用 <code>refresh_token</code> 去更新 <code>access_token</code>，无需用户进行额外的操作。</p>
<p>说了这么多，或许有人会吐槽，一个登录用<code>access_token</code>就行了还要加个<code>refresh_token</code>搞得这么麻烦，或者有的公司<code>refresh_token</code>是后台包办的并不需要前端处理。但是，前置场景在那了，需求都是基于该场景下的。</p>
<ul>
<li>需求</li>
</ul>
<ol>
<li><p>当<code>access_token</code>过期的时候，要用<code>refresh_token</code>去请求获取新的<code>access_token</code>，前端需要做到用户无感知的刷新<code>access_token</code>。比如用户发起一个请求时，如果判断<code>access_token</code>已经过期，那么就先要去调用刷新token接口拿到新的<code>access_token</code>，再重新发起用户请求。</p>
</li>
<li><p>如果同时发起多个用户请求，第一个用户请求去调用刷新token接口，当接口还没返回时，其余的用户请求也依旧发起了刷新token接口请求，就会导致多个请求，这些请求如何处理，就是我们本文的内容了。</p>
</li>
</ol>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>写在请求拦截器里，在请求前，先利用最初请求返回的字段<code>expires_in</code>字段来判断<code>access_token</code>是否已经过期，若已过期，则将请求挂起，先刷新<code>access_token</code>后再继续请求。</p>
<ul>
<li>优点： 能节省http请求</li>
<li>缺点： 因为使用了本地时间判断，若本地时间被篡改，有校验失败的风险</li>
</ul>
<h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>写在响应拦截器里，拦截返回后的数据。先发起用户请求，如果接口返回<code>access_token</code>过期，先刷新<code>access_token</code>，再进行一次重试。</p>
<ul>
<li>优点：无需判断时间</li>
<li>缺点： 会消耗多一次http请求</li>
</ul>
<p>在此我选择的是方案二。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里使用axios，其中做的是请求后拦截，所以用到的是axios的响应拦截器<code>axios.interceptors.response.use()</code>方法</p>
<h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><ul>
<li><p>@utils/auth.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Cookies <span class="keyword">from</span> <span class="string">'js-cookie'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TOKEN_KEY = <span class="string">'access_token'</span></span><br><span class="line"><span class="keyword">const</span> REGRESH_TOKEN_KEY = <span class="string">'refresh_token'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getToken = <span class="function"><span class="params">()</span> =&gt;</span> Cookies.get(TOKEN_KEY)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setToken = <span class="function">(<span class="params">token, params = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  Cookies.set(TOKEN_KEY, token, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> setRefreshToken = <span class="function">(<span class="params">token</span>) =&gt;</span> &#123;</span><br><span class="line">  Cookies.set(REGRESH_TOKEN_KEY, token)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>request.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken, setToken, getRefreshToken &#125; <span class="keyword">from</span> <span class="string">'@utils/auth'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新 access_token 的接口</span></span><br><span class="line"><span class="keyword">const</span> refreshToken = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> instance.post(<span class="string">'/auth/refresh'</span>, &#123; <span class="attr">refresh_token</span>: getRefreshToken() &#125;, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 axios 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL:  process.env.GATSBY_API_URL,</span><br><span class="line">  timeout: <span class="number">30000</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error.response) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// token 过期或无效，返回 401 状态码，在此处理逻辑</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给请求头添加 access_token</span></span><br><span class="line"><span class="keyword">const</span> setHeaderToken = <span class="function">(<span class="params">isNeedToken</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> accessToken = isNeedToken ? getToken() : <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (isNeedToken) &#123; <span class="comment">// api 请求需要携带 access_token </span></span><br><span class="line">    <span class="keyword">if</span> (!accessToken) &#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'不存在 access_token 则跳转回登录页'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    instance.defaults.headers.common.Authorization = <span class="string">`Bearer <span class="subst">$&#123;accessToken&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有些 api 并不需要用户授权使用，则不携带 access_token；默认不携带，需要传则设置第三个参数为 true</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="keyword">get</span> = (url, params = &#123;&#125;, isNeedToken = <span class="literal">false</span>) =&gt; &#123;</span><br><span class="line">  setHeaderToken(isNeedToken)</span><br><span class="line">  <span class="keyword">return</span> instance(&#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    url,</span><br><span class="line">    params,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> post = <span class="function">(<span class="params">url, params = &#123;&#125;, isNeedToken = <span class="literal">false</span></span>) =&gt;</span> &#123;</span><br><span class="line">  setHeaderToken(isNeedToken)</span><br><span class="line">  <span class="keyword">return</span> instance(&#123;</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    url,</span><br><span class="line">    data: params,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>接下来改造 request.js中axios的响应拦截器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error.response) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error.response.status === <span class="number">401</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; config &#125; = error</span><br><span class="line">        <span class="keyword">return</span> refreshToken().then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; access_token &#125; = res.data</span><br><span class="line">            setToken(access_token)</span><br><span class="line">            config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;access_token&#125;</span>`</span></span><br><span class="line">            <span class="keyword">return</span> instance(config)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'抱歉，您的登录状态已失效，请重新登录！'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>约定返回401状态码表示<code>access_token</code>过期或者无效，如果用户发起一个请求后返回结果是<code>access_token</code>过期，则请求刷新<code>access_token</code>的接口。请求成功则进入<code>then</code>里面，重置配置，并刷新<code>access_token</code>并重新发起原来的请求。</p>
<p>但如果<code>refresh_token</code>也过期了，则请求也是返回401。此时调试会发现函数进不到<code>refreshToken()</code>的<code>catch</code>里面，那是因为<code>refreshToken()</code>方法内部是也是用了同个<code>instance</code>实例，重复响应拦截器401的处理逻辑，但该函数本身就是刷新<code>access_token</code>，故需要把该接口排除掉，即：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (error.response.status === <span class="number">401</span> &amp;&amp; !error.config.url.includes(<span class="string">'/auth/refresh'</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就已经实现了无感刷新<code>access_token</code>了，当<code>access_token</code>没过期，正常返回；过期时，则axios内部进行了一次刷新token的操作，再重新发起原来的请求。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="防止多次刷新-token"><a href="#防止多次刷新-token" class="headerlink" title="防止多次刷新 token"></a>防止多次刷新 token</h3><p>如果token是过期的，那请求刷新<code>access_token</code>的接口返回也是有一定时间间隔，如果此时还有其他请求发过来，就会再执行一次刷新<code>access_token</code>的接口，就会导致多次刷新<code>access_token</code>。因此，我们需要做一个判断，定义一个标记判断当前是否处于刷新<code>access_token</code>的状态，如果处在刷新状态则不再允许其他请求调用该接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isRefreshing = <span class="literal">false</span> <span class="comment">// 标记是否正在刷新 token</span></span><br><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error.response) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error.response.status === <span class="number">401</span> &amp;&amp; !error.config.url.includes(<span class="string">'/auth/refresh'</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; config &#125; = error</span><br><span class="line">        <span class="keyword">if</span> (!isRefreshing) &#123;</span><br><span class="line">            isRefreshing = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> refreshToken().then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; access_token &#125; = res.data</span><br><span class="line">                setToken(access_token)</span><br><span class="line">                config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;access_token&#125;</span>`</span></span><br><span class="line">                <span class="keyword">return</span> instance(config)</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'抱歉，您的登录状态已失效，请重新登录！'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">            &#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                isRefreshing = <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="同时发起多个请求的处理"><a href="#同时发起多个请求的处理" class="headerlink" title="同时发起多个请求的处理"></a>同时发起多个请求的处理</h3><p>上面做法还不够，因为如果同时发起多个请求，在token过期的情况，第一个请求进入刷新token方法，则其他请求进去没有做任何逻辑处理，单纯返回失败，最终只执行了第一个请求，这显然不合理。</p>
<p>比如同时发起三个请求，第一个请求进入刷新token的流程，第二个和第三个请求需要存起来，等到token更新后再重新发起请求。</p>
<p>在此，我们定义一个数组<code>requests</code>，用来保存处于等待的请求，之后返回一个<code>Promise</code>，只要不调用<code>resolve</code>方法，该请求就会处于等待状态，则可以知道其实数组存的是函数；等到token更新完毕，则通过数组循环执行函数，即逐个执行resolve重发请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isRefreshing = <span class="literal">false</span> <span class="comment">// 标记是否正在刷新 token</span></span><br><span class="line"><span class="keyword">let</span> requests = [] <span class="comment">// 存储待重发请求的数组</span></span><br><span class="line"></span><br><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error.response) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error.response.status === <span class="number">401</span> &amp;&amp; !error.config.url.includes(<span class="string">'/auth/refresh'</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; config &#125; = error</span><br><span class="line">        <span class="keyword">if</span> (!isRefreshing) &#123;</span><br><span class="line">            isRefreshing = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> refreshToken().then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; access_token &#125; = res.data</span><br><span class="line">                setToken(access_token)</span><br><span class="line">                config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;access_token&#125;</span>`</span></span><br><span class="line">                <span class="comment">// token 刷新后将数组的方法重新执行</span></span><br><span class="line">                requests.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(access_token))</span><br><span class="line">                requests = [] <span class="comment">// 重新请求完清空</span></span><br><span class="line">                <span class="keyword">return</span> instance(config)</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'抱歉，您的登录状态已失效，请重新登录！'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">            &#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                isRefreshing = <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回未执行 resolve 的 Promise</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 用函数形式将 resolve 存入，等待刷新后再执行</span></span><br><span class="line">                requests.push(<span class="function"><span class="params">token</span> =&gt;</span> &#123;</span><br><span class="line">                    config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">                    resolve(instance(config))</span><br><span class="line">                &#125;)  </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>最终 request.js 代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> &#123; getToken, setToken, getRefreshToken &#125; <span class="keyword">from</span> <span class="string">'@utils/auth'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新 access_token 的接口</span></span><br><span class="line"><span class="keyword">const</span> refreshToken = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> instance.post(<span class="string">'/auth/refresh'</span>, &#123; <span class="attr">refresh_token</span>: getRefreshToken() &#125;, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 axios 实例</span></span><br><span class="line"><span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL:  process.env.GATSBY_API_URL,</span><br><span class="line">  timeout: <span class="number">30000</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> isRefreshing = <span class="literal">false</span> <span class="comment">// 标记是否正在刷新 token</span></span><br><span class="line"><span class="keyword">let</span> requests = [] <span class="comment">// 存储待重发请求的数组</span></span><br><span class="line"></span><br><span class="line">instance.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;, error =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error.response) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error.response.status === <span class="number">401</span> &amp;&amp; !error.config.url.includes(<span class="string">'/auth/refresh'</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; config &#125; = error</span><br><span class="line">        <span class="keyword">if</span> (!isRefreshing) &#123;</span><br><span class="line">            isRefreshing = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span> refreshToken().then(<span class="function"><span class="params">res</span>=&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> &#123; access_token &#125; = res.data</span><br><span class="line">                setToken(access_token)</span><br><span class="line">                config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;access_token&#125;</span>`</span></span><br><span class="line">                <span class="comment">// token 刷新后将数组的方法重新执行</span></span><br><span class="line">                requests.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb(access_token))</span><br><span class="line">                requests = [] <span class="comment">// 重新请求完清空</span></span><br><span class="line">                <span class="keyword">return</span> instance(config)</span><br><span class="line">            &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'抱歉，您的登录状态已失效，请重新登录！'</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">            &#125;).finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                isRefreshing = <span class="literal">false</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 返回未执行 resolve 的 Promise</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 用函数形式将 resolve 存入，等待刷新后再执行</span></span><br><span class="line">                requests.push(<span class="function"><span class="params">token</span> =&gt;</span> &#123;</span><br><span class="line">                    config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">                    resolve(instance(config))</span><br><span class="line">                &#125;)  </span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给请求头添加 access_token</span></span><br><span class="line"><span class="keyword">const</span> setHeaderToken = <span class="function">(<span class="params">isNeedToken</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> accessToken = isNeedToken ? getToken() : <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (isNeedToken) &#123; <span class="comment">// api 请求需要携带 access_token </span></span><br><span class="line">    <span class="keyword">if</span> (!accessToken) &#123; </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'不存在 access_token 则跳转回登录页'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    instance.defaults.headers.common.Authorization = <span class="string">`Bearer <span class="subst">$&#123;accessToken&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有些 api 并不需要用户授权使用，则无需携带 access_token；默认不携带，需要传则设置第三个参数为 true</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="keyword">get</span> = (url, params = &#123;&#125;, isNeedToken = <span class="literal">false</span>) =&gt; &#123;</span><br><span class="line">  setHeaderToken(isNeedToken)</span><br><span class="line">  <span class="keyword">return</span> instance(&#123;</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    url,</span><br><span class="line">    params,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> post = <span class="function">(<span class="params">url, params = &#123;&#125;, isNeedToken = <span class="literal">false</span></span>) =&gt;</span> &#123;</span><br><span class="line">  setHeaderToken(isNeedToken)</span><br><span class="line">  <span class="keyword">return</span> instance(&#123;</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    url,</span><br><span class="line">    data: params,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>參考文章</li>
</ul>
<p><a href="https://juejin.im/post/5d5ccdd75188255625591357" target="_blank" rel="noopener">https://juejin.im/post/5d5ccdd75188255625591357</a></p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手带你入门Gatsby</title>
    <url>/2020/07/12/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E5%85%A5%E9%97%A8Gatsby/</url>
    <content><![CDATA[<p>最近在学习 Gatsby，它主要有 SEO 好，而且首页渲染快等优点，在国外很流行的一个框架，这篇长文带你入个门。Gatsby 是一个静态站点生成器，Gatsby 主要的应用的技术是 React 和 GraphQL…</p><a id="more"></a><h2 id="Gatsby-介绍"><a href="#Gatsby-介绍" class="headerlink" title="Gatsby 介绍"></a>Gatsby 介绍</h2><h3 id="什么是-Gatsby"><a href="#什么是-Gatsby" class="headerlink" title="什么是 Gatsby"></a>什么是 Gatsby</h3><p>Gatsby 是一个基于 React ，用于搭建静态站点的开源框架，用于帮助开发者构建运行速度极快的网站。可以说它是一个静态站点生成器，Gatsby 主要的应用的技术是 React 和 GraphQL。</p><p>官网：<a href="https://www.gatsbyjs.org/" target="_blank" rel="noopener">https://www.gatsbyjs.org/</a></p><h3 id="为什么选-Gatsby"><a href="#为什么选-Gatsby" class="headerlink" title="为什么选 Gatsby"></a>为什么选 Gatsby</h3><p>Gatsby 能快速使用 React 生态系统来生成静态网站，它具备更高的性能，而且 Gatsby 的生态也很强大。</p><p>当你想自己动手搭建个人博客时，考虑的是 SEO 要好，而且你不用理会数据库和服务器等复杂的部署设置，Gatsby 构建的网站为静态站点，你可以很轻松的将网站部署在很多服务上。Gatsby 不需要等待请求时生成页面，而是预先生成页面，因此网站的速度会很快。</p><p>Gatsby 中运用了 React, react-router, Webpack 以及 GraphQL 等新技术，也跟随了技术潮流。</p><h2 id="GraphQL-介绍"><a href="#GraphQL-介绍" class="headerlink" title="GraphQL 介绍"></a>GraphQL 介绍</h2><p>上面我们说到了 GraphQL，没了解的同学可能不太清楚。</p><blockquote><p>GraphQL 是一种用于 API 的查询语言，是 Restful API 的替代品。</p></blockquote><p>至于替代 Restful API 一说，个人觉得现在 Restful API 占据绝对的主导地位，当前还是很难被撼动的。因为目前来看，GraphQL 也有它的缺点。</p><p>看到这里没学过 GraphQL 也不用怕，因为用到的不多而且 Gatsby 内置一个界面方便我们操作。GraphQL 目前国外比较火，它作为一门新技术，即使不深入我们也可以了解一下。</p><p>这里我们当然要吹捧它的优点，上面的定义你可能会疑惑，API 不就是后端写好的接口吗，怎么还能查询？</p><p>GraphQL 我们把这个单词拆开的话是： Graph(图形或图表) + QL（Query Language），它是一种图形化的查询语言，描述客户端如何像服务端请求数据的语法规范。听起来模模糊糊，那它相对 Restful API 又解决了什么痛点呢？</p><ol><li>请求你所要的数据不多不少</li></ol><p>相信多数人肯定遇到过的场景，比如项目管理系统，进入某页面展示一个列表，列表上只需展示标题，但你请求返回的数据却多了其他信息，比如创建者、创建时间等。这些信息在这里是多余的，但它可能有它自己存在的理由，或许是其他场景需要返回这些信息，因此该接口就直接包含了所有数据。</p><p>这一点，GraphQL 能准确获取你想要的数据，不多不少，想要返回指定的什么数据，就返回什么数据。数据由应用来控制，而不是服务器。</p><ol start="2"><li>获取多个资源只需要一个请求</li></ol><p>GraphQL 查询不仅能够获得资源的属性，还能沿着资源间引用进一步查询。典型的 REST API 请求多个资源时得载入多个 URL，而 GraphQL 可以通过一次请求就获取你应用所需的所有数据。这样一来，即使是比较慢的移动网络连接下，使用 GraphQL 的应用也能表现得足够迅速。</p><ol start="3"><li>描述所有的可能类型系统</li></ol><p>GraphQL API 基于类型和字段的方式进行组织，而非入口端点。你可以通过一个单一入口端点得到你所有的数据能力。GraphQL 使用类型来保证应用只请求可能的数据，还提供了清晰的辅助性错误信息。应用可以使用类型，而避免编写手动解析代码。</p><p>Gatsby 使用了 GraphQL，作为在本地管理资源的一种方式。</p><h2 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h2><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul><li>安装 Gatsby 脚手架</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g gatsby-cli</span><br></pre></td></tr></table></figure><ul><li>新建项目</li></ul><blockquote><p>gatsby new [projectName][starter]：根据 starter 创建一个新项目</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gatsby new gatsby-blog-demo https:&#x2F;&#x2F;github.com&#x2F;gatsbyjs&#x2F;gatsby-starter-hello-world</span><br></pre></td></tr></table></figure><p>我们这里使用官方最简单版本的 hello-world 模板进行开发，如果你直接使用</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gatsby new gatsby-blog-demo</span><br></pre></td></tr></table></figure><p>默认会使用 <a href="https://github.com/gatsbyjs/gatsby-starter-default" target="_blank" rel="noopener">gatsby-starter-default</a> 来新建项目</p><ul><li>运行项目</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd gatsby-blog-demo</span><br><span class="line">gatsby develop</span><br></pre></td></tr></table></figure><p>打开 <code>localhost:8000</code>，就可以看到输出了一句<code>Hello world!</code></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p>这里介绍 Gatsby 的几个常用命令：</p><ul><li>gastby develop：开启热加载开发环境</li><li>gastby build：打包到 public 下，构建生产环境用的优化过的静态网站所需的一切静态资源、静态页面与 js 代码</li><li>gatsby serve：在打包之后，启动一个本地的服务，供你测试刚才”gatsby build”生成的静态网页</li></ul><h3 id="GraphiQL"><a href="#GraphiQL" class="headerlink" title="GraphiQL"></a>GraphiQL</h3><p>打开<code>http://localhost:8000/__graphql</code>，就会看到 GraphQL 的调试界面，这里可以查看所有的数据、以及调试 query 语句是否返回相应的数据。可以直接在左侧点击选中，就可以自动生成 query 语句。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d4b8f913506df?w=1922&h=538&f=png&s=78717" alt=""></p><h3 id="可能出现的警告"><a href="#可能出现的警告" class="headerlink" title="可能出现的警告"></a>可能出现的警告</h3><p>如果运行后你的控制台出现：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">React-Hot-Loader: react-🔥-dom patch is not detected. React 16.6+ features may not work.</span><br></pre></td></tr></table></figure><p>可以这样解决:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install @hot-loader&#x2F;react-dom</span><br></pre></td></tr></table></figure><p>在根目录下新建<code>gatsby-node.js</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exports.onCreateWebpackConfig &#x3D; (&#123; getConfig, stage &#125;) &#x3D;&gt; &#123;</span><br><span class="line">  const config &#x3D; getConfig()</span><br><span class="line">  if (stage.startsWith(&#39;develop&#39;) &amp;&amp; config.resolve) &#123;</span><br><span class="line">    config.resolve.alias &#x3D; &#123;</span><br><span class="line">      ...config.resolve.alias,</span><br><span class="line">      &#39;react-dom&#39;: &#39;@hot-loader&#x2F;react-dom&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再重新启动项目，就可以消除这个警告</p><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── .cache</span><br><span class="line">├── public</span><br><span class="line">├── src</span><br><span class="line">|  └── pages            &#x2F;&#x2F; 该文件夹下的文件会被映射为路由</span><br><span class="line">|     └── index.js</span><br><span class="line">├── static              &#x2F;&#x2F; 静态资源</span><br><span class="line">├── .prettierignore</span><br><span class="line">├── .prettierrc</span><br><span class="line">├── gatsby-config.js    &#x2F;&#x2F; 基本配置文件</span><br><span class="line">├── LICENSE</span><br><span class="line">├── package.json</span><br><span class="line">├── README.md</span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><h2 id="Gatsby-配置文件"><a href="#Gatsby-配置文件" class="headerlink" title="Gatsby 配置文件"></a>Gatsby 配置文件</h2><p>这里最初始的模板只有一个配置文件，一般项目中都会有 4 个配置文件</p><h3 id="gatsby-config-js"><a href="#gatsby-config-js" class="headerlink" title="gatsby-config.js"></a>gatsby-config.js</h3><p>基本配置文件。整个 Gatsby 站点的配置文件。可以在里面配置网站的相关基本信息。</p><h3 id="gatsby-node-js"><a href="#gatsby-node-js" class="headerlink" title="gatsby-node.js"></a>gatsby-node.js</h3><p>node 相关配置文件。这个文件只会在 build 期间运行一次，比如动态创建一些页面。</p><h3 id="gatsby-browser-js"><a href="#gatsby-browser-js" class="headerlink" title="gatsby-browser.js"></a>gatsby-browser.js</h3><p>客户端相关配置。一些浏览器相关的 API 通过在这个文件里去实现，比如一些监听路由变化，注册 serviceWorker 等等。</p><h3 id="gatsby-ssr-js"><a href="#gatsby-ssr-js" class="headerlink" title="gatsby-ssr.js"></a>gatsby-ssr.js</h3><p>服务端渲染相关配置文件。使用 Gatsby 的服务端渲染 API 自定义影响服务端渲染的默认设置。</p><h2 id="创建页面"><a href="#创建页面" class="headerlink" title="创建页面"></a>创建页面</h2><h3 id="路由页"><a href="#路由页" class="headerlink" title="路由页"></a>路由页</h3><p>我们在 <code>pages</code>目录下创建一个文件<code>about.js</code>，则对应的路由路径为<code>/about</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>about me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> About</span><br></pre></td></tr></table></figure><p>打开<code>http://localhost:8000/about</code>，显示的是我们刚刚创建的页面</p><h3 id="404-页面"><a href="#404-页面" class="headerlink" title="404 页面"></a>404 页面</h3><p><code>pages</code>目录下的文件名即是路由路径，但有一个比较特殊，当匹配不到路径时，Gatsby 会跳转到 404 页面，如果我们在 pages 下创建文件名<code>404.js</code>，会使用我们自定义的 404 页面。当前我们随便输入一个不存在的页面路径：<code>http://localhost:8000/test</code>，页面就会报错。</p><p>我们新建一个文件 404.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>404 页面不存在<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> About</span><br></pre></td></tr></table></figure><p>再随便输入一个路径，显示出该页面：<br><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d52ba499ad501?w=1223&h=404&f=png&s=37041" alt=""></p><p>Gatsby 会确保将 404 页面构建为 404.html，默认情况下会为我们创建此页面，在该页面也列出了网站上的所有页面路由链接,我们可以通过单击<code>Preview custom 404 page</code>看我们刚才创建的 404 页面。</p><p>那我们想直接跳转到我们自定义的 404 页面啊，还要我们点击才跳转。原因是处于开发环境，即当使用 <code>gatsby develop</code>时，Gatsby 使用默认的 404 页面覆盖我们自定义的 404 页面，但实际上是已经生效了。</p><p>我们可以打包，启动一个本地的服务，模拟处于线上环境来看，这个时候才是直接显示我们自定义的 404 页面。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gatsby build</span><br><span class="line">gatsby serve</span><br></pre></td></tr></table></figure><p>然后打开<code>http://localhost:9000/test</code>（任意路径），就能跳转到我们自定义的 404 页面了</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d5e52ae8fcd52?w=334&h=102&f=png&s=3896" alt=""></p><h3 id="创建布局组件"><a href="#创建布局组件" class="headerlink" title="创建布局组件"></a>创建布局组件</h3><ol><li><p>创建一个新目录 <code>src/components</code>。</p></li><li><p>在上面的目录中创建一个布局组件文件 src/components/layout.js：</p></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; children &#125;) =&gt; <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">margin:</span> `<span class="attr">3rem</span> <span class="attr">auto</span>`, <span class="attr">maxWidth:</span> <span class="attr">650</span>, <span class="attr">padding:</span> `<span class="attr">0</span> <span class="attr">1rem</span>` &#125;&#125;&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>src/pages/index.js</code>中，加入 Layout 组件，</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../components/layout'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Layout</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">Layout</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就让整体页面居中了，这里都是 React 的基本操作</p><h2 id="设置-CSS-样式"><a href="#设置-CSS-样式" class="headerlink" title="设置 CSS 样式"></a>设置 CSS 样式</h2><p>Gatsby 中样式可以使用多种形式，普通的 <code>import &#39;./xxx.css</code>我们就不说了。</p><h3 id="使用全局样式"><a href="#使用全局样式" class="headerlink" title="使用全局样式"></a>使用全局样式</h3><p>我们向网站添加全局样式的最直接的方法之一就是使用全局 .css 样式表。</p><p>在 src 目录下新建文件夹<code>styles</code>，添加一个 global.css 文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  background-color: #f5f5f5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在目录下创建 gatsby-browser.js 中，将样式文件导入</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &quot;.&#x2F;src&#x2F;styles&#x2F;global.css&quot;</span><br></pre></td></tr></table></figure><p>重启本地服务，就发现页面背景变为浅灰色了。</p><h3 id="使用-CSS-Module-为组件设置样式"><a href="#使用-CSS-Module-为组件设置样式" class="headerlink" title="使用 CSS Module 为组件设置样式"></a>使用 CSS Module 为组件设置样式</h3><p>CSS Module 可以减少全局污染、防止命名冲突和样式的覆盖。</p><blockquote><p>CSS Module 实现原理是：将所有模块化的类名，修改为成唯一的名称，即添加一些不重复的前缀或后缀。这样使得项目中，不同人员编写的样式不会出现覆盖和冲突。</p></blockquote><ol><li>创建 CSS 文件 <code>src/styles/index.module.css</code></li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.title &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">.text &#123;</span><br><span class="line">  color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用法如下：<code>src/pages/index.js</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;</span><br><span class="line">import Layout from &quot;..&#x2F;components&#x2F;layout&quot;</span><br><span class="line">import styles from &quot;..&#x2F;styles&#x2F;index.module.css&quot;</span><br><span class="line"></span><br><span class="line">export default function Home() &#123;</span><br><span class="line">  console.log(styles)</span><br><span class="line">  return (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;h1 className&#x3D;&#123;styles.title&#125;&gt;Hello World&lt;&#x2F;h1&gt;</span><br><span class="line">      &lt;div className&#x3D;&#123;styles.text&#125;&gt;Test&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;Layout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d61d3f95cadf0?w=718&h=174&f=png&s=5935" alt=""></p><p>输出 <code>styles</code>,可以看到被导入处理的结果:</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d61cc37846a59?w=514&h=68&f=png&s=6441" alt=""><br>如果将其与 CSS 文件进行比较，你会发现每个格式现在都是导入对象中指向长字符串的键（key），例如 <code>title</code> 指向 <code>index-module--title--1i-Wh</code>。 这些样式名称是 CSS 模块生成的。 保证它们在你的网站上是唯一的。 而且由于必须导入它们才能使用这些类，所以对于在任何地方使用这些 CSS 样式都没问题。</p><h3 id="其他处理-CSS-的方式"><a href="#其他处理-CSS-的方式" class="headerlink" title="其他处理 CSS 的方式"></a>其他处理 CSS 的方式</h3><p>使用 css 样式就点到为止了，其他的比如 Sass 等；还有 CSS in JS 的方式，比如 Emotion, Styled Component。可以去官网查看相应支持的 Gatsby 插件，就可以使用了。</p><h2 id="获取-Gatsby-中的数据"><a href="#获取-Gatsby-中的数据" class="headerlink" title="获取 Gatsby 中的数据"></a>获取 Gatsby 中的数据</h2><p>建立网站时，您可能需要重用一些常用的数据——比如公用的网站标题、作者信息等，我们不可能在每个页面都加，所以我们把标题存储在一个位置，然后从其他文件引用该位置就行了，更改的时候也只能更改这一处地方。</p><p>这些常用数据的存放位置就是 <code>gatsby-config.js</code> 文件中的 <code>siteMetadata</code> 对象。打开这个文件，写入代码：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  &#x2F;* Your site config here *&#x2F;</span><br><span class="line">  siteMetadata: &#123;</span><br><span class="line">    title: &#96;Title from siteMetadata&#96;,</span><br><span class="line">    author: &#39;jacky&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务</p><h3 id="使用页面查询"><a href="#使用页面查询" class="headerlink" title="使用页面查询"></a>使用页面查询</h3><p>编辑 <code>src/pages/about.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">'gatsby'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// GraphQL 获取的数据，会当做参数传递到页面组件中</span></span><br><span class="line"><span class="comment">// 数据的形式是 &#123; errors, data &#125;，没有错误则不会有 errors</span></span><br><span class="line"><span class="keyword">const</span> About = <span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.site.siteMetadata.title)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Title: &#123;data.site.siteMetadata.title&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;author: &#123;data.site.siteMetadata.author&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;div&gt;about me&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> About</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> query = graphql<span class="string">`</span></span><br><span class="line"><span class="string">  query &#123;</span></span><br><span class="line"><span class="string">    site &#123;</span></span><br><span class="line"><span class="string">      siteMetadata &#123;</span></span><br><span class="line"><span class="string">        title</span></span><br><span class="line"><span class="string">        author</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>然后就拉出数据了</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d63bec7bccdeb?w=576&h=188&f=png&s=10256" alt=""></p><p>其中，GraphQL 查询语句是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  site &#123;</span><br><span class="line">    siteMetadata &#123;</span><br><span class="line">      title,</span><br><span class="line">      author</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会懵逼， site 是哪里来的，这数据格式怎么是这样，这就是 GraphQL 查询语句了，我们可以打开 Gatsby 内置的 GraphQL 调试界面 <code>http://localhost:8000/__graphql</code>。</p><p>这里的<code>site</code>即为我们<code>gatsby-config.js</code>写的站点配置。</p><p>依次点击左边的<code>site</code>、<code>siteMetadata</code>，然后有我们刚才写的<code>title</code>,<code>author</code>字段 供我们选择，在点击的同时，中间的框会生成查询语句，最后点击运行按钮，会输出查询结果。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d660d32ae1825?w=1442&h=642&f=png&s=61514" alt=""></p><p>当你后面需要获取更多复杂嵌套数据的时候，可以直接在这个界面找和点击，自动生成查询语句就行了。</p><p>由我们自己写的查询语句也知道，上面我们介绍 GraphQL 的时候说的一个特点，获取数据不多不少，即我们可以选择想要的数据，比如我就想获取标题不想获取作者</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export const query &#x3D; graphql&#96;</span><br><span class="line">  query &#123;</span><br><span class="line">    site &#123;</span><br><span class="line">      siteMetadata &#123;</span><br><span class="line">        title</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure><h3 id="使用非页面组件查询（静态查询）"><a href="#使用非页面组件查询（静态查询）" class="headerlink" title="使用非页面组件查询（静态查询）"></a>使用非页面组件查询（静态查询）</h3><p>这里注意，我们需要区分两种方式的查询，上面的例子的查询方式，只适用于页面查询，即是在<code>src/pages</code>下的路由界面，如果在非页面组件下进行 GraphQL 查询，则不能用上面的方式，应该使用 <code>StaticQuery</code> 组件或者 <code>useStaticQuery hook</code>。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 页面查询</span><br><span class="line">export const query &#x3D; graphql&#96;</span><br><span class="line">    query&#123; ... &#125;</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure><p>比如我们创建一个组件<code>src/components/header.js</code></p><ul><li>StaticQuery</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; graphql, StaticQuery &#125; <span class="keyword">from</span> <span class="string">'gatsby'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Header = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;StaticQuery</span><br><span class="line">    query=&#123;graphql<span class="string">`</span></span><br><span class="line"><span class="string">      query &#123;</span></span><br><span class="line"><span class="string">        site &#123;</span></span><br><span class="line"><span class="string">          siteMetadata &#123;</span></span><br><span class="line"><span class="string">            author</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    `</span>&#125;</span><br><span class="line">    render=&#123;data =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;</span><br><span class="line">        site: &#123; siteMetadata &#125;,</span><br><span class="line">      &#125; = data</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>这是Header组件，作者是：&#123;siteMetadata.author&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">  /&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header</span><br></pre></td></tr></table></figure><p>或者使用 useStaticQuery 方式</p><ul><li>useStaticQuery</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;</span><br><span class="line">import &#123; useStaticQuery, graphql &#125; from &quot;gatsby&quot;</span><br><span class="line"></span><br><span class="line">const Header &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  const data &#x3D; useStaticQuery(</span><br><span class="line">    graphql&#96;</span><br><span class="line">      query &#123;</span><br><span class="line">        site &#123;</span><br><span class="line">          siteMetadata &#123;</span><br><span class="line">            author</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#96;</span><br><span class="line">  )</span><br><span class="line">  return &lt;div&gt;这是Header组件，作者是：&#123;data.site.siteMetadata.author&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Header</span><br></pre></td></tr></table></figure><p>然后在<code>src/pages/index.js</code>中引入 Header 组件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../components/layout'</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'../components/header'</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'../styles/index.module.css'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Home</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;h1 className=&#123;styles.title&#125;&gt;Hello World&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className=&#123;styles.text&#125;&gt;Test&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/Layout&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d6d9b2afff80c?w=705&h=203&f=png&s=8464" alt=""></p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="gatsby-source-filesystem"><a href="#gatsby-source-filesystem" class="headerlink" title="gatsby-source-filesystem"></a>gatsby-source-filesystem</h3><p>这个是 Gatsby 的数据源插件，即通过该插件将各方面的数据转换为本地能够通过 GraphQL 提取的内容，用于设置项目的文件系统。</p><ul><li>安装插件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save gatsby-source-filesystem</span><br></pre></td></tr></table></figure><ul><li>在 gatsby-config.js 文件配置</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  siteMetadata: &#123;</span><br><span class="line">    title: <span class="string">`Title from siteMetadata`</span>,</span><br><span class="line">    author: <span class="string">'jacky'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    &#123;</span><br><span class="line">      resolve: <span class="string">`gatsby-source-filesystem`</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        name: <span class="string">`src`</span>, <span class="comment">// 名称，可以用来过滤</span></span><br><span class="line">        path: <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/src/`</span>, <span class="comment">// 文件路径</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务</p><p>打开<code>http://localhost:8000/__graphql</code>，关注<code>allFile</code>和<code>file</code>两个可选项。</p><p>我们点击 <code>allFile</code>这个可选项，依次选择如下图</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d74ca7b60229d?w=1542&h=928&f=png&s=113095" alt=""></p><p>这里我们要知道，我们要查询的数据基本在<code>edges.node</code>下，节点 <code>node</code>是图（graph）中一个对象的特殊称呼，每个 File 节点都包含了你要查询的字段。</p><p>我们选择的<code>id</code>,<code>relativePath</code>,<code>name</code>字段都对应我们 <code>src</code>目录下创建的文件, 还有很多其他字段可选择，由此可知我们创建的 7 个文件的各种信息。</p><p>既然这里能查询出来，说明我们组件里面也能查出来然后使用数据，比如你可以从组件中查询出来做个文件列表。</p><p>这个相比传统的 React 项目就挺厉害了，不用做什么复杂的工作，就能轻松拿下这些数据。Gatsby 比较强大的就是它的生态了，很多插件都配好了，更多插件可以看官网的插件库介绍：<a href="https://www.gatsbyjs.org/plugins/" target="_blank" rel="noopener">https://www.gatsbyjs.org/plugins/</a></p><h3 id="gatsby-transformer-remark"><a href="#gatsby-transformer-remark" class="headerlink" title="gatsby-transformer-remark"></a>gatsby-transformer-remark</h3><p>这个是数据转换插件，我们用 Gatsby 做个人博客的话，它可必不可少。现在我们程序员写博客基本是用 markdown 语法了，做一个博客的话，不可缺少的就是对 markdown 语法的解析。</p><ul><li>安装插件</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save gatsby-transformer-remark</span><br></pre></td></tr></table></figure><ul><li>在 gatsby-config.js 文件配置</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">/* Your site config here */</span></span><br><span class="line">  siteMetadata: &#123;</span><br><span class="line">    title: <span class="string">`Title from siteMetadata`</span>,</span><br><span class="line">    author: <span class="string">'jacky'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    &#123;</span><br><span class="line">      resolve: <span class="string">`gatsby-source-filesystem`</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        name: <span class="string">`src`</span>, <span class="comment">// 名称，可以用来过滤</span></span><br><span class="line">        path: <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/src/`</span>, <span class="comment">// 文件路径</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">`gatsby-transformer-remark`</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务</p><p>这个插件添加了 allMarkdownRemark 和 markdownRemark 两个数据字段</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d7761605cba2b?w=205&h=243&f=png&s=7538" alt=""></p><ul><li>新建 md 文件</li></ul><p>在<code>src</code>下创建<code>_posts</code>目录，添加一个<code>first-blog.md</code>文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;我的第一篇博客&quot;</span><br><span class="line">date: &quot;2020-06-21&quot;</span><br><span class="line">tags: &quot;React&quot;</span><br><span class="line">categories: &quot;React系列&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 这是第一篇博客的标题</span><br><span class="line"></span><br><span class="line">first blog 的内容 1</span><br></pre></td></tr></table></figure><p>如果博客不是自己搭建的，而是直接上某平台写的话，对上面这段语法就可能不太了解，在 md 文件开头的 <code>---</code> 包裹的是 frontmatter（前言），然后在里面可以添加文章的各种关键词信息。</p><p>然后我们就可以在<code>http://localhost:8000/__graphql</code>查询到我们写的 md 文件的详情信息了</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d7823d4e7db7f?w=1703&h=499&f=png&s=61510" alt=""></p><p>我们稍微再改动，创建多两个 md 文件</p><p><code>second-blog.md</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;我的第二篇博客&quot;</span><br><span class="line">date: &quot;2020-06-22&quot;</span><br><span class="line">tags: &quot;Vue&quot;</span><br><span class="line">categories: &quot;Vue系列&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 这是第二篇博客的标题</span><br><span class="line"></span><br><span class="line">second blog 的内容 2</span><br></pre></td></tr></table></figure><p><code>third-blog.md</code></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &quot;我的第三篇博客&quot;</span><br><span class="line">date: &quot;2020-06-23&quot;</span><br><span class="line">tags: &quot;React&quot;</span><br><span class="line">categories: &quot;React系列&quot;</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 这是第三篇博客的标题</span><br><span class="line"></span><br><span class="line">third blog 的内容 3</span><br></pre></td></tr></table></figure><p>再次查询数据，把我们刚刚添加的文章数据都拿下来了</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/21/172d78dc41c94349?w=599&h=687&f=png&s=41548" alt=""></p><p>既然 GraphQL 能拿到数据，说明我们也能把它放到页面展示出来。</p><p>新建文件<code>src/pages/blog.js</code>,我们做一个博客目录汇总：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../components/layout'</span></span><br><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">'gatsby'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Blog = <span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;h1&gt;博客目录&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;data.allMarkdownRemark.edges.map((&#123; node &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          return (</span></span><br><span class="line"><span class="regexp">            &lt;div</span></span><br><span class="line"><span class="regexp">              key=&#123;node.id&#125;</span></span><br><span class="line"><span class="regexp">              style=&#123;&#123;</span></span><br><span class="line"><span class="regexp">                border: '1px solid #000',</span></span><br><span class="line"><span class="regexp">                margin: '10px',</span></span><br><span class="line"><span class="regexp">                padding: '10px',</span></span><br><span class="line"><span class="regexp">              &#125;&#125;</span></span><br><span class="line"><span class="regexp">            &gt;</span></span><br><span class="line"><span class="regexp">              &lt;h2&gt;&#123;node.frontmatter.title&#125;&lt;/</span>h2&gt;</span><br><span class="line">              &lt;div&gt;分类&#123;node.frontmatter.categories&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">              &lt;div&gt;标签：&#123;node.frontmatter.tags&#125;&lt;/</span>div&gt;</span><br><span class="line">              &lt;div&gt;发布时间：&#123;node.frontmatter.date&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">          )</span><br><span class="line">        &#125;)&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Layout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Blog</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> query = graphql<span class="string">`</span></span><br><span class="line"><span class="string">  query &#123;</span></span><br><span class="line"><span class="string">    allMarkdownRemark &#123;</span></span><br><span class="line"><span class="string">      edges &#123;</span></span><br><span class="line"><span class="string">        node &#123;</span></span><br><span class="line"><span class="string">          id</span></span><br><span class="line"><span class="string">          frontmatter &#123;</span></span><br><span class="line"><span class="string">            tags</span></span><br><span class="line"><span class="string">            title</span></span><br><span class="line"><span class="string">            date</span></span><br><span class="line"><span class="string">            categories</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>打开<code>http://localhost:8000/blog</code>，博客目录就展示出来了：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172e1b12d01e3ba3?w=722&h=601&f=png&s=36586" alt=""></p><p>但有个问题，每篇博客的信息确实能拿出来，但是我们要链接啊，即是点击博客标题，进入博客详情页面，即是文章路径，所以接下来我们将创建页面。</p><h2 id="利用数据创建页面"><a href="#利用数据创建页面" class="headerlink" title="利用数据创建页面"></a>利用数据创建页面</h2><h3 id="gatsby-node-js-1"><a href="#gatsby-node-js-1" class="headerlink" title="gatsby-node.js"></a>gatsby-node.js</h3><p>这个时候我们就要建立<code>gatsby-node.js</code>文件了，这个配置文件里面的代码是 node 层相关的。</p><p>前面我们说过 <code>src/pages</code>目录下的文件会全部渲染成路由，但如果我们博客文章一篇篇的详情页要我们自己创建一个 js 文件，这肯定不合理了。</p><p>我们会用到两个 API：</p><h4 id="onCreateNode"><a href="#onCreateNode" class="headerlink" title="onCreateNode"></a>onCreateNode</h4><p>每当创建新节点（或更新）时，Gatsby 都会调用 onCreateNode 函数。</p><p>向<code>gatsby-node.js</code>写入代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.onCreateNode = <span class="function">(<span class="params">&#123; node &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(node.internal.type)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务，查看终端，你会发现打印出很多创建的节点：<code>SitePage</code>, <code>SitePlugin</code>, <code>Site</code>, <code>SiteBuildMetadata</code>, <code>Directory</code>, <code>File</code>, <code>MarkdownRemark</code>,我们关注的只有<code>MarkdownRemark</code>，于是修改函数使其仅仅记录 MarkdownRemark 节点；我们使用每一个 md 文件的名称来作为路径，如要获取文件名称，你需要遍历一遍它的父节点 <code>File</code>，<code>File</code>节点包含了我们需要的文件数据。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.onCreateNode = <span class="function">(<span class="params">&#123; node, getNode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.internal.type === <span class="string">`MarkdownRemark`</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fileNode = getNode(node.parent)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`\n`</span>, fileNode.relativePath)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务，查看终端，打印如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_posts&#x2F;first-blog.md</span><br><span class="line"></span><br><span class="line">_posts&#x2F;second-blog.md</span><br><span class="line"></span><br><span class="line">_posts&#x2F;third-blog.md</span><br></pre></td></tr></table></figure><p>相对路径出来，接下来我们要创建路径，可以使用<code>gatsby-source-filesystem</code>插件带的创建路径的函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createFilePath &#125; = <span class="built_in">require</span>(<span class="string">`gatsby-source-filesystem`</span>)</span><br><span class="line"></span><br><span class="line">exports.onCreateNode = <span class="function">(<span class="params">&#123; node, getNode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (node.internal.type === <span class="string">`MarkdownRemark`</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(createFilePath(&#123; node, getNode, <span class="attr">basePath</span>: <span class="string">`pages`</span> &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务，打印结果如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;_posts&#x2F;first-blog&#x2F;</span><br><span class="line">&#x2F;_posts&#x2F;second-blog&#x2F;</span><br><span class="line">&#x2F;_posts&#x2F;third-blog&#x2F;</span><br></pre></td></tr></table></figure><p>接下来，向 API 传递一个函数<code>createNodeField</code>，该函数允许我们在其他插件创建的节点里创建其他字段。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">exports.onCreateNode = <span class="function">(<span class="params">&#123; node, getNode, actions &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; createNodeField &#125; = actions</span><br><span class="line">  <span class="keyword">if</span> (node.internal.type === <span class="string">`MarkdownRemark`</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> slug = createFilePath(&#123; node, getNode, <span class="attr">basePath</span>: <span class="string">`pages`</span> &#125;)</span><br><span class="line">    createNodeField(&#123;</span><br><span class="line">      node,</span><br><span class="line">      name: <span class="string">`slug`</span>,</span><br><span class="line">      value: slug, <span class="comment">// 通常用 slug 一词代表路径</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务，打开<code>http://localhost:8000/__graphql</code>，就能查询到路径了</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172e1ce4c0a61cae?w=1097&h=448&f=png&s=28484" alt=""></p><h4 id="createPages"><a href="#createPages" class="headerlink" title="createPages"></a>createPages</h4><p>createPages 这个 API 用于添加页面。在创建页面之前，首先要有页面模板，这样创建页面就能指定所使用的模板了。</p><p>新建文件<code>src/templates/blog-post.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../components/layout'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;div&gt;Hello blog post&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Layout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后更改 <code>gatsby-node.js</code>的<code>createPages</code>函数：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">`path`</span>)</span><br><span class="line"></span><br><span class="line">exports.createPages = <span class="keyword">async</span> (&#123; graphql, actions &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> graphql(<span class="string">`</span></span><br><span class="line"><span class="string">    query &#123;</span></span><br><span class="line"><span class="string">      allMarkdownRemark &#123;</span></span><br><span class="line"><span class="string">        edges &#123;</span></span><br><span class="line"><span class="string">          node &#123;</span></span><br><span class="line"><span class="string">            fields &#123;</span></span><br><span class="line"><span class="string">              slug</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span>)</span><br><span class="line">  result.data.allMarkdownRemark.edges.forEach(<span class="function">(<span class="params">&#123; node &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    createPage(&#123;</span><br><span class="line">      path: node.fields.slug,</span><br><span class="line">      component: path.resolve(<span class="string">`./src/templates/blog-post.js`</span>),</span><br><span class="line">      context: &#123;</span><br><span class="line">        slug: node.fields.slug,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启服务，随便输入一个路径，跳转到默认的 404 页面，就会看到自动生成三篇博客的路径了，点击任一篇，跳转的是我们刚创建的 <code>blog-post.js</code>组件。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/24/172e3bb13a244d4c?w=1230&h=548&f=png&s=51476" alt=""></p><p>我们要的是显示博客内容，所以我们需要对模板文件再进行改造：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; graphql &#125; <span class="keyword">from</span> <span class="string">'gatsby'</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../components/layout'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (&#123; data &#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> post = data.markdownRemark</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;&#123;post.frontmatter.title&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div dangerouslySetInnerHTML=&#123;&#123; __html: post.html &#125;&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Layout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> query = graphql<span class="string">`</span></span><br><span class="line"><span class="string">  query($slug: String!) &#123;</span></span><br><span class="line"><span class="string">    markdownRemark(fields: &#123; slug: &#123; eq: $slug &#125; &#125;) &#123;</span></span><br><span class="line"><span class="string">      html</span></span><br><span class="line"><span class="string">      frontmatter &#123;</span></span><br><span class="line"><span class="string">        title</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>上面是动态变量查询的写法，GraphQL 的语法，可以看看 (<a href="https://graphql.org/learn/queries/#variables" target="_blank" rel="noopener">https://graphql.org/learn/queries/#variables</a>)</p><p>完成之后，比如我点击第二篇博客，就可以正确进入页面并显示内容了</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/24/172e3c8f759609dd?w=757&h=255&f=png&s=18207" alt=""></p><p>为了更完善，我们给 blog 目录页面添加可跳转的链接，加入 <code>slug</code>查询字段, 增加 <code>Link</code>跳转，这个用法与 React 路由的 <code>Link</code>差不多一致，涉及不深的情况下暂且当成相同用法。</p><p><code>src/pages/blog.js</code></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'../components/layout'</span></span><br><span class="line"><span class="keyword">import</span> &#123; graphql, Link &#125; <span class="keyword">from</span> <span class="string">'gatsby'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Blog = <span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;h1&gt;博客目录&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;data.allMarkdownRemark.edges.map((&#123; node &#125;) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">          return (</span></span><br><span class="line"><span class="regexp">            &lt;Link to=&#123;node.fields.slug&#125; key=&#123;node.id&#125;&gt;</span></span><br><span class="line"><span class="regexp">              &lt;div</span></span><br><span class="line"><span class="regexp">                style=&#123;&#123;</span></span><br><span class="line"><span class="regexp">                  border: '1px solid #000',</span></span><br><span class="line"><span class="regexp">                  margin: '10px',</span></span><br><span class="line"><span class="regexp">                  padding: '10px',</span></span><br><span class="line"><span class="regexp">                &#125;&#125;</span></span><br><span class="line"><span class="regexp">              &gt;</span></span><br><span class="line"><span class="regexp">                &lt;h2&gt;&#123;node.frontmatter.title&#125;&lt;/</span>h2&gt;</span><br><span class="line">                &lt;div&gt;分类&#123;node.frontmatter.categories&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;div&gt;标签：&#123;node.frontmatter.tags&#125;&lt;/</span>div&gt;</span><br><span class="line">                &lt;div&gt;发布时间：&#123;node.frontmatter.date&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">              &lt;/</span>div&gt;</span><br><span class="line">            &lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">          )</span></span><br><span class="line"><span class="regexp">        &#125;)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/Layout&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Blog</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export const query = graphql`</span></span><br><span class="line"><span class="regexp">  query &#123;</span></span><br><span class="line"><span class="regexp">    allMarkdownRemark &#123;</span></span><br><span class="line"><span class="regexp">      edges &#123;</span></span><br><span class="line"><span class="regexp">        node &#123;</span></span><br><span class="line"><span class="regexp">          id</span></span><br><span class="line"><span class="regexp">          frontmatter &#123;</span></span><br><span class="line"><span class="regexp">            tags</span></span><br><span class="line"><span class="regexp">            title</span></span><br><span class="line"><span class="regexp">            date</span></span><br><span class="line"><span class="regexp">            categories</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">          fields &#123;</span></span><br><span class="line"><span class="regexp">            slug</span></span><br><span class="line"><span class="regexp">          &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">`</span></span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2020/6/24/172e3ce7be50852c?w=722&h=596&f=png&s=36793" alt=""></p><p>现在点击博客，就能跳转到对应页面了，虽然没做样式页面比较丑，但只要在<code>src/_posts</code>目录新建 md 文件，然后这里就能跟着自动刷新，算是一个超简易的博客了。</p><h2 id="打包上线"><a href="#打包上线" class="headerlink" title="打包上线"></a>打包上线</h2><p>停止开发服务，构建生产版本，把静态文件输出到 public 目录中</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gatsby build</span><br></pre></td></tr></table></figure><p>在本地查看生产环境版本，运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gatsby serve</span><br></pre></td></tr></table></figure><p>接下来，就可以在<code>localhost:9000</code>访问我们刚才做的网站了</p><p>本项目的 <a href="https://github.com/Jacky-Summer/gatsby-blog-demo" target="_blank" rel="noopener">github 地址</a></p><p>至此，我们教程就介绍到这里了。</p><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>SSR</tag>
        <tag>Gatsby</tag>
        <tag>GraphQL</tag>
      </tags>
  </entry>
  <entry>
    <title>完全搞懂 BFC</title>
    <url>/2020/07/05/%E5%AE%8C%E5%85%A8%E6%90%9E%E6%87%82-BFC/</url>
    <content><![CDATA[<p>BFC 是 CSS 中一个比较重要的概念，也是面试经常考查的点…</p>
<a id="more"></a>

<h2 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC"></a>什么是 BFC</h2><p>BFC 全称是 Block Formatting Context，即块格式化上下文。</p>
<p>除了 BFC，还有：</p>
<ul>
<li>IFC（行级格式化上下文）- inline 内联</li>
<li>GFC（网格布局格式化上下文）- <code>display: grid</code></li>
<li>FFC（自适应格式化上下文）- <code>display: flex</code>或<code>display: inline-flex</code></li>
</ul>
<blockquote>
<p>注意：同一个元素不能同时存在于两个 BFC 中</p>
</blockquote>
<p>它是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。怎么理解呢？实际就是说 BFC 是一个渲染区域，并且有自己的一套渲染规则，使其内部布局的元素具有一些特性。</p>
<p><strong>BFC 提供一个独立的布局环境，BFC 内部的元素布局与外部互不影响。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/17318faf333483aa?w=798&h=317&f=png&s=23237" alt=""></p>
<h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p>CSS 属性值 display 为 block，list-item，table 的元素。</p>
<p>块级盒具有以下特性：</p>
<ul>
<li>CSS 属性值 display 为 block，list-item，table 时，它就是块级元素</li>
<li>布局上，块级盒呈现为竖直排列的块</li>
<li>每个块级盒都会参与 BFC 的创建</li>
<li>每个块级元素都会至少生成一个块级盒，称为主块级盒；一些元素可能会生成额外的块级盒，比如 <code>&lt;li&gt;</code>，用来存放项目符号</li>
</ul>
<h2 id="创建-BFC"><a href="#创建-BFC" class="headerlink" title="创建 BFC"></a>创建 BFC</h2><p>以下元素会创建 BFC</p>
<ul>
<li>根元素（<code>&lt;html&gt;</code>）</li>
<li>浮动元素（<code>float</code>不为<code>none</code>）</li>
<li>绝对定位元素（<code>position</code>为<code>absolute</code>或<code>fixed</code>）</li>
<li>表格的标题和单元格（<code>display</code> 为 <code>table-caption</code>，<code>table-cell</code>）</li>
<li>匿名表格单元格元素（<code>display</code> 为 <code>table</code> 或 <code>inline-table</code>）</li>
<li>行内块元素（<code>display</code> 为 <code>inline-block</code>）</li>
<li><code>overflow</code> 的值不为 <code>visible</code> 的元素</li>
<li>弹性元素（<code>display</code> 为 <code>flex</code> 或 <code>inline-flex</code> 的元素的直接子元素）</li>
<li>网格元素（<code>display</code> 为 <code>grid</code> 或 <code>inline-grid</code> 的元素的直接子元素）</li>
</ul>
<p>以上是 CSS2.1 规范定义的 BFC 触发方式，在最新的 CSS3 规范中，弹性元素和网格元素会创建 F(Flex)FC 和 G(Grid)FC。</p>
<h2 id="BFC-的特性"><a href="#BFC-的特性" class="headerlink" title="BFC 的特性"></a>BFC 的特性</h2><ul>
<li>BFC 是页面上的一个独立容器，容器里面的子元素不会影响外面的元素。</li>
<li>BFC 内部的块级盒会在垂直方向上一个接一个排列</li>
<li>同一 BFC 下的相邻块级元素可能发生外边距折叠，创建新的 BFC 可以避免外边距折叠</li>
<li>每个元素的外边距盒（margin box）的左边与包含块边框盒（border box）的左边相接触（从右向左的格式的话，则相反），即使存在浮动</li>
<li>浮动盒的区域不会和 BFC 重叠</li>
<li>计算 BFC 的高度时，浮动元素也会参与计算</li>
</ul>
<p>如果不太理解的，在下面 BFC 的应用我会提及。</p>
<h2 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h2><h3 id="自适应两列布局"><a href="#自适应两列布局" class="headerlink" title="自适应两列布局"></a>自适应两列布局</h3><p>左列浮动（定宽或不定宽都可以），给右列开启 BFC。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* html 代码 *&#x2F;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;浮动元素，无固定宽度&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;自适应&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* css 代码 *&#x2F;</span><br><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a0544fd4461f?w=1919&h=234&f=png&s=13127" alt=""></p>
<ol>
<li>将左列设为左浮动，将自身高度塌陷，使得其它块级元素可以和它占据同一行的位置。</li>
<li>右列为 div 块级元素，利用其自身的流特性占满整行。</li>
<li>右列设置<code>overflow: hidden</code>,触发 BFC 特性，使其自身与左列的浮动元素隔离开，不占满整行。</li>
</ol>
<p>这即是上面说的 BFC 的特性之一：<strong>浮动盒的区域不会和 BFC 重叠</strong></p>
<h3 id="防止外边距（margin）重叠"><a href="#防止外边距（margin）重叠" class="headerlink" title="防止外边距（margin）重叠"></a>防止外边距（margin）重叠</h3><h4 id="兄弟元素之间的外边距重叠"><a href="#兄弟元素之间的外边距重叠" class="headerlink" title="兄弟元素之间的外边距重叠"></a>兄弟元素之间的外边距重叠</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* html 代码 *&#x2F;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* css 代码 *&#x2F;</span><br><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.child1 &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-bottom: 10px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.child2 &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-top: 20px;</span><br><span class="line">    background-color: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/17318cb5761f328e?w=183&h=220&f=png&s=2328" alt=""></p>
<p>两个块级元素，红色 div 距离底部 10px，绿色 div 距离顶部 20px，按道理应该两个块级元素相距 30px 才对，但实际却是取距离较大的一个，即 20px。</p>
<blockquote>
<p>块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的较大者，这种行为称为外边距折叠（重叠），注意这个是发生在属于同一 BFC 下的块级元素之间</p>
</blockquote>
<p>根据 BFC 特性，创建一个新的 BFC 就不会发生 margin 折叠了。比如我们在他们两个 div 外层再包裹一层容器，加属性<code>overflow: hidden</code>，触发 BFC，那么两个 div 就不属于同个 BFC 了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* html 代码 *&#x2F;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;child1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;child2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* css 代码 *&#x2F;</span><br><span class="line">.parent &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* ... *&#x2F;</span><br></pre></td></tr></table></figure>

<p>这个关于兄弟元素外边距叠加的问题，除了触发 BFC 也有其他方案，比如你统一只用上边距或下边距，就不会有上面的问题。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/17318dc6636f418f?w=209&h=231&f=png&s=2376" alt=""></p>
<h4 id="父子元素的外边距重叠"><a href="#父子元素的外边距重叠" class="headerlink" title="父子元素的外边距重叠"></a>父子元素的外边距重叠</h4><p>这种情况存在父元素与其第一个或最后一个子元素之间（嵌套元素）。<br>如果在父元素与其第一个/最后一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的外边距 分开，此时子元素的外边距会“溢出”到父元素的外面。</p>
<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* HTML 代码 *&#x2F;</span><br><span class="line">&lt;div id&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* CSS 代码 *&#x2F;</span><br><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">#parent &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: green;</span><br><span class="line">    margin-top: 20px;</span><br><span class="line">&#125;</span><br><span class="line">#child &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: red;</span><br><span class="line">    margin-top: 30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a48a81bc27d9?w=376&h=236&f=png&s=6696" alt=""></p>
<p>如上图，红色的 div 在绿色的 div 内部，且设置了<code>margin-top</code>为 30px，但我们发现红色 div 的顶部与绿色 div 顶部重合，并没有距离顶部 30px，而是溢出到父元素的外面计算。即本来父元素距离顶部只有 20px，被子元素溢出影响，外边距重叠，取较大的值，则距离顶部 30px。</p>
<p>解决办法：</p>
<ol>
<li>给父元素触发 BFC（如添加<code>overflow: hidden</code>）</li>
<li>给父元素添加 border</li>
<li>给父元素添加 padding</li>
</ol>
<p>这样就能实现我们期望的效果了：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a50faed50d4d?w=249&h=221&f=png&s=2040" alt=""></p>
<h3 id="清除浮动解决令父元素高度坍塌的问题"><a href="#清除浮动解决令父元素高度坍塌的问题" class="headerlink" title="清除浮动解决令父元素高度坍塌的问题"></a>清除浮动解决令父元素高度坍塌的问题</h3><p>当容器内子元素设置浮动时，脱离了文档流，容器中总父元素高度只有边框部分高度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* html 代码 *&#x2F;</span><br><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* css 代码 *&#x2F;</span><br><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.parent &#123;</span><br><span class="line">    border: 4px solid red;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a132272ea410?w=1927&h=209&f=png&s=16771" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a249e4c9c33f?w=338&h=679&f=png&s=38121" alt=""></p>
<p>解决办法：给父元素触发 BFC，使其有 BFC 特性：<strong>计算 BFC 的高度时，浮动元素也会参与计算</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    border: 4px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a1fd01267b9d?w=1920&h=237&f=png&s=10195" alt=""></p>
<p>上面我们都是用的<code>overflow: hidden</code>触发 BFC，因为确实常用嘛，但是触发 BFC 也不止是只有这一种方法，如上面写的所示。</p>
<p>比如可以设置<code>float: left</code>; <code>float: right</code>; <code>display: inline-block</code>; <code>overflow: auto</code>; <code>display: flex</code>; <code>display:&quot; table</code>; <code>position</code>为<code>absolute</code>或<code>fixed</code>等等，这些都可以触发，不过父元素宽度表现不一定相同，但父元素高度都被撑出来了。当然实际运用可不是随便挑一个走，还是根据场景选择。</p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，鼓励我继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
  </entry>
  <entry>
    <title>一文汇总 CSS 两列布局和三列布局</title>
    <url>/2020/06/27/%E4%B8%80%E6%96%87%E6%B1%87%E6%80%BB-CSS-%E4%B8%A4%E5%88%97%E5%B8%83%E5%B1%80%E5%92%8C%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>随着大前端的发展，UI 框架层出不穷，让我们前端开发对 CSS 的能力要求变得没那么高或者没那么严苛，起码重要性是比不上 JS 编程的。但是，基础的 CSS 依然需要我们熟练掌握，今天就来总结写下 CSS 布局的方式。</p>
<a id="more"></a>

<h2 id="两列布局"><a href="#两列布局" class="headerlink" title="两列布局"></a>两列布局</h2><h3 id="左列定宽，右列自适应"><a href="#左列定宽，右列自适应" class="headerlink" title="左列定宽，右列自适应"></a>左列定宽，右列自适应</h3><p><img src="https://user-gold-cdn.xitu.io/2020/6/25/172ebffbad247324?w=1918&h=427&f=png&s=21351" alt=""></p>
<h4 id="float-margin-布局"><a href="#float-margin-布局" class="headerlink" title="float + margin 布局"></a>float + margin 布局</h4><p>html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>; <span class="comment">/* 大于或等于左列的宽度 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="float-overflow-布局"><a href="#float-overflow-布局" class="headerlink" title="float + overflow 布局"></a>float + overflow 布局</h4><p>html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="绝对定位布局"><a href="#绝对定位布局" class="headerlink" title="绝对定位布局"></a>绝对定位布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="table-布局"><a href="#table-布局" class="headerlink" title="table 布局"></a>table 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>,</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grid-网格布局"><a href="#grid-网格布局" class="headerlink" title="grid 网格布局"></a>grid 网格布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="左列不定宽，右列自适应"><a href="#左列不定宽，右列自适应" class="headerlink" title="左列不定宽，右列自适应"></a>左列不定宽，右列自适应</h3><p>左列盒子宽度随着内容增加或减少发生变化，右列盒子自适应</p>
<h4 id="float-overflow-布局-1"><a href="#float-overflow-布局-1" class="headerlink" title="float + overflow 布局"></a>float + overflow 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列不定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex-布局-1"><a href="#flex-布局-1" class="headerlink" title="flex 布局"></a>flex 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列不定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a>grid 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列不定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: auto <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三列布局"><a href="#三列布局" class="headerlink" title="三列布局"></a>三列布局</h2><h3 id="两列定宽，一列自适应"><a href="#两列定宽，一列自适应" class="headerlink" title="两列定宽，一列自适应"></a>两列定宽，一列自适应</h3><p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ee126919a5ecb?w=1916&h=408&f=png&s=21184" alt=""></p>
<h4 id="float-margin-布局-1"><a href="#float-margin-布局-1" class="headerlink" title="float + margin 布局"></a>float + margin 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">300px</span>; <span class="comment">/* 左列的宽度 + 中间列的宽度 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="float-overflow-布局-2"><a href="#float-overflow-布局-2" class="headerlink" title="float + overflow 布局"></a>float + overflow 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="table-布局-1"><a href="#table-布局-1" class="headerlink" title="table 布局"></a>table 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex-布局-2"><a href="#flex-布局-2" class="headerlink" title="flex 布局"></a>flex 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grid-布局-1"><a href="#grid-布局-1" class="headerlink" title="grid 布局"></a>grid 布局</h4><p>html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">200px</span> auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="左右定宽，中间自适应"><a href="#左右定宽，中间自适应" class="headerlink" title="左右定宽，中间自适应"></a>左右定宽，中间自适应</h3><p><img src="https://user-gold-cdn.xitu.io/2020/6/27/172f36b76f3065b5?w=1914&h=409&f=png&s=21663" alt=""></p>
<p>圣杯布局和双飞翼布局目的都是希望先加载的是中间的部分，然后再开始加载 left 和 right 两部分相对来说不是很重要的东西。</p>
<h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><p>圣杯布局：为了让中间的内容不被遮挡，将中间 div（或最外层父 div）设置 padding-left 和 padding-right （值等于 left 和 right 的宽度），将左右两个 div 用相对布局 position: relative 并分别配合 left 和 right 属性，以便左右两栏 div 移动后不遮挡中间 div。</p>
<p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>,</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="comment">/* 使 #left 上去一行 */</span></span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>; <span class="comment">/* 使 #right 上去一行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>双飞翼布局，为了中间 div 内容不被遮挡，直接在中间 div 内部创建子 div 用于放置内容，在该子 div 里用 margin-left 和 margin-right 为左右两栏 div 留出位置。</p>
<p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center-inside"</span>&gt;</span>中间列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span>,</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="comment">/* 使 #left 上去一行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>; <span class="comment">/* 使 #right 上去一行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center-inside</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flex-实现"><a href="#flex-实现" class="headerlink" title="flex 实现"></a>flex 实现</h3><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>,</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: -<span class="number">1</span>; <span class="comment">/* 让 #left 居于左侧 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS伪元素实现中间文字，两边横线的效果</title>
    <url>/2020/06/16/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E5%AE%9E%E7%8E%B0%E4%B8%AD%E9%97%B4%E6%96%87%E5%AD%97%EF%BC%8C%E4%B8%A4%E8%BE%B9%E6%A8%AA%E7%BA%BF%E7%9A%84%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>今天做项目的时候，要实现效果：中间是文字，两边是横线围着，其中有间距。了解了几种做法。伪元素这个刚开始没想到，回来又自己敲了一遍，以做记录…</p>
<a id="more"></a>

<p>效果：</p>
<p><img src="/images/css-pseudo.png" alt="image.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS伪元素实现中间文字, 两边横线效果<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line">        width: 640px;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">        text-align: center;</span><br><span class="line">        width: 100%;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> <span class="selector-class">.word</span><span class="selector-pseudo">:before</span>,</span></span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> <span class="selector-class">.word</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 50%;</span><br><span class="line">        width: 40%;</span><br><span class="line">        height: 1px;</span><br><span class="line">        background: blue;</span><br><span class="line">        content: '';</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="comment">/* 调整背景横线的左右距离 */</span></span></span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> <span class="selector-class">.word</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line">        left: 0;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> <span class="selector-class">.word</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">        right: 0;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"word"</span>&gt;</span>中间的字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Formik +Yup 处理 React 表单验证</title>
    <url>/2020/06/13/%E4%BD%BF%E7%94%A8-Formik-Yup-%E5%A4%84%E7%90%86-React-%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>React 操作表单一直都是比较繁琐的操作，在以前用的是 redux-form， 但现在 formik 这个库设计得更加优雅，Github 的 star 数目已经远远超过 redux-form 了。做表单就是为了收集一些数据，然后进行提交。而 redux-form 理念是把这些数据存放到 reducer 中去，当我们表单多的时候，显然对整个 store 的数据管理不太友好，因为多了很多表单数据。而 formik 解决的其中一个痛点就是这个，它可以在组件内部处理这些表单项而简单易用。</p>
<p>Formik 旨在轻松管理具有复杂验证的表单, Formik 支持同步和异步表单级和字段级验证。</p>
<a id="more"></a>

<p><code>例子的 Formik 为 2.1.4 版</code></p>
<p>先来看个基本的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useFormik &#125; <span class="keyword">from</span> <span class="string">'formik'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./FormDemo.css'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查表单字段</span></span><br><span class="line"><span class="keyword">const</span> validate = <span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> errors = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!values.name) &#123;</span><br><span class="line">    errors.name = <span class="string">'不能为空'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (values.name.length &gt; <span class="number">20</span>) &#123;</span><br><span class="line">    errors.name = <span class="string">'名字太长，输入有误'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!values.email) &#123;</span><br><span class="line">    errors.email = <span class="string">'不能为空'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="regexp">/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]&#123;2,4&#125;$/i</span>.test(values.email)) &#123;</span><br><span class="line">    errors.email = <span class="string">'邮箱格式错误'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> errors</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FormDemo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> formik = useFormik(&#123;</span><br><span class="line">    initialValues: &#123;</span><br><span class="line">      name: <span class="string">''</span>,</span><br><span class="line">      email: <span class="string">''</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    validate,</span><br><span class="line">    onSubmit: <span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="built_in">JSON</span>.stringify(values, <span class="literal">null</span>, <span class="number">2</span>))</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;formik.handleSubmit&#125; className=<span class="string">'form-wrap'</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">'form-group'</span>&gt;</span><br><span class="line">        &lt;label&gt;名字&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          name='name'</span></span><br><span class="line"><span class="regexp">          onChange=&#123;formik.handleChange&#125;</span></span><br><span class="line"><span class="regexp">          onBlur=&#123;formik.handleBlur&#125;</span></span><br><span class="line"><span class="regexp">          value=&#123;formik.values.name&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &#123;formik.touched.name &amp;&amp; formik.errors.name ? (</span><br><span class="line">          &lt;div className=<span class="string">'error-tip'</span>&gt;&#123;formik.errors.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        ) : null&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">'form-group'</span>&gt;</span><br><span class="line">        &lt;label&gt;邮箱&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          name='email'</span></span><br><span class="line"><span class="regexp">          onChange=&#123;formik.handleChange&#125;</span></span><br><span class="line"><span class="regexp">          onBlur=&#123;formik.handleBlur&#125;</span></span><br><span class="line"><span class="regexp">          value=&#123;formik.values.email&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &#123;formik.touched.email &amp;&amp; formik.errors.email ? (</span><br><span class="line">          &lt;div className=<span class="string">'error-tip'</span>&gt;&#123;formik.errors.email&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        ) : null&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> FormDemo</span><br></pre></td></tr></table></figure>

<p>以上是一个很简单的表单，输入名字与邮箱。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/13/172acf9ec35b272f?w=433&h=232&f=gif&s=31469" alt=""></p>
<p>上面例子中我们使用的是 useFormik 这种用法，还有使用 <code>&lt;Formik /&gt;</code> 和 <code>withFormik</code> 的用法。</p>
<p>但我们发现一个问题，当正在输入名字的时候，邮箱已经立马显示不能为空了，我们需要的是当点击的时候才做其他表单元素的判断而不是一次性判断完。对这一问题，我们需要再加一个判断<code>touched</code>, 这个代表表单中的某个字段是否被点击过，直译的话就是”触碰过”或”动过”，这样就不会出现上面的问题了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  formik.touched.name &amp;&amp; formik.errors.name ? (</span><br><span class="line">    &lt;div className=<span class="string">'error-tip'</span>&gt;&#123;formik.errors.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  ) : null</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>但发现上面的代码还是挺多, onChange, onBlur, value 等属性还是挺重复的，每个表单元素写一段，其实我们可以更精简，使用 formik 里面的<code>getFieldProps</code>方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">"&#123;formik.handleSubmit&#125;"</span> <span class="attr">className</span>=<span class="string">"form-wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">'name'</span> &#123;<span class="attr">...formik.getFieldProps</span>('<span class="attr">name</span>')&#125; /&gt;</span> &#123;formik.touched.name &amp;&amp;</span><br><span class="line">    formik.errors.name ? (</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"error-tip"</span>&gt;</span>&#123;formik.errors.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ) : null&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">'email'</span> &#123;<span class="attr">...formik.getFieldProps</span>('<span class="attr">email</span>')&#125; /&gt;</span> &#123;formik.touched.email &amp;&amp;</span><br><span class="line">    formik.errors.email ? (</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"error-tip"</span>&gt;</span>&#123;formik.errors.email&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ) : null&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么表单字段的验证能不能简化呢？formik 表单验证大多数我们会选择和 yup 库进行搭配，yup 的专长就是作规则校验的。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> formik = useFormik(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  validationSchema: Yup.object(&#123;</span><br><span class="line">    name: Yup.string().max(<span class="number">20</span>, <span class="string">'名字太长，输入有误'</span>).required(<span class="string">'不能为空'</span>),</span><br><span class="line">    email: Yup.string().email(<span class="string">'邮箱格式错误'</span>).required(<span class="string">'不能为空'</span>),</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>上面 validationSchema 为 Formik 专门为 yup 留出的接口，所以 formik 是很好支持 yup 搭配使用的。</p>
<p>最后附上官网：<a href="https://jaredpalmer.com/formik/" target="_blank" rel="noopener">https://jaredpalmer.com/formik/</a><br><br></p>
<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>Formik</tag>
        <tag>Yup</tag>
      </tags>
  </entry>
  <entry>
    <title>【React 原理（一）】实现 createElement 和 render 方法</title>
    <url>/2020/06/06/%E3%80%90React-%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%91%E5%AE%9E%E7%8E%B0-createElement-%E5%92%8C-render-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在 React 中，我们都知道可以写 jsx 代码会被编译成真正的 DOM 插入到要显示的页面上。这具体是怎么实现的，今天我们就自己动手做一下。</p><a id="more"></a><h2 id="实现-createElement-方法"><a href="#实现-createElement-方法" class="headerlink" title="实现 createElement 方法"></a>实现 createElement 方法</h2><p>这个方法平时开发我们并不会用到，因为它是经 babel 编译后的代码，我们新建一个 React 项目，index.js 最简单的代码结构如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">'title'</span>&gt;</span>Hello React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure><p>这里就 jsx 会变编译成真正的 DOM ，把 html 代码拿到 babel 官网编译</p><p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287948badb8312?w=1162&h=182&f=png&s=14232" alt=""></p><p>于是我们就看到了 React.createElement() 方法，但这只是调用这个方法，它具体做了什么返回什么我们还不知道，我们可以打印这个函数运行的结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  React.createElement(</span><br><span class="line">    <span class="string">'h1'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      className: <span class="string">'title'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'Hello React'</span></span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/1728796fcf7d2054?w=567&h=181&f=png&s=12796" alt=""><br>返回的这个对象就是虚拟 DOM 了。</p><p>我们来分析它返回的对象参数，首先第一个是</p><ul><li><code>$$typeof: REACT_ELEMENT_TYPE</code></li></ul><p>这个是 React 元素对象的标识属性</p><p>REACT_ELEMENT_TYPE 的值是一个 Symbol 类型，代表了一个独一无二的值。如果浏览器不支持 Symbol 类型，值就是一个二进制值。</p><blockquote><p>为什么是 Symbol？主要防止 XSS 攻击伪造一个假的 React 组件。因为 JSON 中是不会存在 Symbol 类型的。</p></blockquote><ul><li>key：这个比如循环中会用到这个 key 值</li><li>props：传入的属性值，比如 id, className, style, children 等</li><li>ref： DOM 的引用</li><li>剩下的是私有属性（本篇不展开讨论）</li></ul><p>在本篇我们会用自己简单的方式实现这两个方法，而不是根据源码，所以实现上的方法只要能实现它的基本功能即可；有个基本概念在，以后再循序渐进学习源码。</p><p>而 createElement 中有三个参数，更确切说是 n 个参数：</p><ul><li>type：表示要渲染的元素类型。这里可以传入一个元素 Tag 名称，也可以传入一个组件（如 div span 等，也可以是是函数组件和类组件）</li><li>props：创建 React 元素所需要的 props。</li><li>childrens（可选参数）：要渲染元素的子元素，这里可以向后传入 n 个参数。可以为文本字符串，也可以为数组</li></ul><p>初步 createElement 方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 JSX 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...childrens</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type,</span><br><span class="line">        props: &#123;</span><br><span class="line">          ...props,</span><br><span class="line">          children: childrens.length &lt;= <span class="number">1</span> ? childrens[<span class="number">0</span>] || <span class="string">''</span> : childrens,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数中 props 和 childrens 是并列关系，然后返回的 props 对象，里面包含了 children，所以我们需要再 props 里面添加 children 参数，然后根据 children 参数为一个或多个的可能在进行取值处理。</p><p>调用该方法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  createElement(</span><br><span class="line">    <span class="string">'h1'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      className: <span class="string">'title'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'Hello React'</span></span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287aecec9a3e91?w=237&h=116&f=png&s=4860" alt=""><br>除去其它本篇我们不讨论的属性，目前算是实现了一半；我们观察原来 React 自身方法输出的结果有 key, ref， 同输出的 props 也是并列关系，于是我们进一步作出处理</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...childrens</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ref, key</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'ref'</span> <span class="keyword">in</span> props) &#123;</span><br><span class="line">    ref = props[<span class="string">'ref'</span>]</span><br><span class="line">    props[<span class="string">'ref'</span>] = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'key'</span> <span class="keyword">in</span> props) &#123;</span><br><span class="line">    key = props[<span class="string">'key'</span>]</span><br><span class="line">    props[<span class="string">'key'</span>] = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children: childrens.length &lt;= <span class="number">1</span> ? childrens[<span class="number">0</span>] || <span class="string">''</span> : childrens,</span><br><span class="line">    &#125;,</span><br><span class="line">    ref,</span><br><span class="line">    key,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的方式调用结果如下：</p><p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287b33de749a06?w=453&h=145&f=png&s=8494" alt=""><br>如果添加多一些属性，我们来看看结果</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  createElement(</span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">'box'</span>, <span class="attr">className</span>: <span class="string">'box'</span>, <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125;, <span class="attr">key</span>: <span class="string">'20'</span> &#125;,</span><br><span class="line">    <span class="string">'this is text'</span>,</span><br><span class="line">    createElement(<span class="string">'h2'</span>, &#123; <span class="attr">className</span>: <span class="string">'title'</span> &#125;, <span class="string">'hello'</span>),</span><br><span class="line">    createElement(<span class="string">'div'</span>, &#123; <span class="attr">className</span>: <span class="string">'content'</span> &#125;, <span class="string">'Hi'</span>)</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287c9de8368ddd?w=467&h=280&f=png&s=17373" alt=""><br>用了这种比较粗鲁的方式添加，设置为 undefined 在实现 render 方法的时候我们会根据这个忽略 props 内部的 key 和 props 属性，这里就实现了最基本的 createElement 方法了。</p><h2 id="实现-render-方法"><a href="#实现-render-方法" class="headerlink" title="实现 render 方法"></a>实现 render 方法</h2><p>render 方法的第一个参数接收的是 createElement 返回的对象，也就是虚拟 DOM；<br>第二个参数则是挂载的目标 DOM。同样的做法，我们用 babel 编译来看：</p><p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287ca773a9b742?w=1259&h=362&f=png&s=43471" alt=""><br>执行后，就被挂在到页面了</p><p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287cc414f3731c?w=343&h=122&f=png&s=6145" alt=""></p><p>实现代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 功能：把创建的对象生成对应的DOM元素，最后插入到页面中</span></span><br><span class="line"><span class="comment"> * objJSX： createElement 返回的 JSX 对象</span></span><br><span class="line"><span class="comment"> * container：挂载的容器，如 document.getElementById('root')</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">objJSX, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; type, props &#125; = objJSX</span><br><span class="line">  <span class="keyword">let</span> newElement = <span class="built_in">document</span>.createElement(type)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="comment">// 遍历传入的 props 属性</span></span><br><span class="line">    <span class="keyword">if</span> (!props.hasOwnProperty(attr)) <span class="keyword">break</span> <span class="comment">// 不是私有的直接结束遍历</span></span><br><span class="line">    <span class="keyword">let</span> value = props[attr] <span class="comment">// &gt;如果当前属性没有值,直接不处理即可</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">undefined</span>) <span class="keyword">continue</span> <span class="comment">// NULL OR UNDEFINED</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对几个特殊属性单独设置</span></span><br><span class="line">    <span class="keyword">switch</span> (attr.toUpperCase()) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'ID'</span>:</span><br><span class="line">        newElement.setAttribute(<span class="string">'id'</span>, value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'CLASSNAME'</span>:</span><br><span class="line">        newElement.setAttribute(<span class="string">'class'</span>, value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'STYLE'</span>: <span class="comment">// 传入的行内样式 style 是个对象，故需遍历赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> styleAttr <span class="keyword">in</span> value) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value.hasOwnProperty(styleAttr)) &#123;</span><br><span class="line">            newElement[<span class="string">'style'</span>][styleAttr] = value[styleAttr]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'CHILDREN'</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 可能是一个值：可能是字符串也可能是一个JSX对象</span></span><br><span class="line"><span class="comment">         * 可能是一个数组：数组中的每一项可能是字符串也可能是JSX对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 首先把一个值也变为数组，这样后期统一操作数组即可</span></span><br><span class="line">        !(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? (value = [value]) : <span class="literal">null</span></span><br><span class="line">        value.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 验证ITEM是什么类型的：如果是字符串就是创建文本节点，如果是对象，我们需要再次执行RENDER方法，把创建的元素放到最开始创建的大盒子中</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">'string'</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> text = <span class="built_in">document</span>.createTextNode(item)</span><br><span class="line">            newElement.appendChild(text)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            render(item, newElement)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        newElement.setAttribute(attr, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  container.appendChild(newElement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><ul><li>ps： <a href="https://images.weserv.nl/?url=https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，鼓励我继续写作吧~</li></ul>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>手写</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 redux-thunk 源码</title>
    <url>/2020/05/30/%E7%90%86%E8%A7%A3-redux-thunk-%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>前面几篇我们就 Redux 展开了几篇文章，这次我们来实现 react-thunk，就不是叫实现 redux-thunk 了，直接上源码，因为源码就 11 行。如果对 Redux 中间件还不理解的，可以看我写的 Redux 文章。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><a href="https://jacky-summer.github.io/2020/04/22/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E4%BD%A0Redux%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/#more">实现一个迷你 Redux（基础版）</a></li><li><a href="https://jacky-summer.github.io/2020/05/14/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARedux%EF%BC%88%E5%AE%8C%E5%96%84%E7%89%88%EF%BC%89/#more">实现一个 Redux（完善版）</a></li><li><a href="https://jacky-summer.github.io/2020/04/28/%E6%B5%85%E8%B0%88React%E7%9A%84Context-API/#more">浅谈 React 的 Context API</a></li><li><a href="https://jacky-summer.github.io/2020/05/24/%E5%B8%A6%E4%BD%A0%E5%AE%9E%E7%8E%B0-react-redux/">带你实现 react-redux</a></li></ul><h2 id="为什么要用-redux-thunk"><a href="#为什么要用-redux-thunk" class="headerlink" title="为什么要用 redux-thunk"></a>为什么要用 redux-thunk</h2><p>在使用 Redux 过程，通过 dispatch 方法派发一个 action 对象。当我们使用 redux-thunk 后，可以 dispatch 一个 function。redux-thunk 会自动调用这个 function，并且传递 dispatch, getState 方法作为参数。这样一来，我们就能在这个 function 里面处理异步逻辑，处理复杂逻辑，这是原来 Redux 做不到的，因为原来就只能 dispatch 一个简单对象。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>redux-thunk 作为 redux 的中间件，主要用来处理异步请求，比如：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// to do ...</span></span><br><span class="line">    axios.get(<span class="string">'https://jsonplaceholder.typicode.com/todos/1'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="redux-thunk-源码"><a href="#redux-thunk-源码" class="headerlink" title="redux-thunk 源码"></a>redux-thunk 源码</h2><p>redux-thunk 的源码比较简洁，实际就 11 行。前几篇我们说到 redux 的中间件形式，<br>本质上是对 store.dispatch 方法进行了增强改造，基本是类似这种形式：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const middleware &#x3D; (store) &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><p>在这里就不详细解释了，可以看 <a href="https://juejin.im/post/5ebb9375f265da7bfe0bf16a" target="_blank" rel="noopener">实现一个 Redux（完善版）</a></p><p>先给个缩水版的实现：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thunk = <span class="function">(<span class="params">&#123; getState, dispatch &#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action(dispatch, getState)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk</span><br></pre></td></tr></table></figure><ul><li>原理：即当 action 为 function 的时候，就调用这个 function (传入 dispatch, getState)并返回；如果不是，就直接传给下一个中间件。</li></ul><p>完整源码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果action是一个function，就返回action(dispatch, getState, extraArgument)，否则返回next(action)。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> action(dispatch, getState, extraArgument)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// next为之前传入的store.dispatch，即改写前的dispatch</span></span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleware()</span><br><span class="line"><span class="comment">// 给thunk设置一个变量withExtraArgument，并且将createThunkMiddleware整个函数赋给它</span></span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk</span><br></pre></td></tr></table></figure><p>我们发现其实还多了 extraArgument 传入，这个是自定义参数，如下用法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> api = <span class="string">'https://jsonplaceholder.typicode.com/todos/1'</span></span><br><span class="line"><span class="keyword">const</span> whatever = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, applyMiddleware(thunk.withExtraArgument(&#123; api, whatever &#125;)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState, &#123; api, whatever &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// you can use api and something else here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同 redux-thunk 非常流行的库 redux-saga 一样，都是在 redux 中做异步请求等副作用。Redux 相关的系列文章就暂时写到这部分为止，下次会写其他系列。</p><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>react-thunk</tag>
      </tags>
  </entry>
  <entry>
    <title>带你实现-react-redux</title>
    <url>/2020/05/24/%E5%B8%A6%E4%BD%A0%E5%AE%9E%E7%8E%B0-react-redux/</url>
    <content><![CDATA[<p>之前我们实现了 redux 的功能，这次我们来实现一下配合 redux 开发中经常会用到的一个库—— react-redux。本文不会详细介绍 react-redux 的使用，另外需要了解 Context API， 再看此文就很容易理解了。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>可以看看我之前写的几篇文章</p><ul><li><a href="https://jacky-summer.github.io/2020/04/22/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E4%BD%A0Redux%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/#more">实现一个迷你 Redux（基础版）</a></li><li><a href="https://jacky-summer.github.io/2020/05/14/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARedux%EF%BC%88%E5%AE%8C%E5%96%84%E7%89%88%EF%BC%89/#more">实现一个 Redux（完善版）</a></li><li><a href="https://jacky-summer.github.io/2020/04/28/%E6%B5%85%E8%B0%88React%E7%9A%84Context-API/#more">浅谈 React 的 Context API</a></li></ul><h2 id="react-redux-基本使用"><a href="#react-redux-基本使用" class="headerlink" title="react-redux 基本使用"></a>react-redux 基本使用</h2><p>用个简单的加减数字作例子, 把代码贴出来：</p><ul><li>redux.js</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// actions</span></span><br><span class="line"><span class="keyword">const</span> ADD_NUM = <span class="string">'ADD_NUM'</span></span><br><span class="line"><span class="keyword">const</span> DESC_NUM = <span class="string">'DESC_NUM'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// action creators</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addNumAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_NUM,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reduceNumAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: DESC_NUM,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  num: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_NUM:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">num</span>: state.num + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">case</span> DESC_NUM:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">num</span>: state.num - <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">'./Demo'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./redux.js'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;Demo /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>Demo.js</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; addNumAction, reduceNumAction &#125; <span class="keyword">from</span> <span class="string">'./redux.js'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="keyword">this</span>.props.num&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.props.addNum&#125;&gt;增加1&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.props.reduceNum&#125;&gt;减少<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    num: state.num,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    addNum() &#123;</span><br><span class="line">      <span class="keyword">const</span> action = addNumAction()</span><br><span class="line">      dispatch(action)</span><br><span class="line">    &#125;,</span><br><span class="line">    reduceNum() &#123;</span><br><span class="line">      <span class="keyword">const</span> action = reduceNumAction()</span><br><span class="line">      dispatch(action)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Demo)</span><br></pre></td></tr></table></figure><p>就可以实现 num 的增减：</p><p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/5/24/172443ab8612774b?w=143&h=82&f=png&s=1764" alt=""><br>其实一个简单的 react-redux， 主要也就是实现 connect 和 Provider 的基本功能</p><ul><li><strong>connect</strong>：可以把 state 和 dispatch 绑定到 react 组件，使得组件可以访问到 redux 的数据</li><li><strong>Provider</strong>：提供的是一个顶层容器的作用，实现 store 的上下文传递</li></ul><h2 id="使用旧版-Context-API-实现"><a href="#使用旧版-Context-API-实现" class="headerlink" title="使用旧版 Context API 实现"></a>使用旧版 Context API 实现</h2><h3 id="实现-Provider"><a href="#实现-Provider" class="headerlink" title="实现 Provider"></a>实现 Provider</h3><p>首先我们看它的用法，就知道它不是一个函数，而是一个组件：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">    &lt;Demo &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Provider&gt;</span><br></pre></td></tr></table></figure><p>React 的 Context API 提供了一种通过组件树传递数据的方法，无需在每个级别手动传递 props 属性。</p><p>Provider 的实现比较简单，核心就是<strong>把 store 放到 context 里面，所有的子元素可以直接取到 store</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    store: PropTypes.object,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.store = props.store <span class="comment">// 也就是 Provider 组件从外部传入的 store</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">store</span>: <span class="keyword">this</span>.store &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children <span class="comment">// 中间包的组件传入了 context，其余原封不动返回组件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有个地方大家知道就好，两种写法一样的，对 context type 的约束</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 不用 static 来声明...</span></span><br><span class="line">&#125;</span><br><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line">  store: PropTypes.object,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-connect"><a href="#实现-connect" class="headerlink" title="实现 connect"></a>实现 connect</h3><p>connect 用法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Demo)</span><br></pre></td></tr></table></figure><p>connect 是一个高阶组件，就是以组件作为参数，返回一个组件。</p><p><strong>connect 负责连接组件，给到 redux 的数据放到组件的属性里</strong></p><ol><li>负责接收一个组件，把 state 的一些数据放进去，返回一个组件</li><li>数据变化的时候，能够通知组件（需要进行监听）</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">WrapComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">      <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">        store: PropTypes.object,</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">          props: &#123;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">        store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.update()) <span class="comment">// 监听更新事件</span></span><br><span class="line">        <span class="keyword">this</span>.update()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      update() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">        <span class="keyword">let</span> stateToProps = mapStateToProps(store.getState()) <span class="comment">// 传入 redux 的 state</span></span><br><span class="line">        <span class="keyword">let</span> dispatchToProps = mapDispatchToProps(store.dispatch) <span class="comment">// 传入 redux 的 dispatch</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          props: &#123;</span><br><span class="line">            ...this.state.props,</span><br><span class="line">            ...stateToProps,</span><br><span class="line">            ...dispatchToProps,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrapComponent</span> &#123;<span class="attr">...this.state.props</span>&#125; /&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 connect 就实现了，但还有一个问题，像上面的例子，我们其实可以直接传入 action creators， 而不用自己定义函数传入 dispatch</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default connect(mapStateToProps, &#123; addNumAction, reduceNumAction &#125;)(Demo)</span><br></pre></td></tr></table></figure><p>调用的时候：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onClick&#x3D;&#123;this.props.addNumAction&#125;&gt;增加1&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button onClick&#x3D;&#123;this.props.reduceNumAction&#125;&gt;减少1&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure><p>那它的 dispatch 哪里来的，其实是用了 redux 的 bindActionCreators 函数，在我介绍 redux 的文章有提到，它作用是将 actionCreator 转化成 dispatch 形式，即</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; addNumAction &#125;  &#x3D;&gt;  (...args) &#x3D;&gt; dispatch(addNumAction(args))</span><br></pre></td></tr></table></figure><p>所以我们需要再更改 connect 函数，同时，这次我们用箭头函数的形式简化代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> connect = <span class="function">(<span class="params">mapStateToProps, mapDispatchToProps</span>) =&gt;</span> <span class="function"><span class="params">WrapComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">      store: PropTypes.object,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props)</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        props: &#123;&#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">      store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.update())</span><br><span class="line">      <span class="keyword">this</span>.update()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">      <span class="keyword">let</span> stateToProps = mapStateToProps(store.getState())</span><br><span class="line">      <span class="keyword">let</span> dispatchToProps</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> mapDispatchToProps === <span class="string">'function'</span>) &#123;</span><br><span class="line">        dispatchToProps = mapDispatchToProps(store.dispatch)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 传递了一个 actionCreator 对象过来</span></span><br><span class="line">        dispatchToProps = bindActionCreators(mapDispatchToProps, store.dispatch)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">          ...this.state.props,</span><br><span class="line">          ...stateToProps,</span><br><span class="line">          ...dispatchToProps,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrapComponent</span> &#123;<span class="attr">...this.state.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，我们实现了最基本版的 react-redux，然后接下来，我们用新版的 Context API 再写一次</p><h2 id="使用新版-Context-API-实现"><a href="#使用新版-Context-API-实现" class="headerlink" title="使用新版 Context API 实现"></a>使用新版 Context API 实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StoreContext = React.createContext(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这次 Provider 采取更简洁的形式写</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">StoreContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;this.props.store&#125;</span>&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">StoreContext.Provider</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">WrapComponent</span>) </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ConnectComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">      <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">          props: &#123;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.props</span><br><span class="line">        store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.update())</span><br><span class="line">        <span class="keyword">this</span>.update()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      update() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.props</span><br><span class="line">        <span class="keyword">let</span> stateToProps = mapStateToProps(store.getState())</span><br><span class="line">        <span class="keyword">let</span> dispatchToProps</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> mapDispatchToProps === <span class="string">'function'</span>) &#123;</span><br><span class="line">          dispatchToProps = mapDispatchToProps(store.dispatch)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 传递了一个 actionCreator 对象过来</span></span><br><span class="line">          dispatchToProps = bindActionCreators(mapDispatchToProps, store.dispatch)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          props: &#123;</span><br><span class="line">            ...this.state.props,</span><br><span class="line">            ...stateToProps,</span><br><span class="line">            ...dispatchToProps,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrapComponent</span> &#123;<span class="attr">...this.state.props</span>&#125; /&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">StoreContext.Consumer</span>&gt;</span>&#123;value =&gt; <span class="tag">&lt;<span class="name">ConnectComponent</span> <span class="attr">store</span>=<span class="string">&#123;value&#125;</span> /&gt;</span>&#125;<span class="tag">&lt;/<span class="name">StoreContext.Consumer</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>手写</tag>
        <tag>React</tag>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个Redux（完善版）</title>
    <url>/2020/05/14/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARedux%EF%BC%88%E5%AE%8C%E5%96%84%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p>上篇写了实现一个迷你 Redux（基础版），本篇将继续完善 Redux</p><a id="more"></a><p>阅读本文前先看：<a href="https://jacky-summer.github.io/2020/04/22/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E4%BD%A0Redux%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/">实现一个迷你 Redux（基础版）</a></p><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>Redux 有个 API 是 applyMiddleware， 专门用来使用中间件的，首先我们得知道，它用来干嘛的。</p><h3 id="为什么会需要中间件？"><a href="#为什么会需要中间件？" class="headerlink" title="为什么会需要中间件？"></a>为什么会需要中间件？</h3><p>假设我们现在需要记录每次的 dispatch 前后 state 的记录， 那要怎么做呢？于是，简单粗暴的在第一个 dispatch 方法前后加代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line"><span class="built_in">console</span>.log(action)</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br></pre></td></tr></table></figure><p>这部分运行结果：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">prev state &#123;<span class="attr">value</span>: <span class="number">10</span>&#125;</span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">"INCREMENT"</span>&#125;</span><br><span class="line">当前数字为：<span class="number">11</span></span><br><span class="line">next state &#123;<span class="attr">value</span>: <span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure><p>但加完发现情况不对，页面有多个 dispatch 的话，要这样写很多次，会产生大量重复代码。突然，又要加需求了，需要记录每次出错的原因,单独的功能要求如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  store.dispatch(action)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后两个需求都要，那就凑合两个，但叠一起看更乱了。</p><h3 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h3><p>显然，我们不能通过这种方式来做。比较理想的方案是 Redux 本身提供一个功能入口，让我们可以在外面添加功能进去，这样代码就不会复杂。</p><p>但如果给我们现有实现的 Redux 添加功能，在哪个环节添加比较合适呢？</p><ul><li>Reducer： 纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。</li><li>View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。</li><li>Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</li></ul><p>我们发现，以上需求都是和 dispatch 相关，只有发送 action 的这个步骤，即 store.dispatch() 方法，可以添加功能。比如添加日志功能，我们只要把日志放进 dispatch 函数里，不就好了吗，我们只需要改造 dispatch 函数，把 dispatch 进行一层封装。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="keyword">const</span> next = store.dispatch</span><br><span class="line">store.dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">    <span class="built_in">console</span>.log(action)</span><br><span class="line">    next(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，对 store.dispatch 进行了重新定义，这就是中间件的雏形。</p><p>所以说 Redux 的中间件就是一个函数，是对 dispatch 方法的扩展，增强 dispatch 的功能。</p><h3 id="实现中间件"><a href="#实现中间件" class="headerlink" title="实现中间件"></a>实现中间件</h3><p>对于上述 dispatch 的封装，实际上是缺陷很大的。万一又来 n 多个需求怎么办? 那 dispatch 函数就混乱到无法维护了，故需要扩展性强的多中间件合作模式。</p><ol><li>我们把 loggerMiddleware 提取出来</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="keyword">const</span> next = store.dispatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loggerMiddleware = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">  <span class="built_in">console</span>.log(action)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    loggerMiddleware(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>把 exceptionMiddleware 提取出来</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    loggerMiddleware(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch = exceptionMiddleware</span><br></pre></td></tr></table></figure><ol start="3"><li>现在代码有个问题，就是 exceptionMiddleware 中间件写死 loggerMiddleware，但以后又万一不要记录功能呢，所以我们需要让 next(action) 变成动态的，即换哪个中间件都可以</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// loggerMiddleware(action)</span></span><br><span class="line">    next(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个写法可能刚开始看不太适应，实际就是函数里面，返回一个函数，即等效于</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// loggerMiddleware(action)</span></span><br><span class="line">      next(action)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传参数的时候即是 exceptionMiddleware(next)(action)</p><ol start="4"><li>同理，我们让 loggerMiddleware 里面无法扩展别的中间件了！我们也把 next 写成动态的</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loggerMiddleware = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">  <span class="built_in">console</span>.log(action)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前为止，整个中间件设计改造如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="keyword">const</span> next = store.dispatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loggerMiddleware = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">  <span class="built_in">console</span>.log(action)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    next(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch = exceptionMiddleware(loggerMiddleware(next))</span><br></pre></td></tr></table></figure><ol start="5"><li>现在又有一个新问题，想想平时使用中间件是从外部引入的，那外部中间件里面怎么会有 store.getState() 这个方法，于是我们把 store 也给独立出去。</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="keyword">const</span> next = store.dispatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loggerMiddleware = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">  <span class="built_in">console</span>.log(action)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    next(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = loggerMiddleware(store)</span><br><span class="line"><span class="keyword">const</span> exception = exceptionMiddleware(store)</span><br><span class="line">store.dispatch = exception(logger(next))</span><br></pre></td></tr></table></figure><ol start="6"><li>如果又有一个新需求，需要在打印日志前输出当前时间戳，我们又需要构造一个中间件</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timeMiddleware = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'time'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().getTime())</span><br><span class="line">  next(action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = loggerMiddleware(store)</span><br><span class="line"><span class="keyword">const</span> exception = exceptionMiddleware(store)</span><br><span class="line"><span class="keyword">const</span> time = timeMiddleware(store)</span><br><span class="line">store.dispatch = exception(time(logger(next)))</span><br></pre></td></tr></table></figure><h3 id="中间件使用方式优化"><a href="#中间件使用方式优化" class="headerlink" title="中间件使用方式优化"></a>中间件使用方式优化</h3><p>上面的写法可知，中间件的使用方式有点繁琐，故我们需要把细节封装起来，通过扩展 createStore 来实现。<br>先来看看期望的用法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 接收旧的 createStore，返回新的 createStore */</span></span><br><span class="line"><span class="keyword">const</span> newCreateStore = applyMiddleware(exceptionMiddleware, timeMiddleware, loggerMiddleware)(createStore)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回了一个 dispatch 被重写过的 store */</span></span><br><span class="line"><span class="keyword">const</span> store = newCreateStore(reducer)</span><br></pre></td></tr></table></figure><h3 id="实现-applyMiddleware"><a href="#实现-applyMiddleware" class="headerlink" title="实现 applyMiddleware"></a>实现 applyMiddleware</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> applyMiddleware = <span class="function"><span class="keyword">function</span> (<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 返回一个重写createStore的方法 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">rewriteCreateStoreFunc</span>(<span class="params">oldCreateStore</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 返回重写后新的 createStore */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">newCreateStore</span>(<span class="params">reducer, preloadedState</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 生成 store</span></span><br><span class="line">      <span class="keyword">const</span> store = oldCreateStore(reducer, preloadedState)</span><br><span class="line">      <span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 只暴露 store 部分给中间件用的API，而不传入整个store</span></span><br><span class="line">      <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">        getState: store.getState,</span><br><span class="line">        dispatch: <span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action),</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 给每个中间件传入API</span></span><br><span class="line">      <span class="comment">// 相当于 const logger = loggerMiddleware(store)，即 const logger = loggerMiddleware(&#123; getState, dispatch &#125;)</span></span><br><span class="line">      <span class="comment">// const chain = [exception, time, logger]</span></span><br><span class="line">      <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">      <span class="comment">// 实现 exception(time((logger(dispatch))))</span></span><br><span class="line">      chain.reverse().map(<span class="function"><span class="params">middleware</span> =&gt;</span> &#123;</span><br><span class="line">        dispatch = middleware(dispatch)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 重写dispatch</span></span><br><span class="line">      store.dispatch = dispatch</span><br><span class="line">      <span class="keyword">return</span> store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看这一处代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chain.reverse().map(<span class="function"><span class="params">middleware</span> =&gt;</span> &#123;</span><br><span class="line">  dispatch = middleware(dispatch)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>要注意一点，中间件是顺序执行，但是 dispatch 却是反序生成的。所以在这步会把数组顺序给反序（比如 applyMiddleware(A, B, C)，因为 A 在调用时需要知道 B 的 dispatch，B 在执行时需要知道 C 的 dispatch，那么需要先知道 C 的 dispatch。）</p><p>官方 Redux 源码，采用了 compose 函数，我们也试试这种方式来写：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> applyMiddleware = <span class="function">(<span class="params">...middlewares</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compose(fn1, fn2, fn3)</span></span><br><span class="line"><span class="comment">// fn1(fn2(fn3))</span></span><br><span class="line"><span class="comment">// 从右到左来组合多个函数: 从右到左把接收到的函数合成后的最终函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> compose = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">ret, item</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> ret(item(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再对代码精简：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> applyMiddleware = <span class="function">(<span class="params">...middlewares</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">    <span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function"><span class="params">action</span> =&gt;</span> dispatch(action),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> compose = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">ret, item</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> ret(item(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createStore-的处理"><a href="#createStore-的处理" class="headerlink" title="createStore 的处理"></a>createStore 的处理</h3><p>现在的问题是，有两个 createStore 了，这怎么区分，上篇我们其实已经先告知了对中间件代码处理，但具体怎么推出的，我们继续看。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有中间件的 createStore</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有中间件的 createStore</span></span><br><span class="line"><span class="keyword">const</span> rewriteCreateStoreFunc = applyMiddleware(exceptionMiddleware, timeMiddleware, loggerMiddleware)</span><br><span class="line"><span class="keyword">const</span> newCreateStore = rewriteCreateStoreFunc(createStore)</span><br><span class="line"><span class="keyword">const</span> store = newCreateStore(counter, preloadedState)</span><br></pre></td></tr></table></figure><p>为了让用户用起来统一一些，我们可以很简单的使他们的使用方式一致，我们修改下 createStore 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer, preloadedState, rewriteCreateStoreFunc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果有 rewriteCreateStoreFunc，那就采用新的 createStore</span></span><br><span class="line">  <span class="keyword">if</span> (rewriteCreateStoreFunc) &#123;</span><br><span class="line">    <span class="keyword">const</span> newCreateStore = rewriteCreateStoreFunc(createStore)</span><br><span class="line">    <span class="keyword">return</span> newCreateStore(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过 Redux 源码 rewriteCreateStoreFunc 换了个名字，还加了判断，也就是我们上篇的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以中间件的用法为</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter, <span class="comment">/* preloadedState可选 */</span> applyMiddleware(logger))</span><br></pre></td></tr></table></figure><h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><p>如果我们做的项目很大，有大量 state，那么维护起来很麻烦。Redux 提供了 combineReducers 这个方法，作用是把多个 reducer 合并成一个 reducer， 每个 reducer 负责独立的模块。</p><p>我们用一个新例子来举例：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initCounterState = &#123;</span><br><span class="line">  value: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> initInfoState = &#123;</span><br><span class="line">  name: <span class="string">'jacky'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">  info: infoReducer,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// counter reducer处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counterReducer</span>(<span class="params">state = initCounterState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        value: state.value + <span class="number">1</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        value: state.value - <span class="number">1</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infoReducer</span>(<span class="params">state = initInfoState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'FULL_NAME'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        name: state.name + <span class="string">' lin'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = store.getState()</span><br><span class="line"><span class="comment">// 一开始counter为：10，info为 jacky</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`一开始counter为：<span class="subst">$&#123;init.counter.value&#125;</span>，info为 <span class="subst">$&#123;init.info.name&#125;</span>`</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  store.getState()</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(listener) <span class="comment">// 监听state的改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// counterReducer</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// infoReducer</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'FULL_NAME'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行完counter为：11，info为jacky lin</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`执行完counter为：<span class="subst">$&#123;store.getState().counter.value&#125;</span>，info为<span class="subst">$&#123;store.getState().info.name&#125;</span>`</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><p>我们来尝试下如何实现这个 API，</p><p>首先要把一个函数里的所有 reducers 循环执行一遍，并且这个函数要遵循(state, action) =&gt; newState 格式。还需要把每个 reducer 的 initState 合并成一个 rootState。<br>实现如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// reducerKeys = ['counter', 'info']</span></span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">  <span class="comment">// 返回合并后的新的reducer函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 生成的新的state</span></span><br><span class="line">    <span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历执行所有的reducers，整合成为一个新的state</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = reducerKeys[i]</span><br><span class="line">      <span class="keyword">const</span> reducer = reducers[key]</span><br><span class="line">      <span class="comment">// 之前的 key 的 state</span></span><br><span class="line">      <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">      <span class="comment">// 执行 分 reducer，获得新的state</span></span><br><span class="line">      <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line"></span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="replaceReducer"><a href="#replaceReducer" class="headerlink" title="replaceReducer"></a>replaceReducer</h2><blockquote><p>在大型 Web 应用程序中，通常需要将应用程序代码拆分为多个可以按需加载的 JS 包。 这种称为“代码分割”的策略通过减小初次加载时的 JS 的包的大小，来提高应用程序的性能。</p></blockquote><p>reducer 拆分后，和组件是一一对应的。我们就希望在做按需加载的时候，reducer 也可以跟着组件在必要的时候再加载，然后用新的 reducer 替换老的 reducer。但实际上只有一个 root reducer 函数, 如果要实现的话就可以用 replaceReducer 这个函数，实现如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function"><span class="keyword">function</span> (<span class="params">reducer, initState</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> replaceReducer = <span class="function"><span class="params">nextReducer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the nextReducer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    reducer = nextReducer</span><br><span class="line">    <span class="comment">// 刷新一遍 state 的值，新来的 reducer 把自己的默认状态放到 state 树上去</span></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="built_in">Symbol</span>() &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    replaceReducer,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*生成新的reducer*/</span></span><br><span class="line"><span class="keyword">const</span> nextReducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">  info: infoReducer,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*replaceReducer*/</span></span><br><span class="line">store.replaceReducer(nextReducer)</span><br></pre></td></tr></table></figure><h2 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h2><p>bindActionCreators 一般比较少用到，在 react-redux 的 connect 函数实现会用到</p><p>会使用到 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 dispatch 或 Redux store 传给它。</p><p>我们通过普通的方式来 隐藏 dispatch 和 actionCreator 试试</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">  info: infoReducer,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 action 的函数就叫 actionCreator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'INCREMENT'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'FULL_NAME'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> store.dispatch(increment.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> store.dispatch(getName.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他地方在实现自增的时候，根本不知道 dispatch，actionCreator等细节</span></span><br><span class="line">actions.increment() <span class="comment">// 自增</span></span><br><span class="line">actions.getName() <span class="comment">// 获得全名</span></span><br></pre></td></tr></table></figure><p>把 actions 生成时候的公共代码提取出来：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = bindActionCreators(&#123; increment, getName &#125;, store.dispatch)</span><br></pre></td></tr></table></figure><p>bindActionCreators 的实现如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回包裹 dispatch 的函数, 将 actionCreator 转化成 dispatch 形式</span></span><br><span class="line"><span class="comment">// eg. &#123; addNumAction &#125;  =&gt;  (...args) =&gt; dispatch(addNumAction(args))</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(actionCreator.apply(<span class="keyword">this</span>, args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params">actionCreators, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// actionCreators 必须是 function 或者 object</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators !== <span class="string">'object'</span> || actionCreators === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(actionCreators)</span><br><span class="line">  <span class="keyword">const</span> boundActionCreators = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">const</span> actionCreator = actionCreators[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span>) &#123;</span><br><span class="line">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> boundActionCreators</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能大家看到这里有点懵逼，让我们来回忆下 react-redux 中 connect 函数的用法，<br>比如有这样一个 actionCreators</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// actionCreators.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNumAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: <span class="string">'ADD_NUM'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Demo.js：在需要用到 store 数据的组件，如 Demo 组件底部我们用 connect 函数连接，如下:</span></span><br><span class="line"><span class="keyword">import</span> &#123; addNumAction &#125; <span class="keyword">from</span> <span class="string">'./actionCreators'</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;</span><br><span class="line">  addNum() &#123;</span><br><span class="line">    dispatch(addNumAction())</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Demo)</span><br></pre></td></tr></table></figure><p>然后通过页面的按钮来出发 action 为 ADD_NUM 对应事件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.props.addNum&#125;&gt;增加<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>但除了上面的用法，mapDispatchToProps 也可以这样用，直接传入一个对象，都没有 dispatch 方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, &#123; addNumAction &#125;)(Demo)</span><br></pre></td></tr></table></figure><p>然后只需触发 addNumAction 就能实现和上面一样的效果。</p><p>为什么可以不传，当你传入对象的时候， connect 函数会判断，大致代码如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatchToProps</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> mapDispatchToProps === <span class="string">'function'</span>) &#123;</span><br><span class="line">  dispatchToProps = mapDispatchToProps(store.dispatch)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 传递了一个 actionCreator 对象过来</span></span><br><span class="line">  dispatchToProps = bindActionCreators(mapDispatchToProps, store.dispatch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就使用了 bindActionCreators 函数，它就是把你传入的 actionCreator 再包一层 dispatch 方法，即</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; addNumAction &#125;  =&gt;  <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(addNumAction(args))</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redux 实现讲到这里就结束了，把原理搞懂了确实对 Redux 的理解加深了好多，之后会继续写相关插件的实现，如 react-redux 等。</p><p>参考资料：</p><p><a href="https://github.com/brickspert/blog/issues/22" target="_blank" rel="noopener">完全理解 redux（从零实现一个 redux）</a></p><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励吧~</li></ul>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>手写</tag>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>总结JS数组方法</title>
    <url>/2020/05/10/%E6%80%BB%E7%BB%93JS%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在日常开发中，使用数组方法的情况是很多的。但总有几个方法用得不是很多，就容易忘记具体用法，于是，今天打算做下总结笔记，回顾数组方法。</p>
<a id="more"></a>

<h2 id="改变原数组的方法（9-个）"><a href="#改变原数组的方法（9-个）" class="headerlink" title="改变原数组的方法（9 个）"></a>改变原数组的方法（9 个）</h2><h3 id="push-和-pop"><a href="#push-和-pop" class="headerlink" title="push()和 pop()"></a>push()和 pop()</h3><p>共同点：<strong>数组尾部操作的方法</strong></p>
<h4 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h4><ul>
<li>用法：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</li>
<li>返回值：把指定的值添加到数组后的新长度。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.push(newEle1, newEle2, ..., newEleX)  要添加到数组末尾的元素</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr.push(<span class="number">4</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><ul>
<li>用法：pop() 方法用于删除并返回数组的最后一个元素。</li>
<li>返回值：arrayObject 的最后一个元素</li>
<li>说明：如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.pop()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.pop() <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="shift-和-unshift"><a href="#shift-和-unshift" class="headerlink" title="shift()和 unshift()"></a>shift()和 unshift()</h3><p>共同点：<strong>数组首部操作的方法</strong></p>
<h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><ul>
<li>用法：用于把数组的第一个元素从其中删除，并返回第一个元素的值。</li>
<li>返回值：数组原来的第一个元素的值。</li>
<li>说明：如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.shift()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.shift() <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><ul>
<li>用法：可向数组的开头添加一个或更多元素，并返回新的长度。</li>
<li>返回值：arrayObject 的新长度。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.unshift(newEle1, newEle2, ..., newEleX)  要添加到数组首部的元素</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.unshift(<span class="number">100</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [100, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="reverse-和-sort"><a href="#reverse-和-sort" class="headerlink" title="reverse()和 sort()"></a>reverse()和 sort()</h3><p>共同点：<strong>重排序的方法</strong></p>
<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><ul>
<li>用法：用于颠倒数组中元素的顺序。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.reverse()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">arr.reverse()</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ['c', 'b', 'a']</span></span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><ul>
<li>用法：用于对数组的元素进行排序。</li>
<li>说明：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.sort(sortby) 可选。规定排序顺序。必须是函数。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'monkey'</span>, <span class="string">'jacky'</span>, <span class="string">'tom'</span>, <span class="string">'john'</span>]</span><br><span class="line">arr.sort()</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ['jacky', 'john', 'monkey', 'tom']</span></span><br></pre></td></tr></table></figure>

<ul>
<li>比较函数的两个参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort的比较函数有两个默认参数，接受参数然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</span><br><span class="line"></span><br><span class="line">若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</span><br><span class="line">若 a 等于 b，则返回 0。</span><br><span class="line">若 a 大于 b，则返回一个大于 0 的值。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment">// 升序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 3, 4, 5, 7, 8, 100]</span></span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b - a</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [100, 8, 7, 5, 4, 3, 1]</span></span><br></pre></td></tr></table></figure>

<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><ul>
<li>用法：向/从数组中添加/删除项目，然后返回被删除的项目。</li>
<li>返回值：包含被删除项目的新数组，如果有的话。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.splice(index, howmany, item1, ....., itemX)</span><br><span class="line"><span class="comment">// index:必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</span></span><br><span class="line"><span class="comment">// howmany:必需。要删除的项目数量。如果设置为 0，则不会删除项目。</span></span><br><span class="line"><span class="comment">// item, ..., itemX:可选。向数组添加的新项目。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 删除数组下标为 1 的元素，删除一个</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line">arr.splice(<span class="number">-3</span>, <span class="number">2</span>) <span class="comment">// 从倒数第三个元素开始删除，删除两个</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 3, 4, 5, 8]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除并添加</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>) <span class="comment">// 删除数组下标为 0 的元素，删除两个；并在数组下标为0的位置添加100</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [100, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不删除只添加</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>) <span class="comment">// 在数组下标为0的位置添加9 10 11</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [9, 10, 11, 1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6：fill"><a href="#ES6：fill" class="headerlink" title="ES6：fill()"></a>ES6：fill()</h3><ul>
<li>用法：用于将一个固定值替换数组的元素。</li>
<li>返回值：修改后的数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.fill(value, start, end)</span><br><span class="line"><span class="comment">// value:必需。填充的值。</span></span><br><span class="line"><span class="comment">// start:可选。开始填充位置。</span></span><br><span class="line"><span class="comment">// end:	可选。停止填充位置 (默认为 arrayObject.length)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充 "replace" 到数组的第三和第四个元素：</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line">arr.fill(<span class="string">'replace'</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ["a", "b", "replace", "replace", "e"]</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6：copyWithin"><a href="#ES6：copyWithin" class="headerlink" title="ES6：copyWithin()"></a>ES6：copyWithin()</h3><ul>
<li>用法：用于从数组的指定位置拷贝元素到数组的另一个指定位置中。</li>
<li>返回值：修改后的数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.copyWithin(target, start, end)</span><br><span class="line"><span class="comment">// value:必需。复制到指定目标索引位置。。</span></span><br><span class="line"><span class="comment">// start:可选。元素复制的起始位置。</span></span><br><span class="line"><span class="comment">// end:	可选。停止复制的索引位置 (默认为 arrayObject.length)。如果为负值，表示倒数。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line">arr.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ["a", "b", "a", "b", "e"]</span></span><br></pre></td></tr></table></figure>

<h2 id="不改变原数组的方法（8-个）"><a href="#不改变原数组的方法（8-个）" class="headerlink" title="不改变原数组的方法（8 个）"></a>不改变原数组的方法（8 个）</h2><ul>
<li>注: 数组的每一项是简单数据类型，且未直接操作数组的情况下</li>
</ul>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><ul>
<li>用法：从已有的数组中返回选定的元素。</li>
<li>返回值：返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.slice(start, end)</span><br><span class="line"><span class="comment">// start:必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。</span></span><br><span class="line"><span class="comment">// end:可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.slice()) <span class="comment">// ["a", "b", "c", "d", "e"]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">2</span>)) <span class="comment">// ["c", "d", "e"]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">0</span>, <span class="number">3</span>)) <span class="comment">// ["a", "b", "c"]</span></span><br></pre></td></tr></table></figure>

<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><ul>
<li>用法：方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.indexOf(item, start)</span><br><span class="line"><span class="comment">// start:必须。查找的元素。</span></span><br><span class="line"><span class="comment">// end:	可选的整数参数。规定在数组中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'c'</span>)) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'a'</span>, <span class="number">1</span>)) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h3><ul>
<li>用法：返回一个指定的元素在数组中最后出现的位置，从该字符串的后面向前查找。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.lastIndexOf(item, start)</span><br><span class="line"><span class="comment">// start:必须。查找的元素。</span></span><br><span class="line"><span class="comment">// end:	可选的整数参数。规定在数组中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。则将从字符串的最后一个字符处开始检索。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'a'</span>)) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'b'</span>, <span class="number">2</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><ul>
<li>用法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。</li>
<li>返回值：返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入 separator 字符串而生成的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.join(separator)</span><br><span class="line"><span class="comment">// separator:可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.join()) <span class="comment">// a,b,c,b,e,a</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">'.'</span>)) <span class="comment">// a.b.c.b.e.a</span></span><br></pre></td></tr></table></figure>

<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ul>
<li>用法：用于连接两个或多个数组。</li>
<li>返回值：返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.concat(arrayX, arrayX, ......, arrayX)</span><br><span class="line"><span class="comment">// arrayX: 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(<span class="number">4</span>, <span class="number">5</span>)) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(arr2)) <span class="comment">// [1, 2, 3, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><ul>
<li>用法：把数组转换为字符串，并返回结果。</li>
<li>返回值：arrayObject 的字符串表示。返回值与没有参数的 join() 方法返回的字符串相同。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.toString()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// a,b,c,b,e,a</span></span><br></pre></td></tr></table></figure>

<p>相对 join() 方法，更推荐使用 join() 方法，不推荐使用该方法</p>
<h3 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString()"></a>toLocaleString()</h3><ul>
<li>用法：把数组转换为本地字符串。</li>
<li>返回值：arrayObject 的本地字符串表示。</li>
<li>说明：首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.toLocaleString()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="number">23</span>, &#123; <span class="attr">name</span>: <span class="string">'jacky'</span> &#125;, <span class="keyword">new</span> <span class="built_in">Date</span>()]</span><br><span class="line"><span class="built_in">console</span>.log(arr.toLocaleString()) <span class="comment">// a,23,[object Object],2020/5/10 上午10:58:37</span></span><br></pre></td></tr></table></figure>

<h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><ul>
<li>用法：用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。</li>
<li>返回值：arrayObject 的本地字符串表示。</li>
<li>说明：首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.includes(searchElement, fromIndex)</span><br><span class="line"><span class="comment">// searchElement：必须。需要查找的元素值。</span></span><br><span class="line"><span class="comment">// fromIndex：可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">2</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">4</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">3</span>, <span class="number">3</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">3</span>, <span class="number">-1</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><ul>
<li>用法：用于调用数组的每个元素，并将元素传递给回调函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。传递给函数的值一般用 "<span class="title">this</span>" 值。如果这个参数为空， "<span class="title">undefined</span>" 会传递给 "<span class="title">this</span>" 值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item) <span class="comment">// 1 2 4 6 8</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item, index, arr)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 0 [1, 2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 2 1 [1, 2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 4 2 [1, 2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 6 3 [1, 2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 8 4 [1, 2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><ul>
<li>用法：用于检测数组所有元素是否都符合指定条件（通过函数提供）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。对象作为该执行回调时使用，传递给函数，用作 "<span class="title">this</span>" 的值。</span></span><br><span class="line"><span class="function">如果省略了 <span class="title">thisValue</span> ，"<span class="title">this</span>" 的值为 "<span class="title">undefined</span>"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>every() 方法使用指定函数检测数组中的所有元素：</p>
<ul>
<li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</li>
<li>如果所有元素都满足条件，则返回 true。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res1 = arr.every(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 检测数组中的所有元素是否大于2</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> res2 = arr.every(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 检测数组中的所有元素是否大于10</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(res2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><ul>
<li>用法：用于检测数组中的元素是否满足指定条件（函数提供）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。对象作为该执行回调时使用，传递给函数，用作 "<span class="title">this</span>" 的值。</span></span><br><span class="line"><span class="function">如果省略了 <span class="title">thisValue</span> ，"<span class="title">this</span>" 的值为 "<span class="title">undefined</span>"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>some() 方法会依次执行数组的每个元素：</p>
<ul>
<li>如果有一个元素满足条件，则表达式返回 true , 剩余的元素不会再执行检测。</li>
<li>如果没有满足条件的元素，则返回 false。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res1 = arr.some(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 检测数组中是否有一个元素是否大于10</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> res2 = arr.some(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 检测数组中是否有一个元素是否大于100</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">100</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(res2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><ul>
<li>用法：创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</li>
<li>返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。对象作为该执行回调时使用，传递给函数，用作 "<span class="title">this</span>" 的值。</span></span><br><span class="line"><span class="function">如果省略了 <span class="title">thisValue</span> ，"<span class="title">this</span>" 的值为 "<span class="title">undefined</span>"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res1 = arr.filter(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回数组中所有大于5的元素</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> res2 = arr.filter(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回数组中所有小于5的元素</span></span><br><span class="line">  <span class="keyword">return</span> num &lt; <span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// [6, 8, 10, 12]</span></span><br><span class="line"><span class="built_in">console</span>.log(res2) <span class="comment">// [4]</span></span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><ul>
<li>用法：返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。对象作为该执行回调时使用，传递给函数，用作 "<span class="title">this</span>" 的值。</span></span><br><span class="line"><span class="function">如果省略了 <span class="title">thisValue</span> ，"<span class="title">this</span>" 的值为 "<span class="title">undefined</span>"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.map(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 数组每个元素都乘10</span></span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// [40, 60, 80, 100, 120]</span></span><br></pre></td></tr></table></figure>

<h2 id="数组归并方法"><a href="#数组归并方法" class="headerlink" title="数组归并方法"></a>数组归并方法</h2><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><ul>
<li>用法：接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</li>
<li>reduce() 可以作为一个高阶函数，用于函数的 compose。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total, currentValue, currentIndex, arr</span>), <span class="title">initialValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">total</span>：必需。初始值, 或者计算结束后的返回值。</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">currentIndex</span>：可选。当前元素的索引</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">initialValue</span>：可选。传递给函数的初始值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total + num</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<h3 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h3><ul>
<li>用法：方法的功能和 reduce() 功能是一样的，不同的是 reduceRight() 从数组的末尾向前将数组中的数组项做累加。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">total, currentValue, currentIndex, arr</span>), <span class="title">initialValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">total</span>：必需。初始值, 或者计算结束后的返回值。</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">currentIndex</span>：可选。当前元素的索引</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">initialValue</span>：可选。传递给函数的初始值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduceRight(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total - num</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈React的Context-API</title>
    <url>/2020/04/28/%E6%B5%85%E8%B0%88React%E7%9A%84Context-API/</url>
    <content><![CDATA[<p>上下文(Context) 提供了在组件之间共享这些值的方法，而不必在树的每个层级显式传递一个 prop 。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般情况下，在你没有绝对把握用好和必须的场景下，是不推荐使用的。</p><p>但是我们依然间接的使用着它，比如许多官方依赖在使用，如：react-redux, mobx-react，react-router。我们需要它功能的时候，更多是靠第三方依赖库就能实现，而不是自己手动写 context。但是，依然需要理解它，对用它的一些依赖库源码理解很有帮助。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: <span class="string">'GrandPa组件的信息'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Father info=&#123;<span class="keyword">this</span>.state.info&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Father extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Son info=&#123;this.props.info&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Son extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;div&gt;我是Son组件，拿到信息为：&#123;this.props.info&#125;&lt;/</span>div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Grandpa</span><br></pre></td></tr></table></figure><p>最后页面输出：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是Son组件，拿到信息为：GrandPa组件的信息</span><br></pre></td></tr></table></figure><p>我们会发现这样的缺点是一层一层传值，如果有更多层级和更多数据的话，会让代码看起来很不整洁，如果中间哪个组件忘了传值基本就完了；而且 Father 组件也并没有用到 info 值，只是将值传给 Son 组件。</p><p>如果使用 context，就能帮我们解决这个层级不停传值的问题。</p><p>context 有旧版和新版之分，以 React v16.3.0 版本划分。</p><h2 id="旧版-Context-API"><a href="#旧版-Context-API" class="headerlink" title="旧版 Context API"></a>旧版 Context API</h2><p>我们先来说下旧版 context API</p><p>将代码改成如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: <span class="string">'GrandPa组件的信息'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">info</span>: <span class="keyword">this</span>.state.info &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Father /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 声明Context对象属性</span></span><br><span class="line"><span class="regexp">Grandpa.childContextTypes = &#123;</span></span><br><span class="line"><span class="regexp">  info: PropTypes.string,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Father extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Son /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Son extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;div&gt;我是Son组件，拿到信息为：&#123;this.context.info&#125;&lt;/</span>div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据约定好的参数类型声明</span></span><br><span class="line">Son.contextTypes = &#123;</span><br><span class="line">  info: PropTypes.string,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Grandpa</span><br></pre></td></tr></table></figure><p>对 PropTypes 类型检查，还可以写成下面这种写法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    info: PropTypes.string,</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: <span class="string">'GrandPa组件的信息'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">info</span>: <span class="keyword">this</span>.state.info &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Father /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>在需要传出去的 context 值和需要接收 context 值都要进行类型检查判断。</p><p>正常用这个 api 可能没什么问题，但如果中间哪个组件用到<code>shouldComponentUpdate</code>方法的话，就很可能出现问题。</p><p>三个组件的层级关系如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;GrandPa&gt;</span><br><span class="line">  &lt;Father&gt;</span><br><span class="line">    &lt;Son /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Father&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>GrandPa&gt;</span><br></pre></td></tr></table></figure><p>如果在 GrandPa 组件设置按钮点击可以更新 info 的值，即通过<code>this.setState({info: &#39;改变值&#39;})</code>方法<br>更新 Context：<br>那么</p><ul><li>GrandPa 组件通过 setState 设置新的 Context 值同时触发子组件重新 render。</li><li>Father 组件重新 render。</li><li>Son 组件重新 render，并拿到更新后的 Context。</li></ul><p>假如在 Father 组件添加函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Father 并不依赖任何值，所以我们默认让它无需重新 render。但是，这会导致 Son 组件也不会重新 render，即无法获取到最新的 Context 值。</p><p>这样的不确定性对于目标组件来说是完全不可控的，也就是说目标组件无法保证自己每一次都可以接收到更新后的 Context 值。这是旧版 API 存在的一个大问题。</p><p>而新版 API 解决了这个问题，我们来看下新版 API 怎么写的</p><h2 id="新版-Context-API"><a href="#新版-Context-API" class="headerlink" title="新版 Context API"></a>新版 Context API</h2><blockquote><p>新版 Context 新增了 creactContext() 方法用来创建一个 context 对象。这个对象包含两个组件，一个是 Provider（生产者），另一个是 Consumer（消费者）。</p></blockquote><ol><li>Provider 和 Consumer 必须来自同一个 Context 对象，即一个由 React.createContext()创建的 Context 对象。</li><li>React.createContext()方法接收一个参数做默认值，当 Consumer 外层没有对应的 Provider 时就会使用该默认值。</li><li>Provider 组件使用 Object.is 方法判断 prop 值是否发生改变，当 prop 的值改变时，其内部组件树中对应的 Consumer 组件会接收到新值并重新渲染。此过程不受 shouldComponentUpdete 方法的影响。</li><li>Consumer 组件接收一个函数作为 children prop 并利用该函数的返回值生成组件树的模式被称为 Render Props 模式。</li></ol><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol><li>首先创建一个 context 对象</li></ol><blockquote><p>React.createContext 方法用于创建一个 Context 对象。该对象包含 Provider 和 Consumer 两个属性，分别为两个 React 组件。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> InfoContext = React.createContext(<span class="string">''</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 Provider 组件生成一个 context</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: <span class="string">'GrandPa组件的信息'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;InfoContext.Provider value=&#123;&#123; <span class="attr">info</span>: <span class="keyword">this</span>.state.info &#125;&#125;&gt;</span><br><span class="line">        &lt;Father /&gt;</span><br><span class="line">      &lt;<span class="regexp">/InfoContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>使用 Consumer 组件获取 context 对象的值</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;InfoContext.Consumer&gt;</span><br><span class="line">        &#123;value =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是Son组件，拿到信息为：&#123;value.info&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;<span class="regexp">/InfoContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>ContextAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个迷你Redux（基础版）</title>
    <url>/2020/04/22/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E4%BD%A0Redux%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p>本文从将从 Redux 原理出发，一步步自己实现一个简单的 Redux，主要目的是了解 Redux 内部之间的联系。看本文之前先要知道 Redux 是怎么用的，对 Redux 用法不会讲解太多。</p><a id="more"></a><h2 id="Redux-介绍"><a href="#Redux-介绍" class="headerlink" title="Redux 介绍"></a>Redux 介绍</h2><p>首先要知道的是，Redux 和 React 没有关系，Redux 可以用在任何框架中。<br>Redux 是一个 JavaScript 状态管理器，是一种新型的前端“架构模式”。</p><p>还有通常与 redux 一起用的一个库——react-redux， 它就是把 Redux 这种架构模式和 React.js 结合起来的一个库，就是 Redux 架构在 React.js 中的体现。</p><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ol><li>Web 应用是一个状态机，视图与状态是一一对应的。</li><li>所有的状态，保存在一个对象里面。</li></ol><h2 id="何时使用-Redux"><a href="#何时使用-Redux" class="headerlink" title="何时使用 Redux"></a>何时使用 Redux</h2><ol><li>用户的使用方式复杂</li><li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li><li>多个用户之间可以协作</li><li>与服务器大量交互，或者使用了 WebSocket</li><li>View 要从多个来源获取数据</li></ol><p>从组件的角度看：</p><ol><li>某个组件的状态，需要共享</li><li>某个状态需要在任何地方都可以拿到</li><li>一个组件需要改变全局状态</li><li>一个组件需要改变另一个组件的状态</li></ol><h2 id="Redux-工作流程"><a href="#Redux-工作流程" class="headerlink" title="Redux 工作流程"></a>Redux 工作流程</h2><p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718ce1ceca204e3?w=898&h=421&f=png&s=148790" alt=""></p><ol><li>Redux 将整个应用状态(state)存储到一个地方(通常我们称其为 store)</li><li>当我们需要修改状态时，必须派发(dispatch)一个 action( action 是一个带有 type 字段的对象)</li><li>专门的状态处理函数 reducer 接收旧的 state 和 action ，并会返回一个新的 state</li><li>通过 subscribe 设置订阅，每次派发动作时，通知所有的订阅者。</li></ol><p>从这个流程中可以看出，Redux 的核心就是一个 观察者 模式。一旦 store 发生了变化就会通知所有的订阅者，视图(在这里是 react 组件)接收到通知之后会进行重新渲染。</p><h2 id="Redux-案例"><a href="#Redux-案例" class="headerlink" title="Redux 案例"></a>Redux 案例</h2><p>为了简化说明，我用和官网差不多的例子改写来作案例<br><a href="https://redux.js.org/introduction/getting-started" target="_blank" rel="noopener">官网 redux demo</a></p><p>新建一个文件 redux.js，然后直接引入，观察控制台输出</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  value: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// reducer处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = defaultState, action</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(state, action)</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        value: state.value + <span class="number">1</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        value: state.value - <span class="number">1</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = store.getState()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`一开始数字为：<span class="subst">$&#123;init.value&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> current = store.getState()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`当前数字为：<span class="subst">$&#123;current.value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(listener) <span class="comment">// 监听state的改变</span></span><br><span class="line"></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line"><span class="comment">// 当前数字为：11</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line"><span class="comment">// 当前数字为：12</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;)</span><br><span class="line"><span class="comment">// 当前数字为：11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;value: 10&#125; &#123;type: &quot;@@redux&#x2F;INIT1.a.7.g.7.t&quot;&#125;</span><br><span class="line">一开始数字为：10</span><br><span class="line">&#123;value: 10&#125; &#123;type: &quot;INCREMENT&quot;&#125;</span><br><span class="line">当前数字为：11</span><br><span class="line">&#123;value: 11&#125; &#123;type: &quot;INCREMENT&quot;&#125;</span><br><span class="line">当前数字为：12</span><br><span class="line">&#123;value: 12&#125; &#123;type: &quot;DECREMENT&quot;&#125;</span><br><span class="line">当前数字为：11</span><br></pre></td></tr></table></figure><p>所有对数据的操作必须通过 dispatch 函数，它接受一个参数 action，action 是一个普通的 JavaScript 对象，action 必须包含一个<code>type</code>字段，告诉它要修改什么，只有它允许才能修改。</p><p>在每次调用进来 reducer 函数我们都打印了 state 和 action，我们手动通过 store.dispatch 方法派发了三次 action，但你会发现输出了四次.这是因为 Redux 内部初始化就自动执行了一次 dispatch 方法，可以看到第一次执行它的 type 对我们数据来说是没有影响的（因为 type 取值<code>@@redux/INIT1.a.7.g.7.t</code>，我们自己 redux 的数据 type 不会取名成这个样子，所以不会跟它重复），即默认输出 state 值</p><h2 id="动手实现一个-Redux"><a href="#动手实现一个-Redux" class="headerlink" title="动手实现一个 Redux"></a>动手实现一个 Redux</h2><ol><li>首先要手动实现一个 Redux 之前，先看看有上述代码涉及到 Redux 什么方法，首先引入了</li></ol><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#39;redux&#39;</span><br><span class="line">&#x2F;&#x2F; 传入reducer</span><br><span class="line">const store &#x3D; createStore(reducer)</span><br></pre></td></tr></table></figure><p>createStore 会返回一个对象，这个对象包含三个方法，于是我们可以列出 Redux 雏形。</p><p>新建 mini-redux.js</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function createStore (reducer) &#123;</span><br><span class="line"></span><br><span class="line">    const getState &#x3D; () &#x3D;&gt; &#123;&#125;</span><br><span class="line">    const subscribe &#x3D; () &#x3D;&gt; &#123;&#125;</span><br><span class="line">    const dispatch &#x3D; () &#x3D;&gt; &#123;&#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">        getState,</span><br><span class="line">        subscribe,</span><br><span class="line">        dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>store.getState()用于获取 state 数据，其实就是简单地把 state 参数返回。于是</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getState,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>dispatch 方法会接收一个 action，执行会调用 <code>reducer</code> 返回一个新状态</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getState,</span><br><span class="line">    dispatch,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>通过 subscribe 设置监听函数（设置订阅），一旦 state 发生变化，就自动执行这个函数（通知所有的订阅者）。</li></ol><p>怎么实现呢？我们可以直接使用 subscribe 函数把你要监听的事件添加到数组, 然后执行 dispatch 方法的时候把 listeners 数组的监听函数给执行一遍。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听函数，可添加多个</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function"><span class="params">listener</span> =&gt;</span> &#123;</span><br><span class="line">    currentListeners.push(listener)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">    currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getState,</span><br><span class="line">    subscribe,</span><br><span class="line">    dispatch,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>翻开一开始我们那个 Redux 例子，其实就是把<code>store.getState()</code>添加进来，dispatch 派发一个 action 后，reducer 执行返回新的 state，并执行了监听函数<code>store.getState()</code>，state 的值就发生变化了。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> current = store.getState()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`当前数字为：<span class="subst">$&#123;current.value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(listener) <span class="comment">// 监听state的改变</span></span><br></pre></td></tr></table></figure><p>上述代码，跟 React 依然没有关系，只是纯属 Redux 例子。但想一想当我们把 Redux 和 React 一起用的时候，还会多做这么一步。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = store.getState()</span><br><span class="line">    <span class="keyword">this</span>.storeChange = <span class="keyword">this</span>.storeChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    store.subscribe(<span class="keyword">this</span>.storeChange)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">storeChange () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(store.getState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 React 里面监听的方法，还要用<code>this.setState()</code>, 这是因为 React 中 state 的改变必须依赖于<code>this.setState</code>方法。所以对于 React 项目，就是组件的 render 方法或 setState 方法放入 listen（监听函数），才会实现视图的自动渲染，改变页面中的 state 值。</p><p>最后一步，注意我们上面说的，当初始化的时候，dispatch 会先自动执行一次，继续改代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function"><span class="params">listener</span> =&gt;</span> &#123;</span><br><span class="line">    currentListeners.push(listener)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">    currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 尽量写得复杂，使不会与我们自定义的action有重复可能</span></span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: <span class="string">'@@mini-redux/~GSDG4%FDG#*&amp;'</span> &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getState,</span><br><span class="line">    subscribe,</span><br><span class="line">    dispatch,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写到这里，我们把引入的 redux 替换我们写的文件</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#39;.&#x2F;mini-redux&#39;</span><br></pre></td></tr></table></figure><p>当我们执行的时候，发现结果并不如我们所愿：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#125; &#123;type: &quot;@@mini-redux&#x2F;~GSDG4%FDG#*&amp;&quot;&#125;</span><br><span class="line">一开始数字为：undefined</span><br><span class="line">&#123;&#125; &#123;type: &quot;INCREMENT&quot;&#125;</span><br><span class="line">当前数字为：NaN</span><br><span class="line">&#123;type: &quot;INCREMENT&quot;&#125;</span><br><span class="line">当前数字为：NaN</span><br><span class="line">&#123;value: NaN&#125; &#123;type: &quot;DECREMENT&quot;&#125;</span><br><span class="line">当前数字为：NaN</span><br></pre></td></tr></table></figure><p>这个怎么回事呢？因为我们写的 redux 一开始就给 state 赋值为{}，在事实 state 初始值是由外部传入的，通常我们自己写的时候会设置默认值</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  value: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = defaultState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但在我们 Redux 实现中却把它手动置为空对象，在这里我们暂时解决方法就是不给它赋值，让它为 undefined，这样 reducer 的默认参数就会生效。redux 初始化第一次 dispatch 时，就会让它自动赋值为 reducer 传入的第一个参数 state 默认值（ES6 函数默认赋值），所以修改如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentState</span><br><span class="line">  <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function"><span class="params">listener</span> =&gt;</span> &#123;</span><br><span class="line">    currentListeners.push(listener)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">    currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: <span class="string">'@@mini-redux/~GSDG4%FDG#*&amp;'</span> &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getState,</span><br><span class="line">    subscribe,</span><br><span class="line">    dispatch,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 mini-redux.js，我们就可以实现跟原来的 redux 完全一样的输出效果了。</p><h2 id="完善-Redux"><a href="#完善-Redux" class="headerlink" title="完善 Redux"></a>完善 Redux</h2><p>接下来我们继续补充知识点</p><ol><li>createStore 实际有三个参数，即</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">createStore(reducer, [preloadedState], enhancer)</span><br></pre></td></tr></table></figure><p>第二个参数 <code>[preloadedState] (any)</code>是可选的: initial state</p><p>第三个参数<code>enhancer(function)</code>也是可选的：用于添加中间件的</p><p>通常情况下，通过 preloadedState 指定的 state 优先级要高于通过 reducer 指定的 state。这种机制的存在允许我们在 reducer 可以通过指明默认参数来指定初始数据，而且还为通过服务端或者其它机制注入数据到 store 中提供了可能。</p><p>第三个参数我们下篇会说，先继续完善一下代码，我们需要对第二个和第三个可选参数进行判断。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当第二个参数没有传preloadedState，而直接传function的话，就会直接把这个function当成enhancer</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    enhancer = preloadedState</span><br><span class="line">    preloadedState = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当第三个参数传了但不是function也会报错</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reducer必须为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the reducer to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> currentState = preloadedState <span class="comment">// 第二个参数没传默认就是undefined赋给currentState</span></span><br><span class="line">  <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于第三个参数判断为什么返回<br><code>return enhancer(createStore)(reducer, preloadedState)</code>我们下篇会说，这篇先忽略。 2. 我们实现了 store.subscribe()方法，但还是不完整的，subscribe 方法可以添加监听函数 listener,它还有返回值，返回一个移除 listener 的函数；另外我们依然要对类型进行判断。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function"><span class="params">listener</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    currentListeners.push(listener)</span><br><span class="line">    <span class="comment">// 通过filter过滤，执行的时候将之前本身已经添加进数组的事件名移除数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      currentListeners = currentListeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过找数组下标的方式移除 listener</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subscribe = <span class="function"><span class="params">listener</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  currentListeners.push(listener)</span><br><span class="line">  <span class="comment">// 通过filter过滤，执行的时候将之前本身已经添加进数组的事件名移除数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = currentListeners.indexOf(listener)</span><br><span class="line">    currentListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除 listener 实际就是取消订阅，使用方式如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(store.getState()))</span><br><span class="line"></span><br><span class="line">unsubscribe() <span class="comment">// 取消监听</span></span><br></pre></td></tr></table></figure><ol start="3"><li>diaptch 方法执行完返回为 action，然后我们同样需要为它作判断</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> isDispatching = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 用于判断action是否为一个普通对象</span></span><br><span class="line">    <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Actions must be plain objects. '</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止多次dispatch请求同时改状态，一定是前面的dispatch结束之后，才dispatch下一个</span></span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      isDispatching = <span class="literal">true</span></span><br><span class="line">      currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isDispatching = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于判断一个值是否为一个普通的对象(普通对象即直接以字面量形式或调用 new Object() 所创建的对象)</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> proto = obj</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Object</span>.getPrototypeOf(proto) !== <span class="literal">null</span>) &#123;</span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(obj) === proto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>isPlainObject 函数中通过 while 不断地判断 Object.getPrototypeOf(proto) !== null 并执行, 最终 proto 会指向 Object.prototype. 这时再判断 Object.getPrototypeOf(obj) === proto, 如果为 true 的话就代表 obj 是通过字面量或调用 new Object() 所创建的对象了。</p><p>保持 action 对象是简单对象的作用是方便 reducer 进行处理，不用处理其他的情况（比如 function/class 实例等）</p><p>至此，我们实现了最基本能用的 Redux 代码，下篇再继续完善 Redux 代码，最后放出基础版 Redux 所有代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当第二个参数没有传preloadedState，而直接传function的话，就会直接把这个function当成enhancer</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    enhancer = preloadedState</span><br><span class="line">    preloadedState = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当第三个参数传了但不是function也会报错</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// reducer必须为函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the reducer to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> currentState = preloadedState <span class="comment">// 第二个参数没传默认就是undefined赋给currentState</span></span><br><span class="line">  <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line">  <span class="keyword">let</span> isDispatching = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> subscribe = <span class="function"><span class="params">listener</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    currentListeners.push(listener)</span><br><span class="line">    <span class="comment">// 通过filter过滤，执行的时候将之前本身已经添加进数组的事件名移除数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      currentListeners = currentListeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 用于判断action是否为一个普通对象</span></span><br><span class="line">    <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Actions must be plain objects. '</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 防止多次dispatch请求同时改状态，一定是前面的dispatch结束之后，才dispatch下一个</span></span><br><span class="line">    <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      isDispatching = <span class="literal">true</span></span><br><span class="line">      currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      isDispatching = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    <span class="keyword">return</span> action</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch(&#123; <span class="attr">type</span>: <span class="string">'@@mini-redux/~GSDG4%FDG#*&amp;'</span> &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getState,</span><br><span class="line">    subscribe,</span><br><span class="line">    dispatch,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于判断一个值是否为一个普通的对象(普通对象即直接以字面量形式或调用 new Object() 所创建的对象)</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> proto = obj</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Object</span>.getPrototypeOf(proto) !== <span class="literal">null</span>) &#123;</span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(obj) === proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：</p><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">Redux 入门教程（一）：基本用法</a></p><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励吧~</li></ul>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>手写</tag>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>React函数this绑定的原因及四种绑定方式对比</title>
    <url>/2020/04/16/React%E5%87%BD%E6%95%B0this%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E5%9B%9B%E7%A7%8D%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>react 组件在绑定函数时，通常有三种方法，此文将对三种方法性能和写法展开写…</p><a id="more"></a><h2 id="为什么要绑定-this"><a href="#为什么要绑定-this" class="headerlink" title="为什么要绑定 this"></a>为什么要绑定 this</h2><p>首先，第一个很重要的问题就是，绑定 this 是什么原因？</p><p>js 里面的 this 绑定是代码执行的时候进行绑定的，而不是编写的时候，所以 this 的指向取决于函数调用时的各种条件。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'jacky'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BindEvent</span><br></pre></td></tr></table></figure><p>来看上面这个例子，运行点击按钮，发现程序报错，即 this 指向不是所在类。由于类的方法默认不会绑定 this，因此在调用的时候如果没有绑定，this 的值将会是 undefined。故我们需要手动绑定 this</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property &#39;state&#39; of undefined</span><br></pre></td></tr></table></figure><p>需要我们自己绑定 this，其实这不是 react 的锅，本质原因是 JavaScript 的 this 机制问题</p><h2 id="this-机制"><a href="#this-机制" class="headerlink" title="this 机制"></a>this 机制</h2><p>来看下面一个例子：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'obj'</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.getName() <span class="comment">// &#123;name: "obj", getName: ƒ&#125; "obj"</span></span><br></pre></td></tr></table></figure><p>结果理所应当，使用<code>.</code>操作符调用函数 obj.getName()，this 指向的是 obj 对象，即 obj 对象是函数 getName 的调用者，但如果改成这样：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleObj = obj.getName</span><br><span class="line">middleObj() <span class="comment">// Window &#123;...&#125; ""</span></span><br></pre></td></tr></table></figure><p>将 getName 函数引用赋值给 middleObj 变量，并使用这个新的函数引用去调用该函数时，打印出 this 为 Window 对象，关于 this 的指向，可简单粗暴理解为<strong>this 永远指向最后调用它的那个对象</strong>。</p><p>如果没有显式调用一个函数，JS 的解释器就会把全局对象当作调用者，在浏览器则是 Window 对象为调用者。</p><p>如果使用严格模式，那么没有显式的使用调用者的情况下，this 指向 undefined 。</p><p>理解完上面，我们用类来作为参照：</p><p>下面定义了一个类，类里的 display 访问 this.name 属性</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  display() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// 运行打印： Foo &#123;name: "jacky"&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo(<span class="string">'jacky'</span>)</span><br><span class="line">foo.display() <span class="comment">// jacky</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> display = foo.display</span><br><span class="line">display()</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot read property 'name' of undefined</span></span><br></pre></td></tr></table></figure><p>当我们将一个函数引用赋值给某个其他变量，并使用这个新的函数引用去调用该函数时，在 display() 方法 this 为<code>undefined</code>，故找不到 name 值报错。</p><p>在这里又有一个问题了，display 这样直接调用，在非严格模式下调用者不是应该为 Window 对象吗？在这里，要知道一个知识点：</p><p><strong>ES6 的 class 语法，所有在 class 中声明的方法都会自动地使用严格模式</strong></p><h2 id="React-的-JSX"><a href="#React-的-JSX" class="headerlink" title="React 的 JSX"></a>React 的 JSX</h2><p>说了这么多，这跟 React 那个有什么联系呢，想搞清楚为什么绑定 this 这个问题前，就想先弄明白 JSX 到底是一个什么东西。</p><blockquote><p>本质上来讲，JSX 只是为 React.createElement(component, props, …children) 方法提供的语法糖。</p></blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button className=<span class="string">'btn'</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure><p>经 babel 编译为：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">React.createElement(<span class="string">'button'</span>, &#123; <span class="attr">className</span>: <span class="string">'btn'</span>, <span class="attr">onClick</span>: <span class="keyword">this</span>.handleClick &#125;, <span class="string">'Click Me'</span>)</span><br></pre></td></tr></table></figure><p>我们把 render 方法里的 JSX 手动写成编译后这种形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick(e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> React.createElement(<span class="string">'button'</span>, &#123; <span class="attr">className</span>: <span class="string">'btn'</span>, <span class="attr">onClick</span>: <span class="keyword">this</span>.handleClick &#125;, <span class="string">'Click Me'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React.createElement 的第二个参数，传入的是一个对象，而这个对象里面有属性的值是取 this 对象里面的属性 ，当这个对象放入 React.createElement 执行后，去取这个 this.handleClick 属性的时候，this 已经不是我们在书写的时候认为的绑定在 Example 组件上了。this.handleClick 这里的 this 会默认绑定，但是又是在 ES6 的 class 中，所以 this 绑定了 undefined。</p><p>在 JSX 语法中: <code>onClick={ this.handleClick }</code>中 onClick 这个属性就是相当于上面的”中间变量”。</p><p>即是将<code>this.handleClick</code>函数赋值给 onClick 这个中间变量，后面不仅要进行 JSX 语法转化,将 JSX 组件转换成<strong>JS 对象</strong>,还要再将 Javascript 对象转换成真实 DOM。把 onClick 作为中间变量,指向一个函数的时候,后面的一系列处理中，使用 onClick 这个中间变量所指向的函数，里面的 this 自然就丢失掉了，不是再指向组件实例了。</p><p>所以，当在组件定义方法想访问 this，才需要手动绑定。</p><h2 id="绑定-this-的方法"><a href="#绑定-this-的方法" class="headerlink" title="绑定 this 的方法"></a>绑定 this 的方法</h2><h3 id="render-方法中绑定-this"><a href="#render-方法中绑定-this" class="headerlink" title="render 方法中绑定 this"></a>render 方法中绑定 this</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'jacky'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法即是在事件函数后使用<code>.bind(this)</code>将 this 绑定到当前组件中。因为 bind 函数会返回一个新的函数，所以每次父组件刷新时，都会重新生成一个函数，即使父组件传递给子组件其他的 props 值不变，子组件每次都会刷新，这将会影响性能，故不推荐使用。</p><h3 id="render-方法中使用箭头函数"><a href="#render-方法中使用箭头函数" class="headerlink" title="render 方法中使用箭头函数"></a>render 方法中使用箭头函数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'jacky'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.handleClick()&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首选要明确一点，<strong>箭头函数中，this 永远绑定了定义箭头函数所在的那个对象</strong></p><p>这种方法写法比较简洁， 最大好处就是传参很灵活，父组件刷新的时候，即使两个箭头函数的函数体是一样的，都会生成一个新的箭头函数。这种方式重新创建函数性能的损耗小于第 1 种。</p><h3 id="构造函数绑定-this"><a href="#构造函数绑定-this" class="headerlink" title="构造函数绑定 this"></a>构造函数绑定 this</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'jacky'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免在 render 中绑定 this 引发可能的性能问题，可以在 constructor 中预先进行绑定。好处是仅需要绑定一次，避免每次渲染时都要重新绑定，也是常推荐的写法，就是写起来繁琐一点，要单独绑定。</p><h3 id="在定义阶段使用箭头函数绑定"><a href="#在定义阶段使用箭头函数绑定" class="headerlink" title="在定义阶段使用箭头函数绑定"></a>在定义阶段使用箭头函数绑定</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'jacky'</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法是 ES7 的写法，ES6 并不支持，不过我们可以配置你的开发环境支持 ES7。</p><p>这种方法避免了第 1 种和第 2 种的可能潜在的性能问题，也比第 3 种方法简洁，也是常推荐的写法。</p><p>至于哪一种是最好的写法，目前还真的无法定论，有待以后开发中得出最佳实践…</p><br><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，欢迎 star</li></ul>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>原生JavaScript DOM操作常见汇总</title>
    <url>/2020/04/09/%E5%8E%9F%E7%94%9FJavaScript-DOM%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>最近在看 JS 性能优化方面，说到了 createDocumentFragment()方法，对该方法有印象，但为了进一步了解，我还是重新查阅一遍，顺便把 DOM 操作也给总结一下。</p>
<a id="more"></a>

<h2 id="创建新节点"><a href="#创建新节点" class="headerlink" title="创建新节点"></a>创建新节点</h2><ul>
<li><strong>createDocumentFragment()方法</strong></li>
</ul>
<p>该方法是用来创建一个虚拟的节点对象，或者说，是用来创建文档碎片节点。它可以包含各种类型的节点，在创建之初是空的。</p>
<p>DocumentFragment 不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。</p>
<p>当把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点，即插入的是括号里的节点。这个特性使得 DocumentFragment 成了占位符，暂时存放那些一次插入文档的节点。</p>
<ul>
<li><strong>createElement()方法</strong></li>
</ul>
<p>在 HTML 文档中，document.createElement() 方法用于创建一个由标签名称 tagName 指定的 HTML 元素</p>
<p>来看一个例子, 对于页面已存在的<code>&lt;ul id=&quot;ul&quot;&gt;&lt;/ul&gt;</code>元素，我们想往里面添加 li 标签</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line">  li.innerHTML = <span class="string">'index: '</span> + i</span><br><span class="line">  ul.appendChild(li)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面操作看起来很正常，但实际要很多的插入操作和改动；而每一次的插入都会引起重新渲染，该操作会引发多次渲染，在性能优化方面，有一点是减少 DOM 操作，因为 DOM 操作导致了页面的重绘或重排。</p>
<ul>
<li>createDocumentFragment()方法和 createElement()方法区别</li>
</ul>
<p>如果是用 createDocumentFragment()方法操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>)</span><br><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line">  li.innerHTML = <span class="string">'index: '</span> + i</span><br><span class="line">  fragment.appendChild(li)</span><br><span class="line">&#125;</span><br><span class="line">ul.appendChild(fragment)</span><br></pre></td></tr></table></figure>

<p>相比 createElement()方法，这次是先将这些元素添加到 fragment 中，再统一将 fragment 添加到页面，会减少页面渲染 dom 的次数，效率会明显提升。因为 fragment 文档片段存在于内存中，并不在 DOM 中，所以将子元素插入到文档片段中时不会引起页面回流（新创建的 fragment 片段在文档内是没有对应的标签的，这里添加的是片段的所有子节点）</p>
<ul>
<li>createTextNode()方法</li>
</ul>
<p>该方法会创建一个文本节点。</p>
<p>HTML 元素通常是由元素节点和文本节点组成。创建一个标题 (h1), 你必须创建 “h1” 元素和文本节点:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> h = <span class="built_in">document</span>.createElement(<span class="string">'h1'</span>)</span><br><span class="line"><span class="keyword">var</span> t = <span class="built_in">document</span>.createTextNode(<span class="string">'Hello World'</span>)</span><br><span class="line">h.appendChild(t)</span><br></pre></td></tr></table></figure>

<h2 id="DOM-更改：添加、移除、替换、插入"><a href="#DOM-更改：添加、移除、替换、插入" class="headerlink" title="DOM 更改：添加、移除、替换、插入"></a>DOM 更改：添加、移除、替换、插入</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加、删除子元素</span></span><br><span class="line">ele.appendChild(el)</span><br><span class="line">ele.removeChild(el)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换子元素</span></span><br><span class="line">ele.replaceChild(el1, el2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入子元素</span></span><br><span class="line">parentElement.insertBefore(newElement, referenceElement)</span><br></pre></td></tr></table></figure>

<p>前面三个用法就一目了然，对于 insertBefore()方法来举个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newEle = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">'insertNode'</span>)</span><br><span class="line">newEle.appendChild(textNode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>)</span><br><span class="line">ul.insertBefore(newEle, ul.firstChild)</span><br></pre></td></tr></table></figure>

<p>页面输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insertNode</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="DOM-查询"><a href="#DOM-查询" class="headerlink" title="DOM 查询"></a>DOM 查询</h2><p>元素查询的 API 返回的的结果是 DOM 节点或者 DOM 节点的列表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getElementById()</span><br><span class="line">getElementsByName()</span><br><span class="line">getElementsByTagName()</span><br><span class="line">getElementsByClassName()</span><br><span class="line">querySelector()</span><br><span class="line">querySelectorAll()</span><br></pre></td></tr></table></figure>

<p>querySelector() 方法返回匹配指定 CSS 选择器元素的第一个子元素， 该方法只返回匹配指定选择器的第一个元素。如果要返回所有匹配元素，需要使用 querySelectorAll() 方法替代．</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.querySelector(&quot;#test&quot;); &#x2F;&#x2F; 获取到id名为test的首个元素</span><br></pre></td></tr></table></figure>

<ul>
<li>querySelector 系列方法与 getElementBy 系列方法对比</li>
</ul>
<ol>
<li>得到的元素不是需要很麻烦的多次 getElementBy..的话，尽量使用 getElementBy 系列方法,因为 getElementBy 系列执行速度更快。</li>
<li>得到的元素需要很麻烦的多次 getElementBy…组合才能得到的话使用 querySelector，方便。</li>
<li>querySelector()选择的标签是静态的，也就是说在选中之后，能够一直保存，也就是脱离了被选择的成为副本。而 getelementsBy 系列方法是动态的，相互映射，在调用时，变化可以及时的反映在页面上。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 querySelector 操作元素</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>)</span><br><span class="line"><span class="keyword">var</span> list = ul.querySelectorAll(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 创建3个新的li标签，添加到ul列表中</span></span><br><span class="line">  ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'li'</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(list.length) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 输出的是添加前li的数量3，而非此时li的总数量6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">var</span> list = ul.getElementsByTagName(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// 创建3个新的li标签，添加到ul列表中</span></span><br><span class="line">  ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'li'</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(list.length) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<ul>
<li>还有元素的 DOM 导航方法：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取父元素、父节点</span></span><br><span class="line"><span class="keyword">var</span> parent = ele.parentElement</span><br><span class="line"><span class="keyword">var</span> parent = ele.parentNode</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子节点，子节点可以是任何一种节点，可以通过nodeType来判断</span></span><br><span class="line"><span class="keyword">var</span> nodes = ele.children</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询子元素</span></span><br><span class="line"><span class="keyword">var</span> els = ele.getElementsByTagName(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">var</span> els = ele.getElementsByClassName(<span class="string">'test'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前元素的第一个/最后一个子元素节点</span></span><br><span class="line"><span class="keyword">var</span> el = ele.firstElementChild</span><br><span class="line"><span class="keyword">var</span> el = ele.lastElementChild</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一个/上一个兄弟元素节点</span></span><br><span class="line"><span class="keyword">var</span> el = ele.nextElementSibling</span><br><span class="line"><span class="keyword">var</span> el = ele.previousElementSibling</span><br></pre></td></tr></table></figure>

<h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getAttribute(key)</span><br><span class="line">setAttribute(key,value)</span><br><span class="line">hasAttribute(key)</span><br><span class="line">removeAttribute(key)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>用React+Antd封装Axios实现全局Loading效果</title>
    <url>/2020/03/29/%E7%94%A8React-Antd%E5%B0%81%E8%A3%85Axios%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80Loading%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>今天在做 react 后台管理的时候要实现一个全局 Loading 效果，通常使用 axios 库与后端进行数据交互。为了更好的用户体验，在每次请求前添加一个加载效果，让用户知道在等待加载。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要实现这个功能，我们可以在每个组件请求手动添加加载效果返回后再将其隐藏，但如果每个请求都这么做，就要做多次重复设置显得很麻烦，但好处是可以设置定制多种请求效果。但考虑到该项目场景为后台管理系统，给管理员使用，花样可以不用搞太多，统一优雅即可，故采取全局设置 loading 效果。</p><h2 id="开发版本"><a href="#开发版本" class="headerlink" title="开发版本"></a>开发版本</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"react"</span>: <span class="string">"^16.13.1"</span>,</span><br><span class="line"><span class="string">"antd"</span>: <span class="string">"^4.0.4"</span>,</span><br><span class="line"><span class="string">"axios"</span>: <span class="string">"^0.19.2"</span></span><br></pre></td></tr></table></figure><h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><ol><li>通过 axios 提供的请求拦截和响应拦截的接口，控制 loading 的显示或者隐藏。在此我还设置了没有网络和网络超时的提示信息</li><li>采用 antd 的 Spin 组件来实现 loading 效果，message 组件来进行消息提示（antd.css 这里没有引入，是因为我设置了按需加载）</li><li>定义变量 requestCount 作为计数器，确保同一时刻如果有多个请求的话，不会同时添加多个 loading，而是只有 1 个，并在所有请求结束后才会隐藏 loading。</li><li>默认所有请求都会自动有 loading 效果。如果某个请求不需要 loading 效果，可以在请求 headers 中设置 isLoading 为 false。</li></ol><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>在 src 目录下新建一个文件 axios.js</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; message, Spin &#125; <span class="keyword">from</span> <span class="string">'antd'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Axios = axios.create(&#123;</span><br><span class="line">  <span class="comment">// baseURL: process.env.BASE_URL, // 设置请求的base url</span></span><br><span class="line">  timeout: <span class="number">20000</span>, <span class="comment">// 设置超时时长</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置post请求头</span></span><br><span class="line">Axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前正在请求的数量</span></span><br><span class="line"><span class="keyword">let</span> requestCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示loading</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showLoading</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (requestCount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    dom.setAttribute(<span class="string">'id'</span>, <span class="string">'loading'</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(dom)</span><br><span class="line">    ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Spin</span> <span class="attr">tip</span>=<span class="string">'加载中...'</span> <span class="attr">size</span>=<span class="string">'large'</span> /&gt;</span></span>, dom)</span><br><span class="line">  &#125;</span><br><span class="line">  requestCount++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏loading</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hideLoading</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  requestCount--</span><br><span class="line">  <span class="keyword">if</span> (requestCount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'loading'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求前拦截</span></span><br><span class="line">Axios.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="comment">// requestCount为0，才创建loading, 避免重复创建</span></span><br><span class="line">    <span class="keyword">if</span> (config.headers.isLoading !== <span class="literal">false</span>) &#123;</span><br><span class="line">      showLoading()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断当前请求是否设置了不显示Loading</span></span><br><span class="line">    <span class="keyword">if</span> (err.config.headers.isLoading !== <span class="literal">false</span>) &#123;</span><br><span class="line">      hideLoading()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回后拦截</span></span><br><span class="line">Axios.interceptors.response.use(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断当前请求是否设置了不显示Loading</span></span><br><span class="line">    <span class="keyword">if</span> (res.config.headers.isLoading !== <span class="literal">false</span>) &#123;</span><br><span class="line">      hideLoading()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.config.headers.isLoading !== <span class="literal">false</span>) &#123;</span><br><span class="line">      hideLoading()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err.message === <span class="string">'Network Error'</span>) &#123;</span><br><span class="line">      message.warning(<span class="string">'网络连接异常！'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err.code === <span class="string">'ECONNABORTED'</span>) &#123;</span><br><span class="line">      message.warning(<span class="string">'请求超时，请重试'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把组件引入，并定义成原型属性方便使用</span></span><br><span class="line">Component.prototype.$axios = Axios</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Axios</span><br></pre></td></tr></table></figure><ol start="2"><li>添加 loading 样式在共用的 css 文件里</li></ol><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#loading</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.75</span>);</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">9999</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>axios 请求</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 引入自定义axios文件路径</span></span><br><span class="line"><span class="comment">// 2. 引入共用css文件（loading样式）</span></span><br><span class="line"><span class="comment">// 3. 在react组件中正常写法请求url即可</span></span><br><span class="line">componentDidMount () &#123;</span><br><span class="line">    axios(&#123;</span><br><span class="line">      url: <span class="string">'/manage/statistic/base_count.do'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(res.data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不加 loading 效果，这样写</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">'/manage/statistic/base_count.do'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(res.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/3/29/17126d31a0fc0571?w=1854&h=954&f=gif&s=427836" alt=""></p>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Ant Design</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解之JavaScript之call, apply, bind方法</title>
    <url>/2020/03/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BJavaScript%E4%B9%8Bcall-apply-bind%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在JavaScript中，call、apply和bind是Function对象自带的三个方法，这三个方法的主要作用是改变函数执行时的上下文，再具体一点就是<strong>改变函数运行时的this指向</strong>。</p>
<a id="more"></a>
<ul>
<li><h2 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h2></li>
</ul>
<p>call() 方法调用一个函数, 其具有一个指定的 this 值和多个参数(参数的列表)。</p>
<blockquote>
<p>fun.call(thisArg, arg1, arg2, …)</p>
</blockquote>
<p>thisArg的取值有以下4种情况：</p>
<ol>
<li>不传，或者传null, undefined， 函数中的this指向window对象（非严格模式下）</li>
<li>传递另一个函数的函数名，函数中的this指向这个函数的引用</li>
<li>传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean</li>
<li>传递一个对象，函数中的this指向这个对象.</li>
</ol>
<p>我们可以用如下代码验证一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);   </span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;&#125;       </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"jacky"</span> &#125;;  </span><br><span class="line"></span><br><span class="line">func1.call();   <span class="comment">// Window</span></span><br><span class="line">func1.call(<span class="literal">null</span>);   <span class="comment">// Window</span></span><br><span class="line">func1.call(<span class="literal">undefined</span>);   <span class="comment">// Window</span></span><br><span class="line">func1.call(<span class="number">1</span>);   <span class="comment">// Number &#123;1&#125;</span></span><br><span class="line">func1.call(<span class="string">''</span>);   <span class="comment">// String &#123;""&#125;</span></span><br><span class="line">func1.call(<span class="literal">true</span>);   <span class="comment">// Boolean &#123;true&#125;</span></span><br><span class="line">func1.call(func2);   <span class="comment">// ƒ func2() &#123;&#125;</span></span><br><span class="line">func1.call(obj);   <span class="comment">// &#123;name: "jacky"&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们再来看个例子，理解怎么改变this的指向：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'animal'</span>;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'cat'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">animal.sayName.call(cat); <span class="comment">// cat</span></span><br><span class="line"><span class="comment">// this 永远指向最后调用它的那个对象</span></span><br><span class="line"><span class="comment">// 该例子中sayName方法的this指向Cat</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h2></li>
</ul>
<p>call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个<strong>数组</strong>里面作为它的第二个参数，他们俩之间的差别在于<strong>参数</strong>的区别。</p>
<p>如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> 和其他参数 <span class="subst">$&#123;args&#125;</span>`</span>); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = &#123;</span><br><span class="line">    name: <span class="string">'xiaomao'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用 call</span></span><br><span class="line">Animal.call(cat, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// xiaomao 和其他参数 1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 apply</span></span><br><span class="line">Animal.apply(cat, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// xiaomao 和其他参数 1,2,3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="call、apply使用"><a href="#call、apply使用" class="headerlink" title="call、apply使用"></a>call、apply使用</h2></li>
</ul>
<p>由于两个方法实际效果是一样的，对于两者平时用该如何选择呢？</p>
<ol>
<li>参数数量/顺序确定就用call，参数数量/顺序不确定的话就用apply。</li>
<li>考虑可读性：参数数量不多就用call，参数数量比较多的话，把参数整合成数组，使用apply。</li>
<li>参数集合已经是一个数组的情况，用apply。</li>
</ol>
<ul>
<li><h2 id="call-apply-的应用"><a href="#call-apply-的应用" class="headerlink" title="call, apply 的应用"></a>call, apply 的应用</h2></li>
</ul>
<h3 id="数组拼接"><a href="#数组拼接" class="headerlink" title="数组拼接"></a>数组拼接</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 apply方法</span></span><br><span class="line">[].push.apply(arr1, arr2);  <span class="comment">// 给arr1添加arr2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h3 id="获取数组中的最大值或最小值"><a href="#获取数组中的最大值或最小值" class="headerlink" title="获取数组中的最大值或最小值"></a>获取数组中的最大值或最小值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">98</span>]; </span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, numbers) );   <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">98</span>) ); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.min.call(<span class="built_in">Math</span>, ...numbers) ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'string'</span>,</span><br><span class="line">    obj = &#123; <span class="attr">name</span>: <span class="string">'jacky'</span> &#125;</span><br><span class="line"><span class="comment">// 判断传入参数是否为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isArray(arr)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isArray(str)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr)); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(str)); <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(obj)); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>

<h3 id="调用父类构造函数实现继承"><a href="#调用父类构造函数实现继承" class="headerlink" title="调用父类构造函数实现继承"></a>调用父类构造函数实现继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;      </span><br><span class="line">    <span class="keyword">this</span>.name = name;      </span><br><span class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      </span><br><span class="line">    &#125;      </span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;    </span><br><span class="line">    Animal.call(<span class="keyword">this</span>, name);    </span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">"xiaomao"</span>);     </span><br><span class="line">cat.showName();   <span class="comment">// xiaomao</span></span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ol>
<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>
<li>每次子类实例化都要执行父类函数，重新声明父类this里所定义的方法，因此父类方法无法复用。</li>
</ol>
<h3 id="类数组对象转数组"><a href="#类数组对象转数组" class="headerlink" title="类数组对象转数组"></a>类数组对象转数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。</p>
<h3 id="代理console-log方法"><a href="#代理console-log方法" class="headerlink" title="代理console.log方法"></a>代理console.log方法</h3><p>注意这里传入多少个参数是不确定的，所以使用apply是最好的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">log(<span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line">log(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h2></li>
</ul>
<p>MDN的解释是：</p>
<blockquote>
<p>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
</blockquote>
<p>说直白一点，bind方法是创建一个函数，然后可以在需要调用的时候再执行函数，并非是立即执行函数；而call，apply是在改变了上下文中的this指向后并立即执行函数。</p>
<p>bind 接收的参数类型与 call 是一样的，给它传递的是一组用逗号分隔的参数列表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123; </span><br><span class="line">    x: <span class="number">2</span>   </span><br><span class="line">&#125;   </span><br><span class="line">bar(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo);   </span><br><span class="line">func(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="bind的应用"><a href="#bind的应用" class="headerlink" title="bind的应用"></a>bind的应用</h2></li>
</ul>
<h3 id="bind绑定回调函数的this指向"><a href="#bind绑定回调函数的this指向" class="headerlink" title="bind绑定回调函数的this指向"></a>bind绑定回调函数的this指向</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(callBack) &#123;</span><br><span class="line">        <span class="keyword">this</span>.className = <span class="string">'PageA'</span></span><br><span class="line">        <span class="keyword">this</span>.MessageCallBack = callBack </span><br><span class="line">        <span class="keyword">this</span>.MessageCallBack(<span class="string">'执行了'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.className = <span class="string">'PageB'</span></span><br><span class="line">        <span class="keyword">this</span>.pageClass = <span class="keyword">new</span> PageA(<span class="keyword">this</span>.handleMessage)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回调函数</span></span><br><span class="line">    handleMessage(msg) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'处理'</span> + <span class="keyword">this</span>.className + <span class="string">'的回调 '</span> + msg) <span class="comment">// 处理PageA的回调 执行了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> PageB();</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，我们发现回调函数this丢失了？问题出在这行代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.pageClass = <span class="keyword">new</span> PageA(<span class="keyword">this</span>.handleMessage)</span><br></pre></td></tr></table></figure>
<p>传递过去的this.handleMessage是一个函数内存地址，没有上下文对象，也就是说该函数没有绑定它的this指向。</p>
<p>解决方案：用bind绑定this的指向</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.pageClass = <span class="keyword">new</span> PageA(<span class="keyword">this</span>.handleMessage.bind(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure>
<p>这也是为什么react的render函数在绑定回调函数的时候，也要使用bind绑定一下this的指向，也是因为同样的问题以及原理。</p>
<ul>
<li><p>多个bind的情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    x: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    x: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">    x: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func1 = bar.bind(obj1).bind(obj2);</span><br><span class="line"><span class="keyword">var</span> func2 = bar.bind(obj1).bind(obj2).bind(obj3);</span><br><span class="line">func1(); <span class="comment">// 2</span></span><br><span class="line">func2(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>输出结果都为第一个绑定的obj对象的x值。原因是，在Javascript中，bind()方法返回的外来的绑定函数对象仅在创建的时候记忆上下文（如果提供了参数），多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。</p>
</li>
<li><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li>
</ul>
<p>call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现; apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数，他们俩之间的差别在于参数的区别。</p>
<p>call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数,其内的this指向为创建它时传入bind的第一个参数，而传入bind的第二个及以后的参数作为原函数的参数来调用原函数。bind的参数可以在函数执行的时候再次添加。</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之作用域链与闭包</title>
    <url>/2020/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>作用域和闭包是 Js 很重要的概念，对此进行深入了解</p>
<a id="more"></a>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是指程序源代码中定义变量的区域。</p>
<p>实际上描述的就是查找变量的范围，作用域必须有的两个功能就是<strong>存储变量</strong>以及<strong>查找变量</strong>，作用域就是发挥这两个作用以及更多作用的规则。</p>
<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<h3 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h3><ul>
<li>词法作用域：（静态作用域）函数的作用域在函数定义的时候就决定了。</li>
<li>动态作用域：函数的作用域是在函数调用的时候才决定的。</li>
</ul>
<p>JavaScript 采用的是词法作用域</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域</p>
<p>全局变量：</p>
<blockquote>
<ol>
<li>生命周期将存在于整个程序之内。</li>
<li>能被程序中任何函数或者方法访问。</li>
<li>在 JavaScript 内默认是可以被修改的。</li>
</ol>
</blockquote>
<p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p>
<h4 id="显式声明"><a href="#显式声明" class="headerlink" title="显式声明"></a>显式声明</h4><p>带有关键字 var 的声明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> winValue = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.winValue) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h4 id="隐式声明"><a href="#隐式声明" class="headerlink" title="隐式声明"></a>隐式声明</h4><p>不带有声明关键字的变量，JS 会默认帮你声明一个全局变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  result = value + <span class="number">1</span> <span class="comment">// 没有用 var 声明</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.result) <span class="comment">// 2 &lt;=  挂在了 window全局对象上</span></span><br></pre></td></tr></table></figure>

<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数作用域内，对外是封闭的，从外层的作用域无法直接访问函数内部的作用域。</p>
<p>在函数内部的变量权限称为函数作用域，有以下特点：</p>
<ol>
<li>每个函数都有自己的作用域，而且调用一次就会生成新的作用域</li>
<li>只能在函数内部才能访问，外部是没有权限访问的</li>
<li>进入函数内部时开启，函数执行完毕后销毁</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="string">'test'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="块级作用域（ES6-新增）"><a href="#块级作用域（ES6-新增）" class="headerlink" title="块级作用域（ES6 新增）"></a>块级作用域（ES6 新增）</h3><p>凡是由{}符号包裹起来的都是块作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>

<p>在 for 循环执行完毕之后 i 变量就被释放了</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链：当访问一个变量时，解释器会首先在当前作用域查找，如果没有找到，就去父作用域找，直到找到该变量或者不在父作用域中，这就是作用域链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>

<p>从上面代码的执行结果可以看出，foo 函数取到了它外部的变量 a, 而最外层的 console.log(b) 操作并没能取得 foo 函数里面的变量 b。</p>
<ul>
<li>作用域链和原型继承查找时的区别：</li>
</ul>
<p>如果去查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回 undefined；但查找的属性在作用域链中不存在的话就会抛出 ReferenceError。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>闭包是指<strong>有权访问另外一个函数作用域中的变量的函数</strong></p>
<p>在 javascript 中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成”定义在一个函数内部的函数”。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p>
<ul>
<li>闭包由两部分构成：</li>
</ul>
<ol>
<li>函数</li>
<li>能访问另外一个函数作用域中的变量</li>
</ol>
<h3 id="为什么有闭包"><a href="#为什么有闭包" class="headerlink" title="为什么有闭包?"></a>为什么有闭包?</h3><blockquote>
<p>之所以出现闭包是因为 JS 的垃圾回收机制，JS 本身为了避免解释器过量消耗内存，造成系统崩溃，自带有一套垃圾回收机制，垃圾回收机制能够检测到一个对象是不是无用的。检测到之后，就会把它占用的内存释放掉。但是实际工作中，我们也会需要一些变量不那么及时的被清理，所以就出现了闭包，用来达成这个效果。</p>
</blockquote>
<h3 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h3><ul>
<li>闭包可以访问当前函数以外的变量</li>
<li>即使外部函数已经返回，闭包仍能访问外部函数定义的变量</li>
<li>参数和变量不会被垃圾回收机制收回。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOuter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'jacky'</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str + name) <span class="comment">// 可以访问getName函数外部的name</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getName(<span class="string">'名字是：'</span>)</span><br><span class="line">&#125;</span><br><span class="line">getOuter() <span class="comment">// 名字是：jacky</span></span><br></pre></td></tr></table></figure>

<p>再来看下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = bar() <span class="comment">// 这一句执行完，变量x并没有被回收，因为要内部函数还需要引用</span></span><br><span class="line"><span class="built_in">console</span>.log(foo()) <span class="comment">// 3  执行内部函数，引用外部变量x</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，在全局执行上下文中定义了一个函数 bar 和变量 foo，函数 bar 内部返回一个匿名函数，所以此刻匿名函数的作用域链初始化为包含了全局变量对象和 bar 中的变量对象。</p>
<p>当执行 var foo = bar()时，把函数 bar 的执行上下文压入栈，当 bar 执行完后，其执行上下文应该弹出栈，但是因为 bar 内部的匿名函数作用域链还引用这 bar 函数内的变量 x，所以 bar 的执行上下文得不到释放，这样就形成了闭包。</p>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><ol>
<li>设计私有的方法和变量（封装，定义模块）。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span> <span class="comment">//私有变量</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      change(<span class="number">1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      change(<span class="number">-1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>匿名函数最大的用途是创建闭包。减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objEvent = objEvent || &#123;&#125;</span><br><span class="line">;(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// some code</span></span><br><span class="line">  &#125;</span><br><span class="line">  objEvent.addEvent = addEvent</span><br><span class="line">  objEvent.removeEvent = removeEvent</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>addEvent 和 removeEvent 都是局部变量，但我们可以通过全局变量 objEvent 使用它</p>
<h3 id="如何销毁闭包"><a href="#如何销毁闭包" class="headerlink" title="如何销毁闭包"></a>如何销毁闭包</h3><p>javascript 中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收。如果两个对象互相引用，而不再被第 3 者所引用，那么这两个互相引用的对象也会被回收。</p>
<p>即释放对闭包的引用，使引用变量为 null。</p>
<h3 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h3><p>优点：</p>
<ol>
<li>闭包里的变量不会污染全局，因为变量被封在闭包里；</li>
<li>所有变量都在闭包里保证了隐私性和私有性；</li>
<li>可以让这些局部变量保存在内存中，实现变量数据共享。</li>
</ol>
<p>缺点：</p>
<p>形成闭包即要把一个函数当成值传递，而且该函数还引用这另一个函数的作用域链使得被引用的函数不能被回收，使用不当容易造成内存泄漏；</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>作用域链</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之 new 原理及模拟实现</title>
    <url>/2020/02/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B-new-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>探讨 new 原理……</p>
<a id="more"></a>

<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例</p>
<p>先看看 new 实现了哪些功能, 先来看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'年龄为:'</span> + <span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="number">18</span>)</span><br><span class="line">person.age <span class="comment">// 访问构造函数里的属性</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">person.getAge() <span class="comment">// 访问原型里的属性</span></span><br><span class="line"><span class="comment">// 年龄为:18</span></span><br></pre></td></tr></table></figure>

<p>从上面代码可以知道，实例 person 可以：</p>
<ol>
<li>访问到 Person 构造函数里的属性</li>
<li>访问到 Person.prototype 中的属性</li>
</ol>
<p>这个是最基本的了，也是刚学会 new 一个对象就知道这是 new 的特点</p>
<h2 id="探讨-new-还做了什么？"><a href="#探讨-new-还做了什么？" class="headerlink" title="探讨 new 还做了什么？"></a>探讨 new 还做了什么？</h2><p>探讨完上面，接下来看看 new 还做了什么？来看几个例子</p>
<h3 id="没有-return-语句"><a href="#没有-return-语句" class="headerlink" title="没有 return 语句"></a>没有 return 语句</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// Person &#123;age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>从构造函数直观看，最后是没有 return 语句的，但我们从返回结果也可以看出构造函数时默认情况会返回一个新对象</p>
<h3 id="return-对象数据类型"><a href="#return-对象数据类型" class="headerlink" title="return 对象数据类型"></a>return 对象数据类型</h3><p>我们尝试在构造函数最后返回一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">'手动返回一个对象'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// &#123;name: "手动返回一个对象"&#125;</span></span><br></pre></td></tr></table></figure>

<p>打印出来的结果可以看出：return 之前的代码片段都被覆盖了，最后返回 return 后面的对象。</p>
<h3 id="return-基本数据类型"><a href="#return-基本数据类型" class="headerlink" title="return 基本数据类型"></a>return 基本数据类型</h3><p>如果构造函数最后 return 的不是对象呢，试下基本数据类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// Person &#123;age: 18&#125;</span></span><br></pre></td></tr></table></figure>

<p>从打印出来的结果可知，和没有 return 效果一样。</p>
<h2 id="new-原理"><a href="#new-原理" class="headerlink" title="new 原理"></a>new 原理</h2><p>mdn 上把内部操作大概分为 4 步：</p>
<blockquote>
<ol>
<li>创建一个空的简单 JavaScript 对象（即{ } ）；</li>
<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；(因此 this 就指向了这个新对象)</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>如果该函数没有返回对象，则返回 this。</li>
</ol>
</blockquote>
<h2 id="模拟实现-new"><a href="#模拟实现-new" class="headerlink" title="模拟实现 new"></a>模拟实现 new</h2><p>new 是关键词，不可以直接覆盖。这里使用 create 来模拟实现 new 的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空的对象</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">    <span class="comment">// 获得构造函数，arguments中去除第一个参数</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 链接到原型，obj 可以访问到构造函数原型中的属性</span></span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line">  <span class="comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">  <span class="keyword">var</span> ret = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="comment">// 优先返回构造函数返回的对象</span></span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看看上面是怎么一步步模拟实现的：</p>
<ol>
<li>用 new Object() 的方式新建了一个空对象 obj</li>
<li>取出第一个参数，即是传入的构造函数。shift 会修改原数组，数组原来的第一个元素的值。</li>
<li>将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性</li>
<li>使用 apply，改变构造函数 this 的指向。将 this 指向 obj 对象 就可以访问到构造函数中的属性</li>
<li>处理返回值。</li>
</ol>
<ul>
<li>构造函数返回值有三种情况：</li>
</ul>
<ol>
<li>没有 return，默认返回之前创建的对象</li>
<li>返回一个对象</li>
<li>返回的不是对象，默认返回之前创建的空对象</li>
</ol>
<p>在上面我们用 instanceof 方法来判断是否为对象</p>
<blockquote>
<p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</p>
</blockquote>
<p>测试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'年龄为:'</span> + <span class="keyword">this</span>.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = create(Person, <span class="number">18</span>)</span><br><span class="line">person.age <span class="comment">// 访问构造函数里的属性</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">person.getAge() <span class="comment">// 访问原型里的属性</span></span><br><span class="line"><span class="comment">// 年龄为:18</span></span><br></pre></td></tr></table></figure>

<p>模拟实现成功！</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>new</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之原型与原型链</title>
    <url>/2020/02/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>对于 JavaScript，原型是很重要的一个基础知识点，涉及的内容很多，在此总结一下</p>
<a id="more"></a>

<h2 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h2><p>原型是一个对象，把 prototype 称为原型对象，prototype 可以让所有的对象实例共享它包含的属性和方法。</p>
<p>JavaScript 规定，每一个函数都有一个 prototype 对象属性，指向另一个对象。prototype 对象属性的所有属性和方法都会被构造函数的实例继承。</p>
<h2 id="只有函数有-prototype-属性"><a href="#只有函数有-prototype-属性" class="headerlink" title="只有函数有 prototype 属性"></a>只有函数有 prototype 属性</h2><p>js 分为函数对象和普通对象，每个对象都有<strong>proto</strong>属性，但是只有函数对象才有 prototype 属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(func.prototype) <span class="comment">// &#123; constructor: function()&#123;...&#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>JS 通过 new 关键字，即靠构造函数生成对象，每次生成的对象都不一样。因为常常需要在两个对象之间共享属性，由于 JS 在设计之初没有类的概念，所以 JS 使用函数的 prototype 属性来处理这部分需要被共享的属性。</p>
<h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Animal.prototype.name = <span class="string">'kiki'</span></span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="built_in">console</span>.log(animal1.name, animal2.name) <span class="comment">// kiki kiki</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 animal1 和 animal2 的原型</p>
<p>每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p>
<p>构造函数和实例原型关系如下图：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/15/17049498b6d308cb?w=885&h=207&f=png&s=21292" alt=""></p>
<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>那么如何表示实例与实例原型之间的关系呢，这里需要讲到另一个属性<strong>proto</strong></p>
<p>每一个 JavaScript 对象(除了 null)都具有的一个属性，叫<strong>proto</strong>，这个属性会指向该对象的原型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="built_in">console</span>.log(dog.__proto__ === Animal.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>于是更新实例与实例原型之间的关系如下图：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/15/17049522bfa417ec?w=866&h=336&f=png&s=32709" alt=""></p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>每个原型都有一个 constructor 属性指向关联的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Animal === Animal.prototype.constructor) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/15/170496796080e487?w=849&h=347&f=png&s=35480" alt=""></p>
<p>则可以得出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="built_in">console</span>.log(dog.__proto__ === Animal.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Object.getPrototypeOf() 方法返回指定对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(dog) === Animal.prototype) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Animal.prototype.constructor == Animal) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>再提一点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="built_in">console</span>.log(dog.constructor === Animal) <span class="comment">// true</span></span><br><span class="line"><span class="comment">/* 当获取 dog.constructor 时，其实 dog 中并没有 constructor 属性,</span></span><br><span class="line"><span class="comment">当不能读取到constructor 属性时，</span></span><br><span class="line"><span class="comment">会从 dog 的原型也就是 Animal.prototype 中读取，正好原型中有该属性, 所以下列代码为true */</span></span><br><span class="line">dog.constructor === Animal.prototype.constructor</span><br></pre></td></tr></table></figure>

<h2 id="实例和原型"><a href="#实例和原型" class="headerlink" title="实例和原型"></a>实例和原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.name = <span class="string">'kiki'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal()</span><br><span class="line"></span><br><span class="line">dog.name = <span class="string">'xiaobai'</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.name) <span class="comment">// xiaobai</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> dog.name</span><br><span class="line"><span class="built_in">console</span>.log(dog.name) <span class="comment">// kiki</span></span><br></pre></td></tr></table></figure>

<p>上述代码。首先构造函数原型设置了 name 值，接着 dog 实例添加了 name 属性，覆盖原型的 name 值，打印 dog.name 时结果自然是 xiaobai。</p>
<p>当删除了 dog 的 name 属性时，读取 dog.name 时，从对象中无法找到 name 属性，就会从 dog 的原型，也就是 dog.<strong>proto</strong>，即 Animal.prototype 中查找，找到结果为 kiki。</p>
<p>如果原型没有设置 name 值，找不到呢？原型的原型又是谁？</p>
<h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>原型本身也是一个对象，既然是对象，我们就可以用最原始的方式创建它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">obj.name = <span class="string">'kiki'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// kiki</span></span><br></pre></td></tr></table></figure>

<p>其实原型对象就是通过 Object 构造函数生成的，所有函数的 默认原型 都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype。</p>
<p>由此，更新关系图：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/16/1704bf72a35f1a74?w=861&h=505&f=png&s=54960" alt=""></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ol>
<li>每个对象都拥有一个原型对象: dog 的原型是 Animal.prototype。</li>
<li>对象的原型可能也是继承其他原型对象的: Animal.prototype 也有它的原型 Object.prototype。</li>
<li>一层一层的，以此类推，这种关系就是原型链。</li>
</ol>
<p>那么<code>Object.prototype</code>的原型是什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。null 表示此处不应该有值，也就是原型链的终点了，所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/16/1704bffc23da9aaf?w=800&h=592&f=png&s=54550" alt=""></p>
<p>上图中的红色线组成的链就可以称之为原型链。</p>
<p>由上述关系图我们可以重新描述一下原型链：</p>
<blockquote>
<p>从一个实例对象开始往上找，这个实例对象的<strong>proto</strong>属性所指向的则是这个实例对象的原型对象，如果用 dog 表示这个实例，则原型对象表示为<code>dog.__proto__</code>。同时，这个原型也是一个对象，而且它也有上一级的原型对象，相对于上一级原型对象而言，它也是一个实例对象，那么它也拥有<strong>proto</strong>属性，它的<strong>proto</strong>属性也指向它的原型对象，后面也以此类推，一直到 Object.prototype 这个原型为止，这就是整个原型链。</p>
</blockquote>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之Generator生成器全解析</title>
    <url>/2020/01/13/ES6%E7%B3%BB%E5%88%97%E4%B9%8BGenerator%E7%94%9F%E6%88%90%E5%99%A8%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>上一篇我们写完了 Iterator 迭代器，这次我们来讲下 Generator 生成器，如果不了解 Iterator 的话建议先看我上一篇博客，因为这篇会涉及迭代器的内容。</p>
<a id="more"></a>

<h2 id="为什么需要-Generator"><a href="#为什么需要-Generator" class="headerlink" title="为什么需要 Generator"></a>为什么需要 Generator</h2><p>在 JavaScript 中，异步编程场景使用非常多，经常会出现需要逐步完成多个异步操作的情况。之前用回调函数实现异步编程如果碰到了这种问题就需要嵌套使用回调函数，异步操作越多，嵌套得就越深，导致代码的可维护性较差，代码阅读起来也很困难。</p>
<p>Generator 函数是 ES6 提出的一种异步编程解决方案，它可以避免回调的嵌套，语法行为与传统函数完全不同。除此之外，Generator 的特性在某些场景使用也十分方便。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>语法上，首先可以把它理解成，Generator 函数是一个状态机，还是一个 Iterator 对象生成函数。它返回的遍历器对象可以依次遍历 Generator 函数内部的每一个状态。Generator 函数是生成一个对象，但是调用的时候前面不能加 new 命令。</p>
<p>通俗来说，Generator 函数它可以随时暂停函数运行，并可以在任意时候恢复函数运行。</p>
<h2 id="与-Iterator-接口的关系"><a href="#与-Iterator-接口的关系" class="headerlink" title="与 Iterator 接口的关系"></a>与 Iterator 接口的关系</h2><p>任意一个对象的 Symbol.iterator 方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p>
<p>由于 Generator 函数就是 Iterator 迭代器生成函数，因此可以把 Generator 赋值给对象的 Symbol.iterator 属性，从而使得该对象具有 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...myIterable]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，Generator 函数赋值给 Symbol.iterator 属性，从而使得 myIterable 对象具有了 Iterator 接口，可以被…运算符遍历了。</p>
<p>Generator 函数执行后，返回一个迭代器对象。该对象本身也具有 Symbol.iterator 属性，执行后返回自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g[<span class="built_in">Symbol</span>.iterator]() === g) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，gen 是一个 Generator 函数，调用它会生成一个迭代器对象 g。它的 Symbol.iterator 属性，也是一个遍历器对象生成函数，执行后返回它自己。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>function 关键字与函数名之间有一个<code>*</code>号，而且这个<code>*</code>前后允许有空白字符，如：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>以上四种写法都可以，根据个人不同习惯，一般第三和第四种用得比较多</p>
<ol start="2">
<li>函数体内部使用 yield 表达式，定义不同的内部状态</li>
<li>普通函数的执行模式是: <strong>执行-结束</strong>, 生成器的执行模式是: <strong>执行-暂停-结束</strong>。生成器可以在执行当中暂停自身，可以立即恢复执行也可以过一段时间之后恢复执行。最大的区别就是它不像普通函数那样保证运行到完毕。</li>
</ol>
<h2 id="yield-关键字"><a href="#yield-关键字" class="headerlink" title="yield 关键字"></a>yield 关键字</h2><p>生成器函数中，有一个特殊的新关键字：<code>yield</code>。由于 Generator 函数返回的是一个 Iterator 对象，只有调用 next 方法才会遍历下一个内部状态,而<code>yield</code>关键字就是<strong>暂停标志</strong>。因为有它，所以才能实现执行-暂停-结束的执行模式。</p>
<p><code>yield</code> 后面可以是任意合法的 JavaScript 表达式，<code>yield</code>语句可以出现的位置可以等价于一般的赋值表达式（比如 a=2）能够出现的位置。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b = <span class="number">2</span> + a = <span class="number">2</span> <span class="comment">// 不合法</span></span><br><span class="line">b = <span class="number">2</span> + <span class="keyword">yield</span> <span class="number">2</span> <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">2</span> + (a = <span class="number">2</span>) <span class="comment">// 合法</span></span><br><span class="line">b = <span class="number">2</span> + (<span class="keyword">yield</span> <span class="number">2</span>) <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>

<p><code>yield</code>关键字的优先级比较低，几乎<code>yield</code>之后的任何表达式都会先进行计算，然后再通过<code>yield</code>向外界产生值。而且<code>yield</code>是右结合运算符，也就是说</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yield yield 2 等价于 (yield (yield 2))</span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：</p>
<ol>
<li>它可以指定调用 next 方法时的返回值以及调用顺序。</li>
<li>每当执行完 yield 语句，函数就会停止执行，直到再次调用 next 方法才会继续执行</li>
<li>yield 关键字只能在生成器内部使用，其他地方会导致语法错误</li>
</ol>
<h2 id="运行生成器函数"><a href="#运行生成器函数" class="headerlink" title="运行生成器函数"></a>运行生成器函数</h2><p>说了这么多，我们来举个简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述为一个生成器函数，如何运行它呢？我们知道，生成器还是一个遍历器/迭代器生成函数，也就是说，返回的 Iterator 对象，可以依次遍历生成器函数内部的每一个状态，所以我们可以使用 next()方法让它运行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = gen() <span class="comment">// 生成器返回的是一个指向内部状态的generator对象</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>首先要知道的是，Generator 函数，不管内部有没有<code>yield</code>语句，调用函数时都不会执行任何语句，也不返回函数执行结果，而是返回一个指向内部状态的 generator 对象，也可以看作是一个 Iterator 对象。只有当调用 next(),内部语句才会执行。</p>
<p>在该函数内部有 3 个<code>yield</code>表达式，即该函数有三个状态：1、2、3。而 Generator 函数在此分段执行，调用 next 方法函数内部逻辑开始执行，遇到<code>yield</code>表达式停止，返回 Iterator 对象，再次调用 next 方法，会从上一次停止时的<code>yield</code>处开始，直到最后。所以我们也不难理解<code>yield</code>语句只是函数暂停执行的一个标记。</p>
<p>再来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen()</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上述生成器函数 gen 有三个状态：hello，world 和 return 语句。</p>
<p>第一次调用 next 方法，生成器函数开始执行，遇到第一个 yield 表达式，返回一个对象，它的 value 属性就是当前 yield 表达式的值 hello，done 属性的值 false，表示遍历还没有结束。</p>
<p>同理第二次调用也是按上述逻辑推</p>
<p>第三次调用 next 方法，遇到了 return 语句（如果没有 return 语句，就执行到函数结束）。此时 next 方法返回的对象的 value 属性，就是紧跟在 return 语句后面的表达式的值，在这里 return 后的值即是”ending”（如果没有 return 语句，则 value 属性的值为 undefined），done 属性的值 true，表示遍历已经结束。</p>
<p>第四次调用，此时 生成器函数已经运行完毕，故 next 方法返回对象的 value 属性为 undefined，done 属性为 true。以后无论调用多少次 next 方法，返回的都是这个值。</p>
<h2 id="next-传递参数"><a href="#next-传递参数" class="headerlink" title="next 传递参数"></a>next 传递参数</h2><p>由上述我们知道总结 next 方法的运行逻辑：</p>
<ol>
<li>遇到 <code>yield</code> 语句暂停执行后面的操作，并将在 <code>yield</code> 后面那个表达式的值，作为返回对象的 value 属性值</li>
<li>下次调用 next 方法时，再继续往下执行，直到遇到下一个 <code>yield</code> 语句</li>
<li>如果没有遇到新的 <code>yield</code> 语句，就一直运行函数结束 到 return 语句为止，将 return 的值作为返回的对象 value 的属性值</li>
<li>如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined</li>
</ol>
<p>那 next 方法可以带参数吗？答案当然是可以的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">yield</span> a + <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> b * <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator1 = gen(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(generator1.next()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator1.next()) <span class="comment">// &#123;value: NaN, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator2 = gen(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(generator2.next(<span class="number">2</span>)) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator2.next(<span class="number">4</span>)) <span class="comment">// &#123;value: 16, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面两个例子中，生成器函数 gen 都接收了一个参数 a,都传入了 1。</p>
<p>第一个例子中：第一次调用 next 方法，let b = yield 1 + 1 = yield 2,即返回<code>yield</code>的 value 值为 2；到了第二次调用时，语句 return b _ 2，返回的对象 value 值居然为 NaN。由此可推断此时的 b 并不是上次计算的结果 2，而是 undefined，所以 undefined _ 4 = NaN</p>
<p>看到这里，不懂生成器的小伙伴可能有点懵逼，表面上变量 b 已经用 yield 语句赋值了，但并没有赋值成功。</p>
<p>再第二个例子：第一次调用 next 方法，let b = yield (1 + 1),此时的 next 方法传入了参数，值为 1，这个参数有什么用呢？答：确实没什么用，这里只是为了示范它对结果无影响。</p>
<blockquote>
<p>第一个 next 方法只是用来启动生成器函数内部的遍历器，传参也没有多大意义。即使传了值，它只是将这个传入的值抛弃而已。ES6 表明，generator 函数在这种情况只是忽略了这些没有被用到的值。</p>
</blockquote>
<p>所以 let b = yield (1 + 1) = yield 2, 返回 value 值仍然为 2；第二次调用 next 方法时传入了参数 4，此时 4 覆盖上次 yield 语句的返回值 2，即 let b = 4;故执行 return b _ 4 语句时，即 return 4 _ 4，即返回了 16。</p>
<ul>
<li>上述结果可以说明：<ul>
<li><strong>yield 语句没有返回值，或者总是返回 undefined；</strong></li>
<li><strong>next 方法如果带上一个参数，这个参数就是作为上一个 yield 语句的返回值。<br>注意：因为 next 方法表示上一个 yield 语句的返回值，所以必须有上一个 yield 语句的存在，那么第一次调用 next 方法时就不能传参数。第一个 next 只是用来启动 Generator 函数内部的遍历器，传参也没有多大意义。</strong></li>
</ul>
</li>
</ul>
<p>对于上述两点，我们需要代码再次加深理解：</p>
<p>yield 后可以不带任何表达式的时候，返回的 value 为 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span></span><br><span class="line">&#125;)()</span><br><span class="line"><span class="built_in">console</span>.log(gen.next()) <span class="comment">// &#123; value: undefined, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>再举一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> x + <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> y / <span class="number">4</span></span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 4, done: false&#125; 返回yield（2+2）= 4</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next(<span class="number">7</span>)) <span class="comment">// &#123;value: 3.5, done: false&#125; 设置yield(x+2) = 7,那么y= 2*7=14,那么yield(y/4) = 3.5</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next(<span class="number">3</span>)) <span class="comment">// &#123;value: 19, done: false&#125; 设置z = yield(y/4) = 3 那么 x+y+z = 2+14+3 = 19</span></span><br></pre></td></tr></table></figure>

<ol>
<li>第一次调用 next 方法，返回 yield（2+2）= 4，返回 value 值为 4</li>
<li>第二次调用 next 方法，next 参数值为 7，覆盖上一次的 yield 值，故 let y = 2 * 7 = 14，则 let z = yield(14 / 4) = 3.5</li>
<li>第三次调用 next 方法，next 参数值为 3，覆盖上一次的 yield 值，故 z = 3，x + y + z = 2 + 14 + 3 = 19</li>
</ol>
<p>这里初次看可能有点绕，建议多看多试几次就容易理解了。</p>
<h2 id="return-与-yield-区别"><a href="#return-与-yield-区别" class="headerlink" title="return 与 yield 区别"></a>return 与 yield 区别</h2><p>从以上的例子也可以看出，函数不仅是碰到 yield 语句才会停止执行，碰到 return 语句也会停止执行。普通函数遇到 return 也会停止执行，Generator 函数也是一个函数，所以很好理解。那么，两者的区别是什么呢？先来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen()</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: "hello", done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>从上面例子可以看出，当碰到 return 语句时，返回对象的 value 值为紧跟 return 后面的值，done 属性值就为 true，代表遍历结束，不管后面是否还有 yield 或者 return 语句。这种区别本质上是因为 yield 语句具备位置记忆功能而 return 语句则没有该功能。</p>
<h2 id="return-与-next-参数区别"><a href="#return-与-next-参数区别" class="headerlink" title="return 与 next 参数区别"></a>return 与 next 参数区别</h2><p>可以总结为三点：</p>
<ol>
<li>return 终结遍历，之后的 yield 语句都失效；next 返回本次 yield 语句的返回值。</li>
<li>return 没有参数的时候，返回{ value: undefined, done: true }；next 没有参数的时候返回本次 yield 语句的返回值。</li>
<li>return 有参数的时候，覆盖本次 yield 语句的返回值，也就是说，返回{ value: 参数, done: true }；next 有参数的时候，覆盖上次 yield 语句的返回值，返回值可能跟参数有关（参数参与计算的话），也可能跟参数无关（参数不参与计算）。</li>
</ol>
<h2 id="return-value-方法"><a href="#return-value-方法" class="headerlink" title="return(value)方法"></a>return(value)方法</h2><p>在生成器里使用 return(value)方法，随时终止生成器，如下面代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = gen()</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.return(<span class="number">10</span>)) <span class="comment">// &#123;value: 10, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>从上述代码我们看出，使用 return()方法我们提前终止了生成器，返回 return 里的值，再次调用 next()方法时，done 属性的值为 true,遍历结束，由此可见 return 提前终止了生成器。</p>
<h2 id="throw-exception-方法"><a href="#throw-exception-方法" class="headerlink" title="throw(exception)方法"></a>throw(exception)方法</h2><p>除了用 return(value)方法可以终止生成生成器，我们还可以调用 throw(exception) 进行提前终止生成器，示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen()</span><br><span class="line"><span class="built_in">console</span>.log(generator.next())</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  generator.throw(<span class="string">'throw error msg'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'必执行的finally语句块'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(generator.next())</span><br></pre></td></tr></table></figure>

<p>输出结果;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"><span class="keyword">throw</span> error msg</span><br><span class="line">必执行的<span class="keyword">finally</span>语句块</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>由此可以看出，在生成器外部调用 try…catch…finally,throw()异常被 try…catch 捕捉并返回，并执行了 finally 代码块中的代码。当再次调用 next 方法，done 属性返回 true,说明生成器已被终止。</p>
<p>我们不仅可以在 next 执行过程中插入 throw()语句，我们还可以在生成器内部插入 try…catch 进行错误处理。</p>
<blockquote>
<p>throw 方法抛出的错误要被内部捕获，前提是必须至少执行过一次 next 方法。</p>
</blockquote>
<p>代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'first Exception'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'second Exception'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = gen()</span><br><span class="line"><span class="built_in">console</span>.log(generator.next())</span><br><span class="line"><span class="built_in">console</span>.log(generator.throw(<span class="string">'exception string'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(generator.throw(<span class="string">'exception string'</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">first Exception</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">second Exception</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<p>从代码输出可以输出，当我们在 generator.throw()方法时，被生成器内部上个暂停点的异常处理代码所捕获，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次 next 方法。由此可见在生成器内部使用 try…catch 可以捕获异常，并不会影响到遍历器的状态。</p>
<h2 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h2><p>如果想要在 Generator 函数内部，调用另一个 Generator 函数。需要在前者的函数体内部，自己手动完成遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span></span><br><span class="line">  <span class="comment">// for...of遍历 gen1()</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> gen1()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> gen2()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p>如果有多个 Generator 函数嵌套，写起来就非常麻烦。<br>ES6 提供了<code>yield*</code>表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p>
<p>把上面的 gen2 函数改写如下,如下也能得到相同的输出结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span></span><br><span class="line">  <span class="keyword">yield</span>* gen1()</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>yield*</code>可以将可迭代的对象 iterable 放在一个生成器里，生成器函数运行到<code>yield*</code> 位置时，将控制权委托给这个迭代器，直到执行完成为止。举个例子，数组也是可迭代对象，因此<code>yield*</code>也可委托给数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span>* gen1()</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = gen2()</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: 5, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()) <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Generator-的应用场景"><a href="#Generator-的应用场景" class="headerlink" title="Generator 的应用场景"></a>Generator 的应用场景</h2><h3 id="异步操作的同步化表达"><a href="#异步操作的同步化表达" class="headerlink" title="异步操作的同步化表达"></a>异步操作的同步化表达</h3><p>Generator 函数的暂停执行的效果，意味着可以把异步操作写在 yield 表达式里面，等到调用 next 方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在 yield 表达式下面，反正要等到调用 next 方法时再执行。所以，Generator 函数的一个重要实际意义就是用来处理异步操作，改写回调函数，避免回调嵌套。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loadUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  showLoadingScreen()</span><br><span class="line">  <span class="keyword">yield</span> loadUIDataAsynchronously()</span><br><span class="line">  hideLoadingScreen()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loader = loadUI()</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.next()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.next()</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一次调用 next 方法时，则会显示 Loading 界面，并且异步加载数据。等到数据加载完成，再一次使用 next 方法，则会隐藏 Loading 界面。可以看到，这种写法的好处是所有 Loading 界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p>
<h3 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span></span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url)</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"><span class="keyword">var</span> result = g.next()</span><br><span class="line"></span><br><span class="line">result.value</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.json()</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    g.next(data)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。不过也可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<h3 id="部署-Iterator-接口"><a href="#部署-Iterator-接口" class="headerlink" title="部署 Iterator 接口"></a>部署 Iterator 接口</h3><p>利用 Generator 函数，可以在任意对象上部署 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i]</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">bar</span>: <span class="number">7</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，myObj 是一个普通对象，通过 iterEntries 函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署 next 方法。</p>
<h3 id="抽奖程序"><a href="#抽奖程序" class="headerlink" title="抽奖程序"></a>抽奖程序</h3><p>比如当前用户还可以抽奖 5 次，用户点了 5 次抽奖后就不能继续抽奖了，如做一个剩余抽奖次数的限制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"start"</span>&gt;</span>抽奖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> draw = <span class="function"><span class="keyword">function</span> (<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 具体抽奖逻辑</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`剩余<span class="subst">$&#123;count&#125;</span>次`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> residue = <span class="function"><span class="keyword">function</span>* (<span class="params">count</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 抽奖次数的限制</span></span><br><span class="line">    count--</span><br><span class="line">    <span class="keyword">yield</span> draw(count) <span class="comment">//执行抽奖的逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = residue(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'start'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  start.next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后我们通过点击 5 次抽奖按钮,依次输出剩余几次。当剩余 0 次时，再点击按钮不会有任何输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">剩余4次</span><br><span class="line">剩余3次</span><br><span class="line">剩余2次</span><br><span class="line">剩余1次</span><br><span class="line">剩余0次</span><br></pre></td></tr></table></figure>

<p>上述通过 generator 来控制抽奖的次数限制的好处是：抽奖次数无需保存在全局变量中，而且把抽奖具体逻辑给分离开。</p>
<h2 id="Generator-函数的语法糖—async-函数"><a href="#Generator-函数的语法糖—async-函数" class="headerlink" title="Generator 函数的语法糖—async 函数"></a>Generator 函数的语法糖—async 函数</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便，而 async 函数是就是 Generator 函数的语法糖。</p>
<ol>
<li><code>async</code> 对应的是 <code>*</code></li>
<li><code>await</code> 对应的是 <code>yield</code></li>
</ol>
<p><code>async</code>和<code>await</code>，比起<code>*</code>号和<code>yield</code>，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p>
<p>比如我们假装模拟一个请求 ajax 方法返回用户数据并输出显示的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'用户数据...'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">yield</span> ajax()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`输出的user数据:<span class="subst">$&#123;user&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当然真实项目不可能这么写，在此只是方便拿数据</span></span><br><span class="line"><span class="keyword">const</span> generator = fetchUser()</span><br><span class="line"><span class="keyword">let</span> obj = generator.next()</span><br><span class="line">generator.next(obj.value)</span><br></pre></td></tr></table></figure>

<p>如果用 async 函数代替,代码就会优雅很多</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> ajax()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`输出的user数据:<span class="subst">$&#123;user&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">fetchUser()</span><br></pre></td></tr></table></figure>

<p>这里可以看出并不需要调用 next()方法，因为 async 函数自带执行器。也就是说，<br>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Generator 是一个可以暂停和继续执行的函数，他可以完全实现 Iterator 的功能，并且由于可以保存上下文，他非常适合实现简单的状态机。另外通过一些流程控制代码的配合，可以比较容易进行异步操作。</p>
<p>Async/Await 就是 generator 进行异步操作的语法糖，该语法糖相比下有更好的应用和语义化，它们搭配 promise，可以通过编写形似同步的代码来处理异步流程，提高代码的简洁性和可读性。</p>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Generator</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之一文彻底弄懂Iterator</title>
    <url>/2020/01/11/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Iterator/</url>
    <content><![CDATA[<p>本文主要来深入剖析 ES6 的 Iterator（迭代器/遍历器），在了解它之前，我们首先要知道为什么需要 Iterator? 它出现的原因是什么?</p>
<a id="more"></a>

<h2 id="从循环说起"><a href="#从循环说起" class="headerlink" title="从循环说起"></a>从循环说起</h2><p>平时开发中，我们经常会用到循环，拿最基本的来说，比如循环一个数组:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]) <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用forEach循环</span></span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item) <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用for in循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]) <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是循环输出字符串的每一个字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abcde'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(str[i]) <span class="comment">// a b c d e</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for in循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(str[k]) <span class="comment">// a b c d e</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach不能遍历字符串，如果硬要用则只能先把字符串转为数组再用数组方式循环</span></span><br></pre></td></tr></table></figure>

<p>如果是循环输出一个 map 对象呢, 妥妥的就一个 foreach 循环，普通的 for 循环和 for…in 都不行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'第一'</span>)</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'第二'</span>)</span><br><span class="line">map.set(<span class="string">'third'</span>, <span class="string">'第三'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach循环</span></span><br><span class="line">map.forEach(<span class="function">(<span class="params">val, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val, key)</span><br><span class="line">  <span class="comment">// 第一 first</span></span><br><span class="line">  <span class="comment">// 第二 second</span></span><br><span class="line">  <span class="comment">// 第三 third</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对于上述各集合数据，我们发现没有一个循环方法是可以一次性解决的。</p>
<p>虽然 forEach 循环不能循环字符串，但字符串可以转为数组再使用 forEach 即可输出，但这操作并不舒服每次使用都要转换。而且 forEach 循环存在缺点：<code>不能使用break，continue语句跳出循环，或者使用return从函数体返回</code>。</p>
<p>而 for 循环在有些情况写代码会增加复杂度，而且不能循环对象。</p>
<p>相比下，for…in 的缺点是不仅遍历数字键名，还会遍历手动添加的自定义键，甚至包括原型链上的键。for…in 主要还是为遍历对象而设计的，并不太适用于遍历数组。</p>
<p>如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.protoValue = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">arr.test = <span class="string">'test'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i]) <span class="comment">// 1 2 3 4 test hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>话说回来，有没有一种更好的循环能一统上述循环问题？ ES6 就有了，用 for…of 循环</p>
<h2 id="for…of-循环出现"><a href="#for…of-循环出现" class="headerlink" title="for…of 循环出现"></a>for…of 循环出现</h2><p>它的出现解决了什么问题呢？首先是当然是能解决了上述我们的问题</p>
<p>对上述数据进行循环输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v) <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> str) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v) <span class="comment">// a b c d e</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">  <span class="comment">// (2) ["first", "第一"]</span></span><br><span class="line">  <span class="comment">// (2) ["second", "第二"]</span></span><br><span class="line">  <span class="comment">// (2) ["third", "第三"]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看看它的优点：</p>
<ol>
<li>简洁直接的遍历数组语法</li>
<li>它避开了 for-in 循环的所有缺点</li>
<li>与 forEach 循环不同的是，它可以使用 break、continue 和 return 语句</li>
</ol>
<p>阮一峰老师的《ECMAScript 6 入门》提到：</p>
<blockquote>
<p>ES6 中引入了 for…of 循环，作为遍历所有数据结构的统一的方法。</p>
</blockquote>
<blockquote>
<p>Iterator 是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
</blockquote>
<p>一个数据结构只要具有 iterator 接口，就可以用 for…of 循环遍历它的成员。</p>
<p>也就是说，并不是所有的对象都能使用 for…of 循环，只有实现了 Iterator 接口的对象，才能够 for…of 来进行遍历取值。</p>
<p>那么，Iterator 是什么呢？我们接着说</p>
<h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
</blockquote>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>为各种数据结构，提供一个统一的、简便的访问接口；</li>
<li>使得数据结构的成员能够按某种次序排列；</li>
<li>创造一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。</li>
</ol>
<p>现在明白了，Iterator 的产生主要是为了使用 for…of 方法。但具体 Iterator 概念还是有些抽象，如果要直接具体的描述的话：</p>
<p>Iterator 其实就是一个具有 next()方法的对象，并且每次调用 next()方法都会返回一个结果对象，这个结果对象有两个属性, 如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    value: 表示当前的值,</span><br><span class="line">    done: 表示遍历是否结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里多了一些概念，我们来梳理一下：</p>
<p>Iterator 是一个特殊的对象：</p>
<ol>
<li>它具有 next()方法，调用该方法就会返回一个结果对象</li>
<li>结果对象有两个属性值：<code>value</code>和<code>done</code>。</li>
<li><code>value</code>表示具体的返回值；done 是布尔类型，表示集合是否完成遍历，没有则返回 true，否则返回 false</li>
<li>内部有一个指针，指向数据结构的起始位置。每调用一次 next()方法，指针都会向后移动一个位置，直到指向最后一个位置。</li>
</ol>
<h3 id="模拟-Iterator"><a href="#模拟-Iterator" class="headerlink" title="模拟 Iterator"></a>模拟 Iterator</h3><p>根据上述描述，我们来模拟一个迭代器，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> done = i &gt;= item.length</span><br><span class="line">      <span class="keyword">var</span> value = !done ? items[i++] : <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: done,</span><br><span class="line">        value: value,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator 就是一个迭代器对象</span></span><br><span class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; done: false, value: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; done: false, value: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; done: false, value: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>

<p>过程:</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的 next 方法，next 方法内部通过闭包来保存指针<code>i</code> 的值，每次调用<code>i</code>都会<code>+1</code>，指向下一个。故第一次指针指向数据结构的第一个成员，输出 1。</li>
<li>第二次调用指针对象的 next 方法，指针就指向数据结构的第二个成员，输出 2。</li>
<li>第三次调用指针对象的 next 方法，数组长度为 3，此时数据结构的结束位置，输出 3。</li>
<li>第四次调用指针对象的 next 方法，此时已遍历完成了，输出 done 为 true 表示完成，value 为 undefined，此后第 n 次调用都是该结果。</li>
</ol>
<p>看到这里大家大概知道<code>Iterator</code>了，但 Iterator 接口主要供 for…of 消费。我们试着用 for…of 循环上面创建 Iterator 对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var iterator &#x3D; makeIterator([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">for (let value of iterator) &#123;</span><br><span class="line">    console.log(value); &#x2F;&#x2F; Uncaught TypeError: iterator is not iterable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果报错，说明我们生成的 iterator 对象并不是可遍历的，这样的结构还不能够被 for…of 循环</p>
<p>那什么样的结构才是可遍历的呢？</p>
<h2 id="可迭代对象-Iterable"><a href="#可迭代对象-Iterable" class="headerlink" title="可迭代对象 Iterable"></a>可迭代对象 Iterable</h2><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>ES6 还引入了一个新的 Symbol 对象，symbol 值是唯一的。</p>
<p>一个数据结构只要部署了 Symbol.iterator 属性，就被视为具有 iterator 接口；调用这个接口，就会返回一个遍历器对象。这样的数据结构才能被称为可迭代对象(Iterator)，该对象可被 for…of 遍历。</p>
<p>照着上面的规定来创建一个可迭代对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">arr[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> done = i &gt;= _this.length</span><br><span class="line">      <span class="keyword">var</span> value = !done ? _this[i++] : <span class="literal">undefined</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: done,</span><br><span class="line">        value: value,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时可以for...of遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item) <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此，我们也可以知道 for…of 遍历的其实是对象的 Symbol.iterator 属性。</p>
<h3 id="原生具备-Iterator-接口的数据结构"><a href="#原生具备-Iterator-接口的数据结构" class="headerlink" title="原生具备 Iterator 接口的数据结构"></a>原生具备 Iterator 接口的数据结构</h3><p>在 ES6 中，所有的集合对象，包括数组，类数组对象（arguments 对象、DOM NodeList 对象），Map 和 Set，还有字符串都是可迭代的，都可以被 for…of 遍历，因为他们都有默认的迭代器。</p>
<p>下面就挑其中几个类型来举例子：</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iteratorObj = arr[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next())</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next())</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next())</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next())</span><br></pre></td></tr></table></figure>

<p>输出结果：<br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/8/16f8433c4b0b041a?w=294&h=282&f=png&s=23046" alt=""><br>由上述对迭代器的概念认识，输出结果也完全符合我们预期。</p>
<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>我们知道普通对象是默认没有部署这个接口的，所以 arguments 这个属性没有在原型上，而是在对象自身的属性上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">arguments</span>[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(obj.next())</span><br><span class="line">  <span class="built_in">console</span>.log(obj.next())</span><br><span class="line">  <span class="built_in">console</span>.log(obj.next())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/8/16f8446fec7e2102?w=508&h=197&f=png&s=20591" alt=""></p>
<h4 id="NodeList"><a href="#NodeList" class="headerlink" title="NodeList"></a>NodeList</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nodeList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'test'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> nodeList) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(node)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/8/16f84531078f206d?w=236&h=61&f=png&s=3489" alt=""></p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>这次直接从原型上找来证明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Map</span>.prototype.hasOwnProperty(<span class="built_in">Symbol</span>.iterator)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>至于其他类型的可迭代对象大家可举一反三。</p>
<h2 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h2><p>有一些场合会默认调用 Iterator 接口（即 Symbol.iterator 方法）</p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set().add('a').add('b').add('c')</span><br><span class="line"></span><br><span class="line">let [x, y] = <span class="keyword">set</span></span><br><span class="line">console.log(x, y) // a b</span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（…）也会调用默认的 Iterator 接口，可以将当前迭代对象转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log([...str]) <span class="comment">// ["h", "e", "l", "l", "o"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>]) <span class="comment">// ["a", "b", "c", "d"]</span></span><br></pre></td></tr></table></figure>

<h3 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h3><p>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = generator()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>关于 yield 之后会再写一篇专题</p>
<h3 id="其他场合"><a href="#其他场合" class="headerlink" title="其他场合"></a>其他场合</h3><p>例如：for…of、Set()、Map()、Array.from()等。我们主要是为了证明调用上面这些函数时着实是用到了 Iterator 接口。</p>
<p>我们贴出上面的实现可迭代对象的代码，进行改动。想一想，尽管我们没有手动添加 Symbol.iterator 属性，但因为 ES6 默认部署了 Symbol.iterator，数组还是可以遍历成功，那当然我们也可以手动修改这个属性，重新部署也可以。</p>
<p>如果我们手动修改生效，影响了输出，证明某方法调用需要用到 Iterator 接口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">arr[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> done = i &gt;= _this.length</span><br><span class="line">      <span class="keyword">var</span> value = !done ? _this[i++] : <span class="literal">undefined</span></span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: done,</span><br><span class="line">        value: value + <span class="string">' 手动添加的属性'</span>, <span class="comment">// 添加自定义值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果显示手动修改生效，证明for...of调用了Iterator接口</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">  <span class="comment">// 1 手动添加的属性</span></span><br><span class="line">  <span class="comment">// 2 手动添加的属性</span></span><br><span class="line">  <span class="comment">// 3 手动添加的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = new Set(arr)</span><br><span class="line">console.log(<span class="keyword">set</span>) // Set(3) &#123;<span class="number">1</span> 手动添加的属性<span class="string">", 2 手动添加的属性"</span>, <span class="number">3</span> 手动添加的属性<span class="string">"&#125;</span></span><br></pre></td></tr></table></figure>

<p>上述其他方法证明也是如此，就不一一列出了。</p>
<h2 id="计算生成的数据结构"><a href="#计算生成的数据结构" class="headerlink" title="计算生成的数据结构"></a>计算生成的数据结构</h2><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p>
<ol>
<li>entries() 返回一个遍历器对象，用来遍历[键名,键值]组成的数组。对于数组，键名就是索引值。</li>
<li>keys() 返回一个遍历器对象，用来遍历所有的键名。</li>
<li>values() 返回一个遍历器对象，用来遍历所有的键值。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'first'</span>, <span class="string">'second'</span>, <span class="string">'third'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 0, "first" ]</span></span><br><span class="line"><span class="comment">// [ 1, "second" ]</span></span><br><span class="line"><span class="comment">// [ 2, "third" ]</span></span><br></pre></td></tr></table></figure>

<h2 id="判断对象是否可迭代"><a href="#判断对象是否可迭代" class="headerlink" title="判断对象是否可迭代"></a>判断对象是否可迭代</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isIterable = <span class="function"><span class="params">obj</span> =&gt;</span> obj != <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> obj[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>())) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>())) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">'hello world'</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="for…of-循环不支持遍历普通对象"><a href="#for…of-循环不支持遍历普通对象" class="headerlink" title="for…of 循环不支持遍历普通对象"></a>for…of 循环不支持遍历普通对象</h3><p>梳理了半天，回到最初，Iterator 的产生主要是为了使用 for…of 方法。而对象不像数组的值是有序的，遍历的时候根本不知道如何确定他们的先后顺序，所以要注意的是 for…of 循环不支持遍历对象。</p>
<p>如果非要遍历对象，同理对象也必须包含[Symbol.iterator]的属性并实现迭代器方法，可以通过手动利用 Object.defineProperty 方法添加该属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// Uncaught TypeError: obj is not iterable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 Iterator 就写到这里了，下一篇写 ES6 的 Generator 生成器。</p>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之箭头函数全解析</title>
    <url>/2020/01/07/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>ES6 中允许使用箭头来定义箭头函数，是 ES6 中较受欢迎也较常使用的新增特性。本文将从箭头函数的基本语法，与普通函数对比，箭头函数不适用场景三个方面进行梳理。</p>
<a id="more"></a>

<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，定义箭头函数语法上要比普通函数简洁得多。箭头函数省去了<code>function</code>关键字，采用箭头<code>=&gt;</code>来定义函数。函数的参数放在<code>=&gt;</code>前面的括号中，函数体跟在<code>=&gt;</code>后的花括号中，箭头函数在参数和箭头之间不能换行。</p>
<h3 id="箭头函数的参数"><a href="#箭头函数的参数" class="headerlink" title="箭头函数的参数"></a>箭头函数的参数</h3><ol>
<li>如果箭头函数没有参数，直接写一个空括号即可。</li>
<li>如果箭头函数的参数只有一个，可以省略包裹参数的括号。</li>
<li>如果箭头函数有多个参数，将参数依次用逗号分隔，参数必须被包裹在括号中。</li>
</ol>
<h3 id="箭头函数的函数体"><a href="#箭头函数的函数体" class="headerlink" title="箭头函数的函数体"></a>箭头函数的函数体</h3><p>如果箭头函数的函数体只有一句代码，即返回某个变量或者返回一个简单的 JS 表达式，可以省去函数体的大括号{ }。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">val</span> =&gt;</span> val</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mulFunction = <span class="function">(<span class="params">num1, num2, num3</span>) =&gt;</span> num1 * num2 * num3</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> mulFunction = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2, num3</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 * num2 * num3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数返回一个对象"><a href="#箭头函数返回一个对象" class="headerlink" title="箭头函数返回一个对象"></a>箭头函数返回一个对象</h3><p>如果箭头函数的函数体只有一句代码且返回一个对象（对象字面量）时，直接写一个表达式是不行的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">// 执行后返回undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是这样还会直接报错</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>原因是花括号被解释为函数体的大括号，解决办法：<strong>用圆括号把对象字面量包起来</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(func()) <span class="comment">// &#123;foo: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不过上面那样解决的缺点是可读性变差了，所以更推荐直接当成多条语句的形式来写，可读性高</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简化回调函数"><a href="#简化回调函数" class="headerlink" title="简化回调函数"></a>简化回调函数</h3><p>这是箭头函数比较常见的用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数写法</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b)</span><br></pre></td></tr></table></figure>

<h2 id="跟普通函数的区别"><a href="#跟普通函数的区别" class="headerlink" title="跟普通函数的区别"></a>跟普通函数的区别</h2><h3 id="没有-this-绑定"><a href="#没有-this-绑定" class="headerlink" title="没有 this 绑定"></a>没有 this 绑定</h3><p>箭头函数没有自己的 this，它会捕获自己在<em>定义时</em>）所处的外层执行环境的 this，并继承这个 this 值。所以，箭头函数中 this 的指向在它被定义的时候就已经确定了，之后永远不会改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.a() <span class="comment">// 打印结果：obj对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.a() <span class="comment">// 打印结果： Window对象</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，箭头函数与外层的 this 保持一致，最外层的 this 就是 Window 对象。</p>
<h3 id="没有-arguments"><a href="#没有-arguments" class="headerlink" title="没有 arguments"></a>没有 arguments</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func2 = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">func1(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line">func2(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Uncaught ReferenceError: arguments is not defined</span></span><br></pre></td></tr></table></figure>

<p>如果非要打印函数参数，可以在箭头函数中使用 rest 参数代替 arguments 对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func2 = <span class="function">(<span class="params">...rest</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(rest) <span class="comment">// (2) [1, 2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不能通过-new-关键字调用"><a href="#不能通过-new-关键字调用" class="headerlink" title="不能通过 new 关键字调用"></a>不能通过 new 关键字调用</h3><p>在构造函数中，this 指向新创建的对象实例</p>
<p>而箭头函数没有 [[Construct]]方法，箭头函数不可以当作构造函数，如果这样做会抛出异常</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Person is not a constructor</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'jacky'</span>)</span><br></pre></td></tr></table></figure>

<p>箭头函数在创建时 this 对象就绑定了，故不会指向对象实例。</p>
<h3 id="没有-new-target"><a href="#没有-new-target" class="headerlink" title="没有 new.target"></a>没有 new.target</h3><p>new.target 是 ES6 新引入的属性，普通函数如果通过 new 调用，new.target 会返回该函数的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span>.target)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat() <span class="comment">// ƒ Cat() &#123; console.log(new.target); &#125;</span></span><br></pre></td></tr></table></figure>

<p>此属性主要：用于确定构造函数是否为 new 调用的。</p>
<p>箭头函数的 this 指向全局对象，在箭头函数中使用箭头函数会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span>.target)</span><br><span class="line">&#125;</span><br><span class="line">a() <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">new</span>.target) <span class="comment">// 报错：Uncaught SyntaxError: new.target expression is not allowed here</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br></pre></td></tr></table></figure>

<h3 id="没有原型"><a href="#没有原型" class="headerlink" title="没有原型"></a>没有原型</h3><p>由于不能通过 new 关键字调用，不能作为构造函数，所以箭头函数不存在 prototype 这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(func.prototype) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="没有-super"><a href="#没有-super" class="headerlink" title="没有 super"></a>没有 super</h3><p>箭头函数没有原型，故也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的。同 this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。</p>
<h3 id="call-apply-bind-方法无法改变箭头函数中-this-的指向"><a href="#call-apply-bind-方法无法改变箭头函数中-this-的指向" class="headerlink" title="call/apply/bind 方法无法改变箭头函数中 this 的指向"></a>call/apply/bind 方法无法改变箭头函数中 this 的指向</h3><p>call()、apply()、bind()方法的共同特点是可以改变 this 的指向，用来动态修改函数执行时 this 的指向。但由于箭头函数的 this 定义时就已经确定了且不会改变。所以这三个方法永远也改变不了箭头函数 this 的指向。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global name'</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'jacky'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数定义在全局作用域</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func() <span class="comment">// global name</span></span><br><span class="line"><span class="comment">// this的指向不会改变，永远指向Window对象,放到到window下的全局变量</span></span><br><span class="line">func.call(obj) <span class="comment">// global name</span></span><br><span class="line">func.apply(obj) <span class="comment">// global name</span></span><br><span class="line">func.bind(obj)() <span class="comment">// global name</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数的解析顺序相对靠前"><a href="#箭头函数的解析顺序相对靠前" class="headerlink" title="箭头函数的解析顺序相对靠前"></a>箭头函数的解析顺序相对靠前</h3><p>虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> callback;</span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="comment">// SyntaxError:非法箭头函数属性</span></span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;&#125;);    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数不支持重名参数"><a href="#箭头函数不支持重名参数" class="headerlink" title="箭头函数不支持重名参数"></a>箭头函数不支持重名参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, <span class="built_in">arguments</span>) <span class="comment">// 2 Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boo = <span class="function">(<span class="params">a, a</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 直接报错：Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span></span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">boo(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-使用-yield-关键字"><a href="#1-使用-yield-关键字" class="headerlink" title="1 使用 yield 关键字"></a>1 使用 yield 关键字</h3><p>yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器（ Generator ）。</p>
<h2 id="箭头函数不适用的场景"><a href="#箭头函数不适用的场景" class="headerlink" title="箭头函数不适用的场景"></a>箭头函数不适用的场景</h2><p><strong>1.不应被用在定义对象的方法上</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x, <span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.x, <span class="keyword">this</span>),</span><br><span class="line">&#125;</span><br><span class="line">obj.b() <span class="comment">// 10  &#123;x: 10, b: ƒ, c: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line">obj.c() <span class="comment">// undefined Window</span></span><br></pre></td></tr></table></figure>

<p>因为它内部 this 的指向原因，当使用 obj.c()的时候，我们希望 c 方法里面的 this 指向 obj，但是它却指向了 obj 所在上下文中的 this（即 window），违背了我们的需求，所以箭头函数不适合作为对象的方法。</p>
<p><strong>2.具有动态上下文的回调函数，也不应使用箭头函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;);</span><br><span class="line">为btn的监听函数是一个箭头函数，导致里面的<span class="keyword">this</span>就是全局对象,而不符合我们想操作按钮本身的需求。如果改成普通函数，<span class="keyword">this</span>就会动态指向被点击的按钮对象</span><br></pre></td></tr></table></figure>

<p>除了前面两点，剩下的跟上面讲的与普通函数的区别重复了，故只作总结不贴代码了:</p>
<ol>
<li>不应被用在定义对象的方法上</li>
<li>具有动态上下文的回调函数，也不应使用箭头函数</li>
<li>不能应用在构造函数中</li>
<li>避免在 prototype 上使用</li>
<li>避免在需要 arguments 上使用</li>
</ol>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>箭头函数</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之模板字符串</title>
    <url>/2020/01/05/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>模板字符串是ES6中非常重要的一个新特性，这个特性使得处理相关业务变得更加容易。</p>
<a id="more"></a>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">`hello world`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>
<p>注意这里不是双引号，而是反撇号`</p>
<p>在模板字符串中，还可以拼接html元素，同时空格、缩进、换行都会被保留，并且如果模板字符串中的变量没有声明，将报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;ul&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;11&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;22&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/5/16f75f81fdc039fd?w=283&h=118&f=png&s=3077" alt=""></p>
<p>上面代码中，<code>&lt;div&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;ul&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;11&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;22&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>.trim();</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/5/16f75fa6f941fbc2?w=285&h=115&f=png&s=3098" alt=""></p>
<p>在模版字符串内使用反引号`时，需要在它前面加转义符\</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">`hello \\n`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<h2 id="嵌入变量"><a href="#嵌入变量" class="headerlink" title="嵌入变量"></a>嵌入变量</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'jacky'</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'我叫'</span> + name + <span class="string">'，大家好'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 我叫jacky，大家好</span></span><br></pre></td></tr></table></figure>
<p>当有变量参与拼接时，ES5下必须用+号这样的形式进行拼接，这样很麻烦而且很容易出错。<br>ES6新增了字符串模版，可以很好的解决这个问题。这时再引用str变量就需要用${name}这种形式了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'jacky'</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'我叫$&#123;name&#125;，大家好'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 我叫jacky，大家好</span></span><br></pre></td></tr></table></figure>
<p>如果大括号内部是一个字符串，将会原样输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> world = <span class="string">'666'</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">`hello <span class="subst">$&#123;<span class="string">'world'</span>&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="对运算的支持"><a href="#对运算的支持" class="headerlink" title="对运算的支持"></a>对运算的支持</h2><p>在${}里面，可以写任意的JS表达式，比如我们用它进行运算</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="string">`<span class="subst">$&#123;a+b&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="模板字符串调用函数"><a href="#模板字符串调用函数" class="headerlink" title="模板字符串调用函数"></a>模板字符串调用函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span>); <span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之变量的解构赋值</title>
    <url>/2020/01/04/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<p>解构赋值在开发中很常用，在此总结它的用法…</p>
<a id="more"></a>

<h2 id="什么是解构？"><a href="#什么是解构？" class="headerlink" title="什么是解构？"></a>什么是解构？</h2><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。它在语法上比 ES5 所提供的更加简洁、紧凑、清晰。它不仅能减少你的代码量，还能从根本上改变你的编码方式。</p>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>以前，为变量赋值，我们只能直接指定值，比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>现在可以用数组解构的方式来进行赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1, 2, 3</span></span><br></pre></td></tr></table></figure>

<p>这是数组解构最基本类型的用法，还可以解构对象数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象数组解构</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [&#123; <span class="attr">name</span>: <span class="string">'jacky'</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">'monkey'</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">'houge'</span> &#125;]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// &#123;name: 'jacky'&#125;, &#123;name: 'monkey'&#125;, &#123;name: 'houge'&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组模式和赋值模式统一"><a href="#数组模式和赋值模式统一" class="headerlink" title="数组模式和赋值模式统一"></a>数组模式和赋值模式统一</h2><p>这条可以理解为等号左边和等号右边的形式要统一，如果不统一解构将失败。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [b, c], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d) <span class="comment">// 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取除第二、三个外的所有数值</span></span><br><span class="line"><span class="keyword">let</span> [a, , , d] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, d) <span class="comment">// 1 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 1 [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, , , ...d] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, d) <span class="comment">// 1 [4, 5]</span></span><br></pre></td></tr></table></figure>

<p>如果解构不成功，变量的值就等于<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// 2 3 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [c] = []</span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>上述是完全解构的情况，还有一种是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组，解构依然可以成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(x, y) <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, d) <span class="comment">// 1 2 4</span></span><br></pre></td></tr></table></figure>

<h2 id="解构的默认值"><a href="#解构的默认值" class="headerlink" title="解构的默认值"></a>解构的默认值</h2><p>解构赋值允许指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b = <span class="number">2</span>] = [<span class="number">1</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a = <span class="number">1</span>, b = <span class="number">2</span>, c, d = <span class="number">13</span>] = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d) <span class="comment">// 10 11 12 13</span></span><br></pre></td></tr></table></figure>

<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而非前者。</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">'aaa'</span>, <span class="attr">b</span>: <span class="string">'bbb'</span> &#125;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: x, <span class="attr">b</span>: y &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(x, y) <span class="comment">// aaa bbb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="string">'aaa'</span>, <span class="attr">b</span>: <span class="string">'bbb'</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// aaa bbb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不按照顺序</span></span><br><span class="line"><span class="keyword">let</span> &#123; b, a &#125; = &#123; <span class="attr">a</span>: <span class="string">'test1'</span>, <span class="attr">b</span>: <span class="string">'test2'</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// test1 test2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套解构</span></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  obj: &#123; name &#125;,</span><br><span class="line">&#125; = &#123; <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="string">'jacky'</span>, <span class="attr">age</span>: <span class="string">'22'</span> &#125; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// jacky</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稍微复杂的嵌套</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [<span class="string">'Hello'</span>, &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;</span><br><span class="line">  p: [x, &#123; y &#125;],</span><br><span class="line">&#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(x, y) <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>

<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: rename &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(rename) <span class="comment">// aaa</span></span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>

<p>如果在解构之前就定义了变量，这时候再解构会出现问题。下面是错误的代码，编译会报错（因为 js 引擎会将{a}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 js 将其解释成代码块，才能解决这个问题）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">"aaa"</span> &#125;;</span><br><span class="line">&#123;a&#125; = obj; <span class="comment">// Uncaught SyntaxError: Unexpected token '='</span></span><br></pre></td></tr></table></figure>

<p>要解决报错，使程序正常，这时候只要在解构的语句外边加一个圆括号就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">'aaa'</span> &#125;</span><br><span class="line">;(&#123; a &#125; = obj)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数的参数也可以使用解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>函数参数的解构也可以使用默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y = <span class="number">7</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">3</span>)) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串解构"><a href="#字符串解构" class="headerlink" title="字符串解构"></a>字符串解构</h2><p>字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e, f] = <span class="string">'hello'</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//h</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">//e</span></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">//l</span></span><br><span class="line"><span class="built_in">console</span>.log(d) <span class="comment">//l</span></span><br><span class="line"><span class="built_in">console</span>.log(e) <span class="comment">//o</span></span><br><span class="line"><span class="built_in">console</span>.log(f) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toString</span>: s &#125; = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(s === <span class="built_in">Number</span>.prototype.toString) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">toString</span>: s &#125; = <span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(s === <span class="built_in">Boolean</span>.prototype.toString) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span> <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h2 id="解构赋值的应用"><a href="#解构赋值的应用" class="headerlink" title="解构赋值的应用"></a>解构赋值的应用</h2><h3 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h3><p>通常交换两个变量的方法需要一个额外的临时变量,如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> temp</span><br><span class="line"></span><br><span class="line">temp = a</span><br><span class="line">a = b</span><br><span class="line">b = temp</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure>

<p>用 ES6 解构赋值的话，会变得很简洁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span></span><br><span class="line">;[a, b] = [b, a]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure>

<h3 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h3><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example()</span><br></pre></td></tr></table></figure>

<h3 id="访问数组中元素"><a href="#访问数组中元素" class="headerlink" title="访问数组中元素"></a>访问数组中元素</h3><p>有种场景，比如有一个数组（可能为空）。并且希望访问数组的第一个、第二个或第 n 个项，但如果该项不存在，则使用指定默认值。<br>通常会使用数组的<code>length</code>属性来判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstItem = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">if</span> (list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  firstItem = list[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstItem) <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>

<p>如果用 ES6 解构赋值来实现上述逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = []</span><br><span class="line"><span class="keyword">const</span> [firstItem = <span class="string">'hello'</span>] = list</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstItem) <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>

<h3 id="提取-JSON-数据"><a href="#提取-JSON-数据" class="headerlink" title="提取 JSON 数据"></a>提取 JSON 数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">'OK'</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number)</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历-Map-结构"><a href="#遍历-Map-结构" class="headerlink" title="遍历 Map 结构"></a>遍历 Map 结构</h3><p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>)</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">' is '</span> + value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>

<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文章部分内容参考：阮一峰老师的《ECMAScript 6 入门》一书</li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>解构赋值</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之let和const与var的区别</title>
    <url>/2019/12/28/ES6%E7%B3%BB%E5%88%97%E4%B9%8Blet%E5%92%8Cconst%E4%B8%8Evar%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>ES6规范新增了let、const两种变量声明方式，项目中也经常要用到，今天借着温习ES6语法，来总结let 、const、var的区别。</p>
<a id="more"></a>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>来看下面三段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// Uncaught ReferenceError: c is not defined</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>用var声明的变量，会在其作用域中发生变量提升，js默认给变量一个undefined值。</p>
<p>但是，在ES6中使用let/const声明的变量，不存在变量提升过程。也就是说，在使用let/const声明的变量，声明前访问它，都会报错。</p>
<h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><blockquote>
<p>代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'global'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    a = <span class="string">'block'</span>;    <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，if代码块里，在let声明变量a之前，都是a的”暂时性死区”,在该范围内访问a都会报错。<br>由此可见，块级作用域内存在let声明的话，它所声明的变量就绑定在这个块级作用域，不再受外部影响。</p>
<h2 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h2><p>let 和 const 命令声明的变量不允许重复声明；而使用var声明变量，可以多次重复声明一个同名变量，但最终变量的值为最后一次声明赋值的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'last value'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// last value</span></span><br></pre></td></tr></table></figure>

<p>let与const在相同作用域声明重复的变量会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure>
<p>var和let同时声明同一个变量，也是报同样的错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'b' has already been declared</span></span><br></pre></td></tr></table></figure>
<p>或先var，再let</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'c' has already been declared</span></span><br></pre></td></tr></table></figure>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>这里就涉及到一个最经典的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 5 5 5 5 5 </span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个问题的解决可以使用闭包等，ES6的let为这个问题提供了新的解决方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用let声明的变量仅在块级作用域内有效。 i在循环体内的局部作用域，不受外界影响。</p>
<p>在ES6之前，都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以花括号{}限定不了var声明变量的访问范围。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">9</span>;     <span class="comment">// es6的let: b变量只在花括号内有效</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="let、const声明的全局变量不会作为window对象的一个属性"><a href="#let、const声明的全局变量不会作为window对象的一个属性" class="headerlink" title="let、const声明的全局变量不会作为window对象的一个属性"></a>let、const声明的全局变量不会作为window对象的一个属性</h2><p>使用var声明的全局变量，会被JS自动添加在全局对象window上，但let和const不会</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>



<h2 id="const声明常量"><a href="#const声明常量" class="headerlink" title="const声明常量"></a>const声明常量</h2><p>由于const用来声明常量，一旦声明，就必须立即初始化，而且声明之后值不能改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<p>常量的值不变，实际上是指常量指向的那个内存地址中所保存的数据不可更改。</p>
<p>对于基本数据类型（数值，字符串、布尔值），他们本身具体的值就保存在常量所指向对应的栈内存地址中，所以修改值就等于修改栈内存地址，这显然不允许会报错。</p>
<p>但是，如果一个常量的值是一个引用类型值，那么常量所指向的内存地址（堆内存）中实际保存的是指向该引用类型值的一个指针（也就是引用类型值在内存中的地址）。所以const只能保证该引用类型地址不变，但该地址中的具体数据是可以变化的。</p>
<p>如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;a: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当obj指向了另一个对象，即obj中保存的地址发生了变化，即会报错</span></span><br><span class="line">obj = &#123;&#125;;  <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<h2 id="如何正确使用"><a href="#如何正确使用" class="headerlink" title="如何正确使用"></a>如何正确使用</h2><p>在开发的时候，声明变量我们应该少使用var，避免产生不必要的全局变量。当需要改变变量的值时声明用let，对于需要写保护的变量或定义常量使用const。</p>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>swiper父级元素处于隐藏状态滚动效果失效问题</title>
    <url>/2019/12/25/swiper%E7%88%B6%E7%BA%A7%E5%85%83%E7%B4%A0%E5%A4%84%E4%BA%8E%E9%9A%90%E8%97%8F%E7%8A%B6%E6%80%81%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在使用 vue-awesome-swiper 的时候，实现这样一个功能, 点击页面的 banner 图（Banner.vue），进入一个图片画廊（Gallary.vue），可以查看更多相关的照片，但发现轮播图滚动效果失效,本文将解决这个问题。</p><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2019/12/25/16f3aa7f03be6109?w=432&h=764&f=gif&s=1825248" alt=""></p><p>原因是：一开始 Gallay.vue 的所有用 swiper 控制的图片处于隐藏状态，直到点击才进入图片画廊显示图片。swiper 其父级元素处于隐藏状态(display:none), 会导致 swiper 初始化失败, 页面中的滚动效果就会有问题。</p><p>Gallary.vue 的结构</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span> @<span class="attr">click</span>=<span class="string">"handleGallaryClick"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">:options</span>=<span class="string">"swiperOption"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">swiper-slide</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of imgs"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"swiper-img"</span> <span class="attr">:src</span>=<span class="string">"item"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span> <span class="attr">slot</span>=<span class="string">"pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一开始 Gallary 组件都是通过父组件 Banner 的 v-show 值设置处于隐藏状态</p><p>解决办法：<br>通过 swiper 的配置项：</p><blockquote><p>observer<br>启动动态检查器(OB/观众/观看者)，当改变 swiper 的样式（例如隐藏/显示）或者修改 swiper 的子元素时</p></blockquote><blockquote><p>observeParents<br>将 observe 应用于 Swiper 的父元素。当 Swiper 的父元素变化时，例如 window.resize，Swiper 更新。</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        swiperOption: &#123;</span><br><span class="line">            pagination : &#123;</span><br><span class="line">                el: &#39;.swiper-pagination&#39;,</span><br><span class="line">                type: &#39;fraction&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            observeParents: true, &#x2F;&#x2F;修改swiper的父元素时，自动初始化swiper</span><br><span class="line">            observer: true   &#x2F;&#x2F;修改swiper自己或子元素时，自动初始化swiper</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/12/25/16f3ab29259088a7?w=431&h=759&f=gif&s=974520" alt=""></p>]]></content>
      <categories>
        <category>Vue 系列</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>swiper</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义checkbox样式</title>
    <url>/2019/12/14/%E8%87%AA%E5%AE%9A%E4%B9%89checkbox%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>由于原生的checkbox样式比较难看，所以我们经常需要改写它的样式，美化复选框，所以今天总结下自定义checkbox样式的方法</p>
<a id="more"></a>
<p>html文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox-inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">class</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"hobby"</span>&gt;</span>羽毛球<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"checkmark"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox-inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">class</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"hobby"</span>&gt;</span>跑步<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"checkmark"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.checkbox-inline</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkbox</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkmark</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hobby</span>&#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkbox-inline</span> <span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> ~ <span class="selector-class">.checkmark</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#492c94</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkbox-inline</span> <span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> ~ <span class="selector-class">.checkmark</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkbox-inline</span> <span class="selector-class">.checkmark</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border</span>: solid white;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图（未选中与选中对比）：</p>
<p><img src="/images/custom-checkbox.png" alt="image.png"></p>
<p>采取的做法是</p>
<ol>
<li>先将原生的checkbox样式隐藏，设置宽高为0，使其隐藏不占位。</li>
<li>在label标签里面添加额外的span标签，用来做自定义样式</li>
<li>添加伪元素，利用css3的transform属性做矩形旋转，做出打勾的样式，并将其隐藏。</li>
<li>当checkbox被选中时，利用css3的选择器:checked，匹配每个已被选中的 checkbox 元素；再使用兄弟选择符~，匹配到同层级checkmark类，就可以显示和触发自定义checkbox选中状态的样式了</li>
</ol>
<p>这里还涉及到一个知识点，伪元素属于主元素的一部分，因此点击伪元素触发的是主元素的click事件。</p>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-awesome-swiper修改轮播图pagination的颜色</title>
    <url>/2019/12/12/vue-awesome-swiper%E4%BF%AE%E6%94%B9%E8%BD%AE%E6%92%AD%E5%9B%BEpagination%E7%9A%84%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<p>在使用 vue-awsome-swiper 轮播图的时候，pagination 处于当前选中状态默认是蓝色，但通过修改这个类并无法改变其背景颜色…</p><a id="more"></a><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">:options</span>=<span class="string">"swiperOption"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper-slide</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of swiperList"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"swiper-img"</span> <span class="attr">:src</span>=<span class="string">"item.imgUrl"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span> <span class="attr">slot</span>=<span class="string">"pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/12/22/16f2bbbf5fbc739b?w=433&h=140&f=png&s=141401" alt=""></p><p>原因是为 style 设置了 scoped 以后，swiper 分页样式就失效了。分页是在 mounted 里创建的，此时创建的 DOM，vue 不会帮 swiper 的 pagination 加上 scoped 自定义属性。</p><p>解决办法：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &gt;&gt;&gt; <span class="selector-class">.swiper-pagination-bullet-active</span></span><br><span class="line">    <span class="selector-tag">background</span>: <span class="selector-id">#ff0</span></span><br></pre></td></tr></table></figure><pre><code>.wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active
表示的是在wrapper下所有出现.swiper-pagination-bullet-active</code></pre><p>效果如下：<br><img src="https://user-gold-cdn.xitu.io/2019/12/22/16f2bc67d4dbfa0f?w=426&h=136&f=png&s=151132" alt=""></p>]]></content>
      <categories>
        <category>Vue 系列</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>swiper</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue实现星级评价效果</title>
    <url>/2019/12/09/Vue%E5%AE%9E%E7%8E%B0%E6%98%9F%E7%BA%A7%E8%AF%84%E4%BB%B7%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>在做店家评价的时候，常常会有星级评价的效果，今天来试试看怎么实现它…</p><a id="more"></a><p>我们把星级评价单独做成一个 Star 组件，抽离出来，其中父组件中引入(传入的是评分的值)</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"score"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Star</span> <span class="attr">:score</span>=<span class="string">"poiInfo.wm_poi_score"</span>&gt;</span><span class="tag">&lt;/<span class="name">Star</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>初始 Star.vue</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;star&quot;&gt;</span><br><span class="line">      &lt;span class&#x3D;&quot;star-item&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123; score &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;Star&#39;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    score: Number,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>首先我们把要做星级图片用类名为 star-item 的 span 标签循环出来，星级图片有三张，全星，半星，空星<br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/29/16f51be56d1a5ea8?w=20&h=19&f=png&s=1215" alt=""><br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/29/16f51bdf50383e0f?w=20&h=19&f=png&s=1349" alt=""><br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/29/16f51be27b49b42d?w=20&h=19&f=png&s=1220" alt=""></p><p>下面只罗列关键的 css 部分, 通过增加类区分图片</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.star-item</span><span class="selector-class">.on</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(./img/star24_on@<span class="number">2</span>x.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-item</span><span class="selector-class">.half</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(./img/star24_half@<span class="number">2</span>x.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-item</span><span class="selector-class">.off</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(./img/star24_off@<span class="number">2</span>x.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来修改 Star.vue 的代码</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"star"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"star-item"</span> <span class="attr">v-for</span>=<span class="string">"(itemClass, index) in itemClasses"</span> <span class="attr">:key</span>=<span class="string">"index"</span> <span class="attr">:class</span>=<span class="string">"itemClass"</span>&gt;</span> <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>itemClasses 值是通过计算属性获取的，思路：</p><ol><li>通过 computed 返回一个长度为 5 的数组（显示 5 颗星）</li><li>数组的值是上述 css 取的不同星对应的类名，再通过绑定每一个循环添加的 class，从而遍历星级。</li></ol><p>比如举例评分：</p><ul><li>4.7 分对应的数组为[‘on’, ‘on’, ‘on’, ‘on’, ‘half’]</li><li>3.4 分对应的数组为[‘on’, ‘on’, ‘on’, ‘half’, ‘half’]</li></ul><p>JS 部分的代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 星星长度</span></span><br><span class="line"><span class="keyword">const</span> LENGTH = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 星星的状态</span></span><br><span class="line"><span class="keyword">const</span> CLS_ON = <span class="string">'on'</span></span><br><span class="line"><span class="keyword">const</span> CLS_HALF = <span class="string">'half'</span></span><br><span class="line"><span class="keyword">const</span> CLS_OFF = <span class="string">'off'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'Star'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    score: <span class="built_in">Number</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    itemClasses() &#123;</span><br><span class="line">      <span class="keyword">let</span> result = []</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> score = <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.score * <span class="number">2</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 半星 (通过跟1取余判断是否为小数)</span></span><br><span class="line">      <span class="keyword">let</span> hasDecimal = score % <span class="number">1</span> !== <span class="number">0</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 全星 （向下取整，获取全星部分）</span></span><br><span class="line">      <span class="keyword">let</span> integer = <span class="built_in">Math</span>.floor(score)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 遍历全星</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; integer; i++) &#123;</span><br><span class="line">        result.push(CLS_ON)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 处理半星</span></span><br><span class="line">      <span class="keyword">if</span> (hasDecimal) &#123;</span><br><span class="line">        result.push(CLS_HALF)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 补齐</span></span><br><span class="line">      <span class="keyword">while</span> (result.length &lt; LENGTH) &#123;</span><br><span class="line">        <span class="comment">// 到这里还不够五颗星，则凑空星</span></span><br><span class="line">        result.push(CLS_OFF)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>itemClasses 最终是返回了一个长度为 5 的数组，需要注意的是</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let score &#x3D; Math.floor(this.score * 2) &#x2F; 2</span><br></pre></td></tr></table></figure><p>半星的划分：只有当小数第一位大于或等于 5 才可以算为半星，否则是空星。该计算是为了小数部分&gt;=0.5 的计算结果带有小数，从而再后面跟 1 取余判断是否为半星。一开始有点蒙，多试几个数想想就懂了。</p><blockquote><p>比如 4.3 分没有半星，4.5 有半星出现</p></blockquote><p>结果：<br>比如传入的值为 4.7，则显示</p><p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/29/16f51d7db002aa38?w=161&h=28&f=png&s=5690" alt=""></p>]]></content>
      <categories>
        <category>Vue 系列</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>页面内容是否超出可视高度，footer始终保持底部显示</title>
    <url>/2019/12/07/CSS%E7%B3%BB%E5%88%97%E4%B9%8B%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E8%B6%85%E5%87%BA%E5%8F%AF%E8%A7%86%E9%AB%98%E5%BA%A6%EF%BC%8Cfooter%E5%A7%8B%E7%BB%88%E4%BF%9D%E6%8C%81%E5%BA%95%E9%83%A8%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>记录一个项目中经常会用到的技巧，footer区（比如版权信息）要始终居于页面底部。如果用fixed定位显然不可取，因为要保证页面高度大于屏幕高度时，footer区要跟随着页面滚动保持在底部</p>
<a id="more"></a>
<p>如下图：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/7/16ee0e36c5c55fea?w=1737&h=899&f=png&s=23364" alt=""></p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/7/16ee0e3a25e302bd?w=1577&h=903&f=png&s=27932" alt=""></p>
<ul>
<li>tip：以下两个方法仅适用于footer区高度固定的情况</li>
</ul>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>页面结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main-container&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;box&quot;&gt;这是主要内容&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;footer&gt;这是底部&lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>关键的css<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-container</span>&#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">footer</span>&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如上代码，主要内容区和footer区必须为并列关系。设置main-container为border-box，即元素的内边距和边框都在已设定的高度内绘制，我们设置了min-height为100%，即最小高度是铺满整屏幕。padding-bottom在border-box盒子中，留出高度40px的空白块。footer的margin-top为-40px（如果footer有设置高度，padding-bottom的值应以footer高度为准），即向上拉到空白块内，main-container最小高度为整个屏幕，故页面内容不足也可以显示在底部。</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>页面结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main-container&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;box&quot;&gt;这是主要内容&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;footer&gt;这是底部&lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>关键的css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html,body&#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.wrapper&#123;</span><br><span class="line">    min-height: 100%;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.main-container&#123;</span><br><span class="line">    padding-bottom: 40px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">footer&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    height: 40px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码时用绝对定位，相对于wrapper居于底部，跟第一个方法有异曲同工之妙。</p>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之执行上下文和变量对象</title>
    <url>/2019/11/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>继续接着上篇文章，今天再细说执行上下文中的变量对象…</p>
<a id="more"></a>

<p>上篇我们说到函数上下文的结构可表示为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ExecutionContextObj = &#123;</span><br><span class="line">  VO: <span class="built_in">window</span>, <span class="comment">// 变量对象</span></span><br><span class="line">  ScopeChain: &#123;&#125;, <span class="comment">// 作用域链</span></span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即每个函数上下文，都要有这三个重要属性：</p>
<ul>
<li>变量对象(Variable object, VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><h3 id="什么是变量对象"><a href="#什么是变量对象" class="headerlink" title="什么是变量对象"></a>什么是变量对象</h3><p>变量对象是与执行上下文的相关的数据作用域，存储了在上下文中定义的变量和函数声明。因为不同执行上下文的变量对象略有不同，所以变量对象一般分为全局上下文下的变量对象和函数上下文下的变量对象。</p>
<h3 id="变量对象-VO-的创建过程"><a href="#变量对象-VO-的创建过程" class="headerlink" title="变量对象(VO)的创建过程"></a>变量对象(VO)的创建过程</h3><p>变量对象的创建，属于执行上下文中的创建阶段，依次经过以下三个过程：</p>
<p>创建执行上下文有两个阶段：一个是创建阶段，一个是执行阶段。变量对象的创建，属于执行上下文中的创建阶段，会依次经过三个过程：</p>
<h4 id="1-为函数的形参赋值（函数上下文）"><a href="#1-为函数的形参赋值（函数上下文）" class="headerlink" title="1.为函数的形参赋值（函数上下文）"></a>1.为函数的形参赋值（函数上下文）</h4><p>在进入函数执行上下文时，会首先检查实参个数，接着对实参对象和形参进行赋值。如果没有实参，属性值设为 undefined；当传入的实参数量小于形参数量，则会将没有被赋值的形参赋值为 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c) <span class="comment">// 1 2 undefined</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>此时变量对象的结构为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">VO = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="literal">undefined</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-函数声明"><a href="#2-函数声明" class="headerlink" title="2.函数声明"></a>2.函数声明</h4><p>遇到同名的函数时，后面函数会覆盖前面的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'先声明的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'后声明的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">//ƒ fn() &#123; console.log('后声明的'); &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-变量声明"><a href="#3-变量声明" class="headerlink" title="3.变量声明"></a>3.变量声明</h4><p>检查当前环境中通过变量声明(var)并赋值为 undefined（变量提升产生的原因）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">// ƒ fn() &#123; console.log('后声明的');&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'先声明的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'后声明的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>由上面我们看出，当变量名称与函数名称同名时，会忽略此变量声明，即同名时，函数声明优先</p>
<p>js 虽然单线程的语言，执行顺序为顺序执行，但 JS 引擎并不是一行一行地分析和执行程序，而是一段一段地分析执行。</p>
<p>让我们从 JS 引擎的角度理一理上述三个过程：<strong>函数提升和变量提升，是全局执行上下文做的准备工作；当执行函数时，又会创建一个执行上下文，做的是这个函数内部的准备工作；这就是 JS 引擎分析代码的”预编译阶段”，做完该工作才进入执行阶段。</strong></p>
<h3 id="全局上下文的变量对象"><a href="#全局上下文的变量对象" class="headerlink" title="全局上下文的变量对象"></a>全局上下文的变量对象</h3><p>在客户端 JavaScript 中，全局对象就是 Window 对象;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> <span class="comment">// 在全局上下文使用var定义变量a，作为全局变量的宿主</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// window对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>对于全局上下文中来说，变量对象就是全局对象，</p>
<h3 id="变量对象变为活动对象"><a href="#变量对象变为活动对象" class="headerlink" title="变量对象变为活动对象"></a>变量对象变为活动对象</h3><p>执行上下文的第二个阶段为执行阶段，此时会进行变量赋值，执行其他代码等工作，此时，变量对象变为活动对象(Active object, AO)。</p>
<blockquote>
<p>活动对象和变量对象其实是同个东西，只是规范概念上的差异。只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫活动对象。而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p>
</blockquote>
<p>所以明确，活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">// ƒ fn() &#123; console.log('后声明的');&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'先声明的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'后声明的'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(fn) <span class="comment">//20</span></span><br></pre></td></tr></table></figure>

<p>上述代码，真正开始执行是从第一行 console.log(fn)。在此之前，变量对象 VO 是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建过程</span></span><br><span class="line">EC= &#123;</span><br><span class="line">  VO：&#123;&#125;, <span class="comment">// 创建变量对象</span></span><br><span class="line">  scopeChain: [&#123;VO&#125;], <span class="comment">// 作用域链</span></span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span> <span class="comment">// this绑定</span></span><br><span class="line">&#125;</span><br><span class="line">VO = &#123;</span><br><span class="line">  <span class="comment">// argument: &#123;&#125;, // 当前为全局上下文，不存在arguments</span></span><br><span class="line">  fn: reference to <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="comment">// 函数fn的引用地址</span></span><br><span class="line">  b: undefiend  <span class="comment">// 变量提升</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据变量对象创建的三个过程，</p>
<ol>
<li>首先是 arguments 对象的创建（全局上下文没有则忽略）</li>
<li>其次，是检查函数的声明。此时，函数 fn 声明了两次，则后一次的声明会覆盖上一次的声明。</li>
<li>最后，是检查变量的声明，先声明了变量 b，将它赋值为 undefined；接着遇到 fn 的变量声明，由于 fn 已经被声明为一个函数，故忽略该变量声明。</li>
</ol>
<p>到此，变量对象的创建阶段完成，接下来进行执行阶段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.执行console.log(fn);此时fn为声明的第二个函数，故输出结果：&quot;后声明的&quot;。</span><br><span class="line">2.执行console.log(b)，此时b已被赋值为undefined，故输出结果：&quot;undefined&quot;。</span><br><span class="line">3.执行赋值操作： b &#x3D; 10;</span><br><span class="line">4.执行console.log(b) ，故输出b为10。</span><br><span class="line">5.执行赋值操作： fn &#x3D; 20;</span><br><span class="line">6.执行console.log(fn) ，故输出fn为20。</span><br></pre></td></tr></table></figure>

<p>执行到最后一步时，执行上下文如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行阶段</span></span><br><span class="line">EC = &#123;</span><br><span class="line">  VO = &#123;&#125;;</span><br><span class="line">  scopeChain: &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// VO ---- AO</span></span><br><span class="line">AO = &#123;</span><br><span class="line">  argument: &#123;&#125;;</span><br><span class="line">  fn: <span class="number">20</span>;</span><br><span class="line">  b: <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，就是变量对象在代码执行前及执行后的变化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>全局上下文的变量对象初始化是全局对象</p>
</li>
<li><p>函数上下文的变量对象初始化只包括 arguments 对象</p>
</li>
<li><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p>
</li>
<li><p>在代码执行阶段，会再次修改变量对象的属性值</p>
</li>
</ol>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>执行上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之执行上下文和执行栈</title>
    <url>/2019/11/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
    <content><![CDATA[<p>都说想成为出色的 JavaScript 开发者，就要深入学习 JavaScript 程序内部的执行机制，最近学了一遍 JS 的执行上下文和执行栈，以此作总结。</p>
<a id="more"></a>

<p>首先先来了解几个专业概念</p>
<ul>
<li><p>EC：函数执行环境（或执行上下文），Execution Context</p>
</li>
<li><p>ECS：执行环境栈，Execution Context Stack</p>
</li>
<li><p>VO：变量对象，Variable Object</p>
</li>
<li><p>AO：活动对象，Active Object</p>
</li>
<li><p>scope chain：作用域链</p>
</li>
</ul>
<h2 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h2><p>每次当控制器转到 ECMAScript 可执行代码的时候，它都是在执行上下文中运行，即是指当前执行环境中的变量、函数声明，参数，作用域链，this 等信息。</p>
<h3 id="组成代码示例"><a href="#组成代码示例" class="headerlink" title="组成代码示例"></a>组成代码示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ExecutionContextObj = &#123;</span><br><span class="line">  VO: <span class="built_in">window</span>, <span class="comment">// 变量对象</span></span><br><span class="line">  ScopeChain: &#123;&#125;, <span class="comment">// 作用域链</span></span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><p>JavaScript 中有三种执行上下文类型。</p>
<ol>
<li><p><strong>全局执行上下文</strong>—— 这是默认上下文，浏览器中的全局对象就是 window 对象，任何不在函数内部的代码都在全局上下文中，this 指向这个全局对象。</p>
</li>
<li><p><strong>函数执行上下文</strong> —— 当<strong>函数被调用时创建</strong>,会为该函数创建一个新的执行上下文，可以有任意个。</p>
</li>
<li><p><strong>Eval 函数执行上下文</strong> ——<br>执行 eval 函数内部的代码也有属于它的上下文，由于开发中是尽量避免或不用 eval 函数，故此不作讨论。</p>
</li>
</ol>
<h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也叫调用栈，被用来存储代码运行时创建的所有执行上下文。</p>
<blockquote>
<p>栈：一种数据结构，遵循后进先出的原则</p>
</blockquote>
<p>当 JavaScript 引擎第一次遇到脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p>
<p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn1被调用了 -- 创建了fn1的函数执行上下文，压入栈'</span>)</span><br><span class="line">  fn2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn2执行完成，fn2的执行上下文会从栈中弹出'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn2被调用了 -- 创建了fn2的函数执行上下文，压入栈'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn1执行完成，fn2的执行上下文会从栈中弹出'</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fn1被调用了 -- 创建了fn1的函数执行上下文，压入栈</span><br><span class="line">fn2被调用了 -- 创建了fn2的函数执行上下文，压入栈</span><br><span class="line">fn2执行完成，fn2的执行上下文会从栈中弹出</span><br><span class="line">fn1执行完成，fn2的执行上下文会从栈中弹出</span><br></pre></td></tr></table></figure>

<p>上述代码的执行上下文栈：<br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/11/27/16ead7c041a4b415?w=1276&h=316&f=png&s=30716" alt=""></p>
<p>当上述代码在浏览器加载时，JavaScript 引擎创建了一个全局执行上下文并把它压入栈中，当函数 fn1()被调用时，JavaScript 为该函数创建了一个函数执行上下文，并把它压入当前执行栈的顶部。</p>
<p>当 fn1()函数内部调用 fn2()函数时，JavaScript 引擎同样创建了 fn2()的函数执行上下文并压入栈的顶部。然后执行了 fn2()函数后，fn2()函数会从当前栈（后进先出结构）弹出，并且按程序执行顺序继续执行 fn1()函数，即此刻处于 fn1 的函数执行上下文。</p>
<p>当 fn1()函数执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。</p>
<h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>已经知道 JavaScript 怎样管理执行上下文了，现在来了解 JavaScript 引擎是怎么创建执行上下文的。</p>
<p>创建执行上下文有两个阶段：</p>
<ol>
<li>创建阶段</li>
<li>执行阶段。</li>
</ol>
<p>在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：</p>
<ol>
<li>this 绑定</li>
<li>创建(LexicalEnvironment)词法环境组件</li>
<li>创建(VariableEnvironment)变量环境组件</li>
</ol>
<p>执行上下文在概念可表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecutionContext &#x3D; &#123;</span><br><span class="line">  ThisBinding &#x3D; &lt;this value&gt;,</span><br><span class="line">  LexicalEnvironment &#x3D; &#123; ... &#125;,</span><br><span class="line">  VariableEnvironment &#x3D; &#123; ... &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-创建阶段"><a href="#1-创建阶段" class="headerlink" title="1. 创建阶段"></a>1. 创建阶段</h3><h4 id="this-绑定"><a href="#this-绑定" class="headerlink" title="this 绑定"></a>this 绑定</h4><p>在全局执行上下文中，this 的值指向全局对象。(在浏览器中，this 引用 window 对象)</p>
<p>在函数执行上下文中，this 的指向取决于函数是如何被调用的,在本篇暂不对 this 指向做详细讨论。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> win = obj.fn</span><br><span class="line"></span><br><span class="line">obj.fn() <span class="comment">//this指向obj</span></span><br><span class="line">win() <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>

<h4 id="词法环境（Lexical-Environment）"><a href="#词法环境（Lexical-Environment）" class="headerlink" title="词法环境（Lexical Environment）"></a>词法环境（Lexical Environment）</h4><p>ES6 官方文档把词法环境定义为：</p>
<blockquote>
<p>词法环境是用来定义 基于词法嵌套结构的 ECMAScript 代码内的标识符与变量值和函数值之间的关联关系 的一种规范类型。一个词法环境由环境记录（Environment Record）和一个可能为 null 的对外部词法环境的引用（outer）组成。一般来说，词法环境都与特定的 ECMAScript 代码语法结构相关联，例如函数、代码块、TryCatch 中的 Catch 从句，并且每次执行这类代码时都会创建新的词法环境。</p>
</blockquote>
<p>可以理解为词法环境是一种包含标识符(变量/函数的名称)和变量(函数/原始值/数组对象等)映射的数据结构</p>
<h5 id="词法环境有两个组成部分"><a href="#词法环境有两个组成部分" class="headerlink" title="词法环境有两个组成部分"></a>词法环境有两个组成部分</h5><ol>
<li><p>声明式环境记录器：存储变量和函数声明的实际位置</p>
</li>
<li><p>对象环境记录器：可以访问其外部词法环境(作用域)</p>
</li>
</ol>
<h5 id="词法环境有两种类型"><a href="#词法环境有两种类型" class="headerlink" title="词法环境有两种类型"></a>词法环境有两种类型</h5><ol>
<li><p>全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</p>
</li>
<li><p>函数环境：用户在函数中定义的变量被存储在环境记录中，包含了 arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p>
</li>
</ol>
<h4 id="变量环境-VariableEnvironment"><a href="#变量环境-VariableEnvironment" class="headerlink" title="变量环境 (VariableEnvironment)"></a>变量环境 (VariableEnvironment)</h4><p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p>
<p>在 ES6 中，词法环境组件和变量环境组件之间的一个区别是前者用于存储函数声明和变量 let 和 const 绑定，而后者仅用于存储变量 var 绑定。</p>
<h3 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2.执行阶段"></a>2.执行阶段</h3><p>在此阶段，完成对所有这些变量的分配，最后执行代码。（在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined）</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>执行上下文</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之实现继承的7种方式</title>
    <url>/2019/11/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%847%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>有必要搞清楚 JS 实现继承的方式…</p>
<a id="more"></a>

<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>核心：<strong>将父类的实例作为子类的原型</strong></p>
<p>首先，要知道构造函数、原型和实例之间的关系：构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'父类的名字'</span></span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'子类的名字'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果此时有Son的原型对象有方法或属性，下面Son.prototype = new Father()，由于原型重定向，原型上的方法和属性会丢失</span></span><br><span class="line">Son.prototype.getAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'子类的年龄'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father() <span class="comment">// 核心:创建父类的实例，并将该实例赋值给子类的prototype</span></span><br><span class="line"></span><br><span class="line">Son.prototype.getSonName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'子类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son()</span><br><span class="line">son.getFatherName() <span class="comment">// 父类的方法</span></span><br><span class="line">Son.prototype.__proto__.getFatherName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缺点：如果有多个实例对其父类原型，则会互相影响</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'子类改变父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line">son.getFatherName() <span class="comment">// 子类改变父类的方法</span></span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ol>
<li><p>父类使用 this 声明的属性(私有属性和公有属性)被所有实例共享,在多个实例之间对引用类型数据操作会互相影响。</p>
</li>
<li><p>创建子类实例时，无法向父类构造函数传参。</p>
</li>
</ol>
<h2 id="借用构造函数继承-call"><a href="#借用构造函数继承-call" class="headerlink" title="借用构造函数继承(call)"></a>借用构造函数继承(call)</h2><p>核心：<strong>使用父类的构造函数来增强子类实例</strong>，即复制父类的实例属性给子类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>, name, age) <span class="comment">// 继承自Father</span></span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>, <span class="number">22</span>, <span class="string">'前端开发'</span>)</span><br><span class="line"><span class="comment">//son.getFatherName(); // Uncaught TypeError: son.getFatherName is not a function</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>可以向父类传递参数,而且解决了原型链继承中：父类属性使用 this 声明的属性会在所有实例共享的问题。</li>
</ol>
<p>缺点：</p>
<ol>
<li>只能继承父类通过 this 声明的属性/方法，不能继承父类 prototype 上的属性/方法。</li>
<li>每次子类实例化都要执行父类函数，重新声明父类 this 里所定义的方法，因此父类方法无法复用。</li>
</ol>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>核心：<strong>组合上述两种方法，用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.sex = <span class="string">'man'</span></span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>, name, age) <span class="comment">// 第二次调用:创建子类型实例的时候</span></span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father() <span class="comment">// 第一次调用:设置子类型实例的原型的时候</span></span><br><span class="line">Son.prototype.constructor = Son <span class="comment">// prototype构造器指回自己</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>, <span class="number">22</span>, <span class="string">'前端开发'</span>)</span><br><span class="line">son.getFatherName()</span><br><span class="line"><span class="built_in">console</span>.log(son)</span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/11/20/16e89812367319c7?w=517&h=227&f=png&s=19707" alt=""></p>
<p>优点：</p>
<ol>
<li>可以继承父类原型上的属性，可以传参，可复用。</li>
<li>每个新子类对象实例引入的构造函数属性是私有的。</li>
</ol>
<p>缺点：</p>
<ol>
<li>两次调用父类函数(new fatherFn()和 fatherFn.call(this))，造成一定的性能损耗。</li>
<li>在使用子类创建实例对象时，其原型中会存在两份相同属性/方法的问题。</li>
</ol>
<p>拓展：</p>
<h3 id="constructor-的作用"><a href="#constructor-的作用" class="headerlink" title="constructor 的作用"></a>constructor 的作用</h3><p><strong>返回创建实例对象的 Object 构造函数的引用</strong>。</p>
<blockquote>
<p>当我们只有实例对象没有构造函数的引用时：<br>某些场景下，我们对实例对象经过多轮导入导出，我们不知道实例是从哪个函数中构造出来或者追踪实例的构造函数，较为艰难。(它主要防止一种情况下出错，就是你显式地去使用构造函数。比如，我并不知道 instance 是由哪个函数实例化出来的，但是我想 clone 一个，这时就可以这样——&gt;instance.constructor)<br>这个时候就可以通过实例对象的 constructor 属性来得到构造函数的引用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> sonFn() <span class="comment">// 实例化子类</span></span><br><span class="line"><span class="keyword">export</span> instance;</span><br><span class="line"><span class="comment">// 多轮导入+导出，导致sonFn追踪非常麻烦，或者不想在文件中再引入sonFn</span></span><br><span class="line"><span class="keyword">let</span>  fn = instance.constructor</span><br></pre></td></tr></table></figure>

<p>因此每次<strong>重写</strong>函数的 prototype 都应该修正一下 constructor 的指向，以保持读取 constructor 指向的一致性</p>
<h2 id="原型式继承（Object-create-）"><a href="#原型式继承（Object-create-）" class="headerlink" title="原型式继承（Object.create()）"></a>原型式继承（Object.create()）</h2><p>核心：利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Object.create() 的实现原理 */</span></span><br><span class="line"><span class="comment">// cloneObject()对传入其中的对象执行了一次浅拷贝，将构造函数F的原型直接指向传入的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = obj <span class="comment">// 将传进来obj对象作为空函数的prototype</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F() <span class="comment">// 此对象的原型为被继承的对象, 通过原型链查找可以拿到被继承对象的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> father = &#123;</span><br><span class="line">  name: <span class="string">'jacky'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  courses: [<span class="string">'前端'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var son1 = Object.create(father); // 效果一样</span></span><br><span class="line"><span class="keyword">var</span> son1 = cloneObject(father)</span><br><span class="line">son1.courses.push(<span class="string">'后端'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son2 = cloneObject(father)</span><br><span class="line">son2.courses.push(<span class="string">'全栈'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(father.courses) <span class="comment">//  ["前端", "后端", "全栈"]</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<p>从已有对象衍生新对象，不需要创建自定义类型</p>
<p>缺点：</p>
<p>与原型链继承一样。多个实例共享被继承对象的属性，存在篡改的可能；也无法传参。</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>核心：<strong>在原型式继承的基础上，创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象(增加了一些新的方法和属性)，最后返回对象。</strong></p>
<p>使用场景：专门为对象来做某种固定方式的增强。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(obj)</span><br><span class="line">  clone.skill = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'run'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = &#123;</span><br><span class="line">  eat: <span class="string">'food'</span>,</span><br><span class="line">  drink: <span class="string">'water'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = createAnother(animal)</span><br><span class="line">dog.skill()</span><br></pre></td></tr></table></figure>

<p>优点：没有创建自定义类型，因为只是套了个壳子增加特定属性/方法返回对象，以达到增强对象的目的</p>
<p>缺点：</p>
<p>同原型式继承：原型链继承多个实例的引用类型属性指向相同，存在篡改的可能，也无法传递参数</p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>核心：结合借用构造函数传递参数和寄生模式实现继承</p>
<ol>
<li>通过借用构造函数(call)来继承父类 this 声明的属性/方法</li>
<li>通过原型链来继承方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  Father.call(<span class="keyword">this</span>, name, age) <span class="comment">// 借用构造继承: 继承父类通过this声明属性和方法至子类实例的属性上</span></span><br><span class="line">  <span class="keyword">this</span>.job = job</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄生式继承：封装了son.prototype对象原型式继承father.prototype的过程，并且增强了传入的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">son, father</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(father.prototype) <span class="comment">// 原型式继承：浅拷贝father.prototype对象</span></span><br><span class="line">  clone.constructor = son <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">  son.prototype = clone <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Son, Father) <span class="comment">// 将父类原型指向子类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">Son.prototype.getSonName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'子类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>, <span class="number">22</span>, <span class="string">'前端开发'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(son)</span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/11/23/16e97782ff645ca0?w=361&h=182&f=png&s=24333" alt=""></p>
<ul>
<li>寄生组合式继承相对于组合继承有如下优点：</li>
</ul>
<ol>
<li>只调用一次父类 Father 构造函数。不必为了指定子类的原型而调用构造函数，而是间接的让 Son.prototype 访问到 Father.prototype。</li>
<li>避免在子类 prototype 上创建不必要多余的属性。<br>使用原型式继承父类的 prototype，保持了原型链上下文不变, instanceof 和 isPrototypeOf()也能正常使用。 3.寄生组合式继承是最成熟的继承方法, 也是现在最常用的继承方法，众多 JS 库采用的继承方案也是它。</li>
</ol>
<p>缺点：</p>
<p>硬要说的话，就是给子类原型添加属性和方法的时候，一定要放在 inheritPrototype()方法之后</p>
<h2 id="ES6-extends-继承（最优方式）"><a href="#ES6-extends-继承（最优方式）" class="headerlink" title="ES6 extends 继承（最优方式）"></a>ES6 extends 继承（最优方式）</h2><p>核心： 类之间通过 extends 关键字实现继承，清晰方便。 class 仅仅是一个语法糖，它的核心思想仍然是寄生组合式继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  skill() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类的技能'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, job) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name, age) <span class="comment">// 调用父类的constructor,只有调用super之后，才可以使用this关键字</span></span><br><span class="line">    <span class="keyword">this</span>.job = job</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.job)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>, <span class="number">22</span>, <span class="string">'前端开发'</span>)</span><br><span class="line">son.skill() <span class="comment">// 父类的技能</span></span><br><span class="line">son.getInfo() <span class="comment">// jacky 22 前端开发</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果子类没有定义 constructor 方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有 constructor 方法。</li>
</ul>
<blockquote>
<p>子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。这是因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。</p>
</blockquote>
<h2 id="ES5-继承与-ES6-继承的区别"><a href="#ES5-继承与-ES6-继承的区别" class="headerlink" title="ES5 继承与 ES6 继承的区别"></a>ES5 继承与 ES6 继承的区别</h2><ol>
<li>ES5 的继承实质上是先创建子类的实例对象，再将父类的方法添加到 this 上( Father.call(this) )。</li>
<li>ES6 的继承是先创建父类的实例对象 this，再用子类的构造函数修改 this。</li>
<li>因为子类没有自己的 this 对象，所以必须先调用父类的 super()方法。</li>
</ol>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title>实现swiper自定义分页器</title>
    <url>/2019/11/16/%E5%AE%9E%E7%8E%B0swiper%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E9%A1%B5%E5%99%A8/</url>
    <content><![CDATA[<p><strong>问题:不想使用swiper(用的是4.5.1版本)的自带的圆钮式的分页器，需要自定义样式同时分页器需要摆在图片外面</strong></p>
<a id="more"></a>

<p>解决办法:利用swiper提供的renderCustom()方法</p>
<p>html文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-wrapper"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/IMG_20191109_141728.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/IMG_20191109_154050.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--分页器要放图片外显示的话，需要移出来--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;div class="swiper-pagination"&gt;&lt;/div&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySwiper = <span class="keyword">new</span> Swiper (<span class="string">'.swiper-container'</span>, &#123;</span><br><span class="line">        autoplay: &#123;</span><br><span class="line">            delay: <span class="number">3000</span>,</span><br><span class="line">            disableOnInteraction: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        pagination: &#123;</span><br><span class="line">            el: <span class="string">'.swiper-pagination'</span>,</span><br><span class="line">            type: <span class="string">'custom'</span>,</span><br><span class="line">            renderCustom: <span class="function"><span class="keyword">function</span> (<span class="params">swiper, current, total</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> customPaginationHtml = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">                    <span class="comment">// 判断哪个分页器此刻应该被激活</span></span><br><span class="line">                    <span class="keyword">if</span>(i == (current - <span class="number">1</span>)) &#123;</span><br><span class="line">                        customPaginationHtml += <span class="string">'&lt;span class="swiper-pagination-customs swiper-pagination-customs-active"&gt;&lt;/span&gt;'</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        customPaginationHtml += <span class="string">'&lt;span class="swiper-pagination-customs"&gt;&lt;/span&gt;'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> customPaginationHtml;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>css文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.swiper-box</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">74vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">34vw</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">4vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-container</span> <span class="selector-class">.swiper-slide</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-pagination</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">74vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-pagination-bullet</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">4vw</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 包裹自定义分页器的div的位置的样式 */</span></span><br><span class="line"><span class="selector-class">.swiper-pagination-custom</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: -<span class="number">5vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-pagination-customs</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../img/point-grey.png); <span class="comment">/* 未轮播到的图片分页样式 */</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: contain;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.4vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.4vw</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">2vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*自定义分页器激活时的样式表现*/</span></span><br><span class="line"><span class="selector-class">.swiper-pagination-customs-active</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../img/point-green.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：<img src="/images/swiper-pagination.png" alt=" "></p>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端原生JS之开启和禁止页面滚动</title>
    <url>/2019/11/10/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%8E%9F%E7%94%9FJS%E4%B9%8B%E5%BC%80%E5%90%AF%E5%92%8C%E7%A6%81%E6%AD%A2%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/</url>
    <content><![CDATA[<p>在做移动端页面通常有操作需要禁止页面的滚动，来看看原生js怎么操作</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 禁止页面滚动</span></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'touchmove'</span>, handler, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>passive：false。 设置该属性的目的主要是为了在阻止事件默认行为导致的卡顿。等待监听器的执行是耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。加上{ passive: false }能防止页面卡顿。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启页面滚动</span></span><br><span class="line"><span class="built_in">document</span>.body.removeEventListener(<span class="string">'touchmove'</span>, handler, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure></li>
<li>注意点，不能这样写<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启页面滚动</span></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">&#125;, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure></li>
<li>添加和移除的函数对象应该是同一个,否则移除不起作用,即listener不能直接用匿名函数</li>
</ul>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>sessionStorage、localStorage用法总结</title>
    <url>/2019/11/03/sessionStorage%E3%80%81localStorage%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>在工作中使用 sessionStorage 存储数据时，发现 sessionStorage 无法直接存储数组和对象，如存入对象则显示为”[object Object]”，对此作下记录，重新温习 sessionStorage 和 localStorage</p>
<a id="more"></a>

<p>html5 中的 web Storage 包括了两种存储方式：sessionStorage 和 localStorage</p>
<h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><p>存储大小为 5MB，都保存在客户端，不与服务器进行交互通信，有相同的 Web API</p>
<h2 id="sessionStorage、localStorage-区别"><a href="#sessionStorage、localStorage-区别" class="headerlink" title="sessionStorage、localStorage 区别"></a>sessionStorage、localStorage 区别</h2><p>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</p>
<p>sessionStorage 数据在当前浏览器窗口关闭后自动删除。</p>
<p>因此<strong>sessionStorage 和 localStorage 的主要区别在于他们存储数据的生命周期</strong>，sessionStorage 存储的数据的生命周期是一个会话，而 localStorage 存储的数据的生命周期是永久，除非主动删除数据，否则永远不会过期</p>
<h2 id="Web-Storage-API"><a href="#Web-Storage-API" class="headerlink" title="Web Storage API"></a>Web Storage API</h2><p>localStorage 和 sessionStorage 有着统一的 API 接口，下面以 sessionStorage 为例介绍一下 API 接口使用方法</p>
<h3 id="添加键值对"><a href="#添加键值对" class="headerlink" title="添加键值对"></a>添加键值对</h3><p><strong>setItem(key,value)：为指定 key 值设置一个对应的 value 值</strong></p>
<p>除了使用 setItem 方法，还可以使用 sessionStorage.key = value 或者 sessionStorage[‘key’] = value 这两种形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把name值存储到name的键上</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'name'</span>, <span class="string">'jacky'</span>) <span class="comment">// 法1</span></span><br><span class="line"><span class="comment">// sessionStorage.name = 'jacky'; // 法2</span></span><br><span class="line"><span class="comment">// sessionStorage['name'] = 'jacky'; // 法3</span></span><br></pre></td></tr></table></figure>

<p><strong>添加数组和对象</strong></p>
<p>需要注意的是 key 和 value 值必须是<strong>字符串形式</strong>的，如果不是字符串，会调用它们相应的 toString()方法来转换成字符串再存储。</p>
<p>所以要存储数组或对象时，应先转换成字符串格式（如 JSON 格式）再进行存储，使用<strong>JSON.stringify(obj)方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'jacky'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">&#125;</span><br><span class="line">sessionStorage[<span class="string">'person'</span>] = <span class="built_in">JSON</span>.stringify(obj)</span><br><span class="line"><span class="comment">//sessionStorage['person'] = obj; 不能这样存储，这样存进去结果是"[object Object]"</span></span><br></pre></td></tr></table></figure>

<p>存进去之后则为字符串格式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;"</span>name<span class="string">":"</span>jacky<span class="string">","</span>age<span class="string">":22&#125;"</span></span><br></pre></td></tr></table></figure>

<p>需要拿出来使用的时候则使用<strong>JSON.parse()方法</strong>将 JSON 字符串转换为对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="built_in">JSON</span>.parse(sessionStorage[<span class="string">'person'</span>])</span><br></pre></td></tr></table></figure>

<p>同理，数组也是这个用这个方法进行存储。</p>
<h3 id="getItem（key）：根据指定的-key-值获取对应的-value-值"><a href="#getItem（key）：根据指定的-key-值获取对应的-value-值" class="headerlink" title="getItem（key）：根据指定的 key 值获取对应的 value 值"></a>getItem（key）：根据指定的 key 值获取对应的 value 值</h3><p>和 setItem 一样，getItem 也有两种等效形式,value = sessionStorage.key 和 value = sessionStorage[‘key’]。获取到的 value 值是字符串类型，如果需要其他类型，需要自己做类型转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取存储到 name 的键上的值</span></span><br><span class="line"><span class="keyword">var</span> name = sessionStorage.getItem(<span class="string">'name'</span>)</span><br><span class="line"><span class="comment">// var name = sessionStorage.name;</span></span><br><span class="line"><span class="comment">// var name = sessionStorage['name'];</span></span><br></pre></td></tr></table></figure>

<h3 id="removeItem（key）：删除指定的-key-值对应的-value-值"><a href="#removeItem（key）：删除指定的-key-值对应的-value-值" class="headerlink" title="removeItem（key）：删除指定的 key 值对应的 value 值"></a>removeItem（key）：删除指定的 key 值对应的 value 值</h3><p>注意 localStorage 没有数据过期的概念，所有数据如果失效了，需要开发者手动删除。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = sessionStorage.getItem(<span class="string">'name'</span>) <span class="comment">// "jacky"</span></span><br><span class="line">sessionStorage.removeItem(<span class="string">'name'</span>)</span><br><span class="line">name = sessionStorage.getItem(<span class="string">'name'</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h3 id="clear-：删除所有存储的内容"><a href="#clear-：删除所有存储的内容" class="headerlink" title="clear()：删除所有存储的内容"></a>clear()：删除所有存储的内容</h3><p>它和 removeItem 不同的地方是 removeItem 删除的是某一项，而 clear 是删除所有。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清除 localStorage</span></span><br><span class="line">sessionStorage.clear()</span><br><span class="line"><span class="keyword">var</span> len = sessionStorage.length <span class="comment">// 0</span></span><br><span class="line"><span class="comment">//length属性用于获取 sessionStorage 中键值对的数量。</span></span><br></pre></td></tr></table></figure>

<h3 id="key-index-：在指定的数字位置获取该位置的名字"><a href="#key-index-：在指定的数字位置获取该位置的名字" class="headerlink" title="key(index)：在指定的数字位置获取该位置的名字"></a>key(index)：在指定的数字位置获取该位置的名字</h3><p>需要注意的是赋值早的键值对应的索引值大，赋值完的键值对应的索引小,key 方法可用于遍历 sessionStorage 存储的键值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">'name'</span>, <span class="string">'jacky'</span>)</span><br><span class="line"><span class="keyword">var</span> key = sessionStorage.key(<span class="number">0</span>) <span class="comment">// 'name'</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'age'</span>, <span class="number">10</span>)</span><br><span class="line">key = sessionStorage.key(<span class="number">0</span>) <span class="comment">// 'age'</span></span><br><span class="line">key = sessionStorage.key(<span class="number">1</span>) <span class="comment">// 'name'</span></span><br></pre></td></tr></table></figure>

<h2 id="两者应用场景"><a href="#两者应用场景" class="headerlink" title="两者应用场景"></a>两者应用场景</h2><h3 id="sessionStorage-应用场景"><a href="#sessionStorage-应用场景" class="headerlink" title="sessionStorage 应用场景"></a>sessionStorage 应用场景</h3><p>进行页面传值</p>
<h3 id="localStorage-应用场景"><a href="#localStorage-应用场景" class="headerlink" title="localStorage 应用场景"></a>localStorage 应用场景</h3><ol>
<li>适合长期保存在本地的数据</li>
<li>可以用于存储该浏览器对该页面的访问次数</li>
</ol>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>storage</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之获取数组中的最大值方法（this,apply）</title>
    <url>/2019/10/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E6%96%B9%E6%B3%95%EF%BC%88this-apply%EF%BC%89/</url>
    <content><![CDATA[<p>1.排序法 2.假设法 3.基于 Math.max 与 apply 4.ES6 展开运算符</p>
<a id="more"></a>

<h2 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h2><p>思路：给数组先排序(由大到小排序),第一项就是最大值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> max1 = arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b - a</span><br><span class="line">&#125;)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">console</span>.log(max1)</span><br></pre></td></tr></table></figure>

<h2 id="假设法"><a href="#假设法" class="headerlink" title="假设法"></a>假设法</h2><p>思路：假设第一个值是最大值,依次遍历数组中后面的每一项,和假设的值进行比较,如果比假设的值要大,把当前项赋值给 MAX…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> max2 = arr[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= arr.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> item = arr[i]</span><br><span class="line">  item &gt; max2 ? (max2 = item) : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(max2)</span><br></pre></td></tr></table></figure>

<h2 id="基于-Math-max-与-apply"><a href="#基于-Math-max-与-apply" class="headerlink" title="基于 Math.max 与 apply"></a>基于 Math.max 与 apply</h2><p>思路：基于基于 Math.max 完成和 apply 特性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr))</span><br></pre></td></tr></table></figure>

<p>这个是要重点理解的一个方案，call,apply,bind 常常会被放一起比较<br>首先，call，apply，bind 这三个方法其实都是继承自 Function.prototype 中的，属于实例方法。<br>三个方法的作用，都是<strong>改变 this 的指向</strong>，只是用法稍微有些区别</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>什么是 this</p>
<p><strong>this 既不指向函数自身，也不指函数的词法作用域</strong>。它在函数定义的时候是确定不了的,在函数被调用时才发生的绑定，也就是说<code>this具体指向什么，取决于你是怎么调用的函数</code>。</p>
<p>怎么判断 this</p>
<blockquote>
<p>1.给当前元素的某个事件绑定方法, 当事件触发方法执行的时候，方法中的 THIS 是当前操作的元素对象 2.普通函数执行，函数中的 THIS 取决于执行的主体，谁执行的，THIS 就是谁（执行主体：方法执行，看方法名前面是否有“点”，有的话，点前面是谁 this 就是谁，没有 this 是 window）<br>下面看个例子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  myFunction() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">myFunction() <span class="comment">// true</span></span><br><span class="line">obj.myFunction() <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>对 this 有了大致了解后，再来看 call 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'windowName'</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'objName'</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">  name: <span class="string">'obj1Name'</span>,</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">//windowName</span></span><br><span class="line">fn.call(obj) <span class="comment">// objName：虽然是fn调用，但call改变了this指向，this的指向是obj,故obj.name的值为objName</span></span><br><span class="line">fn.call(obj1) <span class="comment">// obj1Name</span></span><br></pre></td></tr></table></figure>

<p>call 方法执行的时候，内部处理了一些事情。首先把要操作函数中的 this 关键字变为 call 方法第一个传递的实参值,把 call 方法第二个及第二个以后的实参获取到，把要操作的函数执行，并且把第二个以后的传递进来的实参传给函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line">fn.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>CALL 中的细节</p>
<blockquote>
<p>1.非严格模式下，如果参数不传，或者第一个传递的是 null/undefined，this 都指向 window 2.在严格模式下，第一个参数是谁，this 就指向谁（包括 null/undefined），不传 this 是 undefined<br>在上述代码中，如果用 apply，则是</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b)</span><br><span class="line">&#125;</span><br><span class="line">fn.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>apply：和 call 基本上一模一样，唯一区别在于<strong>传参方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj, <span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">fn.apply(obj, [<span class="number">10</span>, <span class="number">20</span>]) <span class="comment">//APPLY把需要传递给FN的参数放到一个数组（或者类数组）中传递进去，虽然写的是一个数组，但是也相当于给FN一个个的传递</span></span><br></pre></td></tr></table></figure>

<p>bind：语法和 call 一模一样，唯一的区别在于立即执行还是等待执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">10</span>,<span class="number">20</span>) 改变FN中的THIS,并且把FN立即执行</span><br><span class="line">fn.bind(obj,<span class="number">10</span>,<span class="number">20</span>) 改变FN中的THIS,此时的FN并没有执行（不兼容IE6~<span class="number">8</span>）</span><br></pre></td></tr></table></figure>

<p>bind 调用之后是返回原函数，需要再调用一次才行</p>
<hr>
<p>回到原题，求数组最大值<br>Math.max(arr)这样肯定是报错的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(ary)) <span class="comment">// =&gt; NaN</span></span><br><span class="line"><span class="comment">// =&gt; Math.max是获取一堆数中的最大值,需要我们把比较的数,一个个的传递给这个方法 //=&gt;Math.max(12,13,14...) =&gt;Math.max([12,13,14...])这样只是传递一个值</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr)</span><br><span class="line"><span class="comment">// =&gt; 利用了apply的一个特征：虽然放的是一个数组，但是执行方法的时候，也是把数组中的每一项一个个的传递给函数</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6-展开运算符"><a href="#ES6-展开运算符" class="headerlink" title="ES6 展开运算符"></a>ES6 展开运算符</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...arr))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之由一道题来思考闭包</title>
    <url>/2019/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E6%9D%A5%E6%80%9D%E8%80%83%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>从一道很经典的闭包问题说起…</p>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>闭包就是指有权访问另一个函数作用域中的变量的函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;点击li标签弹出对应数字&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">0</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;1&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">2</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;3&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var list = document.getElementsByTagName('li');</span></span><br><span class="line"><span class="regexp">    for(var i = 0;i &lt; list.length;i++)&#123;</span></span><br><span class="line"><span class="regexp">     list[i].onclick = function()&#123;</span></span><br><span class="line"><span class="regexp">         alert(i);</span></span><br><span class="line"><span class="regexp">     &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>如上题，最为常见的一个例子，这里解释由这道题引出的 js 知识点，如上我们知道在浏览器运行无论点击哪个 li 标签都是弹出 3,首先来理解为什么会弹出 3。</p>
<p>程序通过 for 循环给每个 li 标签绑定了事件，然后通过点击 li 标签触发方法，即执行 alert(i)。js 中有个作用域链查找机制，首先会在 onclick 返回的函数作用域查找 i 变量的值，找不到则往上一层找 i，上一层即是 window 全局作用域，即找到全局变量 i，即 for 循环定义的 i。</p>
<p>注意 for 循环的 i 并不是私有变量，而是全局变量。</p>
<blockquote>
<p>js 中所有的事件绑定都是异步编程（当前这件事件没有彻底完成，不再等待，继续执行下面的任务）</p>
</blockquote>
<p>当绑定 onclick 事件后，不需要等待执行，继续执行下一个循环任务，所以当我们点击执行方法的时候，循环早已结束,即是最后 i=3。故程序执行后全局变量 i 被循环执行后赋值为最终的 3，所以当点击的时候，外层循环已经结束，页面加载完成预示着 js 代码都已经执行完成，即执行 alert(i)时，由于 i 不是私有变量，便会找到上一级 window 作用域全局的 i，所以无论点击哪个 li 标签都是弹出 3</p>
<h2 id="为什么要用闭包"><a href="#为什么要用闭包" class="headerlink" title="为什么要用闭包"></a>为什么要用闭包</h2><p>那么，解决这个问题的缘由，在于 i 每次在页面加载完就赋值为 3，alert(i)的时候总是找到全局变量 i。在 ES5 传统语法中，能形成作用域的只有全局和函数，现在每次 i 找的都是全局，那么要保住 i 的值只能在全局和 onclick 返回函数的作用域中间再加一个小的私有作用域，即是大的作用域外再加一个小的作用域，这样 i 往上一层作用域查找时，就会获取小作用域的 i 的值，而不会去获取全局变量的 i 值。</p>
<p>这个思路解决问题就需要引入闭包，在这个理解上闭包是指函数变量可以保存在函数作用域内，因此看起来是函数将变量“包裹”了起来。于是，代码改成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  list[i].onclick = (<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//形参n</span></span><br><span class="line">    <span class="comment">//=&gt;让自执行函数执行,把执行的返回值(return)赋值给onclick</span></span><br><span class="line">    <span class="comment">//（此处onclick绑定的是返回的小函数，点击的时候执行的是小函数）,</span></span><br><span class="line">    <span class="comment">// 自执行函数在给事件赋值的时候就已经执行了</span></span><br><span class="line">    <span class="comment">// 自执行函数形成一个私有作用域</span></span><br><span class="line">    <span class="keyword">var</span> i = n</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i) <span class="comment">//传入实参i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环三次，形成三个不销毁的私有作用域（自执行函数执行），而每一个不销毁的栈内存中都存储了一个私有变量 i，而这个值分别是每一次执行传递进来的全局 i 的值（也就是：第一个不销毁的作用域存储的是 0，第二个是 1，第三个是 2，第四个是 3）；当点击的时候，执行返回的小函数，遇到变量 i，向它自己的上级作用域查找。这样就达到了我们需要的效果，这种闭包实现，也可以有另一种写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*原理同法二都是形成三个不销毁的私有作用域,分别存储需要的索引值*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  ;(<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    list[n].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(n)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于初始的代码，如果说为什么不能实现，那原因就可归纳为：</p>
<blockquote>
</blockquote>
<ol>
<li>执行方法,形成一个私有的栈内存,遇到变量 i,i 不是私有变量,向上一级作用域查找（上级作用域 window）</li>
<li>所有的事件绑定都是异步编程,绑定事件后,不需要等待执行,继续执行下一个循环任务,所以当我们点击执行方法的时候,循环早已结束（让全局的 i 等于循环最后的结果 3）</li>
</ol>
<h2 id="ES6-语法的解决方式"><a href="#ES6-语法的解决方式" class="headerlink" title="ES6 语法的解决方式"></a>ES6 语法的解决方式</h2><p>在 ES6 中，解决这种问题只需要一个 let 变量，ES6 中才有块级作用域（类似于私有作用域）的概念</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  list[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包对内存的影响"><a href="#闭包对内存的影响" class="headerlink" title="闭包对内存的影响"></a>闭包对内存的影响</h2><p>从上面可知，每次 for 都会形成一个私有作用域，每个都里面保存的变量 i 的值，程序运行后这些作用域并不会被销毁，所以由于闭包会携带包含它的函数的作用域，所以会比其他函数占用更多内容，过度使用闭包会导致内存占用过多。</p>
<p>在真实项目中为了保证 JS 的性能（堆栈内存的性能优化），应该尽可能的减少闭包的使用（不销毁的堆栈内存是耗性能的）</p>
<h2 id="堆内存和栈内存的释放"><a href="#堆内存和栈内存的释放" class="headerlink" title="堆内存和栈内存的释放"></a>堆内存和栈内存的释放</h2><p>这里又要提到一个知识点，js 中存储方式的分类：</p>
<blockquote>
<p>JS 中的内存分为堆内存和栈内存<br>堆内存：存储引用数据类型值（对象：键值对 函数：代码字符串）<br>栈内存：提供 JS 代码执行的环境和存储基本类型值</p>
</blockquote>
<p>粗暴理解 var 定义的变量存在栈内存中，如 for 循环中的 i 是存在栈内存中的；而函数，它是存在堆内存中</p>
<p><strong>一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉（在栈内存中存储的值也都会释放掉）</strong>，那为什么闭包的栈内存不会被自动释放掉，在 js 中也有特殊不被销毁的情况：</p>
<blockquote>
<p>1.函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用了，此时栈内存不能释放（一旦释放外面找不到原有的内容了） 2.全局栈内存只有在页面关闭的时候才会被释放掉</p>
</blockquote>
<p>闭包则是属于第一种情况，onclick 函数形成的栈内存，被小函数【alert(i)，i 找到 onclick 作用域获取 i 值】占用了 onclick 函数的栈内存（变量 i 是存在栈内存中），故栈内存不能被释放，所以才会说闭包过度使用容易导致内存被占用过多，因为不会自动释放内存。</p>
<p><strong>堆内存的释放</strong></p>
<blockquote>
<p>堆内存让所有引用堆内存空间地址的变量赋值为 null 即可（没有变量占用这个堆内存了，浏览器会在空闲的时候把它释放掉）</p>
</blockquote>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之变量提升</title>
    <url>/2019/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>原理：JS 引擎的工作方式是先解析代码，获取所有被声明的变量；然后在运行。JS 代码自上而下执行之前，浏览器首先会把所有带”VAR”/“FUNCTION”关键词的进行提前”声明”或者”定义”，这种预先处理机制称之为 “变量提升”。</p>
<a id="more"></a>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">//undefined undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>,</span><br><span class="line">  b = <span class="number">12</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a, b) <span class="comment">//=&gt;undefined 12</span></span><br><span class="line">  <span class="keyword">var</span> a = (b = <span class="number">13</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(a, b) <span class="comment">//=&gt;13 13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn()</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">//=&gt;12 13</span></span><br></pre></td></tr></table></figure>

<ul>
<li>undefined undefined：首先输出这个结果是因为变量提升，即前三行变成</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">//undefined undefined</span></span><br><span class="line">a = <span class="number">12</span></span><br><span class="line">b = <span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li>undefined 12：接下来执行函数 fn（fn 一开始也被执行了变量提升,只不过函数中存储的都是字符串而已），对 fn 内部进行分析，即内部代码变成：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">//undefined 12</span></span><br><span class="line">a = <span class="number">13</span></span><br><span class="line">b = <span class="number">13</span> <span class="comment">//不加var的本质是WIN的属性，即相当于window.b = 13;</span></span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">//13 13</span></span><br></pre></td></tr></table></figure>

<p>一开始 b 在 fn 内部找不到，便会开始往上一层找，找到了全局的 b，于是 b 输出 12。</p>
<p>当经过 var a = b = 13; 后，b 被赋值为 13，于是输出先从函数内部找 b，找到了 b=13，第二次输出 b 为 13。（！同时，最先定义的全局变量 b = 12 也被赋值为 13，故最后的 b 也等于 13）</p>
<blockquote>
<p>私有作用域中带 var 和不带 var 的区别：</p>
<ol>
<li>带 var 的在私有作用于变量提升阶段，都声明为私有变量，和外界没有任何的关系</li>
<li>不带 var 不是私有变量，会向它的上级作用于查找，一直找到 window 为止（这种查找机制叫做：“作用域链”），也就是在私有作用域中操作的这个非私有变量，是一直操作别人的</li>
</ol>
</blockquote>
<h2 id="只对等号左边进行变量提升"><a href="#只对等号左边进行变量提升" class="headerlink" title="只对等号左边进行变量提升"></a>只对等号左边进行变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sum()</span><br><span class="line">fn() <span class="comment">// Uncaught TypeError: fn is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;匿名函数之函数表达式</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn'</span>)</span><br><span class="line">&#125; <span class="comment">//=&gt;代码执行到此处会把函数值赋值给fn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;普通的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'sum'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件判断下的变量提升"><a href="#条件判断下的变量提升" class="headerlink" title="条件判断下的变量提升"></a>条件判断下的变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在当前作用域下，不管条件是否成立都要进行变量提升</span></span><br><span class="line"><span class="comment"> *   =&gt;带VAR的还是只声明</span></span><br><span class="line"><span class="comment"> *   =&gt;带FUNCTION的在老版本浏览器渲染机制下，声明和定义都处理，但是为了迎合ES6中的块级作用</span></span><br><span class="line"><span class="comment"> *     域，新版浏览器对于函数（在条件判断中的函数），</span></span><br><span class="line"><span class="comment"> *     不管条件是否成立，都只是先声明，没有定义，类似于var</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span> === <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="重名问题的处理"><a href="#重名问题的处理" class="headerlink" title="重名问题的处理"></a>重名问题的处理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn() <span class="comment">//=&gt;4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">//=&gt;4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn() <span class="comment">//=&gt;4</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">100</span> <span class="comment">//=&gt;带VAR的在提升阶段只把声明处理了,赋值操作没有处理,所以在代码执行的时候需要完成赋值 FN=100</span></span><br><span class="line">fn() <span class="comment">//=&gt;100() Uncaught TypeError: fn is not a function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<p>带 VAR 和 FUNCTION 关键字声明相同的名字，这种也算是重名了（其实是一个 FN，只是存储值的类型不一样）<br>关于重名的处理：如果名字重复了，不会重新的声明，但是会重新的定义（重新赋值）[不管是变量提升还是代码执行阶段皆是如此]</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>变量提升</tag>
      </tags>
  </entry>
  <entry>
    <title>jquery设计的巧妙</title>
    <url>/2019/09/07/jquery%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B7%A7%E5%A6%99/</url>
    <content><![CDATA[<p>最近开始阅读jquery的源码，首先先提炼出jquery的核心结构。</p>
<a id="more"></a>
<h2 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window,undefined</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<h3 id="为什么传入window"><a href="#为什么传入window" class="headerlink" title="为什么传入window?"></a>为什么传入window?</h3><p><strong>1.代码压缩</strong></p>
<p>首先从代码压缩混淆的角度考虑，用线上工具来压缩混淆下面这段示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name=<span class="string">"hello"</span>;</span><br><span class="line">  <span class="built_in">window</span>.description=<span class="string">"hi "</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>压完混完后瘦了一点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> a=<span class="string">"hello"</span>;<span class="built_in">window</span>.description=<span class="string">"hi "</span>+a&#125;</span><br></pre></td></tr></table></figure>
<p>用a代替了name，但是window既不是声明的局部变量也不是参数，是不会被压缩混淆的。<br>所以将window作为参数传入可解决这个问题。将window作为参数传入，可以在压缩代码时进行优化，即参数名可以压缩变短。也可以在函数内另起个简短的变量名代替。  </p>
<p><strong>2.作用域</strong></p>
<p>访问当前作用域下的变量比访问全局变量要快<br>如果不传入，每个语句都要去找一次window。如果将window作为参数传递过去，不要每个语句都去找window，提高了效率。</p>
<h3 id="为什么要传入undefined？"><a href="#为什么要传入undefined？" class="headerlink" title="为什么要传入undefined？"></a>为什么要传入undefined？</h3><p>undefined并不是作为JavaScript的保留关键字；undefined在IE8及以下中是可以对其重新赋值的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var undefined&#x3D;&quot;new value&quot;;</span><br><span class="line">alert(undefined);&#x2F;&#x2F;alert “new value&quot;</span><br></pre></td></tr></table></figure>
<p>执行匿名函数的时候，只传递一个参数window，而不传递undefined，那么函数体中的undefined局部变量的值，刚好就是undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">8</span>;  </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window </span>) </span>&#123;   </span><br><span class="line">    alert(<span class="built_in">window</span>.undefined); <span class="comment">// 8  </span></span><br><span class="line">    alert(<span class="literal">undefined</span>); <span class="comment">// 8  </span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>加了undefined后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">8</span>;  </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;   </span><br><span class="line">    alert(<span class="built_in">window</span>.undefined);  <span class="comment">// 8  </span></span><br><span class="line">    alert(<span class="literal">undefined</span>); <span class="comment">// 此处undefined参数为局部的名称为undefined变量，值为undefined  </span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>在 自调用匿名函数 的作用域内，确保undefined是真的未定义。因为undefined能够被重写，赋予新的值.</p>
<h2 id="new-jQuery-fn-init-selector-context"><a href="#new-jQuery-fn-init-selector-context" class="headerlink" title="new jQuery.fn.init( selector, context );"></a>new jQuery.fn.init( selector, context );</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context );</span><br><span class="line">    <span class="comment">//=&gt;创建了init这个类的实例，也相当于创建了jQuery这个类的实例（因为在后面的时候，让init.prototype=jQuery.prototype）&#125;;</span></span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要理解这段代码，首先要理解jquery的两种调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'body'</span>).css(<span class="string">'background'</span>,<span class="string">'red'</span>);</span><br><span class="line">$.parseJSON(<span class="string">'&#123;&#125;'</span>);</span><br></pre></td></tr></table></figure>
<p>$(‘body’)应该是一个实例对象，css是每个实例共享的方法，是原型上的方法。<br>而$则是一个类，parseJSON则是类的静态方法。  </p>
<h3 id="如何不用new关键字得到jQuery对象？"><a href="#如何不用new关键字得到jQuery对象？" class="headerlink" title="如何不用new关键字得到jQuery对象？"></a>如何不用new关键字得到jQuery对象？</h3><p>一般获取实例对象调取实例方法的例子，如果没有使用new则会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo=<span class="keyword">new</span> Demo(<span class="string">"jacky"</span>);</span><br><span class="line">demo.change();</span><br></pre></td></tr></table></figure>
<p>但是获取jQuery对象（以下简称JQ对象）用new和不用new都可以，返回的是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log($(<span class="string">'*'</span>).length);<span class="comment">//14</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> $(<span class="string">'*'</span>).length);<span class="comment">//14</span></span><br></pre></td></tr></table></figure>
<p>为了做到这点，我们很容易想到需要<strong>在构造函数内部返回对象</strong>。</p>
<p>构造函数有return值怎么办？<br><strong>构造函数里没有显式调用return时，默认是返回this对象，也就是新创建的实例对象。</strong></p>
<p>当构造函数里调用return时，分两种情况：</p>
<blockquote>
<p>1.return的是五种简单数据类型：String，Number，Boolean，Null，Undefined。 这种情况下，忽视return值，依然返回this对象。<br>2.return的是Object 这种情况下，不再返回this对象，而是返回return语句的返回值。</p>
</blockquote>
<p>所以我们应该在jQuery构造函数内部去返回一个对象，这样就可以不用new的方式去创建JQ对象了，其实这时候，构造函数就相当于一个工厂函数了。</p>
<p>该返回什么样的对象？对于这个对象有何要求？<br>这个对象必须可以调用jQuery.prototype上的方法</p>
<p>我们使用或自己写jQuery插件的时候会经常遇到$.fn这个对象，很多插件都是通过扩展这个对象来实现的。<br>$.fn其实对应着jQuery.prototype，$和fn分别是jQuery和prototype的简写方式，只要我们把方法扩展到这个原型对象身上，通过$()获取的JQ对象都是可以访问到方法的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.fn.greeting=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'hi'</span>)&#125;;</span><br><span class="line">$(<span class="string">'body'</span>).greeting();<span class="comment">// alert 'hi'</span></span><br></pre></td></tr></table></figure>
<p>jquery源码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context, rootjQuery );</span><br><span class="line">&#125;,</span><br><span class="line">jQuery.fn = jQuery.prototype = &#123; <span class="comment">// fn即对应prototype</span></span><br><span class="line">    <span class="keyword">constructor</span>: jQuery,</span><br><span class="line">    init: function( selector, context, rootjQuery ) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jQuery.fn.init.prototype = jQuery.fn;<br>看到上面这段源码，原因就很明显了，”jQuery.fn.init.prototype = jQuery.fn”这句很重要，它将init的原型指向jQuery的原型，所以JQ对象才可以访问‘css’、’show’、’hide’这些写在jQuery.fn上的方法。其实我们所说的JQ对象根本就是init函数的实例对象，而init则是jQuery原型上的一个对象，它本身是没有什么方法的，全靠从jQuery原型上拿。</p>
<p>为何要从init这绕这么一大圈来访问jQuery的原型，而不是直接返回一个jQuery实例直接通过这个实例来访问自身原型？比如说代码可以写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> jQuery();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题很明显，死在循环里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jQuery.fn.init();<span class="comment">// 不同点在于去掉了new关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做点动作来证明加上new是有用的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jQuery.fn.init();</span><br><span class="line">&#125;,</span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name=<span class="string">'sheila'</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    anotherName:<span class="string">'sunwukong'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> jq=jQuery();</span><br><span class="line"><span class="built_in">console</span>.log(jq.anotherName);<span class="comment">// "sunwukong"</span></span><br><span class="line"><span class="built_in">console</span>.log(jq.name);<span class="comment">// "sheila"</span></span><br></pre></td></tr></table></figure>
<p>上面这段代码是为了说明this的作用域问题，其不仅能访问init函数内部，还能向上一层到fn对象，作用域不独立.如果是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(jq.anotherName);<span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(jq.name);<span class="comment">//  "sheila"</span></span><br></pre></td></tr></table></figure>
<p>加不加new还牵涉到一个更重要的问题：返回的对象究竟是谁。</p>
<p>不加new的情况下，’jQuery.fn.init()’相当于调用方法，this指向的以及最后返回的都是同一个jQuery.fn对象，$(‘body’)和$(‘p’)就没有区分了。</p>
<p>显然，这是不合理的。而加了new，就是每次用构造函数实例化了一个新对象，彼此都是不同的</p>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>this.props.history.push()报错解决</title>
    <url>/2019/04/05/this-props-history-push%E6%96%B9%E6%B3%95%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>在使用 React 的路由跳转时，出现了这个错误”cannot read property ‘push’ of undefined”，找来找去，发现是子组件这样调用时才会报错,它不是路由组件。以下是解决方案：</p><a id="more"></a><p>在我的每个页面中，Header 组件都会引入，使其成为子组件</p><h3 id="通过父组件传值给子组件"><a href="#通过父组件传值给子组件" class="headerlink" title="通过父组件传值给子组件"></a>通过父组件传值给子组件</h3><p>在父组件中，传递一个 history 给子组件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Header history=&#123;<span class="keyword">this</span>.props.history&#125; /&gt;</span><br></pre></td></tr></table></figure><p>子组件方法还是一样写</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.history.push(<span class="string">'/login'</span>)</span><br></pre></td></tr></table></figure><p>但如果 Header 组件被嵌套封装更深的话是不行的，这时只能选择第二种方法。</p><h3 id="使用-withRouter"><a href="#使用-withRouter" class="headerlink" title="使用 withRouter"></a>使用 withRouter</h3><blockquote><p>默认情况下必须经过路由匹配渲染的组件才存在 this.props,才拥有路由参数，执行 this.props.history.push(‘/login’)跳转到对应路由的页面，然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用 withRouter 就可以给此组件传入路由参数，将 react-router 的 history、location、match 三个对象传入 props 对象上，此时就可以使用 this.props。</p></blockquote><p>可见当一个非路由组件也想访问到当前路由的 match,location,history 对象，那么 withRouter 将是一个非常好的选择，可以理解为将一个组件包裹成路由组件。</p><p>用法：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Header) <span class="comment">// export时要使用withRouter</span></span><br></pre></td></tr></table></figure><p>在 Header 组件引入并使用，就可以使用 this.props.history.push 方法进行正常跳转了~~</p>]]></content>
      <categories>
        <category>React系列</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB性能之逐条插入与批量插入</title>
    <url>/2018/05/12/MongoDB%E6%80%A7%E8%83%BD%E4%B9%8B%E9%80%90%E6%9D%A1%E6%8F%92%E5%85%A5%E4%B8%8E%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/</url>
    <content><![CDATA[<p>在 mongoDB 中，当我们要插入很多数据时，可以选择用循环依次逐条插入，或者可以先把所有数据装在一个数组再整个数组插入集合，但是，最好使用第二种方式…</p>
<a id="more"></a>

<p>如下代码所示（已新建数据库 log 和集合 test），在 js 写入如下代码</p>
<h2 id="逐条插入"><a href="#逐条插入" class="headerlink" title="逐条插入"></a>逐条插入</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() <span class="comment">//获得开始时间</span></span><br><span class="line"><span class="keyword">var</span> db = connect(<span class="string">'log'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  db.test.insert(&#123; <span class="attr">num</span>: <span class="number">1</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> runTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - startTime <span class="comment">//获得运行时间</span></span><br><span class="line">print(<span class="string">'runTime is '</span> + runTime + <span class="string">'ms'</span>) <span class="comment">//runTime is 745ms</span></span><br></pre></td></tr></table></figure>

<h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() <span class="comment">//获得开始时间</span></span><br><span class="line"><span class="keyword">var</span> db = connect(<span class="string">'log'</span>)</span><br><span class="line"><span class="keyword">var</span> tempArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  tempArr.push(&#123; <span class="attr">num</span>: <span class="number">1</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">db.test.insert(tempArr)</span><br><span class="line"><span class="keyword">var</span> runTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - startTime</span><br><span class="line">print(<span class="string">'runTime is '</span> + runTime + <span class="string">'ms'</span>) <span class="comment">// runTime is 48ms</span></span><br></pre></td></tr></table></figure>

<p>由运行时间来看，批量插入比逐条插入所用的时间少了很多，在小型项目中可能感受不到的差距，在大项目就是性能的问题了，故应使用第二种方式来批量插入数据。</p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
</search>
