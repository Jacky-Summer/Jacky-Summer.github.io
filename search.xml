<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>this.props.history.push()报错解决</title>
    <url>/2020/04/05/this-props-history-push%E6%96%B9%E6%B3%95%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>在使用React的路由跳转时，出现了这个错误”cannot read property ‘push’ of undefined”，找来找去，发现是子组件这样调用时才会报错,它不是路由组件。以下是解决方案：</p>
<a id="more"></a>
<p>在我的每个页面中，Header组件都会引入，使其成为子组件</p>
<h3 id="通过父组件传值给子组件"><a href="#通过父组件传值给子组件" class="headerlink" title="通过父组件传值给子组件"></a>通过父组件传值给子组件</h3><p>在父组件中，传递一个history给子组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Header history=&#123;<span class="keyword">this</span>.props.history&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>子组件方法还是一样写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`this.props.history.push('/login')`</span></span><br></pre></td></tr></table></figure>
<p>但如果Header组件被嵌套封装更深的话是不行的，这时只能选择第二种方法。</p>
<h3 id="使用withRouter"><a href="#使用withRouter" class="headerlink" title="使用withRouter"></a>使用withRouter</h3><blockquote>
<p>默认情况下必须经过路由匹配渲染的组件才存在this.props,才拥有路由参数，执行this.props.history.push(‘/login’)跳转到对应路由的页面，然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用withRouter就可以给此组件传入路由参数，将react-router的history、location、match三个对象传入props对象上，此时就可以使用this.props。</p>
</blockquote>
<p>可见当一个非路由组件也想访问到当前路由的match,location,history对象，那么withRouter将是一个非常好的选择，可以理解为将一个组件包裹成路由组件。</p>
<p>用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Header); <span class="comment">// export时要使用withRouter</span></span><br></pre></td></tr></table></figure>
<p>在Header组件引入并使用，就可以使用this.props.history.push方法进行正常跳转了~~</p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之变量的解构赋值</title>
    <url>/2020/01/04/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<p>解构赋值在开发中很常用，在此总结它的用法…</p>
<a id="more"></a>
<h2 id="什么是解构？"><a href="#什么是解构？" class="headerlink" title="什么是解构？"></a>什么是解构？</h2><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。它在语法上比ES5所提供的更加简洁、紧凑、清晰。它不仅能减少你的代码量，还能从根本上改变你的编码方式。</p>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>以前，为变量赋值，我们只能直接指定值，比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>现在可以用数组解构的方式来进行赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1, 2, 3</span></span><br></pre></td></tr></table></figure>
<p>这是数组解构最基本类型的用法，还可以解构对象数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象数组解构</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [&#123;<span class="attr">name</span>: <span class="string">'jacky'</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'monkey'</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'houge'</span>&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// &#123;name: 'jacky'&#125;, &#123;name: 'monkey'&#125;, &#123;name: 'houge'&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组模式和赋值模式统一"><a href="#数组模式和赋值模式统一" class="headerlink" title="数组模式和赋值模式统一"></a>数组模式和赋值模式统一</h2><p>这条可以理解为等号左边和等号右边的形式要统一，如果不统一解构将失败。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [b, c], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d); <span class="comment">// 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 提取除第二、三个外的所有数值</span></span><br><span class="line"><span class="keyword">let</span> [a, , , d] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, d); <span class="comment">// 1 4</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 1 [2, 3, 4]</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> [a, , , ...d] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, d); <span class="comment">// 1 [4, 5]</span></span><br></pre></td></tr></table></figure>
<p>如果解构不成功，变量的值就等于<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 2 3 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [c] = [];</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上述是完全解构的情况，还有一种是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组，解构依然可以成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(x, y); <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, d); <span class="comment">// 1 2 4</span></span><br></pre></td></tr></table></figure>

<h2 id="解构的默认值"><a href="#解构的默认值" class="headerlink" title="解构的默认值"></a>解构的默认值</h2><p>解构赋值允许指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b=<span class="number">2</span>] = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>, b=<span class="number">2</span>, c, d=<span class="number">13</span>] = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d); <span class="comment">// 10 11 12 13</span></span><br></pre></td></tr></table></figure>

<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 对象解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而非前者。</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">"aaa"</span>, <span class="attr">b</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: x, <span class="attr">b</span>: y &#125; = obj; </span><br><span class="line"><span class="built_in">console</span>.log(x, y); <span class="comment">// aaa bbb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="string">'aaa'</span>, <span class="attr">b</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// aaa bbb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不按照顺序</span></span><br><span class="line"><span class="keyword">let</span> &#123; b, a &#125; = &#123; <span class="attr">a</span>: <span class="string">'test1'</span>, <span class="attr">b</span>: <span class="string">'test2'</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// test1 test2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套解构</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">obj</span>: &#123; name &#125;&#125; = &#123; <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="string">'jacky'</span>, <span class="attr">age</span>: <span class="string">'22'</span> &#125; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// jacky</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稍微复杂的嵌套</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    p: [</span><br><span class="line">        <span class="string">'Hello'</span>,</span><br><span class="line">        &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(x, y); <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: rename &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>,<span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(rename); <span class="comment">// aaa</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>
<p>如果在解构之前就定义了变量，这时候再解构会出现问题。下面是错误的代码，编译会报错（因为js引擎会将{a}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免js将其解释成代码块，才能解决这个问题）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">"aaa"</span> &#125;;</span><br><span class="line">&#123;a&#125; = obj; <span class="comment">// Uncaught SyntaxError: Unexpected token '='</span></span><br></pre></td></tr></table></figure>
<p>要解决报错，使程序正常，这时候只要在解构的语句外边加一个圆括号就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">"aaa"</span> &#125;;</span><br><span class="line">( &#123;a&#125; = obj );</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数的参数也可以使用解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>函数参数的解构也可以使用默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y = <span class="number">7</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">3</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串解构"><a href="#字符串解构" class="headerlink" title="字符串解构"></a>字符串解构</h2><p>字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e, f] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//h</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//e</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">//l</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">//l</span></span><br><span class="line"><span class="built_in">console</span>.log(e); <span class="comment">//o</span></span><br><span class="line"><span class="built_in">console</span>.log(f); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s === <span class="built_in">Number</span>.prototype.toString); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s === <span class="built_in">Boolean</span>.prototype.toString); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h2 id="解构赋值的应用"><a href="#解构赋值的应用" class="headerlink" title="解构赋值的应用"></a>解构赋值的应用</h2><h3 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h3><p>通常交换两个变量的方法需要一个额外的临时变量,如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> temp;</span><br><span class="line"></span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure>
<p>用ES6解构赋值的话，会变得很简洁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">[a, b] = [b ,a];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure>

<h3 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h3><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>

<h3 id="访问数组中元素"><a href="#访问数组中元素" class="headerlink" title="访问数组中元素"></a>访问数组中元素</h3><p>有种场景，比如有一个数组（可能为空）。并且希望访问数组的第一个、第二个或第n个项，但如果该项不存在，则使用指定默认值。<br>通常会使用数组的<code>length</code>属性来判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstItem = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">if</span> (list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    firstItem = list[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstItem); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>如果用ES6解构赋值来实现上述逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [];</span><br><span class="line"><span class="keyword">const</span> [firstItem = <span class="string">'hello'</span>] = list;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstItem); <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>

<h3 id="提取-JSON-数据"><a href="#提取-JSON-数据" class="headerlink" title="提取 JSON 数据"></a>提取 JSON 数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历-Map-结构"><a href="#遍历-Map-结构" class="headerlink" title="遍历 Map 结构"></a>遍历 Map 结构</h3><p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文章部分内容参考：阮一峰老师的《ECMAScript 6 入门》一书</li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之let和const与var的区别</title>
    <url>/2019/12/28/ES6%E7%B3%BB%E5%88%97%E4%B9%8Blet%E5%92%8Cconst%E4%B8%8Evar%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>ES6规范新增了let、const两种变量声明方式，项目中也经常要用到，今天借着温习ES6语法，来总结let 、const、var的区别。</p>
<a id="more"></a>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>来看下面三段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// Uncaught ReferenceError: c is not defined</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>用var声明的变量，会在其作用域中发生变量提升，js默认给变量一个undefined值。</p>
<p>但是，在ES6中使用let/const声明的变量，不存在变量提升过程。也就是说，在使用let/const声明的变量，声明前访问它，都会报错。</p>
<h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><blockquote>
<p>代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'global'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    a = <span class="string">'block'</span>;    <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，if代码块里，在let声明变量a之前，都是a的”暂时性死区”,在该范围内访问a都会报错。<br>由此可见，块级作用域内存在let声明的话，它所声明的变量就绑定在这个块级作用域，不再受外部影响。</p>
<h2 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h2><p>let 和 const 命令声明的变量不允许重复声明；而使用var声明变量，可以多次重复声明一个同名变量，但最终变量的值为最后一次声明赋值的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'last value'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// last value</span></span><br></pre></td></tr></table></figure>

<p>let与const在相同作用域声明重复的变量会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure>
<p>var和let同时声明同一个变量，也是报同样的错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'b' has already been declared</span></span><br></pre></td></tr></table></figure>
<p>或先var，再let</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'c' has already been declared</span></span><br></pre></td></tr></table></figure>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>这里就涉及到一个最经典的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 5 5 5 5 5 </span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个问题的解决可以使用闭包等，ES6的let为这个问题提供了新的解决方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用let声明的变量仅在块级作用域内有效。 i在循环体内的局部作用域，不受外界影响。</p>
<p>在ES6之前，都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以花括号{}限定不了var声明变量的访问范围。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">9</span>;     <span class="comment">// es6的let: b变量只在花括号内有效</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="let、const声明的全局变量不会作为window对象的一个属性"><a href="#let、const声明的全局变量不会作为window对象的一个属性" class="headerlink" title="let、const声明的全局变量不会作为window对象的一个属性"></a>let、const声明的全局变量不会作为window对象的一个属性</h2><p>使用var声明的全局变量，会被JS自动添加在全局对象window上，但let和const不会</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>



<h2 id="const声明常量"><a href="#const声明常量" class="headerlink" title="const声明常量"></a>const声明常量</h2><p>由于const用来声明常量，一旦声明，就必须立即初始化，而且声明之后值不能改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<p>常量的值不变，实际上是指常量指向的那个内存地址中所保存的数据不可更改。</p>
<p>对于基本数据类型（数值，字符串、布尔值），他们本身具体的值就保存在常量所指向对应的栈内存地址中，所以修改值就等于修改栈内存地址，这显然不允许会报错。</p>
<p>但是，如果一个常量的值是一个引用类型值，那么常量所指向的内存地址（堆内存）中实际保存的是指向该引用类型值的一个指针（也就是引用类型值在内存中的地址）。所以const只能保证该引用类型地址不变，但该地址中的具体数据是可以变化的。</p>
<p>如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;a: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当obj指向了另一个对象，即obj中保存的地址发生了变化，即会报错</span></span><br><span class="line">obj = &#123;&#125;;  <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<h2 id="如何正确使用"><a href="#如何正确使用" class="headerlink" title="如何正确使用"></a>如何正确使用</h2><p>在开发的时候，声明变量我们应该少使用var，避免产生不必要的全局变量。当需要改变变量的值时声明用let，对于需要写保护的变量或定义常量使用const。</p>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>页面内容是否超出可视高度，footer始终保持底部显示</title>
    <url>/2019/12/07/CSS%E7%B3%BB%E5%88%97%E4%B9%8B%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E8%B6%85%E5%87%BA%E5%8F%AF%E8%A7%86%E9%AB%98%E5%BA%A6%EF%BC%8Cfooter%E5%A7%8B%E7%BB%88%E4%BF%9D%E6%8C%81%E5%BA%95%E9%83%A8%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>记录一个项目中经常会用到的技巧，footer区（比如版权信息）要始终居于页面底部。如果用fixed定位显然不可取，因为要保证页面高度大于屏幕高度时，footer区要跟随着页面滚动保持在底部</p>
<a id="more"></a>
<p>如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/7/16ee0e36c5c55fea?w=1737&h=899&f=png&s=23364" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/7/16ee0e3a25e302bd?w=1577&h=903&f=png&s=27932" alt=""></p>
<ul>
<li>tip：以下两个方法仅适用于footer区高度固定的情况</li>
</ul>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>页面结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main-container&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;box&quot;&gt;这是主要内容&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;footer&gt;这是底部&lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>关键的css<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-container</span>&#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">footer</span>&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如上代码，主要内容区和footer区必须为并列关系。设置main-container为border-box，即元素的内边距和边框都在已设定的高度内绘制，我们设置了min-height为100%，即最小高度是铺满整屏幕。padding-bottom在border-box盒子中，留出高度40px的空白块。footer的margin-top为-40px（如果footer有设置高度，padding-bottom的值应以footer高度为准），即向上拉到空白块内，main-container最小高度为整个屏幕，故页面内容不足也可以显示在底部。</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>页面结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main-container&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;box&quot;&gt;这是主要内容&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;footer&gt;这是底部&lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>关键的css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html,body&#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.wrapper&#123;</span><br><span class="line">    min-height: 100%;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.main-container&#123;</span><br><span class="line">    padding-bottom: 40px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">footer&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    height: 40px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码时用绝对定位，相对于wrapper居于底部，跟第一个方法有异曲同工之妙。</p>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之执行上下文和变量对象</title>
    <url>/2019/11/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>继续接着上篇文章，今天再细说执行上下文中的变量对象…</p>
<a id="more"></a>
<p>上篇我们说到函数上下文的结构可表示为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ExecutionContextObj = &#123;</span><br><span class="line">    VO: <span class="built_in">window</span>,     <span class="comment">// 变量对象</span></span><br><span class="line">    ScopeChain: &#123;&#125;, <span class="comment">// 作用域链</span></span><br><span class="line">    <span class="keyword">this</span>: <span class="built_in">window</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>即每个函数上下文，都要有这三个重要属性：</p>
<ul>
<li>变量对象(Variable object, VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><h3 id="什么是变量对象"><a href="#什么是变量对象" class="headerlink" title="什么是变量对象"></a>什么是变量对象</h3><p>变量对象是与执行上下文的相关的数据作用域，存储了在上下文中定义的变量和函数声明。因为不同执行上下文的变量对象略有不同，所以变量对象一般分为全局上下文下的变量对象和函数上下文下的变量对象。</p>
<h3 id="变量对象-VO-的创建过程"><a href="#变量对象-VO-的创建过程" class="headerlink" title="变量对象(VO)的创建过程"></a>变量对象(VO)的创建过程</h3><p>变量对象的创建，属于执行上下文中的创建阶段，依次经过以下三个过程：</p>
<p>创建执行上下文有两个阶段：一个是创建阶段，一个是执行阶段。变量对象的创建，属于执行上下文中的创建阶段，会依次经过三个过程：</p>
<h4 id="1-为函数的形参赋值（函数上下文）"><a href="#1-为函数的形参赋值（函数上下文）" class="headerlink" title="1.为函数的形参赋值（函数上下文）"></a>1.为函数的形参赋值（函数上下文）</h4><p>在进入函数执行上下文时，会首先检查实参个数，接着对实参对象和形参进行赋值。如果没有实参，属性值设为undefined；当传入的实参数量小于形参数量，则会将没有被赋值的形参赋值为 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1 2 undefined</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>此时变量对象的结构为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">VO = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-函数声明"><a href="#2-函数声明" class="headerlink" title="2.函数声明"></a>2.函数声明</h4><p>遇到同名的函数时，后面函数会覆盖前面的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'先声明的'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'后声明的'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn); <span class="comment">//ƒ fn() &#123; console.log('后声明的'); &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-变量声明"><a href="#3-变量声明" class="headerlink" title="3.变量声明"></a>3.变量声明</h4><p>检查当前环境中通过变量声明(var)并赋值为undefined（变量提升产生的原因）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn); <span class="comment">// ƒ fn() &#123; console.log('后声明的');&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'先声明的'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'后声明的'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>由上面我们看出，当变量名称与函数名称同名时，会忽略此变量声明，即同名时，函数声明优先</p>
<p>js虽然单线程的语言，执行顺序为顺序执行，但JS引擎并不是一行一行地分析和执行程序，而是一段一段地分析执行。</p>
<p>让我们从JS引擎的角度理一理上述三个过程：<strong>函数提升和变量提升，是全局执行上下文做的准备工作；当执行函数时，又会创建一个执行上下文，做的是这个函数内部的准备工作；这就是JS引擎分析代码的”预编译阶段”，做完该工作才进入执行阶段。</strong></p>
<h3 id="全局上下文的变量对象"><a href="#全局上下文的变量对象" class="headerlink" title="全局上下文的变量对象"></a>全局上下文的变量对象</h3><p>在客户端 JavaScript 中，全局对象就是 Window 对象;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; <span class="comment">// 在全局上下文使用var定义变量a，作为全局变量的宿主</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>对于全局上下文中来说，变量对象就是全局对象，</p>
<h3 id="变量对象变为活动对象"><a href="#变量对象变为活动对象" class="headerlink" title="变量对象变为活动对象"></a>变量对象变为活动对象</h3><p>执行上下文的第二个阶段为执行阶段，此时会进行变量赋值，执行其他代码等工作，此时，变量对象变为活动对象(Active object, AO)。</p>
<blockquote>
<p>活动对象和变量对象其实是同个东西，只是规范概念上的差异。只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫活动对象。而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p>
</blockquote>
<p>所以明确，活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn); <span class="comment">// ƒ fn() &#123; console.log('后声明的');&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'先声明的'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'后声明的'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">20</span>;        </span><br><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>上述代码，真正开始执行是从第一行console.log(fn)。在此之前，变量对象VO是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建过程</span></span><br><span class="line">EC= &#123;</span><br><span class="line">  VO：&#123;&#125;, <span class="comment">// 创建变量对象</span></span><br><span class="line">  scopeChain: [&#123;VO&#125;], <span class="comment">// 作用域链</span></span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span> <span class="comment">// this绑定</span></span><br><span class="line">&#125;</span><br><span class="line">VO = &#123;</span><br><span class="line">  <span class="comment">// argument: &#123;&#125;, // 当前为全局上下文，不存在arguments</span></span><br><span class="line">  fn: reference to <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="comment">// 函数fn的引用地址</span></span><br><span class="line">  b: undefiend  <span class="comment">// 变量提升</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据变量对象创建的三个过程，</p>
<ol>
<li>首先是arguments对象的创建（全局上下文没有则忽略）</li>
<li>其次，是检查函数的声明。此时，函数fn声明了两次，则后一次的声明会覆盖上一次的声明。</li>
<li>最后，是检查变量的声明，先声明了变量b，将它赋值为 undefined；接着遇到fn的变量声明，由于fn已经被声明为一个函数，故忽略该变量声明。 </li>
</ol>
<p>到此，变量对象的创建阶段完成，接下来进行执行阶段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.执行console.log(fn);此时fn为声明的第二个函数，故输出结果：&quot;后声明的&quot;。</span><br><span class="line">2.执行console.log(b)，此时b已被赋值为undefined，故输出结果：&quot;undefined&quot;。</span><br><span class="line">3.执行赋值操作： b &#x3D; 10;</span><br><span class="line">4.执行console.log(b) ，故输出b为10。</span><br><span class="line">5.执行赋值操作： fn &#x3D; 20;</span><br><span class="line">6.执行console.log(fn) ，故输出fn为20。</span><br></pre></td></tr></table></figure>

<p>执行到最后一步时，执行上下文如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行阶段</span></span><br><span class="line">EC = &#123;</span><br><span class="line">  VO = &#123;&#125;;</span><br><span class="line">  scopeChain: &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// VO ---- AO</span></span><br><span class="line">AO = &#123;</span><br><span class="line">  argument: &#123;&#125;;</span><br><span class="line">  fn: <span class="number">20</span>;</span><br><span class="line">  b: <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上，就是变量对象在代码执行前及执行后的变化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>全局上下文的变量对象初始化是全局对象</p>
</li>
<li><p>函数上下文的变量对象初始化只包括 arguments 对象</p>
</li>
<li><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p>
</li>
<li><p>在代码执行阶段，会再次修改变量对象的属性值</p>
</li>
</ol>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之执行上下文和执行栈</title>
    <url>/2019/11/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
    <content><![CDATA[<p>都说想成为出色的JavaScript 开发者，就要深入学习 JavaScript 程序内部的执行机制，最近学了一遍JS的执行上下文和执行栈，以此作总结。</p>
<a id="more"></a>
<p>首先先来了解几个专业概念</p>
<ul>
<li><p>EC：函数执行环境（或执行上下文），Execution Context</p>
</li>
<li><p>ECS：执行环境栈，Execution Context Stack</p>
</li>
<li><p>VO：变量对象，Variable Object</p>
</li>
<li><p>AO：活动对象，Active Object</p>
</li>
<li><p>scope chain：作用域链</p>
</li>
</ul>
<h2 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h2><p>每次当控制器转到ECMAScript可执行代码的时候，它都是在执行上下文中运行，即是指当前执行环境中的变量、函数声明，参数，作用域链，this等信息。</p>
<h3 id="组成代码示例"><a href="#组成代码示例" class="headerlink" title="组成代码示例"></a>组成代码示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ExecutionContextObj = &#123;</span><br><span class="line">    VO: <span class="built_in">window</span>,     <span class="comment">// 变量对象</span></span><br><span class="line">    ScopeChain: &#123;&#125;, <span class="comment">// 作用域链</span></span><br><span class="line">    <span class="keyword">this</span>: <span class="built_in">window</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><p>JavaScript 中有三种执行上下文类型。</p>
<ol>
<li><p><strong>全局执行上下文</strong>——  这是默认上下文，浏览器中的全局对象就是window对象，任何不在函数内部的代码都在全局上下文中，this指向这个全局对象。</p>
</li>
<li><p><strong>函数执行上下文</strong> —— 当<strong>函数被调用时创建</strong>,会为该函数创建一个新的执行上下文，可以有任意个。 </p>
</li>
<li><p><strong>Eval 函数执行上下文</strong> ——<br>执行 eval函数内部的代码也有属于它的上下文，由于开发中是尽量避免或不用eval函数，故此不作讨论。</p>
</li>
</ol>
<h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也叫调用栈，被用来存储代码运行时创建的所有执行上下文。</p>
<blockquote>
<p>栈：一种数据结构，遵循后进先出的原则</p>
</blockquote>
<p>当 JavaScript 引擎第一次遇到脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p>
<p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn1被调用了 -- 创建了fn1的函数执行上下文，压入栈'</span>);</span><br><span class="line">  fn2(); </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn2执行完成，fn2的执行上下文会从栈中弹出'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn2被调用了 -- 创建了fn2的函数执行上下文，压入栈'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn1执行完成，fn2的执行上下文会从栈中弹出'</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fn1被调用了 -- 创建了fn1的函数执行上下文，压入栈</span><br><span class="line">fn2被调用了 -- 创建了fn2的函数执行上下文，压入栈</span><br><span class="line">fn2执行完成，fn2的执行上下文会从栈中弹出</span><br><span class="line">fn1执行完成，fn2的执行上下文会从栈中弹出</span><br></pre></td></tr></table></figure>
<p>上述代码的执行上下文栈：<br><img src="https://user-gold-cdn.xitu.io/2019/11/27/16ead7c041a4b415?w=1276&h=316&f=png&s=30716" alt=""></p>
<p>当上述代码在浏览器加载时，JavaScript引擎创建了一个全局执行上下文并把它压入栈中，当函数fn1()被调用时，JavaScript为该函数创建了一个函数执行上下文，并把它压入当前执行栈的顶部。</p>
<p>当fn1()函数内部调用fn2()函数时，JavaScript引擎同样创建了fn2()的函数执行上下文并压入栈的顶部。然后执行了fn2()函数后，fn2()函数会从当前栈（后进先出结构）弹出，并且按程序执行顺序继续执行fn1()函数，即此刻处于fn1的函数执行上下文。</p>
<p>当 fn1()函数执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。</p>
<h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>已经知道JavaScript 怎样管理执行上下文了，现在来了解JavaScript引擎是怎么创建执行上下文的。</p>
<p>创建执行上下文有两个阶段：</p>
<ol>
<li>创建阶段</li>
<li>执行阶段。</li>
</ol>
<p>在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：</p>
<ol>
<li>this绑定</li>
<li>创建(LexicalEnvironment)词法环境组件</li>
<li>创建(VariableEnvironment)变量环境组件</li>
</ol>
<p>执行上下文在概念可表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecutionContext &#x3D; &#123;</span><br><span class="line">  ThisBinding &#x3D; &lt;this value&gt;,</span><br><span class="line">  LexicalEnvironment &#x3D; &#123; ... &#125;,</span><br><span class="line">  VariableEnvironment &#x3D; &#123; ... &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-创建阶段"><a href="#1-创建阶段" class="headerlink" title="1. 创建阶段"></a>1. 创建阶段</h3><h4 id="this-绑定"><a href="#this-绑定" class="headerlink" title="this 绑定"></a>this 绑定</h4><p>在全局执行上下文中，this 的值指向全局对象。(在浏览器中，this引用window对象)</p>
<p>在函数执行上下文中，this的指向取决于函数是如何被调用的,在本篇暂不对this指向做详细讨论。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> win = obj.fn;</span><br><span class="line"></span><br><span class="line">obj.fn(); <span class="comment">//this指向obj</span></span><br><span class="line">win(); <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>

<h4 id="词法环境（Lexical-Environment）"><a href="#词法环境（Lexical-Environment）" class="headerlink" title="词法环境（Lexical Environment）"></a>词法环境（Lexical Environment）</h4><p>ES6官方文档把词法环境定义为：</p>
<blockquote>
<p>词法环境是用来定义 基于词法嵌套结构的ECMAScript代码内的标识符与变量值和函数值之间的关联关系 的一种规范类型。一个词法环境由环境记录（Environment Record）和一个可能为null的对外部词法环境的引用（outer）组成。一般来说，词法环境都与特定的ECMAScript代码语法结构相关联，例如函数、代码块、TryCatch中的Catch从句，并且每次执行这类代码时都会创建新的词法环境。</p>
</blockquote>
<p>可以理解为词法环境是一种包含标识符(变量/函数的名称)和变量(函数/原始值/数组对象等)映射的数据结构</p>
<h5 id="词法环境有两个组成部分"><a href="#词法环境有两个组成部分" class="headerlink" title="词法环境有两个组成部分"></a>词法环境有两个组成部分</h5><ol>
<li><p>声明式环境记录器：存储变量和函数声明的实际位置</p>
</li>
<li><p>对象环境记录器：可以访问其外部词法环境(作用域)</p>
</li>
</ol>
<h5 id="词法环境有两种类型"><a href="#词法环境有两种类型" class="headerlink" title="词法环境有两种类型"></a>词法环境有两种类型</h5><ol>
<li><p>全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</p>
</li>
<li><p>函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p>
</li>
</ol>
<h4 id="变量环境-VariableEnvironment"><a href="#变量环境-VariableEnvironment" class="headerlink" title="变量环境 (VariableEnvironment)"></a>变量环境 (VariableEnvironment)</h4><p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p>
<p>在ES6中，词法环境组件和变量环境组件之间的一个区别是前者用于存储函数声明和变量let和const绑定，而后者仅用于存储变量var绑定。</p>
<h3 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2.执行阶段"></a>2.执行阶段</h3><p>在此阶段，完成对所有这些变量的分配，最后执行代码。（在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined）</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之实现继承的7种方式</title>
    <url>/2019/11/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%847%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>有必要搞清楚JS实现继承的方式…</p>
<a id="more"></a>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>核心：<strong>将父类的实例作为子类的原型</strong></p>
<p>首先，要知道构造函数、原型和实例之间的关系：构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'父类的名字'</span>;</span><br><span class="line">&#125;   </span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'子类的名字'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果此时有Son的原型对象有方法或属性，下面Son.prototype = new Father()，由于原型重定向，原型上的方法和属性会丢失</span></span><br><span class="line">Son.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类的年龄'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father(); <span class="comment">// 核心:创建父类的实例，并将该实例赋值给子类的prototype</span></span><br><span class="line"></span><br><span class="line">Son.prototype.getSonName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类的方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line">son.getFatherName(); <span class="comment">// 父类的方法</span></span><br><span class="line">Son.prototype.__proto__.getFatherName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 缺点：如果有多个实例对其父类原型，则会互相影响</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类改变父类的方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line">son.getFatherName(); <span class="comment">// 子类改变父类的方法</span></span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ol>
<li><p>父类使用this声明的属性(私有属性和公有属性)被所有实例共享,在多个实例之间对引用类型数据操作会互相影响。</p>
</li>
<li><p>创建子类实例时，无法向父类构造函数传参。</p>
</li>
</ol>
<h2 id="借用构造函数继承-call"><a href="#借用构造函数继承-call" class="headerlink" title="借用构造函数继承(call)"></a>借用构造函数继承(call)</h2><p>核心：<strong>使用父类的构造函数来增强子类实例</strong>，即复制父类的实例属性给子类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;  </span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>,name, age); <span class="comment">// 继承自Father</span></span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>, <span class="number">22</span>, <span class="string">'前端开发'</span>);</span><br><span class="line"><span class="comment">//son.getFatherName(); // Uncaught TypeError: son.getFatherName is not a function</span></span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ol>
<li>可以向父类传递参数,而且解决了原型链继承中：父类属性使用this声明的属性会在所有实例共享的问题。</li>
</ol>
<p>缺点：</p>
<ol>
<li>只能继承父类通过this声明的属性/方法，不能继承父类prototype上的属性/方法。</li>
<li>每次子类实例化都要执行父类函数，重新声明父类this里所定义的方法，因此父类方法无法复用。</li>
</ol>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>核心：<strong>组合上述两种方法，用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sex = <span class="string">'man'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>,name,age); <span class="comment">// 第二次调用:创建子类型实例的时候</span></span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father(); <span class="comment">// 第一次调用:设置子类型实例的原型的时候</span></span><br><span class="line">Son.prototype.constructor = Son; <span class="comment">// prototype构造器指回自己 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>, <span class="number">22</span>, <span class="string">'前端开发'</span>);</span><br><span class="line">son.getFatherName();</span><br><span class="line"><span class="built_in">console</span>.log(son)</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/11/20/16e89812367319c7?w=517&h=227&f=png&s=19707" alt=""></p>
<p>优点：</p>
<ol>
<li>可以继承父类原型上的属性，可以传参，可复用。</li>
<li>每个新子类对象实例引入的构造函数属性是私有的。</li>
</ol>
<p>缺点：</p>
<ol>
<li>两次调用父类函数(new fatherFn()和fatherFn.call(this))，造成一定的性能损耗。</li>
<li>在使用子类创建实例对象时，其原型中会存在两份相同属性/方法的问题。</li>
</ol>
<p>拓展：</p>
<h3 id="constructor的作用"><a href="#constructor的作用" class="headerlink" title="constructor的作用"></a>constructor的作用</h3><p><strong>返回创建实例对象的Object构造函数的引用</strong>。</p>
<blockquote>
<p>当我们只有实例对象没有构造函数的引用时：<br>某些场景下，我们对实例对象经过多轮导入导出，我们不知道实例是从哪个函数中构造出来或者追踪实例的构造函数，较为艰难。(它主要防止一种情况下出错，就是你显式地去使用构造函数。比如，我并不知道instance是由哪个函数实例化出来的，但是我想clone一个，这时就可以这样——&gt;instance.constructor)<br>这个时候就可以通过实例对象的constructor属性来得到构造函数的引用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> sonFn() <span class="comment">// 实例化子类</span></span><br><span class="line"><span class="keyword">export</span> instance;</span><br><span class="line"><span class="comment">// 多轮导入+导出，导致sonFn追踪非常麻烦，或者不想在文件中再引入sonFn</span></span><br><span class="line"><span class="keyword">let</span>  fn = instance.constructor</span><br></pre></td></tr></table></figure>

<p>因此每次<strong>重写</strong>函数的prototype都应该修正一下constructor的指向，以保持读取constructor指向的一致性</p>
<h2 id="原型式继承（Object-create-）"><a href="#原型式继承（Object-create-）" class="headerlink" title="原型式继承（Object.create()）"></a>原型式继承（Object.create()）</h2><p>核心：利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Object.create() 的实现原理 */</span></span><br><span class="line"><span class="comment">// cloneObject()对传入其中的对象执行了一次浅拷贝，将构造函数F的原型直接指向传入的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = obj; <span class="comment">// 将传进来obj对象作为空函数的prototype</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F(); <span class="comment">// 此对象的原型为被继承的对象, 通过原型链查找可以拿到被继承对象的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> father = &#123;</span><br><span class="line">    name: <span class="string">'jacky'</span>,</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">    courses: [<span class="string">'前端'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var son1 = Object.create(father); // 效果一样</span></span><br><span class="line"><span class="keyword">var</span> son1 = cloneObject(father);</span><br><span class="line">son1.courses.push(<span class="string">'后端'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son2 = cloneObject(father);</span><br><span class="line">son2.courses.push(<span class="string">'全栈'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(father.courses); <span class="comment">//  ["前端", "后端", "全栈"]</span></span><br></pre></td></tr></table></figure>
<p>优点：</p>
<p>从已有对象衍生新对象，不需要创建自定义类型</p>
<p>缺点：</p>
<p>与原型链继承一样。多个实例共享被继承对象的属性，存在篡改的可能；也无法传参。</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>核心：<strong>在原型式继承的基础上，创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象(增加了一些新的方法和属性)，最后返回对象。</strong></p>
<p>使用场景：专门为对象来做某种固定方式的增强。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(obj);</span><br><span class="line">    clone.skill = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'run'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = &#123;</span><br><span class="line">    eat: <span class="string">'food'</span>,</span><br><span class="line">    drink: <span class="string">'water'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = createAnother(animal);</span><br><span class="line">dog.skill();</span><br></pre></td></tr></table></figure>

<p>优点：没有创建自定义类型，因为只是套了个壳子增加特定属性/方法返回对象，以达到增强对象的目的</p>
<p>缺点：</p>
<p>同原型式继承：原型链继承多个实例的引用类型属性指向相同，存在篡改的可能，也无法传递参数</p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>核心：结合借用构造函数传递参数和寄生模式实现继承</p>
<ol>
<li>通过借用构造函数(call)来继承父类this声明的属性/方法</li>
<li>通过原型链来继承方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>,name,age); <span class="comment">// 借用构造继承: 继承父类通过this声明属性和方法至子类实例的属性上</span></span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄生式继承：封装了son.prototype对象原型式继承father.prototype的过程，并且增强了传入的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">son,father</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(father.prototype); <span class="comment">// 原型式继承：浅拷贝father.prototype对象</span></span><br><span class="line">    clone.constructor = son;  <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">    son.prototype = clone; <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Son,Father); <span class="comment">// 将父类原型指向子类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">Son.prototype.getSonName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>,<span class="number">22</span>,<span class="string">'前端开发'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son);</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/11/23/16e97782ff645ca0?w=361&h=182&f=png&s=24333" alt=""></p>
<ul>
<li>寄生组合式继承相对于组合继承有如下优点：</li>
</ul>
<ol>
<li>只调用一次父类Father构造函数。不必为了指定子类的原型而调用构造函数，而是间接的让 Son.prototype 访问到 Father.prototype。</li>
<li>避免在子类prototype上创建不必要多余的属性。<br>使用原型式继承父类的prototype，保持了原型链上下文不变, instanceof 和isPrototypeOf()也能正常使用。</li>
<li>寄生组合式继承是最成熟的继承方法, 也是现在最常用的继承方法，众多JS库采用的继承方案也是它。</li>
</ol>
<p>缺点：</p>
<p>硬要说的话，就是给子类原型添加属性和方法的时候，一定要放在inheritPrototype()方法之后</p>
<h2 id="ES6-extends继承（最优方式）"><a href="#ES6-extends继承（最优方式）" class="headerlink" title="ES6 extends继承（最优方式）"></a>ES6 extends继承（最优方式）</h2><p>核心： 类之间通过extends关键字实现继承，清晰方便。 class 仅仅是一个语法糖，它的核心思想仍然是寄生组合式继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  skill() &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'父类的技能'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, job)&#123;</span><br><span class="line">	<span class="keyword">super</span>(name, age); <span class="comment">// 调用父类的constructor,只有调用super之后，才可以使用this关键字</span></span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.job);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>,<span class="number">22</span>,<span class="string">'前端开发'</span>);</span><br><span class="line">son.skill(); <span class="comment">// 父类的技能</span></span><br><span class="line">son.getInfo(); <span class="comment">// jacky 22 前端开发</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</li>
</ul>
<blockquote>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p>
</blockquote>
<h2 id="ES5继承与ES6继承的区别"><a href="#ES5继承与ES6继承的区别" class="headerlink" title="ES5继承与ES6继承的区别"></a>ES5继承与ES6继承的区别</h2><ol>
<li>ES5的继承实质上是先创建子类的实例对象，再将父类的方法添加到this上( Father.call(this) )。</li>
<li>ES6的继承是先创建父类的实例对象this，再用子类的构造函数修改this。</li>
<li>因为子类没有自己的this对象，所以必须先调用父类的super()方法。</li>
</ol>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>sessionStorage、localStorage用法总结</title>
    <url>/2019/11/03/sessionStorage%E3%80%81localStorage%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>在工作中使用sessionStorage存储数据时，发现sessionStorage无法直接存储数组和对象，如存入对象则显示为”[object Object]”，对此作下记录，重新温习sessionStorage和localStorage</p>
<a id="more"></a>

<p>html5 中的 web Storage 包括了两种存储方式：sessionStorage 和 localStorage</p>
<h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><p>存储大小为5MB，都保存在客户端，不与服务器进行交互通信，有相同的Web API</p>
<h2 id="sessionStorage、localStorage区别"><a href="#sessionStorage、localStorage区别" class="headerlink" title="sessionStorage、localStorage区别"></a>sessionStorage、localStorage区别</h2><p>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</p>
<p>sessionStorage 数据在当前浏览器窗口关闭后自动删除。</p>
<p>因此<strong>sessionStorage 和 localStorage 的主要区别在于他们存储数据的生命周期</strong>，sessionStorage 存储的数据的生命周期是一个会话，而 localStorage存储的数据的生命周期是永久，除非主动删除数据，否则永远不会过期</p>
<h2 id="Web-Storage-API"><a href="#Web-Storage-API" class="headerlink" title="Web Storage API"></a>Web Storage API</h2><p>localStorage 和 sessionStorage 有着统一的API接口，下面以sessionStorage为例介绍一下 API 接口使用方法</p>
<h3 id="添加键值对"><a href="#添加键值对" class="headerlink" title="添加键值对"></a>添加键值对</h3><p><strong>setItem(key,value)：为指定key值设置一个对应的value值</strong></p>
<p>除了使用setItem方法，还可以使用sessionStorage.key = value或者sessionStorage[‘key’] = value这两种形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把name值存储到name的键上</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'name'</span>, <span class="string">'jacky'</span>); <span class="comment">// 法1 </span></span><br><span class="line"><span class="comment">// sessionStorage.name = 'jacky'; // 法2 </span></span><br><span class="line"><span class="comment">// sessionStorage['name'] = 'jacky'; // 法3</span></span><br></pre></td></tr></table></figure>
<p><strong>添加数组和对象</strong></p>
<p>需要注意的是key和value值必须是<strong>字符串形式</strong>的，如果不是字符串，会调用它们相应的toString()方法来转换成字符串再存储。</p>
<p>所以要存储数组或对象时，应先转换成字符串格式（如JSON格式）再进行存储，使用<strong>JSON.stringify(obj)方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'jacky'</span>, </span><br><span class="line">    age: <span class="number">22</span></span><br><span class="line">&#125;;</span><br><span class="line">sessionStorage[<span class="string">'person'</span>] = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line"><span class="comment">//sessionStorage['person'] = obj; 不能这样存储，这样存进去结果是"[object Object]"</span></span><br></pre></td></tr></table></figure>

<p>存进去之后则为字符串格式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;"</span>name<span class="string">":"</span>jacky<span class="string">","</span>age<span class="string">":22&#125;"</span></span><br></pre></td></tr></table></figure>

<p>需要拿出来使用的时候则使用<strong>JSON.parse()方法</strong>将JSON字符串转换为对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="built_in">JSON</span>.parse(sessionStorage[<span class="string">'person'</span>])</span><br></pre></td></tr></table></figure>
<p>同理，数组也是这个用这个方法进行存储。</p>
<h3 id="getItem（key）：根据指定的key值获取对应的value值"><a href="#getItem（key）：根据指定的key值获取对应的value值" class="headerlink" title="getItem（key）：根据指定的key值获取对应的value值"></a>getItem（key）：根据指定的key值获取对应的value值</h3><p>和setItem一样，getItem也有两种等效形式,value = sessionStorage.key和value = sessionStorage[‘key’]。获取到的 value 值是字符串类型，如果需要其他类型，需要自己做类型转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取存储到 name 的键上的值</span></span><br><span class="line"><span class="keyword">var</span> name = sessionStorage.getItem(<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">// var name = sessionStorage.name;</span></span><br><span class="line"><span class="comment">// var name = sessionStorage['name'];</span></span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### removeItem（key）：删除指定的key值对应的value值</span></span><br><span class="line"><span class="string">注意localStorage 没有数据过期的概念，所有数据如果失效了，需要开发者手动删除。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="keyword">var</span> name = sessionStorage.getItem(<span class="string">'name'</span>); <span class="comment">// "jacky"</span></span><br><span class="line">    sessionStorage.removeItem(<span class="string">'name'</span>);</span><br><span class="line">    name = sessionStorage.getItem(<span class="string">'name'</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h3 id="clear-：删除所有存储的内容"><a href="#clear-：删除所有存储的内容" class="headerlink" title="clear()：删除所有存储的内容"></a>clear()：删除所有存储的内容</h3><p>它和removeItem不同的地方是removeItem删除的是某一项，而clear是删除所有。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清除 localStorage</span></span><br><span class="line">sessionStorage.clear();</span><br><span class="line"><span class="keyword">var</span> len = sessionStorage.length; <span class="comment">// 0</span></span><br><span class="line"><span class="comment">//length属性用于获取 sessionStorage 中键值对的数量。</span></span><br></pre></td></tr></table></figure>

<h3 id="key-index-：在指定的数字位置获取该位置的名字"><a href="#key-index-：在指定的数字位置获取该位置的名字" class="headerlink" title="key(index)：在指定的数字位置获取该位置的名字"></a>key(index)：在指定的数字位置获取该位置的名字</h3><p>需要注意的是赋值早的键值对应的索引值大，赋值完的键值对应的索引小,key方法可用于遍历 sessionStorage 存储的键值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">'name'</span>,<span class="string">'jacky'</span>);</span><br><span class="line"><span class="keyword">var</span> key = sessionStorage.key(<span class="number">0</span>); <span class="comment">// 'name'</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'age'</span>, <span class="number">10</span>);</span><br><span class="line">key = sessionStorage.key(<span class="number">0</span>); <span class="comment">// 'age'</span></span><br><span class="line">key = sessionStorage.key(<span class="number">1</span>); <span class="comment">// 'name'</span></span><br></pre></td></tr></table></figure>

<h2 id="两者应用场景"><a href="#两者应用场景" class="headerlink" title="两者应用场景"></a>两者应用场景</h2><h3 id="sessionStorage应用场景"><a href="#sessionStorage应用场景" class="headerlink" title="sessionStorage应用场景"></a>sessionStorage应用场景</h3><p>进行页面传值</p>
<h3 id="localStorage应用场景"><a href="#localStorage应用场景" class="headerlink" title="localStorage应用场景"></a>localStorage应用场景</h3><ol>
<li>适合长期保存在本地的数据</li>
<li>可以用于存储该浏览器对该页面的访问次数</li>
</ol>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之获取数组中的最大值方法（this,apply）</title>
    <url>/2019/10/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E6%96%B9%E6%B3%95%EF%BC%88this-apply%EF%BC%89/</url>
    <content><![CDATA[<p>1.排序法 2.假设法 3.基于Math.max与apply 4.ES6展开运算符</p>
<a id="more"></a>
<h2 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h2><p>思路：给数组先排序(由大到小排序),第一项就是最大值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> max1 = arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b-a;</span><br><span class="line">&#125;)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(max1);</span><br></pre></td></tr></table></figure>
<h2 id="假设法"><a href="#假设法" class="headerlink" title="假设法"></a>假设法</h2><p>思路：假设第一个值是最大值,依次遍历数组中后面的每一项,和假设的值进行比较,如果比假设的值要大,把当前项赋值给MAX…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> max2 = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = arr[i];</span><br><span class="line">    item &gt; max2 ? max2 = item : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(max2);</span><br></pre></td></tr></table></figure>
<h2 id="基于Math-max与apply"><a href="#基于Math-max与apply" class="headerlink" title="基于Math.max与apply"></a>基于Math.max与apply</h2><p>思路：基于基于Math.max完成和apply特性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span> ,<span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr));</span><br></pre></td></tr></table></figure>
<p>这个是要重点理解的一个方案，call,apply,bind常常会被放一起比较<br>首先，call，apply，bind这三个方法其实都是继承自Function.prototype中的，属于实例方法。<br>三个方法的作用，都是<strong>改变this的指向</strong>，只是用法稍微有些区别</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>什么是this</p>
<p><strong>this 既不指向函数自身，也不指函数的词法作用域</strong>。它在函数定义的时候是确定不了的,在函数被调用时才发生的绑定，也就是说<code>this具体指向什么，取决于你是怎么调用的函数</code>。</p>
<p>怎么判断this</p>
<blockquote>
<p>1.给当前元素的某个事件绑定方法, 当事件触发方法执行的时候，方法中的THIS是当前操作的元素对象<br>2.普通函数执行，函数中的THIS取决于执行的主体，谁执行的，THIS就是谁（执行主体：方法执行，看方法名前面是否有“点”，有的话，点前面是谁this就是谁，没有this是window）<br>下面看个例子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    myFunction()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(); <span class="comment">// true</span></span><br><span class="line">obj.myFunction(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>对this有了大致了解后，再来看call方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'windowName'</span>;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'objName'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name:<span class="string">'obj1Name'</span></span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">//windowName</span></span><br><span class="line">fn.call(obj); <span class="comment">// objName：虽然是fn调用，但call改变了this指向，this的指向是obj,故obj.name的值为objName</span></span><br><span class="line">fn.call(obj1); <span class="comment">// obj1Name</span></span><br></pre></td></tr></table></figure>
<p>call方法执行的时候，内部处理了一些事情。首先把要操作函数中的this关键字变为call方法第一个传递的实参值,把call方法第二个及第二个以后的实参获取到，把要操作的函数执行，并且把第二个以后的传递进来的实参传给函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line">fn.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>CALL中的细节</p>
<blockquote>
<p>1.非严格模式下，如果参数不传，或者第一个传递的是null/undefined，this都指向window<br>2.在严格模式下，第一个参数是谁，this就指向谁（包括null/undefined），不传this是undefined<br>在上述代码中，如果用apply，则是</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line">fn.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>apply：和call基本上一模一样，唯一区别在于<strong>传参方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">fn.apply(obj,[<span class="number">10</span>,<span class="number">20</span>]) <span class="comment">//APPLY把需要传递给FN的参数放到一个数组（或者类数组）中传递进去，虽然写的是一个数组，但是也相当于给FN一个个的传递</span></span><br></pre></td></tr></table></figure>
<p>bind：语法和call一模一样，唯一的区别在于立即执行还是等待执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">10</span>,<span class="number">20</span>) 改变FN中的THIS,并且把FN立即执行</span><br><span class="line">fn.bind(obj,<span class="number">10</span>,<span class="number">20</span>) 改变FN中的THIS,此时的FN并没有执行（不兼容IE6~<span class="number">8</span>）</span><br></pre></td></tr></table></figure>
<p>bind调用之后是返回原函数，需要再调用一次才行</p>
<hr>
<p>回到原题，求数组最大值<br>Math.max(arr)这样肯定是报错的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(ary)); <span class="comment">// =&gt; NaN </span></span><br><span class="line"><span class="comment">// =&gt; Math.max是获取一堆数中的最大值,需要我们把比较的数,一个个的传递给这个方法 //=&gt;Math.max(12,13,14...) =&gt;Math.max([12,13,14...])这样只是传递一个值</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr);</span><br><span class="line"><span class="comment">// =&gt; 利用了apply的一个特征：虽然放的是一个数组，但是执行方法的时候，也是把数组中的每一项一个个的传递给函数</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6展开运算符"><a href="#ES6展开运算符" class="headerlink" title="ES6展开运算符"></a>ES6展开运算符</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...arr));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之由一道题来思考闭包</title>
    <url>/2019/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E6%9D%A5%E6%80%9D%E8%80%83%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>从一道很经典的闭包问题说起…</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>闭包就是指有权访问另一个函数作用域中的变量的函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;点击li标签弹出对应数字&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">0</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;1&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">2</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;3&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var list = document.getElementsByTagName('li');</span></span><br><span class="line"><span class="regexp">    for(var i = 0;i &lt; list.length;i++)&#123;</span></span><br><span class="line"><span class="regexp">     list[i].onclick = function()&#123;</span></span><br><span class="line"><span class="regexp">         alert(i);</span></span><br><span class="line"><span class="regexp">     &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>如上题，最为常见的一个例子，这里解释由这道题引出的js知识点，如上我们知道在浏览器运行无论点击哪个li标签都是弹出3,首先来理解为什么会弹出3。</p>
<p>程序通过for循环给每个li标签绑定了事件，然后通过点击li标签触发方法，即执行alert(i)。js中有个作用域链查找机制，首先会在onclick返回的函数作用域查找i变量的值，找不到则往上一层找i，上一层即是window全局作用域，即找到全局变量i，即for循环定义的i。</p>
<p>注意for循环的i并不是私有变量，而是全局变量。</p>
<blockquote>
<p>js中所有的事件绑定都是异步编程（当前这件事件没有彻底完成，不再等待，继续执行下面的任务）</p>
</blockquote>
<p>当绑定onclick事件后，不需要等待执行，继续执行下一个循环任务，所以当我们点击执行方法的时候，循环早已结束,即是最后i=3。故程序执行后全局变量i被循环执行后赋值为最终的3，所以当点击的时候，外层循环已经结束，页面加载完成预示着js代码都已经执行完成，即执行alert(i)时，由于i不是私有变量，便会找到上一级window作用域全局的i，所以无论点击哪个li标签都是弹出3</p>
<h2 id="为什么要用闭包"><a href="#为什么要用闭包" class="headerlink" title="为什么要用闭包"></a>为什么要用闭包</h2><p>那么，解决这个问题的缘由，在于i每次在页面加载完就赋值为3，alert(i)的时候总是找到全局变量i。在ES5传统语法中，能形成作用域的只有全局和函数，现在每次i找的都是全局，那么要保住i的值只能在全局和onclick返回函数的作用域中间再加一个小的私有作用域，即是大的作用域外再加一个小的作用域，这样i往上一层作用域查找时，就会获取小作用域的i的值，而不会去获取全局变量的i值。</p>
<p>这个思路解决问题就需要引入闭包，在这个理解上闭包是指函数变量可以保存在函数作用域内，因此看起来是函数将变量“包裹”了起来。于是，代码改成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; list.length;i++)&#123;</span><br><span class="line">    list[i].onclick = (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;<span class="comment">//形参n</span></span><br><span class="line">        <span class="comment">//=&gt;让自执行函数执行,把执行的返回值(return)赋值给onclick</span></span><br><span class="line">        <span class="comment">//（此处onclick绑定的是返回的小函数，点击的时候执行的是小函数）,</span></span><br><span class="line">        <span class="comment">// 自执行函数在给事件赋值的时候就已经执行了</span></span><br><span class="line">        <span class="comment">// 自执行函数形成一个私有作用域</span></span><br><span class="line">        <span class="keyword">var</span> i = n;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);<span class="comment">//传入实参i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环三次，形成三个不销毁的私有作用域（自执行函数执行），而每一个不销毁的栈内存中都存储了一个私有变量i，而这个值分别是每一次执行传递进来的全局i的值（也就是：第一个不销毁的作用域存储的是0，第二个是1，第三个是2，第四个是3）；当点击的时候，执行返回的小函数，遇到变量i，向它自己的上级作用域查找。这样就达到了我们需要的效果，这种闭包实现，也可以有另一种写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*原理同法二都是形成三个不销毁的私有作用域,分别存储需要的索引值*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; list.length;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        list[n].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(n);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于初始的代码，如果说为什么不能实现，那原因就可归纳为：</p>
<blockquote>
</blockquote>
<ol>
<li>执行方法,形成一个私有的栈内存,遇到变量i,i不是私有变量,向上一级作用域查找（上级作用域window）</li>
<li>所有的事件绑定都是异步编程,绑定事件后,不需要等待执行,继续执行下一个循环任务,所以当我们点击执行方法的时候,循环早已结束（让全局的i等于循环最后的结果3）</li>
</ol>
<h2 id="ES6语法的解决方式"><a href="#ES6语法的解决方式" class="headerlink" title="ES6语法的解决方式"></a>ES6语法的解决方式</h2><p>在ES6中，解决这种问题只需要一个let变量，ES6中才有块级作用域（类似于私有作用域）的概念</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; list.length;i++)&#123;</span><br><span class="line">    list[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包对内存的影响"><a href="#闭包对内存的影响" class="headerlink" title="闭包对内存的影响"></a>闭包对内存的影响</h2><p>从上面可知，每次for都会形成一个私有作用域，每个都里面保存的变量i的值，程序运行后这些作用域并不会被销毁，所以由于闭包会携带包含它的函数的作用域，所以会比其他函数占用更多内容，过度使用闭包会导致内存占用过多。</p>
<p>在真实项目中为了保证JS的性能（堆栈内存的性能优化），应该尽可能的减少闭包的使用（不销毁的堆栈内存是耗性能的）</p>
<h2 id="堆内存和栈内存的释放"><a href="#堆内存和栈内存的释放" class="headerlink" title="堆内存和栈内存的释放"></a>堆内存和栈内存的释放</h2><p>这里又要提到一个知识点，js中存储方式的分类：</p>
<blockquote>
<p>JS中的内存分为堆内存和栈内存<br>堆内存：存储引用数据类型值（对象：键值对  函数：代码字符串）<br>栈内存：提供JS代码执行的环境和存储基本类型值</p>
</blockquote>
<p>粗暴理解var定义的变量存在栈内存中，如for循环中的i是存在栈内存中的；而函数，它是存在堆内存中</p>
<p><strong>一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉（在栈内存中存储的值也都会释放掉）</strong>，那为什么闭包的栈内存不会被自动释放掉，在js中也有特殊不被销毁的情况：</p>
<blockquote>
<p>1.函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用了，此时栈内存不能释放（一旦释放外面找不到原有的内容了）<br>2.全局栈内存只有在页面关闭的时候才会被释放掉</p>
</blockquote>
<p>闭包则是属于第一种情况，onclick函数形成的栈内存，被小函数【alert(i)，i找到onclick作用域获取i值】占用了onclick函数的栈内存（变量i是存在栈内存中），故栈内存不能被释放，所以才会说闭包过度使用容易导致内存被占用过多，因为不会自动释放内存。</p>
<p><strong>堆内存的释放</strong></p>
<blockquote>
<p>堆内存让所有引用堆内存空间地址的变量赋值为null即可（没有变量占用这个堆内存了，浏览器会在空闲的时候把它释放掉）</p>
</blockquote>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之变量提升</title>
    <url>/2019/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>原理：JS引擎的工作方式是先解析代码，获取所有被声明的变量；然后在运行。JS代码自上而下执行之前，浏览器首先会把所有带”VAR”/“FUNCTION”关键词的进行提前”声明”或者”定义”，这种预先处理机制称之为 “变量提升”。</p>
<a id="more"></a>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">//undefined undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>,</span><br><span class="line">    b = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b);<span class="comment">//=&gt;undefined 12</span></span><br><span class="line">    <span class="keyword">var</span> a = b = <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b);<span class="comment">//=&gt;13 13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">//=&gt;12 13</span></span><br></pre></td></tr></table></figure>

<ul>
<li>undefined undefined：首先输出这个结果是因为变量提升，即前三行变成<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//undefined undefined</span></span><br><span class="line">a = <span class="number">12</span>;</span><br><span class="line">b = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li>
<li>undefined 12：接下来执行函数fn（fn一开始也被执行了变量提升,只不过函数中存储的都是字符串而已），对fn内部进行分析，即内部代码变成：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//undefined 12</span></span><br><span class="line">a = <span class="number">13</span>;</span><br><span class="line">b = <span class="number">13</span>; <span class="comment">//不加var的本质是WIN的属性，即相当于window.b = 13; </span></span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//13 13</span></span><br></pre></td></tr></table></figure>
<p>一开始b在fn内部找不到，便会开始往上一层找，找到了全局的b，于是b输出12。</p>
<p>当经过var a = b = 13; 后，b被赋值为13，于是输出先从函数内部找b，找到了b=13，第二次输出b为13。（！同时，最先定义的全局变量b = 12也被赋值为13，故最后的b也等于13）</p>
<blockquote>
<p>私有作用域中带var和不带var的区别：</p>
<ol>
<li>带var的在私有作用于变量提升阶段，都声明为私有变量，和外界没有任何的关系</li>
<li>不带var不是私有变量，会向它的上级作用于查找，一直找到window为止（这种查找机制叫做：“作用域链”），也就是在私有作用域中操作的这个非私有变量，是一直操作别人的</li>
</ol>
</blockquote>
<h2 id="只对等号左边进行变量提升"><a href="#只对等号左边进行变量提升" class="headerlink" title="只对等号左边进行变量提升"></a>只对等号左边进行变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sum();</span><br><span class="line">fn();<span class="comment">// Uncaught TypeError: fn is not a function </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;匿名函数之函数表达式</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn'</span>);</span><br><span class="line">&#125;<span class="comment">//=&gt;代码执行到此处会把函数值赋值给fn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;普通的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sum'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件判断下的变量提升"><a href="#条件判断下的变量提升" class="headerlink" title="条件判断下的变量提升"></a>条件判断下的变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在当前作用域下，不管条件是否成立都要进行变量提升</span></span><br><span class="line"><span class="comment"> *   =&gt;带VAR的还是只声明</span></span><br><span class="line"><span class="comment"> *   =&gt;带FUNCTION的在老版本浏览器渲染机制下，声明和定义都处理，但是为了迎合ES6中的块级作用 </span></span><br><span class="line"><span class="comment"> *     域，新版浏览器对于函数（在条件判断中的函数），</span></span><br><span class="line"><span class="comment"> *     不管条件是否成立，都只是先声明，没有定义，类似于var</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> === <span class="number">2</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="重名问题的处理"><a href="#重名问题的处理" class="headerlink" title="重名问题的处理"></a>重名问题的处理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn();<span class="comment">//=&gt;4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line">fn();<span class="comment">//=&gt;4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;</span><br><span class="line">fn();<span class="comment">//=&gt;4</span></span><br><span class="line"><span class="keyword">var</span> fn=<span class="number">100</span>;<span class="comment">//=&gt;带VAR的在提升阶段只把声明处理了,赋值操作没有处理,所以在代码执行的时候需要完成赋值 FN=100</span></span><br><span class="line">fn();<span class="comment">//=&gt;100() Uncaught TypeError: fn is not a function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>);&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>);&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p>带VAR和FUNCTION关键字声明相同的名字，这种也算是重名了（其实是一个FN，只是存储值的类型不一样）<br>关于重名的处理：如果名字重复了，不会重新的声明，但是会重新的定义（重新赋值）[不管是变量提升还是代码执行阶段皆是如此]</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
