<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>完全搞懂 BFC</title>
    <url>/2020/07/05/%E5%AE%8C%E5%85%A8%E6%90%9E%E6%87%82-BFC/</url>
    <content><![CDATA[<p>BFC 是 CSS 中一个比较重要的概念，也是面试经常考查的点…</p>
<a id="more"></a>

<h2 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC"></a>什么是 BFC</h2><p>BFC 全称是 Block Formatting Context，即块格式化上下文。</p>
<p>除了 BFC，还有：</p>
<ul>
<li>IFC（行级格式化上下文）- inline 内联</li>
<li>GFC（网格布局格式化上下文）- <code>display: grid</code></li>
<li>FFC（自适应格式化上下文）- <code>display: flex</code>或<code>display: inline-flex</code></li>
</ul>
<blockquote>
<p>注意：同一个元素不能同时存在于两个 BFC 中</p>
</blockquote>
<p>它是 Web 页面的可视 CSS 渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。怎么理解呢？实际就是说 BFC 是一个渲染区域，并且有自己的一套渲染规则，使其内部布局的元素具有一些特性。</p>
<p><strong>BFC 提供一个独立的布局环境，BFC 内部的元素布局与外部互不影响。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/17318faf333483aa?w=798&h=317&f=png&s=23237" alt=""></p>
<h2 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h2><p>CSS 属性值 display 为 block，list-item，table 的元素。</p>
<p>块级盒具有以下特性：</p>
<ul>
<li>CSS 属性值 display 为 block，list-item，table 时，它就是块级元素</li>
<li>布局上，块级盒呈现为竖直排列的块</li>
<li>每个块级盒都会参与 BFC 的创建</li>
<li>每个块级元素都会至少生成一个块级盒，称为主块级盒；一些元素可能会生成额外的块级盒，比如 <code>&lt;li&gt;</code>，用来存放项目符号</li>
</ul>
<h2 id="创建-BFC"><a href="#创建-BFC" class="headerlink" title="创建 BFC"></a>创建 BFC</h2><p>以下元素会创建 BFC</p>
<ul>
<li>根元素（<code>&lt;html&gt;</code>）</li>
<li>浮动元素（<code>float</code>不为<code>none</code>）</li>
<li>绝对定位元素（<code>position</code>为<code>absolute</code>或<code>fixed</code>）</li>
<li>表格的标题和单元格（<code>display</code> 为 <code>table-caption</code>，<code>table-cell</code>）</li>
<li>匿名表格单元格元素（<code>display</code> 为 <code>table</code> 或 <code>inline-table</code>）</li>
<li>行内块元素（<code>display</code> 为 <code>inline-block</code>）</li>
<li><code>overflow</code> 的值不为 <code>visible</code> 的元素</li>
<li>弹性元素（<code>display</code> 为 <code>flex</code> 或 <code>inline-flex</code> 的元素的直接子元素）</li>
<li>网格元素（<code>display</code> 为 <code>grid</code> 或 <code>inline-grid</code> 的元素的直接子元素）</li>
</ul>
<p>以上是 CSS2.1 规范定义的 BFC 触发方式，在最新的 CSS3 规范中，弹性元素和网格元素会创建 F(Flex)FC 和 G(Grid)FC。</p>
<h2 id="BFC-的特性"><a href="#BFC-的特性" class="headerlink" title="BFC 的特性"></a>BFC 的特性</h2><ul>
<li>BFC 是页面上的一个独立容器，容器里面的子元素不会影响外面的元素。</li>
<li>BFC 内部的块级盒会在垂直方向上一个接一个排列</li>
<li>同一 BFC 下的相邻块级元素可能发生外边距折叠，创建新的 BFC 可以避免外边距折叠</li>
<li>每个元素的外边距盒（margin box）的左边与包含块边框盒（border box）的左边相接触（从右向左的格式的话，则相反），即使存在浮动</li>
<li>浮动盒的区域不会和 BFC 重叠</li>
<li>计算 BFC 的高度时，浮动元素也会参与计算</li>
</ul>
<p>如果不太理解的，在下面 BFC 的应用我会提及。</p>
<h2 id="BFC-的应用"><a href="#BFC-的应用" class="headerlink" title="BFC 的应用"></a>BFC 的应用</h2><h3 id="自适应两列布局"><a href="#自适应两列布局" class="headerlink" title="自适应两列布局"></a>自适应两列布局</h3><p>左列浮动（定宽或不定宽都可以），给右列开启 BFC。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* html 代码 *&#x2F;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;left&quot;&gt;浮动元素，无固定宽度&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;right&quot;&gt;自适应&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* css 代码 *&#x2F;</span><br><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    height: 200px;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.right &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a0544fd4461f?w=1919&h=234&f=png&s=13127" alt=""></p>
<ol>
<li>将左列设为左浮动，将自身高度塌陷，使得其它块级元素可以和它占据同一行的位置。</li>
<li>右列为 div 块级元素，利用其自身的流特性占满整行。</li>
<li>右列设置<code>overflow: hidden</code>,触发 BFC 特性，使其自身与左列的浮动元素隔离开，不占满整行。</li>
</ol>
<p>这即是上面说的 BFC 的特性之一：<strong>浮动盒的区域不会和 BFC 重叠</strong></p>
<h3 id="防止外边距（margin）重叠"><a href="#防止外边距（margin）重叠" class="headerlink" title="防止外边距（margin）重叠"></a>防止外边距（margin）重叠</h3><h4 id="兄弟元素之间的外边距重叠"><a href="#兄弟元素之间的外边距重叠" class="headerlink" title="兄弟元素之间的外边距重叠"></a>兄弟元素之间的外边距重叠</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* html 代码 *&#x2F;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;child2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* css 代码 *&#x2F;</span><br><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.child1 &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-bottom: 10px;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br><span class="line">.child2 &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin-top: 20px;</span><br><span class="line">    background-color: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/17318cb5761f328e?w=183&h=220&f=png&s=2328" alt=""></p>
<p>两个块级元素，红色 div 距离底部 10px，绿色 div 距离顶部 20px，按道理应该两个块级元素相距 30px 才对，但实际却是取距离较大的一个，即 20px。</p>
<blockquote>
<p>块级元素的上外边距和下外边距有时会合并（或折叠）为一个外边距，其大小取其中的较大者，这种行为称为外边距折叠（重叠），注意这个是发生在属于同一 BFC 下的块级元素之间</p>
</blockquote>
<p>根据 BFC 特性，创建一个新的 BFC 就不会发生 margin 折叠了。比如我们在他们两个 div 外层再包裹一层容器，加属性<code>overflow: hidden</code>，触发 BFC，那么两个 div 就不属于同个 BFC 了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* html 代码 *&#x2F;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;child1&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;child2&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* css 代码 *&#x2F;</span><br><span class="line">.parent &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* ... *&#x2F;</span><br></pre></td></tr></table></figure>

<p>这个关于兄弟元素外边距叠加的问题，除了触发 BFC 也有其他方案，比如你统一只用上边距或下边距，就不会有上面的问题。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/17318dc6636f418f?w=209&h=231&f=png&s=2376" alt=""></p>
<h4 id="父子元素的外边距重叠"><a href="#父子元素的外边距重叠" class="headerlink" title="父子元素的外边距重叠"></a>父子元素的外边距重叠</h4><p>这种情况存在父元素与其第一个或最后一个子元素之间（嵌套元素）。<br>如果在父元素与其第一个/最后一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的外边距 分开，此时子元素的外边距会“溢出”到父元素的外面。</p>
<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* HTML 代码 *&#x2F;</span><br><span class="line">&lt;div id&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* CSS 代码 *&#x2F;</span><br><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">#parent &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: green;</span><br><span class="line">    margin-top: 20px;</span><br><span class="line">&#125;</span><br><span class="line">#child &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: red;</span><br><span class="line">    margin-top: 30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a48a81bc27d9?w=376&h=236&f=png&s=6696" alt=""></p>
<p>如上图，红色的 div 在绿色的 div 内部，且设置了<code>margin-top</code>为 30px，但我们发现红色 div 的顶部与绿色 div 顶部重合，并没有距离顶部 30px，而是溢出到父元素的外面计算。即本来父元素距离顶部只有 20px，被子元素溢出影响，外边距重叠，取较大的值，则距离顶部 30px。</p>
<p>解决办法：</p>
<ol>
<li>给父元素触发 BFC（如添加<code>overflow: hidden</code>）</li>
<li>给父元素添加 border</li>
<li>给父元素添加 padding</li>
</ol>
<p>这样就能实现我们期望的效果了：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a50faed50d4d?w=249&h=221&f=png&s=2040" alt=""></p>
<h3 id="清除浮动解决令父元素高度坍塌的问题"><a href="#清除浮动解决令父元素高度坍塌的问题" class="headerlink" title="清除浮动解决令父元素高度坍塌的问题"></a>清除浮动解决令父元素高度坍塌的问题</h3><p>当容器内子元素设置浮动时，脱离了文档流，容器中总父元素高度只有边框部分高度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* html 代码 *&#x2F;</span><br><span class="line">&lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;* css 代码 *&#x2F;</span><br><span class="line">* &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 0;</span><br><span class="line">&#125;</span><br><span class="line">.parent &#123;</span><br><span class="line">    border: 4px solid red;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    width: 200px;</span><br><span class="line">    height: 200px;</span><br><span class="line">    background-color: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a132272ea410?w=1927&h=209&f=png&s=16771" alt=""></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a249e4c9c33f?w=338&h=679&f=png&s=38121" alt=""></p>
<p>解决办法：给父元素触发 BFC，使其有 BFC 特性：<strong>计算 BFC 的高度时，浮动元素也会参与计算</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.parent &#123;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    border: 4px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a1fd01267b9d?w=1920&h=237&f=png&s=10195" alt=""></p>
<p>上面我们都是用的<code>overflow: hidden</code>触发 BFC，因为确实常用嘛，但是触发 BFC 也不止是只有这一种方法，如上面写的所示。</p>
<p>比如可以设置<code>float: left</code>; <code>float: right</code>; <code>display: inline-block</code>; <code>overflow: auto</code>; <code>display: flex</code>; <code>display:&quot; table</code>; <code>position</code>为<code>absolute</code>或<code>fixed</code>等等，这些都可以触发，不过父元素宽度表现不一定相同，但父元素高度都被撑出来了。当然实际运用可不是随便挑一个走，还是根据场景选择。</p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，鼓励我继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
  </entry>
  <entry>
    <title>一文汇总 CSS 两列布局和三列布局</title>
    <url>/2020/06/27/%E4%B8%80%E6%96%87%E6%B1%87%E6%80%BB-CSS-%E4%B8%A4%E5%88%97%E5%B8%83%E5%B1%80%E5%92%8C%E4%B8%89%E5%88%97%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<p>随着大前端的发展，UI 框架层出不穷，让我们前端开发对 CSS 的能力要求变得没那么高或者没那么严苛，起码重要性是比不上 JS 编程的。但是，基础的 CSS 依然需要我们熟练掌握，今天就来总结写下 CSS 布局的方式。</p>
<a id="more"></a>

<h2 id="两列布局"><a href="#两列布局" class="headerlink" title="两列布局"></a>两列布局</h2><h3 id="左列定宽，右列自适应"><a href="#左列定宽，右列自适应" class="headerlink" title="左列定宽，右列自适应"></a>左列定宽，右列自适应</h3><p><img src="https://user-gold-cdn.xitu.io/2020/6/25/172ebffbad247324?w=1918&h=427&f=png&s=21351" alt=""></p>
<h4 id="float-margin-布局"><a href="#float-margin-布局" class="headerlink" title="float + margin 布局"></a>float + margin 布局</h4><p>html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">200px</span>; <span class="comment">/* 大于或等于左列的宽度 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="float-overflow-布局"><a href="#float-overflow-布局" class="headerlink" title="float + overflow 布局"></a>float + overflow 布局</h4><p>html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="绝对定位布局"><a href="#绝对定位布局" class="headerlink" title="绝对定位布局"></a>绝对定位布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="table-布局"><a href="#table-布局" class="headerlink" title="table 布局"></a>table 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>,</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grid-网格布局"><a href="#grid-网格布局" class="headerlink" title="grid 网格布局"></a>grid 网格布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">200px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="左列不定宽，右列自适应"><a href="#左列不定宽，右列自适应" class="headerlink" title="左列不定宽，右列自适应"></a>左列不定宽，右列自适应</h3><p>左列盒子宽度随着内容增加或减少发生变化，右列盒子自适应</p>
<h4 id="float-overflow-布局-1"><a href="#float-overflow-布局-1" class="headerlink" title="float + overflow 布局"></a>float + overflow 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列不定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex-布局-1"><a href="#flex-布局-1" class="headerlink" title="flex 布局"></a>flex 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列不定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a>grid 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列不定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: auto <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三列布局"><a href="#三列布局" class="headerlink" title="三列布局"></a>三列布局</h2><h3 id="两列定宽，一列自适应"><a href="#两列定宽，一列自适应" class="headerlink" title="两列定宽，一列自适应"></a>两列定宽，一列自适应</h3><p><img src="https://user-gold-cdn.xitu.io/2020/6/26/172ee126919a5ecb?w=1916&h=408&f=png&s=21184" alt=""></p>
<h4 id="float-margin-布局-1"><a href="#float-margin-布局-1" class="headerlink" title="float + margin 布局"></a>float + margin 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">300px</span>; <span class="comment">/* 左列的宽度 + 中间列的宽度 */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="float-overflow-布局-2"><a href="#float-overflow-布局-2" class="headerlink" title="float + overflow 布局"></a>float + overflow 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="table-布局-1"><a href="#table-布局-1" class="headerlink" title="table 布局"></a>table 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="flex-布局-2"><a href="#flex-布局-2" class="headerlink" title="flex 布局"></a>flex 布局</h4><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="grid-布局-1"><a href="#grid-布局-1" class="headerlink" title="grid 布局"></a>grid 布局</h4><p>html 代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列定宽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列自适应<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">200px</span> auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="左右定宽，中间自适应"><a href="#左右定宽，中间自适应" class="headerlink" title="左右定宽，中间自适应"></a>左右定宽，中间自适应</h3><p><img src="https://user-gold-cdn.xitu.io/2020/6/27/172f36b76f3065b5?w=1914&h=409&f=png&s=21663" alt=""></p>
<p>圣杯布局和双飞翼布局目的都是希望先加载的是中间的部分，然后再开始加载 left 和 right 两部分相对来说不是很重要的东西。</p>
<h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><p>圣杯布局：为了让中间的内容不被遮挡，将中间 div（或最外层父 div）设置 padding-left 和 padding-right （值等于 left 和 right 的宽度），将左右两个 div 用相对布局 position: relative 并分别配合 left 和 right 属性，以便左右两栏 div 移动后不遮挡中间 div。</p>
<p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>,</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="comment">/* 使 #left 上去一行 */</span></span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>; <span class="comment">/* 使 #right 上去一行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>双飞翼布局，为了中间 div 内容不被遮挡，直接在中间 div 内部创建子 div 用于放置内容，在该子 div 里用 margin-left 和 margin-right 为左右两栏 div 留出位置。</p>
<p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center-inside"</span>&gt;</span>中间列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#left</span>,</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="comment">/* 使 #left 上去一行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>; <span class="comment">/* 使 #right 上去一行 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center-inside</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flex-实现"><a href="#flex-实现" class="headerlink" title="flex 实现"></a>flex 实现</h3><p>html 代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span>中间列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>左列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>右列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>css 代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span>,</span><br><span class="line"><span class="selector-id">#right</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#left</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: -<span class="number">1</span>; <span class="comment">/* 让 #left 居于左侧 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgrey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS伪元素实现中间文字，两边横线的效果</title>
    <url>/2020/06/16/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E5%AE%9E%E7%8E%B0%E4%B8%AD%E9%97%B4%E6%96%87%E5%AD%97%EF%BC%8C%E4%B8%A4%E8%BE%B9%E6%A8%AA%E7%BA%BF%E7%9A%84%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>今天做项目的时候，要实现效果：中间是文字，两边是横线围着，其中有间距。了解了几种做法。伪元素这个刚开始没想到，回来又自己敲了一遍，以做记录…</p>
<a id="more"></a>

<p>效果：</p>
<p><img src="/images/css-pseudo.png" alt="image.png"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>CSS伪元素实现中间文字, 两边横线效果<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.container</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line">        width: 640px;</span><br><span class="line">        margin: 0 auto;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> &#123;</span></span><br><span class="line">        text-align: center;</span><br><span class="line">        width: 100%;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> <span class="selector-class">.word</span><span class="selector-pseudo">:before</span>,</span></span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> <span class="selector-class">.word</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 50%;</span><br><span class="line">        width: 40%;</span><br><span class="line">        height: 1px;</span><br><span class="line">        background: blue;</span><br><span class="line">        content: '';</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="comment">/* 调整背景横线的左右距离 */</span></span></span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> <span class="selector-class">.word</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line">        left: 0;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="css">      <span class="selector-class">.wrapper</span> <span class="selector-class">.word</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">        right: 0;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"word"</span>&gt;</span>中间的字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Formik +Yup 处理 React 表单验证</title>
    <url>/2020/06/13/%E4%BD%BF%E7%94%A8-Formik-Yup-%E5%A4%84%E7%90%86-React-%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<p>React 操作表单一直都是比较繁琐的操作，在以前用的是 redux-form， 但现在 formik 这个库设计得更加优雅，Github 的 star 数目已经远远超过 redux-form 了。做表单就是为了收集一些数据，然后进行提交。而 redux-form 理念是把这些数据存放到 reducer 中去，当我们表单多的时候，显然对整个 store 的数据管理不太友好，因为多了很多表单数据。而 formik 解决的其中一个痛点就是这个，它可以在组件内部处理这些表单项而简单易用。</p>
<p>Formik 旨在轻松管理具有复杂验证的表单, Formik 支持同步和异步表单级和字段级验证。</p>
<a id="more"></a>

<p><code>例子的 Formik 为 2.1.4 版</code></p>
<p>先来看个基本的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; useFormik &#125; <span class="keyword">from</span> <span class="string">'formik'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./FormDemo.css'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查表单字段</span></span><br><span class="line"><span class="keyword">const</span> validate = <span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> errors = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!values.name) &#123;</span><br><span class="line">    errors.name = <span class="string">'不能为空'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (values.name.length &gt; <span class="number">20</span>) &#123;</span><br><span class="line">    errors.name = <span class="string">'名字太长，输入有误'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!values.email) &#123;</span><br><span class="line">    errors.email = <span class="string">'不能为空'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="regexp">/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]&#123;2,4&#125;$/i</span>.test(values.email)) &#123;</span><br><span class="line">    errors.email = <span class="string">'邮箱格式错误'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> errors</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> FormDemo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> formik = useFormik(&#123;</span><br><span class="line">    initialValues: &#123;</span><br><span class="line">      name: <span class="string">''</span>,</span><br><span class="line">      email: <span class="string">''</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    validate,</span><br><span class="line">    onSubmit: <span class="function"><span class="params">values</span> =&gt;</span> &#123;</span><br><span class="line">      alert(<span class="built_in">JSON</span>.stringify(values, <span class="literal">null</span>, <span class="number">2</span>))</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;form onSubmit=&#123;formik.handleSubmit&#125; className=<span class="string">'form-wrap'</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">'form-group'</span>&gt;</span><br><span class="line">        &lt;label&gt;名字&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          name='name'</span></span><br><span class="line"><span class="regexp">          onChange=&#123;formik.handleChange&#125;</span></span><br><span class="line"><span class="regexp">          onBlur=&#123;formik.handleBlur&#125;</span></span><br><span class="line"><span class="regexp">          value=&#123;formik.values.name&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &#123;formik.touched.name &amp;&amp; formik.errors.name ? (</span><br><span class="line">          &lt;div className=<span class="string">'error-tip'</span>&gt;&#123;formik.errors.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        ) : null&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">'form-group'</span>&gt;</span><br><span class="line">        &lt;label&gt;邮箱&lt;<span class="regexp">/label&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input</span></span><br><span class="line"><span class="regexp">          name='email'</span></span><br><span class="line"><span class="regexp">          onChange=&#123;formik.handleChange&#125;</span></span><br><span class="line"><span class="regexp">          onBlur=&#123;formik.handleBlur&#125;</span></span><br><span class="line"><span class="regexp">          value=&#123;formik.values.email&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">        &#123;formik.touched.email &amp;&amp; formik.errors.email ? (</span><br><span class="line">          &lt;div className=<span class="string">'error-tip'</span>&gt;&#123;formik.errors.email&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        ) : null&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">      &lt;button type=<span class="string">'submit'</span>&gt;Submit&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>form&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> FormDemo</span><br></pre></td></tr></table></figure>

<p>以上是一个很简单的表单，输入名字与邮箱。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/6/13/172acf9ec35b272f?w=433&h=232&f=gif&s=31469" alt=""></p>
<p>上面例子中我们使用的是 useFormik 这种用法，还有使用 <code>&lt;Formik /&gt;</code> 和 <code>withFormik</code> 的用法。</p>
<p>但我们发现一个问题，当正在输入名字的时候，邮箱已经立马显示不能为空了，我们需要的是当点击的时候才做其他表单元素的判断而不是一次性判断完。对这一问题，我们需要再加一个判断<code>touched</code>, 这个代表表单中的某个字段是否被点击过，直译的话就是”触碰过”或”动过”，这样就不会出现上面的问题了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  formik.touched.name &amp;&amp; formik.errors.name ? (</span><br><span class="line">    &lt;div className=<span class="string">'error-tip'</span>&gt;&#123;formik.errors.name&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  ) : null</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>但发现上面的代码还是挺多, onChange, onBlur, value 等属性还是挺重复的，每个表单元素写一段，其实我们可以更精简，使用 formik 里面的<code>getFieldProps</code>方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">"&#123;formik.handleSubmit&#125;"</span> <span class="attr">className</span>=<span class="string">"form-wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>名字<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">'name'</span> &#123;<span class="attr">...formik.getFieldProps</span>('<span class="attr">name</span>')&#125; /&gt;</span> &#123;formik.touched.name &amp;&amp;</span><br><span class="line">    formik.errors.name ? (</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"error-tip"</span>&gt;</span>&#123;formik.errors.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ) : null&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">'email'</span> &#123;<span class="attr">...formik.getFieldProps</span>('<span class="attr">email</span>')&#125; /&gt;</span> &#123;formik.touched.email &amp;&amp;</span><br><span class="line">    formik.errors.email ? (</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"error-tip"</span>&gt;</span>&#123;formik.errors.email&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    ) : null&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么表单字段的验证能不能简化呢？formik 表单验证大多数我们会选择和 yup 库进行搭配，yup 的专长就是作规则校验的。用法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> formik = useFormik(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  validationSchema: Yup.object(&#123;</span><br><span class="line">    name: Yup.string().max(<span class="number">20</span>, <span class="string">'名字太长，输入有误'</span>).required(<span class="string">'不能为空'</span>),</span><br><span class="line">    email: Yup.string().email(<span class="string">'邮箱格式错误'</span>).required(<span class="string">'不能为空'</span>),</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>上面 validationSchema 为 Formik 专门为 yup 留出的接口，所以 formik 是很好支持 yup 搭配使用的。</p>
<p>最后附上官网：<a href="https://jaredpalmer.com/formik/" target="_blank" rel="noopener">https://jaredpalmer.com/formik/</a><br><br></p>
<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>Formik</tag>
        <tag>Yup</tag>
      </tags>
  </entry>
  <entry>
    <title>【React 原理（一）】实现 createElement 和 render 方法</title>
    <url>/2020/06/06/%E3%80%90React-%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%E3%80%91%E5%AE%9E%E7%8E%B0-createElement-%E5%92%8C-render-%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在 React 中，我们都知道可以写 jsx 代码会被编译成真正的 DOM 插入到要显示的页面上。这具体是怎么实现的，今天我们就自己动手做一下。</p>
<a id="more"></a>

<h2 id="实现-createElement-方法"><a href="#实现-createElement-方法" class="headerlink" title="实现 createElement 方法"></a>实现 createElement 方法</h2><p>这个方法平时开发我们并不会用到，因为它是经 babel 编译后的代码，我们新建一个 React 项目，index.js 最简单的代码结构如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">'title'</span>&gt;</span>Hello React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure>

<p>这里就 jsx 会变编译成真正的 DOM ，把 html 代码拿到 babel 官网编译</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287948badb8312?w=1162&h=182&f=png&s=14232" alt=""></p>
<p>于是我们就看到了 React.createElement() 方法，但这只是调用这个方法，它具体做了什么返回什么我们还不知道，我们可以打印这个函数运行的结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  React.createElement(</span><br><span class="line">    <span class="string">'h1'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      className: <span class="string">'title'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'Hello React'</span></span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/1728796fcf7d2054?w=567&h=181&f=png&s=12796" alt=""><br>返回的这个对象就是虚拟 DOM 了。</p>
<p>我们来分析它返回的对象参数，首先第一个是</p>
<ul>
<li><code>$$typeof: REACT_ELEMENT_TYPE</code></li>
</ul>
<p>这个是 React 元素对象的标识属性</p>
<p>REACT_ELEMENT_TYPE 的值是一个 Symbol 类型，代表了一个独一无二的值。如果浏览器不支持 Symbol 类型，值就是一个二进制值。</p>
<blockquote>
<p>为什么是 Symbol？主要防止 XSS 攻击伪造一个假的 React 组件。因为 JSON 中是不会存在 Symbol 类型的。</p>
</blockquote>
<ul>
<li>key：这个比如循环中会用到这个 key 值</li>
<li>props：传入的属性值，比如 id, className, style, children 等</li>
<li>ref： DOM 的引用</li>
<li>剩下的是私有属性（本篇不展开讨论）</li>
</ul>
<p>在本篇我们会用自己简单的方式实现这两个方法，而不是根据源码，所以实现上的方法只要能实现它的基本功能即可；有个基本概念在，以后再循序渐进学习源码。</p>
<p>而 createElement 中有三个参数，更确切说是 n 个参数：</p>
<ul>
<li>type：表示要渲染的元素类型。这里可以传入一个元素 Tag 名称，也可以传入一个组件（如 div span 等，也可以是是函数组件和类组件）</li>
<li>props：创建 React 元素所需要的 props。</li>
<li>childrens（可选参数）：要渲染元素的子元素，这里可以向后传入 n 个参数。可以为文本字符串，也可以为数组</li>
</ul>
<p>初步 createElement 方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 JSX 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...childrens</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type,</span><br><span class="line">        props: &#123;</span><br><span class="line">          ...props,</span><br><span class="line">          children: childrens.length &lt;= <span class="number">1</span> ? childrens[<span class="number">0</span>] || <span class="string">''</span> : childrens,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数中 props 和 childrens 是并列关系，然后返回的 props 对象，里面包含了 children，所以我们需要再 props 里面添加 children 参数，然后根据 children 参数为一个或多个的可能在进行取值处理。</p>
<p>调用该方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  createElement(</span><br><span class="line">    <span class="string">'h1'</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      className: <span class="string">'title'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'Hello React'</span></span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287aecec9a3e91?w=237&h=116&f=png&s=4860" alt=""><br>除去其它本篇我们不讨论的属性，目前算是实现了一半；我们观察原来 React 自身方法输出的结果有 key, ref， 同输出的 props 也是并列关系，于是我们进一步作出处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...childrens</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ref, key</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'ref'</span> <span class="keyword">in</span> props) &#123;</span><br><span class="line">    ref = props[<span class="string">'ref'</span>]</span><br><span class="line">    props[<span class="string">'ref'</span>] = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'key'</span> <span class="keyword">in</span> props) &#123;</span><br><span class="line">    key = props[<span class="string">'key'</span>]</span><br><span class="line">    props[<span class="string">'key'</span>] = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    props: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children: childrens.length &lt;= <span class="number">1</span> ? childrens[<span class="number">0</span>] || <span class="string">''</span> : childrens,</span><br><span class="line">    &#125;,</span><br><span class="line">    ref,</span><br><span class="line">    key,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的方式调用结果如下：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287b33de749a06?w=453&h=145&f=png&s=8494" alt=""><br>如果添加多一些属性，我们来看看结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  createElement(</span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">'box'</span>, <span class="attr">className</span>: <span class="string">'box'</span>, <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">'red'</span> &#125;, <span class="attr">key</span>: <span class="string">'20'</span> &#125;,</span><br><span class="line">    <span class="string">'this is text'</span>,</span><br><span class="line">    createElement(<span class="string">'h2'</span>, &#123; <span class="attr">className</span>: <span class="string">'title'</span> &#125;, <span class="string">'hello'</span>),</span><br><span class="line">    createElement(<span class="string">'div'</span>, &#123; <span class="attr">className</span>: <span class="string">'content'</span> &#125;, <span class="string">'Hi'</span>)</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287c9de8368ddd?w=467&h=280&f=png&s=17373" alt=""><br>用了这种比较粗鲁的方式添加，设置为 undefined 在实现 render 方法的时候我们会根据这个忽略 props 内部的 key 和 props 属性，这里就实现了最基本的 createElement 方法了。</p>
<h2 id="实现-render-方法"><a href="#实现-render-方法" class="headerlink" title="实现 render 方法"></a>实现 render 方法</h2><p>render 方法的第一个参数接收的是 createElement 返回的对象，也就是虚拟 DOM；<br>第二个参数则是挂载的目标 DOM。同样的做法，我们用 babel 编译来看：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287ca773a9b742?w=1259&h=362&f=png&s=43471" alt=""><br>执行后，就被挂在到页面了</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/6/6/17287cc414f3731c?w=343&h=122&f=png&s=6145" alt=""></p>
<p>实现代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 功能：把创建的对象生成对应的DOM元素，最后插入到页面中</span></span><br><span class="line"><span class="comment"> * objJSX： createElement 返回的 JSX 对象</span></span><br><span class="line"><span class="comment"> * container：挂载的容器，如 document.getElementById('root')</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">objJSX, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; type, props &#125; = objJSX</span><br><span class="line">  <span class="keyword">let</span> newElement = <span class="built_in">document</span>.createElement(type)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> props) &#123;</span><br><span class="line">    <span class="comment">// 遍历传入的 props 属性</span></span><br><span class="line">    <span class="keyword">if</span> (!props.hasOwnProperty(attr)) <span class="keyword">break</span> <span class="comment">// 不是私有的直接结束遍历</span></span><br><span class="line">    <span class="keyword">let</span> value = props[attr] <span class="comment">// &gt;如果当前属性没有值,直接不处理即可</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">undefined</span>) <span class="keyword">continue</span> <span class="comment">// NULL OR UNDEFINED</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对几个特殊属性单独设置</span></span><br><span class="line">    <span class="keyword">switch</span> (attr.toUpperCase()) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'ID'</span>:</span><br><span class="line">        newElement.setAttribute(<span class="string">'id'</span>, value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'CLASSNAME'</span>:</span><br><span class="line">        newElement.setAttribute(<span class="string">'class'</span>, value)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'STYLE'</span>: <span class="comment">// 传入的行内样式 style 是个对象，故需遍历赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> styleAttr <span class="keyword">in</span> value) &#123;</span><br><span class="line">          <span class="keyword">if</span> (value.hasOwnProperty(styleAttr)) &#123;</span><br><span class="line">            newElement[<span class="string">'style'</span>][styleAttr] = value[styleAttr]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'CHILDREN'</span>:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 可能是一个值：可能是字符串也可能是一个JSX对象</span></span><br><span class="line"><span class="comment">         * 可能是一个数组：数组中的每一项可能是字符串也可能是JSX对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 首先把一个值也变为数组，这样后期统一操作数组即可</span></span><br><span class="line">        !(value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) ? (value = [value]) : <span class="literal">null</span></span><br><span class="line">        value.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 验证ITEM是什么类型的：如果是字符串就是创建文本节点，如果是对象，我们需要再次执行RENDER方法，把创建的元素放到最开始创建的大盒子中</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">'string'</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> text = <span class="built_in">document</span>.createTextNode(item)</span><br><span class="line">            newElement.appendChild(text)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            render(item, newElement)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        newElement.setAttribute(attr, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  container.appendChild(newElement)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>ps： <a href="https://images.weserv.nl/?url=https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，鼓励我继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>理解 redux-thunk 源码</title>
    <url>/2020/05/30/%E7%90%86%E8%A7%A3-redux-thunk-%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<p>前面几篇我们就 Redux 展开了几篇文章，这次我们来实现 react-thunk，就不是叫实现 redux-thunk 了，直接上源码，因为源码就 11 行。如果对 Redux 中间件还不理解的，可以看我写的 Redux 文章。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="https://jacky-summer.github.io/2020/04/22/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E4%BD%A0Redux%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/#more" target="_blank" rel="noopener">实现一个迷你 Redux（基础版）</a></li>
<li><a href="https://jacky-summer.github.io/2020/05/14/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARedux%EF%BC%88%E5%AE%8C%E5%96%84%E7%89%88%EF%BC%89/#more" target="_blank" rel="noopener">实现一个 Redux（完善版）</a></li>
<li><a href="https://jacky-summer.github.io/2020/04/28/%E6%B5%85%E8%B0%88React%E7%9A%84Context-API/#more" target="_blank" rel="noopener">浅谈 React 的 Context API</a></li>
<li><a href="https://jacky-summer.github.io/2020/05/24/%E5%B8%A6%E4%BD%A0%E5%AE%9E%E7%8E%B0-react-redux/" target="_blank" rel="noopener">带你实现 react-redux</a></li>
</ul>
<h2 id="为什么要用-redux-thunk"><a href="#为什么要用-redux-thunk" class="headerlink" title="为什么要用 redux-thunk"></a>为什么要用 redux-thunk</h2><p>在使用 Redux 过程，通过 dispatch 方法派发一个 action 对象。当我们使用 redux-thunk 后，可以 dispatch 一个 function。redux-thunk 会自动调用这个 function，并且传递 dispatch, getState 方法作为参数。这样一来，我们就能在这个 function 里面处理异步逻辑，处理复杂逻辑，这是原来 Redux 做不到的，因为原来就只能 dispatch 一个简单对象。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>redux-thunk 作为 redux 的中间件，主要用来处理异步请求，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// to do ...</span></span><br><span class="line">    axios.get(<span class="string">'https://jsonplaceholder.typicode.com/todos/1'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="redux-thunk-源码"><a href="#redux-thunk-源码" class="headerlink" title="redux-thunk 源码"></a>redux-thunk 源码</h2><p>redux-thunk 的源码比较简洁，实际就 11 行。前几篇我们说到 redux 的中间件形式，<br>本质上是对 store.dispatch 方法进行了增强改造，基本是类似这种形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const middleware &#x3D; (store) &#x3D;&gt; next &#x3D;&gt; action &#x3D;&gt; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在这里就不详细解释了，可以看 <a href="https://juejin.im/post/5ebb9375f265da7bfe0bf16a" target="_blank" rel="noopener">实现一个 Redux（完善版）</a></p>
<p>先给个缩水版的实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> thunk = <span class="function">(<span class="params">&#123; getState, dispatch &#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> action(dispatch, getState)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk</span><br></pre></td></tr></table></figure>

<ul>
<li>原理：即当 action 为 function 的时候，就调用这个 function (传入 dispatch, getState)并返回；如果不是，就直接传给下一个中间件。</li>
</ul>
<p>完整源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createThunkMiddleware</span>(<span class="params">extraArgument</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果action是一个function，就返回action(dispatch, getState, extraArgument)，否则返回next(action)。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> action(dispatch, getState, extraArgument)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// next为之前传入的store.dispatch，即改写前的dispatch</span></span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> thunk = createThunkMiddleware()</span><br><span class="line"><span class="comment">// 给thunk设置一个变量withExtraArgument，并且将createThunkMiddleware整个函数赋给它</span></span><br><span class="line">thunk.withExtraArgument = createThunkMiddleware</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk</span><br></pre></td></tr></table></figure>

<p>我们发现其实还多了 extraArgument 传入，这个是自定义参数，如下用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> api = <span class="string">'https://jsonplaceholder.typicode.com/todos/1'</span></span><br><span class="line"><span class="keyword">const</span> whatever = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  applyMiddleware(thunk.withExtraArgument(&#123; api, whatever &#125;))</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// later</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fetchData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch, getState, &#123; api, whatever &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// you can use api and something else here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>同 redux-thunk 非常流行的库 redux-saga 一样，都是在 redux 中做异步请求等副作用。Redux 相关的系列文章就暂时写到这部分为止，下次会写其他系列。</p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>react-thunk</tag>
      </tags>
  </entry>
  <entry>
    <title>带你实现-react-redux</title>
    <url>/2020/05/24/%E5%B8%A6%E4%BD%A0%E5%AE%9E%E7%8E%B0-react-redux/</url>
    <content><![CDATA[<p>之前我们实现了 redux 的功能，这次我们来实现一下配合 redux 开发中经常会用到的一个库—— react-redux。本文不会详细介绍 react-redux 的使用，另外需要了解 Context API， 再看此文就很容易理解了。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>可以看看我之前写的几篇文章</p>
<ul>
<li><a href="https://jacky-summer.github.io/2020/04/22/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E4%BD%A0Redux%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/#more" target="_blank" rel="noopener">实现一个迷你 Redux（基础版）</a></li>
<li><a href="https://jacky-summer.github.io/2020/05/14/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARedux%EF%BC%88%E5%AE%8C%E5%96%84%E7%89%88%EF%BC%89/#more" target="_blank" rel="noopener">实现一个 Redux（完善版）</a></li>
<li><a href="https://jacky-summer.github.io/2020/04/28/%E6%B5%85%E8%B0%88React%E7%9A%84Context-API/#more" target="_blank" rel="noopener">浅谈 React 的 Context API</a></li>
</ul>
<h2 id="react-redux-基本使用"><a href="#react-redux-基本使用" class="headerlink" title="react-redux 基本使用"></a>react-redux 基本使用</h2><p>用个简单的加减数字作例子, 把代码贴出来：</p>
<ul>
<li>redux.js</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// actions</span></span><br><span class="line"><span class="keyword">const</span> ADD_NUM = <span class="string">'ADD_NUM'</span></span><br><span class="line"><span class="keyword">const</span> DESC_NUM = <span class="string">'DESC_NUM'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// action creators</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addNumAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: ADD_NUM,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reduceNumAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: DESC_NUM,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  num: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reducer</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_NUM:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">num</span>: state.num + <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">case</span> DESC_NUM:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">num</span>: state.num - <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">'./Demo'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./redux.js'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;Demo /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>

<p>Demo.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; addNumAction, reduceNumAction &#125; <span class="keyword">from</span> <span class="string">'./redux.js'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.props)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;<span class="keyword">this</span>.props.num&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;this.props.addNum&#125;&gt;增加1&lt;/</span>button&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.props.reduceNum&#125;&gt;减少<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    num: state.num,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    addNum() &#123;</span><br><span class="line">      <span class="keyword">const</span> action = addNumAction()</span><br><span class="line">      dispatch(action)</span><br><span class="line">    &#125;,</span><br><span class="line">    reduceNum() &#123;</span><br><span class="line">      <span class="keyword">const</span> action = reduceNumAction()</span><br><span class="line">      dispatch(action)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Demo)</span><br></pre></td></tr></table></figure>

<p>就可以实现 num 的增减：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/5/24/172443ab8612774b?w=143&h=82&f=png&s=1764" alt=""><br>其实一个简单的 react-redux， 主要也就是实现 connect 和 Provider 的基本功能</p>
<ul>
<li><strong>connect</strong>：可以把 state 和 dispatch 绑定到 react 组件，使得组件可以访问到 redux 的数据</li>
<li><strong>Provider</strong>：提供的是一个顶层容器的作用，实现 store 的上下文传递</li>
</ul>
<h2 id="使用旧版-Context-API-实现"><a href="#使用旧版-Context-API-实现" class="headerlink" title="使用旧版 Context API 实现"></a>使用旧版 Context API 实现</h2><h3 id="实现-Provider"><a href="#实现-Provider" class="headerlink" title="实现 Provider"></a>实现 Provider</h3><p>首先我们看它的用法，就知道它不是一个函数，而是一个组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Provider store&#x3D;&#123;store&#125;&gt;</span><br><span class="line">    &lt;Demo &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;Provider&gt;</span><br></pre></td></tr></table></figure>

<p>React 的 Context API 提供了一种通过组件树传递数据的方法，无需在每个级别手动传递 props 属性。</p>
<p>Provider 的实现比较简单，核心就是<strong>把 store 放到 context 里面，所有的子元素可以直接取到 store</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    store: PropTypes.object,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.store = props.store <span class="comment">// 也就是 Provider 组件从外部传入的 store</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">store</span>: <span class="keyword">this</span>.store &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children <span class="comment">// 中间包的组件传入了 context，其余原封不动返回组件</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有个地方大家知道就好，两种写法一样的，对 context type 的约束</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 不用 static 来声明...</span></span><br><span class="line">&#125;</span><br><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line">  store: PropTypes.object,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现-connect"><a href="#实现-connect" class="headerlink" title="实现 connect"></a>实现 connect</h3><p>connect 用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Demo)</span><br></pre></td></tr></table></figure>

<p>connect 是一个高阶组件，就是以组件作为参数，返回一个组件。</p>
<p><strong>connect 负责连接组件，给到 redux 的数据放到组件的属性里</strong></p>
<ol>
<li>负责接收一个组件，把 state 的一些数据放进去，返回一个组件</li>
<li>数据变化的时候，能够通知组件（需要进行监听）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">mapStateToProps, mapDispatchToProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">WrapComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">      <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">        store: PropTypes.object,</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">          props: &#123;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">        store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.update()) <span class="comment">// 监听更新事件</span></span><br><span class="line">        <span class="keyword">this</span>.update()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      update() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">        <span class="keyword">let</span> stateToProps = mapStateToProps(store.getState()) <span class="comment">// 传入 redux 的 state</span></span><br><span class="line">        <span class="keyword">let</span> dispatchToProps = mapDispatchToProps(store.dispatch) <span class="comment">// 传入 redux 的 dispatch</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          props: &#123;</span><br><span class="line">            ...this.state.props,</span><br><span class="line">            ...stateToProps,</span><br><span class="line">            ...dispatchToProps,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrapComponent</span> &#123;<span class="attr">...this.state.props</span>&#125; /&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样 connect 就实现了，但还有一个问题，像上面的例子，我们其实可以直接传入 action creators， 而不用自己定义函数传入 dispatch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default connect(mapStateToProps, &#123; addNumAction, reduceNumAction &#125;)(Demo)</span><br></pre></td></tr></table></figure>

<p>调用的时候：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onClick&#x3D;&#123;this.props.addNumAction&#125;&gt;增加1&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button onClick&#x3D;&#123;this.props.reduceNumAction&#125;&gt;减少1&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>那它的 dispatch 哪里来的，其实是用了 redux 的 bindActionCreators 函数，在我介绍 redux 的文章有提到，它作用是将 actionCreator 转化成 dispatch 形式，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; addNumAction &#125;  &#x3D;&gt;  (...args) &#x3D;&gt; dispatch(addNumAction(args))</span><br></pre></td></tr></table></figure>

<p>所以我们需要再更改 connect 函数，同时，这次我们用箭头函数的形式简化代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> connect = <span class="function">(<span class="params">mapStateToProps, mapDispatchToProps</span>) =&gt;</span> <span class="function"><span class="params">WrapComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">      store: PropTypes.object,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">      <span class="keyword">super</span>(props)</span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line">        props: &#123;&#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">      store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.update())</span><br><span class="line">      <span class="keyword">this</span>.update()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update() &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">      <span class="keyword">let</span> stateToProps = mapStateToProps(store.getState())</span><br><span class="line">      <span class="keyword">let</span> dispatchToProps</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> mapDispatchToProps === <span class="string">'function'</span>) &#123;</span><br><span class="line">        dispatchToProps = mapDispatchToProps(store.dispatch)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 传递了一个 actionCreator 对象过来</span></span><br><span class="line">        dispatchToProps = bindActionCreators(mapDispatchToProps, store.dispatch)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        props: &#123;</span><br><span class="line">          ...this.state.props,</span><br><span class="line">          ...stateToProps,</span><br><span class="line">          ...dispatchToProps,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrapComponent</span> &#123;<span class="attr">...this.state.props</span>&#125; /&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上，我们实现了最基本版的 react-redux，然后接下来，我们用新版的 Context API 再写一次</p>
<h2 id="使用新版-Context-API-实现"><a href="#使用新版-Context-API-实现" class="headerlink" title="使用新版 Context API 实现"></a>使用新版 Context API 实现</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; bindActionCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> StoreContext = React.createContext(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这次 Provider 采取更简洁的形式写</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;StoreContext.Provider value=&#123;<span class="keyword">this</span>.props.store&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/StoreContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export function connect(mapStateToProps, mapDispatchToProps) &#123;</span></span><br><span class="line"><span class="regexp">  return function (WrapComponent) &#123;</span></span><br><span class="line"><span class="regexp">    class ConnectComponent extends Component &#123;</span></span><br><span class="line"><span class="regexp">      constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">        super(props)</span></span><br><span class="line"><span class="regexp">        this.state = &#123;</span></span><br><span class="line"><span class="regexp">          props: &#123;&#125;,</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      componentDidMount() &#123;</span></span><br><span class="line"><span class="regexp">        const &#123; store &#125; = this.props</span></span><br><span class="line"><span class="regexp">        store.subscribe(() =&gt; this.update())</span></span><br><span class="line"><span class="regexp">        this.update()</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      update() &#123;</span></span><br><span class="line"><span class="regexp">        const &#123; store &#125; = this.props</span></span><br><span class="line"><span class="regexp">        let stateToProps = mapStateToProps(store.getState())</span></span><br><span class="line"><span class="regexp">        let dispatchToProps</span></span><br><span class="line"><span class="regexp">        if (typeof mapDispatchToProps === 'function') &#123;</span></span><br><span class="line"><span class="regexp">          dispatchToProps = mapDispatchToProps(store.dispatch)</span></span><br><span class="line"><span class="regexp">        &#125; else &#123;</span></span><br><span class="line"><span class="regexp">          /</span><span class="regexp">/ 传递了一个 actionCreator 对象过来</span></span><br><span class="line"><span class="regexp">          dispatchToProps = bindActionCreators(mapDispatchToProps, store.dispatch)</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">        this.setState(&#123;</span></span><br><span class="line"><span class="regexp">          props: &#123;</span></span><br><span class="line"><span class="regexp">            ...this.state.props,</span></span><br><span class="line"><span class="regexp">            ...stateToProps,</span></span><br><span class="line"><span class="regexp">            ...dispatchToProps,</span></span><br><span class="line"><span class="regexp">          &#125;,</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      render() &#123;</span></span><br><span class="line"><span class="regexp">        return &lt;WrapComponent &#123;...this.state.props&#125; /</span>&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">      &lt;StoreContext.Consumer&gt;</span><br><span class="line">        &#123;value =&gt; <span class="xml"><span class="tag">&lt;<span class="name">ConnectComponent</span> <span class="attr">store</span>=<span class="string">&#123;value&#125;</span> /&gt;</span></span>&#125;</span><br><span class="line">      &lt;<span class="regexp">/StoreContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>react-redux</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个Redux（完善版）</title>
    <url>/2020/05/14/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AARedux%EF%BC%88%E5%AE%8C%E5%96%84%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p>上篇写了实现一个迷你 Redux（基础版），本篇将继续完善 Redux</p>
<a id="more"></a>

<p>阅读本文前先看：<a href="https://jacky-summer.github.io/2020/04/22/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E4%BD%A0Redux%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/" target="_blank" rel="noopener">实现一个迷你 Redux（基础版）</a></p>
<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>Redux 有个 API 是 applyMiddleware， 专门用来使用中间件的，首先我们得知道，它用来干嘛的。</p>
<h3 id="为什么会需要中间件？"><a href="#为什么会需要中间件？" class="headerlink" title="为什么会需要中间件？"></a>为什么会需要中间件？</h3><p>假设我们现在需要记录每次的 dispatch 前后 state 的记录， 那要怎么做呢？于是，简单粗暴的在第一个 dispatch 方法前后加代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line"><span class="built_in">console</span>.log(action)</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br></pre></td></tr></table></figure>

<p>这部分运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">prev state &#123;<span class="attr">value</span>: <span class="number">10</span>&#125;</span><br><span class="line">&#123;<span class="attr">type</span>: <span class="string">"INCREMENT"</span>&#125;</span><br><span class="line">当前数字为：<span class="number">11</span></span><br><span class="line">next state &#123;<span class="attr">value</span>: <span class="number">11</span>&#125;</span><br></pre></td></tr></table></figure>

<p>但加完发现情况不对，页面有多个 dispatch 的话，要这样写很多次，会产生大量重复代码。突然，又要加需求了，需要记录每次出错的原因,单独的功能要求如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  store.dispatch(action)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后两个需求都要，那就凑合两个，但叠一起看更乱了。</p>
<h3 id="中间件的概念"><a href="#中间件的概念" class="headerlink" title="中间件的概念"></a>中间件的概念</h3><p>显然，我们不能通过这种方式来做。比较理想的方案是 Redux 本身提供一个功能入口，让我们可以在外面添加功能进去，这样代码就不会复杂。</p>
<p>但如果给我们现有实现的 Redux 添加功能，在哪个环节添加比较合适呢？</p>
<ul>
<li>Reducer： 纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。</li>
<li>View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。</li>
<li>Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。</li>
</ul>
<p>我们发现，以上需求都是和 dispatch 相关，只有发送 action 的这个步骤，即 store.dispatch() 方法，可以添加功能。比如添加日志功能，我们只要把日志放进 dispatch 函数里，不就好了吗，我们只需要改造 dispatch 函数，把 dispatch 进行一层封装。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="keyword">const</span> next = store.dispatch</span><br><span class="line">store.dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">    <span class="built_in">console</span>.log(action)</span><br><span class="line">    next(action)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码，对 store.dispatch 进行了重新定义，这就是中间件的雏形。</p>
<p>所以说 Redux 的中间件就是一个函数，是对 dispatch 方法的扩展，增强 dispatch 的功能。</p>
<h3 id="实现中间件"><a href="#实现中间件" class="headerlink" title="实现中间件"></a>实现中间件</h3><p>对于上述 dispatch 的封装，实际上是缺陷很大的。万一又来 n 多个需求怎么办? 那 dispatch 函数就混乱到无法维护了，故需要扩展性强的多中间件合作模式。</p>
<ol>
<li>我们把 loggerMiddleware 提取出来</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="keyword">const</span> next = store.dispatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loggerMiddleware = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">  <span class="built_in">console</span>.log(action)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    loggerMiddleware(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>把 exceptionMiddleware 提取出来</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    loggerMiddleware(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch = exceptionMiddleware</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>现在代码有个问题，就是 exceptionMiddleware 中间件写死 loggerMiddleware，但以后又万一不要记录功能呢，所以我们需要让 next(action) 变成动态的，即换哪个中间件都可以</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// loggerMiddleware(action)</span></span><br><span class="line">    next(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个写法可能刚开始看不太适应，实际就是函数里面，返回一个函数，即等效于</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// loggerMiddleware(action)</span></span><br><span class="line">      next(action)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传参数的时候即是 exceptionMiddleware(next)(action)</p>
<ol start="4">
<li>同理，我们让 loggerMiddleware 里面无法扩展别的中间件了！我们也把 next 写成动态的</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> loggerMiddleware = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">  <span class="built_in">console</span>.log(action)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前为止，整个中间件设计改造如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="keyword">const</span> next = store.dispatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loggerMiddleware = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">  <span class="built_in">console</span>.log(action)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    next(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">store.dispatch = exceptionMiddleware(loggerMiddleware(next))</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>现在又有一个新问题，想想平时使用中间件是从外部引入的，那外部中间件里面怎么会有 store.getState() 这个方法，于是我们把 store 也给独立出去。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="keyword">const</span> next = store.dispatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> loggerMiddleware = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'prev state'</span>, store.getState())</span><br><span class="line">  <span class="built_in">console</span>.log(action)</span><br><span class="line">  next(action)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'next state'</span>, store.getState())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exceptionMiddleware = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    next(action)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'错误信息: '</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = loggerMiddleware(store)</span><br><span class="line"><span class="keyword">const</span> exception = exceptionMiddleware(store)</span><br><span class="line">store.dispatch = exception(logger(next))</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>如果又有一个新需求，需要在打印日志前输出当前时间戳，我们又需要构造一个中间件</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timeMiddleware = <span class="function"><span class="params">store</span> =&gt;</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'time'</span>, <span class="keyword">new</span> <span class="built_in">Date</span>().getTime())</span><br><span class="line">  next(action)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = loggerMiddleware(store)</span><br><span class="line"><span class="keyword">const</span> exception = exceptionMiddleware(store)</span><br><span class="line"><span class="keyword">const</span> time = timeMiddleware(store)</span><br><span class="line">store.dispatch = exception(time(logger(next)))</span><br></pre></td></tr></table></figure>

<h3 id="中间件使用方式优化"><a href="#中间件使用方式优化" class="headerlink" title="中间件使用方式优化"></a>中间件使用方式优化</h3><p>上面的写法可知，中间件的使用方式有点繁琐，故我们需要把细节封装起来，通过扩展 createStore 来实现。<br>先来看看期望的用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 接收旧的 createStore，返回新的 createStore */</span></span><br><span class="line"><span class="keyword">const</span> newCreateStore = applyMiddleware(</span><br><span class="line">  exceptionMiddleware,</span><br><span class="line">  timeMiddleware,</span><br><span class="line">  loggerMiddleware</span><br><span class="line">)(createStore)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回了一个 dispatch 被重写过的 store */</span></span><br><span class="line"><span class="keyword">const</span> store = newCreateStore(reducer)</span><br></pre></td></tr></table></figure>

<h3 id="实现-applyMiddleware"><a href="#实现-applyMiddleware" class="headerlink" title="实现 applyMiddleware"></a>实现 applyMiddleware</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> applyMiddleware = <span class="function"><span class="keyword">function</span> (<span class="params">...middlewares</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 返回一个重写createStore的方法 */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">rewriteCreateStoreFunc</span>(<span class="params">oldCreateStore</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 返回重写后新的 createStore */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">newCreateStore</span>(<span class="params">reducer, preloadedState</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 生成 store</span></span><br><span class="line">      <span class="keyword">const</span> store = oldCreateStore(reducer, preloadedState)</span><br><span class="line">      <span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 只暴露 store 部分给中间件用的API，而不传入整个store</span></span><br><span class="line">      <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">        getState: store.getState,</span><br><span class="line">        dispatch: <span class="function"><span class="params">action</span> =&gt;</span> store.dispatch(action),</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 给每个中间件传入API</span></span><br><span class="line">      <span class="comment">// 相当于 const logger = loggerMiddleware(store)，即 const logger = loggerMiddleware(&#123; getState, dispatch &#125;)</span></span><br><span class="line">      <span class="comment">// const chain = [exception, time, logger]</span></span><br><span class="line">      <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">      <span class="comment">// 实现 exception(time((logger(dispatch))))</span></span><br><span class="line">      chain.reverse().map(<span class="function"><span class="params">middleware</span> =&gt;</span> &#123;</span><br><span class="line">        dispatch = middleware(dispatch)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 重写dispatch</span></span><br><span class="line">      store.dispatch = dispatch</span><br><span class="line">      <span class="keyword">return</span> store</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来看这一处代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chain.reverse().map(<span class="function"><span class="params">middleware</span> =&gt;</span> &#123;</span><br><span class="line">  dispatch = middleware(dispatch)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>要注意一点，中间件是顺序执行，但是 dispatch 却是反序生成的。所以在这步会把数组顺序给反序（比如 applyMiddleware(A, B, C)，因为 A 在调用时需要知道 B 的 dispatch，B 在执行时需要知道 C 的 dispatch，那么需要先知道 C 的 dispatch。）</p>
<p>官方 Redux 源码，采用了 compose 函数，我们也试试这种方式来写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> applyMiddleware = <span class="function">(<span class="params">...middlewares</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compose(fn1, fn2, fn3)</span></span><br><span class="line"><span class="comment">// fn1(fn2(fn3))</span></span><br><span class="line"><span class="comment">// 从右到左来组合多个函数: 从右到左把接收到的函数合成后的最终函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> compose = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">ret, item</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> ret(item(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们再对代码精简：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> applyMiddleware = <span class="function">(<span class="params">...middlewares</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">    <span class="keyword">let</span> dispatch = store.dispatch</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> middlewareAPI = &#123;</span><br><span class="line">      getState: store.getState,</span><br><span class="line">      dispatch: <span class="function"><span class="params">action</span> =&gt;</span> dispatch(action),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> chain = middlewares.map(<span class="function"><span class="params">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class="line">    dispatch = compose(...chain)(store.dispatch)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...store,</span><br><span class="line">      dispatch,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> compose = <span class="function">(<span class="params">...funcs</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">ret, item</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> ret(item(...args)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createStore-的处理"><a href="#createStore-的处理" class="headerlink" title="createStore 的处理"></a>createStore 的处理</h3><p>现在的问题是，有两个 createStore 了，这怎么区分，上篇我们其实已经先告知了对中间件代码处理，但具体怎么推出的，我们继续看。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 没有中间件的 createStore</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有中间件的 createStore</span></span><br><span class="line"><span class="keyword">const</span> rewriteCreateStoreFunc = applyMiddleware(</span><br><span class="line">  exceptionMiddleware,</span><br><span class="line">  timeMiddleware,</span><br><span class="line">  loggerMiddleware</span><br><span class="line">)</span><br><span class="line"><span class="keyword">const</span> newCreateStore = rewriteCreateStoreFunc(createStore)</span><br><span class="line"><span class="keyword">const</span> store = newCreateStore(counter, preloadedState)</span><br></pre></td></tr></table></figure>

<p>为了让用户用起来统一一些，我们可以很简单的使他们的使用方式一致，我们修改下 createStore 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function">(<span class="params">reducer, preloadedState, rewriteCreateStoreFunc</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果有 rewriteCreateStoreFunc，那就采用新的 createStore</span></span><br><span class="line">  <span class="keyword">if</span> (rewriteCreateStoreFunc) &#123;</span><br><span class="line">    <span class="keyword">const</span> newCreateStore = rewriteCreateStoreFunc(createStore)</span><br><span class="line">    <span class="keyword">return</span> newCreateStore(reducer, preloadedState)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过 Redux 源码 rewriteCreateStoreFunc 换了个名字，还加了判断，也就是我们上篇的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以中间件的用法为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = createStore(counter, <span class="comment">/* preloadedState可选 */</span> applyMiddleware(logger))</span><br></pre></td></tr></table></figure>

<h2 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h2><p>如果我们做的项目很大，有大量 state，那么维护起来很麻烦。Redux 提供了 combineReducers 这个方法，作用是把多个 reducer 合并成一个 reducer， 每个 reducer 负责独立的模块。</p>
<p>我们用一个新例子来举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initCounterState = &#123;</span><br><span class="line">  value: <span class="number">10</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> initInfoState = &#123;</span><br><span class="line">  name: <span class="string">'jacky'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">  info: infoReducer,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// counter reducer处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">counterReducer</span>(<span class="params">state = initCounterState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        value: state.value + <span class="number">1</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        value: state.value - <span class="number">1</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infoReducer</span>(<span class="params">state = initInfoState, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'FULL_NAME'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...state,</span><br><span class="line">        name: state.name + <span class="string">' lin'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = store.getState()</span><br><span class="line"><span class="comment">// 一开始counter为：10，info为 jacky</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`一开始counter为：<span class="subst">$&#123;init.counter.value&#125;</span>，info为 <span class="subst">$&#123;init.info.name&#125;</span>`</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  store.getState()</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(listener) <span class="comment">// 监听state的改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// counterReducer</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// infoReducer</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'FULL_NAME'</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行完counter为：11，info为jacky lin</span></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">  <span class="string">`执行完counter为：<span class="subst">$&#123;store.getState().counter.value&#125;</span>，info为<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">    store.getState().info.name</span></span></span><br><span class="line"><span class="string"><span class="subst">  &#125;</span>`</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>我们来尝试下如何实现这个 API，</p>
<p>首先要把一个函数里的所有 reducers 循环执行一遍，并且这个函数要遵循(state, action) =&gt; newState 格式。还需要把每个 reducer 的 initState 合并成一个 rootState。<br>实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">combineReducers</span>(<span class="params">reducers</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// reducerKeys = ['counter', 'info']</span></span><br><span class="line">  <span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line">  <span class="comment">// 返回合并后的新的reducer函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">combination</span>(<span class="params">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 生成的新的state</span></span><br><span class="line">    <span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历执行所有的reducers，整合成为一个新的state</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> key = reducerKeys[i]</span><br><span class="line">      <span class="keyword">const</span> reducer = reducers[key]</span><br><span class="line">      <span class="comment">// 之前的 key 的 state</span></span><br><span class="line">      <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">      <span class="comment">// 执行 分 reducer，获得新的state</span></span><br><span class="line">      <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line"></span><br><span class="line">      nextState[key] = nextStateForKey</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="replaceReducer"><a href="#replaceReducer" class="headerlink" title="replaceReducer"></a>replaceReducer</h2><blockquote>
<p>在大型 Web 应用程序中，通常需要将应用程序代码拆分为多个可以按需加载的 JS 包。 这种称为“代码分割”的策略通过减小初次加载时的 JS 的包的大小，来提高应用程序的性能。</p>
</blockquote>
<p>reducer 拆分后，和组件是一一对应的。我们就希望在做按需加载的时候，reducer 也可以跟着组件在必要的时候再加载，然后用新的 reducer 替换老的 reducer。但实际上只有一个 root reducer 函数, 如果要实现的话就可以用 replaceReducer 这个函数，实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> createStore = <span class="function"><span class="keyword">function</span> (<span class="params">reducer, initState</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> replaceReducer = <span class="function"><span class="params">nextReducer</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nextReducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the nextReducer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    reducer = nextReducer</span><br><span class="line">    <span class="comment">// 刷新一遍 state 的值，新来的 reducer 把自己的默认状态放到 state 树上去</span></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="built_in">Symbol</span>() &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    replaceReducer,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*生成新的reducer*/</span></span><br><span class="line"><span class="keyword">const</span> nextReducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">  info: infoReducer,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">/*replaceReducer*/</span></span><br><span class="line">store.replaceReducer(nextReducer)</span><br></pre></td></tr></table></figure>

<h2 id="bindActionCreators"><a href="#bindActionCreators" class="headerlink" title="bindActionCreators"></a>bindActionCreators</h2><p>bindActionCreators 一般比较少用到，在 react-redux 的 connect 函数实现会用到</p>
<p>会使用到 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 dispatch 或 Redux store 传给它。</p>
<p>我们通过普通的方式来 隐藏 dispatch 和 actionCreator 试试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  counter: counterReducer,</span><br><span class="line">  info: infoReducer,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 action 的函数就叫 actionCreator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'INCREMENT'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type: <span class="string">'FULL_NAME'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  increment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> store.dispatch(increment.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> store.dispatch(getName.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 其他地方在实现自增的时候，根本不知道 dispatch，actionCreator等细节</span></span><br><span class="line">actions.increment() <span class="comment">// 自增</span></span><br><span class="line">actions.getName() <span class="comment">// 获得全名</span></span><br></pre></td></tr></table></figure>

<p>把 actions 生成时候的公共代码提取出来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = bindActionCreators(&#123; increment, getName &#125;, store.dispatch)</span><br></pre></td></tr></table></figure>

<p>bindActionCreators 的实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回包裹 dispatch 的函数, 将 actionCreator 转化成 dispatch 形式</span></span><br><span class="line"><span class="comment">// eg. &#123; addNumAction &#125;  =&gt;  (...args) =&gt; dispatch(addNumAction(args))</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span>(<span class="params">actionCreator, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(actionCreator.apply(<span class="keyword">this</span>, args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bindActionCreators</span>(<span class="params">actionCreators, dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// actionCreators 必须是 function 或者 object</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreators !== <span class="string">'object'</span> || actionCreators === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(actionCreators)</span><br><span class="line">  <span class="keyword">const</span> boundActionCreators = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">const</span> actionCreator = actionCreators[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> actionCreator === <span class="string">'function'</span>) &#123;</span><br><span class="line">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> boundActionCreators</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能大家看到这里有点懵逼，让我们来回忆下 react-redux 中 connect 函数的用法，<br>比如有这样一个 actionCreators</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// actionCreators.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNumAction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">type</span>: <span class="string">'ADD_NUM'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Demo.js：在需要用到 store 数据的组件，如 Demo 组件底部我们用 connect 函数连接，如下:</span></span><br><span class="line"><span class="keyword">import</span> &#123; addNumAction &#125; <span class="keyword">from</span> <span class="string">'./actionCreators'</span></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;</span><br><span class="line">  addNum() &#123;</span><br><span class="line">    dispatch(addNumAction())</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Demo)</span><br></pre></td></tr></table></figure>

<p>然后通过页面的按钮来出发 action 为 ADD_NUM 对应事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="keyword">this</span>.props.addNum&#125;&gt;增加<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>

<p>但除了上面的用法，mapDispatchToProps 也可以这样用，直接传入一个对象，都没有 dispatch 方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, &#123; addNumAction &#125;)(Demo)</span><br></pre></td></tr></table></figure>

<p>然后只需触发 addNumAction 就能实现和上面一样的效果。</p>
<p>为什么可以不传，当你传入对象的时候， connect 函数会判断，大致代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dispatchToProps</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> mapDispatchToProps === <span class="string">'function'</span>) &#123;</span><br><span class="line">  dispatchToProps = mapDispatchToProps(store.dispatch)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 传递了一个 actionCreator 对象过来</span></span><br><span class="line">  dispatchToProps = bindActionCreators(mapDispatchToProps, store.dispatch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就使用了 bindActionCreators 函数，它就是把你传入的 actionCreator 再包一层 dispatch 方法，即</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; addNumAction &#125;  =&gt;  <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(addNumAction(args))</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Redux 实现讲到这里就结束了，把原理搞懂了确实对 Redux 的理解加深了好多，之后会继续写相关插件的实现，如 react-redux 等。</p>
<p>参考资料：</p>
<p><a href="https://github.com/brickspert/blog/issues/22" target="_blank" rel="noopener">完全理解 redux（从零实现一个 redux）</a></p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励吧~</li>
</ul>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>总结JS数组方法</title>
    <url>/2020/05/10/%E6%80%BB%E7%BB%93JS%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在日常开发中，使用数组方法的情况是很多的。但总有几个方法用得不是很多，就容易忘记具体用法，于是，今天打算做下总结笔记，回顾数组方法。</p>
<a id="more"></a>

<h2 id="改变原数组的方法（9-个）"><a href="#改变原数组的方法（9-个）" class="headerlink" title="改变原数组的方法（9 个）"></a>改变原数组的方法（9 个）</h2><h3 id="push-和-pop"><a href="#push-和-pop" class="headerlink" title="push()和 pop()"></a>push()和 pop()</h3><p>共同点：<strong>数组尾部操作的方法</strong></p>
<h4 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h4><ul>
<li>用法：push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。</li>
<li>返回值：把指定的值添加到数组后的新长度。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.push(newEle1, newEle2, ..., newEleX)  要添加到数组末尾的元素</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">arr.push(<span class="number">4</span>) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 4]</span></span><br></pre></td></tr></table></figure>

<h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><ul>
<li>用法：pop() 方法用于删除并返回数组的最后一个元素。</li>
<li>返回值：arrayObject 的最后一个元素</li>
<li>说明：如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.pop()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.pop() <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<h3 id="shift-和-unshift"><a href="#shift-和-unshift" class="headerlink" title="shift()和 unshift()"></a>shift()和 unshift()</h3><p>共同点：<strong>数组首部操作的方法</strong></p>
<h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><ul>
<li>用法：用于把数组的第一个元素从其中删除，并返回第一个元素的值。</li>
<li>返回值：数组原来的第一个元素的值。</li>
<li>说明：如果数组是空的，那么 shift() 方法将不进行任何操作，返回 undefined 值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.shift()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.shift() <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>

<h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><ul>
<li>用法：可向数组的开头添加一个或更多元素，并返回新的长度。</li>
<li>返回值：arrayObject 的新长度。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.unshift(newEle1, newEle2, ..., newEleX)  要添加到数组首部的元素</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">arr.unshift(<span class="number">100</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [100, 1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<h3 id="reverse-和-sort"><a href="#reverse-和-sort" class="headerlink" title="reverse()和 sort()"></a>reverse()和 sort()</h3><p>共同点：<strong>重排序的方法</strong></p>
<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><ul>
<li>用法：用于颠倒数组中元素的顺序。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.reverse()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">arr.reverse()</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ['c', 'b', 'a']</span></span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><ul>
<li>用法：用于对数组的元素进行排序。</li>
<li>说明：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.sort(sortby) 可选。规定排序顺序。必须是函数。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'monkey'</span>, <span class="string">'jacky'</span>, <span class="string">'tom'</span>, <span class="string">'john'</span>]</span><br><span class="line">arr.sort()</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ['jacky', 'john', 'monkey', 'tom']</span></span><br></pre></td></tr></table></figure>

<ul>
<li>比较函数的两个参数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort的比较函数有两个默认参数，接受参数然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</span><br><span class="line"></span><br><span class="line">若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。</span><br><span class="line">若 a 等于 b，则返回 0。</span><br><span class="line">若 a 大于 b，则返回一个大于 0 的值。</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment">// 升序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 3, 4, 5, 7, 8, 100]</span></span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b - a</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [100, 8, 7, 5, 4, 3, 1]</span></span><br></pre></td></tr></table></figure>

<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><ul>
<li>用法：向/从数组中添加/删除项目，然后返回被删除的项目。</li>
<li>返回值：包含被删除项目的新数组，如果有的话。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.splice(index, howmany, item1, ....., itemX)</span><br><span class="line"><span class="comment">// index:必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</span></span><br><span class="line"><span class="comment">// howmany:必需。要删除的项目数量。如果设置为 0，则不会删除项目。</span></span><br><span class="line"><span class="comment">// item, ..., itemX:可选。向数组添加的新项目。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">arr.splice(<span class="number">1</span>, <span class="number">1</span>) <span class="comment">// 删除数组下标为 1 的元素，删除一个</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line">arr.splice(<span class="number">-3</span>, <span class="number">2</span>) <span class="comment">// 从倒数第三个元素开始删除，删除两个</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 3, 4, 5, 8]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除并添加</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>) <span class="comment">// 删除数组下标为 0 的元素，删除两个；并在数组下标为0的位置添加100</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [100, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>不删除只添加</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">arr.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>) <span class="comment">// 在数组下标为0的位置添加9 10 11</span></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [9, 10, 11, 1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6：fill"><a href="#ES6：fill" class="headerlink" title="ES6：fill()"></a>ES6：fill()</h3><ul>
<li>用法：用于将一个固定值替换数组的元素。</li>
<li>返回值：修改后的数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.fill(value, start, end)</span><br><span class="line"><span class="comment">// value:必需。填充的值。</span></span><br><span class="line"><span class="comment">// start:可选。开始填充位置。</span></span><br><span class="line"><span class="comment">// end:	可选。停止填充位置 (默认为 arrayObject.length)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 填充 "replace" 到数组的第三和第四个元素：</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line">arr.fill(<span class="string">'replace'</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ["a", "b", "replace", "replace", "e"]</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6：copyWithin"><a href="#ES6：copyWithin" class="headerlink" title="ES6：copyWithin()"></a>ES6：copyWithin()</h3><ul>
<li>用法：用于从数组的指定位置拷贝元素到数组的另一个指定位置中。</li>
<li>返回值：修改后的数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.copyWithin(target, start, end)</span><br><span class="line"><span class="comment">// value:必需。复制到指定目标索引位置。。</span></span><br><span class="line"><span class="comment">// start:可选。元素复制的起始位置。</span></span><br><span class="line"><span class="comment">// end:	可选。停止复制的索引位置 (默认为 arrayObject.length)。如果为负值，表示倒数。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line">arr.copyWithin(<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// ["a", "b", "a", "b", "e"]</span></span><br></pre></td></tr></table></figure>

<h2 id="不改变原数组的方法（8-个）"><a href="#不改变原数组的方法（8-个）" class="headerlink" title="不改变原数组的方法（8 个）"></a>不改变原数组的方法（8 个）</h2><ul>
<li>注: 数组的每一项是简单数据类型，且未直接操作数组的情况下</li>
</ul>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><ul>
<li>用法：从已有的数组中返回选定的元素。</li>
<li>返回值：返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.slice(start, end)</span><br><span class="line"><span class="comment">// start:必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。</span></span><br><span class="line"><span class="comment">// end:可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.slice()) <span class="comment">// ["a", "b", "c", "d", "e"]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">2</span>)) <span class="comment">// ["c", "d", "e"]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">0</span>, <span class="number">3</span>)) <span class="comment">// ["a", "b", "c"]</span></span><br></pre></td></tr></table></figure>

<h3 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h3><ul>
<li>用法：方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.indexOf(item, start)</span><br><span class="line"><span class="comment">// start:必须。查找的元素。</span></span><br><span class="line"><span class="comment">// end:	可选的整数参数。规定在数组中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'c'</span>)) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'a'</span>, <span class="number">1</span>)) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h3><ul>
<li>用法：返回一个指定的元素在数组中最后出现的位置，从该字符串的后面向前查找。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.lastIndexOf(item, start)</span><br><span class="line"><span class="comment">// start:必须。查找的元素。</span></span><br><span class="line"><span class="comment">// end:	可选的整数参数。规定在数组中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。则将从字符串的最后一个字符处开始检索。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'a'</span>)) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'b'</span>, <span class="number">2</span>)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><ul>
<li>用法：用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。</li>
<li>返回值：返回一个字符串。该字符串是通过把 arrayObject 的每个元素转换为字符串，然后把这些字符串连接起来，在两个元素之间插入 separator 字符串而生成的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.join(separator)</span><br><span class="line"><span class="comment">// separator:可选。指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.join()) <span class="comment">// a,b,c,b,e,a</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.join(<span class="string">'.'</span>)) <span class="comment">// a.b.c.b.e.a</span></span><br></pre></td></tr></table></figure>

<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><ul>
<li>用法：用于连接两个或多个数组。</li>
<li>返回值：返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.concat(arrayX, arrayX, ......, arrayX)</span><br><span class="line"><span class="comment">// arrayX: 必需。该参数可以是具体的值，也可以是数组对象。可以是任意多个。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(<span class="number">4</span>, <span class="number">5</span>)) <span class="comment">// [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1.concat(arr2)) <span class="comment">// [1, 2, 3, 6, 7, 8]</span></span><br></pre></td></tr></table></figure>

<h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><ul>
<li>用法：把数组转换为字符串，并返回结果。</li>
<li>返回值：arrayObject 的字符串表示。返回值与没有参数的 join() 方法返回的字符串相同。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.toString()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.toString()) <span class="comment">// a,b,c,b,e,a</span></span><br></pre></td></tr></table></figure>

<p>相对 join() 方法，更推荐使用 join() 方法，不推荐使用该方法</p>
<h3 id="toLocaleString-NaN"><a href="#toLocaleString-NaN" class="headerlink" title="toLocaleString()"></a>toLocaleString()</h3><ul>
<li>用法：把数组转换为本地字符串。</li>
<li>返回值：arrayObject 的本地字符串表示。</li>
<li>说明：首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.toLocaleString()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="number">23</span>, &#123; <span class="attr">name</span>: <span class="string">'jacky'</span> &#125;, <span class="keyword">new</span> <span class="built_in">Date</span>()]</span><br><span class="line"><span class="built_in">console</span>.log(arr.toLocaleString()) <span class="comment">// a,23,[object Object],2020/5/10 上午10:58:37</span></span><br></pre></td></tr></table></figure>

<h3 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h3><ul>
<li>用法：用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。</li>
<li>返回值：arrayObject 的本地字符串表示。</li>
<li>说明：首先调用每个数组元素的 toLocaleString() 方法，然后使用地区特定的分隔符把生成的字符串连接起来，形成一个字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.includes(searchElement, fromIndex)</span><br><span class="line"><span class="comment">// searchElement：必须。需要查找的元素值。</span></span><br><span class="line"><span class="comment">// fromIndex：可选。从该索引处开始查找 searchElement。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜索。默认为 0。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">2</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">4</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">3</span>, <span class="number">3</span>)) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="number">3</span>, <span class="number">-1</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历方法"><a href="#遍历方法" class="headerlink" title="遍历方法"></a>遍历方法</h2><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><ul>
<li>用法：用于调用数组的每个元素，并将元素传递给回调函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。传递给函数的值一般用 "<span class="title">this</span>" 值。如果这个参数为空， "<span class="title">undefined</span>" 会传递给 "<span class="title">this</span>" 值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item) <span class="comment">// 1 2 4 6 8</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item, index, arr)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 0 [1, 2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 2 1 [1, 2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 4 2 [1, 2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 6 3 [1, 2, 4, 6, 8]</span></span><br><span class="line"><span class="comment">// 8 4 [1, 2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>

<h3 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h3><ul>
<li>用法：用于检测数组所有元素是否都符合指定条件（通过函数提供）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.every(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。对象作为该执行回调时使用，传递给函数，用作 "<span class="title">this</span>" 的值。</span></span><br><span class="line"><span class="function">如果省略了 <span class="title">thisValue</span> ，"<span class="title">this</span>" 的值为 "<span class="title">undefined</span>"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>every() 方法使用指定函数检测数组中的所有元素：</p>
<ul>
<li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</li>
<li>如果所有元素都满足条件，则返回 true。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res1 = arr.every(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 检测数组中的所有元素是否大于2</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> res2 = arr.every(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 检测数组中的所有元素是否大于10</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(res2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h3><ul>
<li>用法：用于检测数组中的元素是否满足指定条件（函数提供）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.some(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。对象作为该执行回调时使用，传递给函数，用作 "<span class="title">this</span>" 的值。</span></span><br><span class="line"><span class="function">如果省略了 <span class="title">thisValue</span> ，"<span class="title">this</span>" 的值为 "<span class="title">undefined</span>"</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>some() 方法会依次执行数组的每个元素：</p>
<ul>
<li>如果有一个元素满足条件，则表达式返回 true , 剩余的元素不会再执行检测。</li>
<li>如果没有满足条件的元素，则返回 false。</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res1 = arr.some(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 检测数组中是否有一个元素是否大于10</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> res2 = arr.some(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 检测数组中是否有一个元素是否大于100</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">100</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(res2) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><ul>
<li>用法：创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</li>
<li>返回值：返回数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.filter(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。对象作为该执行回调时使用，传递给函数，用作 "<span class="title">this</span>" 的值。</span></span><br><span class="line"><span class="function">如果省略了 <span class="title">thisValue</span> ，"<span class="title">this</span>" 的值为 "<span class="title">undefined</span>"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res1 = arr.filter(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回数组中所有大于5的元素</span></span><br><span class="line">  <span class="keyword">return</span> num &gt; <span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> res2 = arr.filter(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回数组中所有小于5的元素</span></span><br><span class="line">  <span class="keyword">return</span> num &lt; <span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res1) <span class="comment">// [6, 8, 10, 12]</span></span><br><span class="line"><span class="built_in">console</span>.log(res2) <span class="comment">// [4]</span></span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><ul>
<li>用法：返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.map(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, arr</span>), <span class="title">thisValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">index</span>：可选。当前元素的索引值。</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">thisValue</span>：可选。对象作为该执行回调时使用，传递给函数，用作 "<span class="title">this</span>" 的值。</span></span><br><span class="line"><span class="function">如果省略了 <span class="title">thisValue</span> ，"<span class="title">this</span>" 的值为 "<span class="title">undefined</span>"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.map(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 数组每个元素都乘10</span></span><br><span class="line">  <span class="keyword">return</span> num * <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// [40, 60, 80, 100, 120]</span></span><br></pre></td></tr></table></figure>

<h2 id="数组归并方法"><a href="#数组归并方法" class="headerlink" title="数组归并方法"></a>数组归并方法</h2><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><ul>
<li>用法：接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</li>
<li>reduce() 可以作为一个高阶函数，用于函数的 compose。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">total, currentValue, currentIndex, arr</span>), <span class="title">initialValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">total</span>：必需。初始值, 或者计算结束后的返回值。</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">currentIndex</span>：可选。当前元素的索引</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">initialValue</span>：可选。传递给函数的初始值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total + num</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<h3 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h3><ul>
<li>用法：方法的功能和 reduce() 功能是一样的，不同的是 reduceRight() 从数组的末尾向前将数组中的数组项做累加。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arrayObject.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">total, currentValue, currentIndex, arr</span>), <span class="title">initialValue</span>)</span></span><br><span class="line"><span class="function">// <span class="title">total</span>：必需。初始值, 或者计算结束后的返回值。</span></span><br><span class="line"><span class="function">// <span class="title">currentValue</span>：必需。当前元素</span></span><br><span class="line"><span class="function">// <span class="title">currentIndex</span>：可选。当前元素的索引</span></span><br><span class="line"><span class="function">// <span class="title">arr</span>：可选。可选。当前元素所属的数组对象。</span></span><br><span class="line"><span class="function">// <span class="title">initialValue</span>：可选。传递给函数的初始值</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">20</span>]</span><br><span class="line"><span class="keyword">let</span> res = arr.reduceRight(<span class="function">(<span class="params">total, num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total - num</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li>
</ul>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈React的Context-API</title>
    <url>/2020/04/28/%E6%B5%85%E8%B0%88React%E7%9A%84Context-API/</url>
    <content><![CDATA[<p>上下文(Context) 提供了在组件之间共享这些值的方法，而不必在树的每个层级显式传递一个 prop 。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一般情况下，在你没有绝对把握用好和必须的场景下，是不推荐使用的。</p>
<p>但是我们依然间接的使用着它，比如许多官方依赖在使用，如：react-redux, mobx-react，react-router。我们需要它功能的时候，更多是靠第三方依赖库就能实现，而不是自己手动写 context。但是，依然需要理解它，对用它的一些依赖库源码理解很有帮助。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: <span class="string">'GrandPa组件的信息'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Father info=&#123;<span class="keyword">this</span>.state.info&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Father extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Son info=&#123;this.props.info&#125; /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Son extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;div&gt;我是Son组件，拿到信息为：&#123;this.props.info&#125;&lt;/</span>div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Grandpa</span><br></pre></td></tr></table></figure>

<p>最后页面输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是Son组件，拿到信息为：GrandPa组件的信息</span><br></pre></td></tr></table></figure>

<p>我们会发现这样的缺点是一层一层传值，如果有更多层级和更多数据的话，会让代码看起来很不整洁，如果中间哪个组件忘了传值基本就完了；而且 Father 组件也并没有用到 info 值，只是将值传给 Son 组件。</p>
<p>如果使用 context，就能帮我们解决这个层级不停传值的问题。</p>
<p>context 有旧版和新版之分，以 React v16.3.0 版本划分。</p>
<h2 id="旧版-Context-API"><a href="#旧版-Context-API" class="headerlink" title="旧版 Context API"></a>旧版 Context API</h2><p>我们先来说下旧版 context API</p>
<p>将代码改成如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: <span class="string">'GrandPa组件的信息'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">info</span>: <span class="keyword">this</span>.state.info &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Father /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 声明Context对象属性</span></span><br><span class="line"><span class="regexp">Grandpa.childContextTypes = &#123;</span></span><br><span class="line"><span class="regexp">  info: PropTypes.string,</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Father extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Son /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Son extends Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return &lt;div&gt;我是Son组件，拿到信息为：&#123;this.context.info&#125;&lt;/</span>div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据约定好的参数类型声明</span></span><br><span class="line">Son.contextTypes = &#123;</span><br><span class="line">  info: PropTypes.string,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Grandpa</span><br></pre></td></tr></table></figure>

<p>对 PropTypes 类型检查，还可以写成下面这种写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    info: PropTypes.string,</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: <span class="string">'GrandPa组件的信息'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">info</span>: <span class="keyword">this</span>.state.info &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Father /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在需要传出去的 context 值和需要接收 context 值都要进行类型检查判断。</p>
<p>正常用这个 api 可能没什么问题，但如果中间哪个组件用到<code>shouldComponentUpdate</code>方法的话，就很可能出现问题。</p>
<p>三个组件的层级关系如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;GrandPa&gt;</span><br><span class="line">  &lt;Father&gt;</span><br><span class="line">    &lt;Son /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Father&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>GrandPa&gt;</span><br></pre></td></tr></table></figure>

<p>如果在 GrandPa 组件设置按钮点击可以更新 info 的值，即通过<code>this.setState({info: &#39;改变值&#39;})</code>方法<br>更新 Context：<br>那么</p>
<ul>
<li>GrandPa 组件通过 setState 设置新的 Context 值同时触发子组件重新 render。</li>
<li>Father 组件重新 render。</li>
<li>Son 组件重新 render，并拿到更新后的 Context。</li>
</ul>
<p>假如在 Father 组件添加函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Father 并不依赖任何值，所以我们默认让它无需重新 render。但是，这会导致 Son 组件也不会重新 render，即无法获取到最新的 Context 值。</p>
<p>这样的不确定性对于目标组件来说是完全不可控的，也就是说目标组件无法保证自己每一次都可以接收到更新后的 Context 值。这是旧版 API 存在的一个大问题。</p>
<p>而新版 API 解决了这个问题，我们来看下新版 API 怎么写的</p>
<h2 id="新版-Context-API"><a href="#新版-Context-API" class="headerlink" title="新版 Context API"></a>新版 Context API</h2><blockquote>
<p>新版 Context 新增了 creactContext() 方法用来创建一个 context 对象。这个对象包含两个组件，一个是 Provider（生产者），另一个是 Consumer（消费者）。</p>
</blockquote>
<ol>
<li>Provider 和 Consumer 必须来自同一个 Context 对象，即一个由 React.createContext()创建的 Context 对象。</li>
<li>React.createContext()方法接收一个参数做默认值，当 Consumer 外层没有对应的 Provider 时就会使用该默认值。</li>
<li>Provider 组件使用 Object.is 方法判断 prop 值是否发生改变，当 prop 的值改变时，其内部组件树中对应的 Consumer 组件会接收到新值并重新渲染。此过程不受 shouldComponentUpdete 方法的影响。</li>
<li>Consumer 组件接收一个函数作为 children prop 并利用该函数的返回值生成组件树的模式被称为 Render Props 模式。</li>
</ol>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ol>
<li>首先创建一个 context 对象</li>
</ol>
<blockquote>
<p>React.createContext 方法用于创建一个 Context 对象。该对象包含 Provider 和 Consumer 两个属性，分别为两个 React 组件。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> InfoContext = React.createContext(<span class="string">''</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 Provider 组件生成一个 context</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandpa</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: <span class="string">'GrandPa组件的信息'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;InfoContext.Provider value=&#123;&#123; <span class="attr">info</span>: <span class="keyword">this</span>.state.info &#125;&#125;&gt;</span><br><span class="line">        &lt;Father /&gt;</span><br><span class="line">      &lt;<span class="regexp">/InfoContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 Consumer 组件获取 context 对象的值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;InfoContext.Consumer&gt;</span><br><span class="line">        &#123;(value) =&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>我是Son组件，拿到信息为：&#123;value.info&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &lt;<span class="regexp">/InfoContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个迷你Redux（基础版）</title>
    <url>/2020/04/22/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E4%BD%A0Redux%EF%BC%88%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%89/</url>
    <content><![CDATA[<p>本文从将从Redux原理出发，一步步自己实现一个简单的Redux，主要目的是了解Redux内部之间的联系。看本文之前先要知道Redux是怎么用的，对Redux用法不会讲解太多。</p>
<a id="more"></a>

<h2 id="Redux介绍"><a href="#Redux介绍" class="headerlink" title="Redux介绍"></a>Redux介绍</h2><p>首先要知道的是，Redux 和 React 没有关系，Redux 可以用在任何框架中。<br>Redux 是一个JavaScript 状态管理器，是一种新型的前端“架构模式”。</p>
<p>还有通常与redux一起用的一个库——react-redux， 它就是把 Redux 这种架构模式和 React.js 结合起来的一个库，就是 Redux 架构在 React.js 中的体现。</p>
<h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ol>
<li>Web 应用是一个状态机，视图与状态是一一对应的。</li>
<li>所有的状态，保存在一个对象里面。</li>
</ol>
<h2 id="何时使用Redux"><a href="#何时使用Redux" class="headerlink" title="何时使用Redux"></a>何时使用Redux</h2><ol>
<li>用户的使用方式复杂</li>
<li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li>
<li>多个用户之间可以协作</li>
<li>与服务器大量交互，或者使用了WebSocket</li>
<li>View要从多个来源获取数据</li>
</ol>
<p>从组件的角度看：</p>
<ol>
<li>某个组件的状态，需要共享</li>
<li>某个状态需要在任何地方都可以拿到</li>
<li>一个组件需要改变全局状态</li>
<li>一个组件需要改变另一个组件的状态</li>
</ol>
<h2 id="Redux工作流程"><a href="#Redux工作流程" class="headerlink" title="Redux工作流程"></a>Redux工作流程</h2><p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718ce1ceca204e3?w=898&h=421&f=png&s=148790" alt=""></p>
<ol>
<li>Redux 将整个应用状态(state)存储到一个地方(通常我们称其为 store)</li>
<li>当我们需要修改状态时，必须派发(dispatch)一个 action( action 是一个带有 type 字段的对象)</li>
<li>专门的状态处理函数 reducer 接收旧的 state 和 action ，并会返回一个新的 state</li>
<li>通过 subscribe 设置订阅，每次派发动作时，通知所有的订阅者。</li>
</ol>
<p>从这个流程中可以看出，Redux 的核心就是一个 观察者 模式。一旦 store 发生了变化就会通知所有的订阅者，视图(在这里是react组件)接收到通知之后会进行重新渲染。</p>
<h2 id="Redux案例"><a href="#Redux案例" class="headerlink" title="Redux案例"></a>Redux案例</h2><p>为了简化说明，我用和官网差不多的例子改写来作案例<br><a href="https://redux.js.org/introduction/getting-started" target="_blank" rel="noopener">官网redux demo</a></p>
<p>新建一个文件redux.js，然后直接引入，观察控制台输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">    value: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// reducer处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span> (<span class="params">state = defaultState, action</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(state, action)</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'INCREMENT'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                value: state.value + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'DECREMENT'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                value: state.value - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = store.getState()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`一开始数字为：<span class="subst">$&#123;init.value&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> current = store.getState()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`当前数字为：<span class="subst">$&#123;current.value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(listener) <span class="comment">// 监听state的改变</span></span><br><span class="line"></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line"><span class="comment">// 当前数字为：11</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'INCREMENT'</span> &#125;)</span><br><span class="line"><span class="comment">// 当前数字为：12</span></span><br><span class="line">store.dispatch(&#123; <span class="attr">type</span>: <span class="string">'DECREMENT'</span> &#125;)</span><br><span class="line"><span class="comment">// 当前数字为：11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;value: 10&#125; &#123;type: &quot;@@redux&#x2F;INIT1.a.7.g.7.t&quot;&#125;</span><br><span class="line">一开始数字为：10</span><br><span class="line">&#123;value: 10&#125; &#123;type: &quot;INCREMENT&quot;&#125;</span><br><span class="line">当前数字为：11</span><br><span class="line">&#123;value: 11&#125; &#123;type: &quot;INCREMENT&quot;&#125;</span><br><span class="line">当前数字为：12</span><br><span class="line">&#123;value: 12&#125; &#123;type: &quot;DECREMENT&quot;&#125;</span><br><span class="line">当前数字为：11</span><br></pre></td></tr></table></figure>
<p>所有对数据的操作必须通过 dispatch 函数，它接受一个参数action，action是一个普通的JavaScript对象，action必须包含一个<code>type</code>字段，告诉它要修改什么，只有它允许才能修改。</p>
<p>在每次调用进来reducer函数我们都打印了state和action，我们手动通过store.dispatch方法派发了三次action，但你会发现输出了四次.这是因为Redux内部初始化就自动执行了一次dispatch方法，可以看到第一次执行它的type对我们数据来说是没有影响的（因为type取值<code>@@redux/INIT1.a.7.g.7.t</code>，我们自己redux的数据type不会取名成这个样子，所以不会跟它重复），即默认输出state值</p>
<h2 id="动手实现一个Redux"><a href="#动手实现一个Redux" class="headerlink" title="动手实现一个Redux"></a>动手实现一个Redux</h2><ol>
<li>首先要手动实现一个Redux之前，先看看有上述代码涉及到Redux什么方法，首先引入了<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#39;redux&#39;</span><br><span class="line">&#x2F;&#x2F; 传入reducer</span><br><span class="line">const store &#x3D; createStore(reducer)</span><br></pre></td></tr></table></figure>
createStore 会返回一个对象，这个对象包含三个方法，于是我们可以列出Redux雏形。</li>
</ol>
<p>新建mini-redux.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export function createStore (reducer) &#123;</span><br><span class="line"></span><br><span class="line">    const getState &#x3D; () &#x3D;&gt; &#123;&#125;</span><br><span class="line">    const subscribe &#x3D; () &#x3D;&gt; &#123;&#125;</span><br><span class="line">    const dispatch &#x3D; () &#x3D;&gt; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    return &#123; </span><br><span class="line">        getState, </span><br><span class="line">        subscribe, </span><br><span class="line">        dispatch </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>store.getState()用于获取 state 数据，其实就是简单地把 state 参数返回。于是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        getState</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>dispatch方法会接收一个action，执行会调用 <code>reducer</code> 返回一个新状态</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        getState,</span><br><span class="line">        dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 subscribe 设置监听函数（设置订阅），一旦 state 发生变化，就自动执行这个函数（通知所有的订阅者）。</p>
</li>
</ol>
<p>怎么实现呢？我们可以直接使用subscribe函数把你要监听的事件添加到数组, 然后执行dispatch方法的时候把listeners数组的监听函数给执行一遍。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听函数，可添加多个</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        currentListeners.push(listener)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">        currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        getState,</span><br><span class="line">        subscribe,</span><br><span class="line">        dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻开一开始我们那个Redux例子，其实就是把<code>store.getState()</code>添加进来，dispatch派发一个action后，reducer执行返回新的state，并执行了监听函数<code>store.getState()</code>，state的值就发生变化了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listener</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> current = store.getState()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`当前数字为：<span class="subst">$&#123;current.value&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(listener) <span class="comment">// 监听state的改变</span></span><br></pre></td></tr></table></figure>
<p>上述代码，跟React依然没有关系，只是纯属Redux例子。但想一想当我们把Redux和React一起用的时候，还会多做这么一步。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = store.getState()</span><br><span class="line">    <span class="keyword">this</span>.storeChange = <span class="keyword">this</span>.storeChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    store.subscribe(<span class="keyword">this</span>.storeChange)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">storeChange () &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(store.getState())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在React里面监听的方法，还要用<code>this.setState()</code>, 这是因为React中state的改变必须依赖于<code>this.setState</code>方法。所以对于 React 项目，就是组件的render方法或setState方法放入listen（监听函数），才会实现视图的自动渲染，改变页面中的state值。</p>
<p>最后一步，注意我们上面说的，当初始化的时候，dispatch会先自动执行一次，继续改代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        currentListeners.push(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">        currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尽量写得复杂，使不会与我们自定义的action有重复可能</span></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'@@mini-redux/~GSDG4%FDG#*&amp;'</span> &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        getState, </span><br><span class="line">        subscribe, </span><br><span class="line">        dispatch </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写到这里，我们把引入的redux替换我们写的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#39;.&#x2F;mini-redux&#39;</span><br></pre></td></tr></table></figure>
<p>当我们执行的时候，发现结果并不如我们所愿：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#125; &#123;type: &quot;@@mini-redux&#x2F;~GSDG4%FDG#*&amp;&quot;&#125;</span><br><span class="line">一开始数字为：undefined</span><br><span class="line">&#123;&#125; &#123;type: &quot;INCREMENT&quot;&#125;</span><br><span class="line">当前数字为：NaN</span><br><span class="line">&#123;type: &quot;INCREMENT&quot;&#125;</span><br><span class="line">当前数字为：NaN</span><br><span class="line">&#123;value: NaN&#125; &#123;type: &quot;DECREMENT&quot;&#125;</span><br><span class="line">当前数字为：NaN</span><br></pre></td></tr></table></figure>
<p>这个怎么回事呢？因为我们写的redux一开始就给state赋值为{}，在事实state初始值是由外部传入的，通常我们自己写的时候会设置默认值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">    value: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span> (<span class="params">state = defaultState, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但在我们Redux实现中却把它手动置为空对象，在这里我们暂时解决方法就是不给它赋值，让它为undefined，这样reducer的默认参数就会生效。redux初始化第一次dispatch时，就会让它自动赋值为reducer传入的第一个参数state默认值（ES6函数默认赋值），所以修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState </span><br><span class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        currentListeners.push(listener)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">        currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'@@mini-redux/~GSDG4%FDG#*&amp;'</span> &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        getState, </span><br><span class="line">        subscribe, </span><br><span class="line">        dispatch </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个mini-redux.js，我们就可以实现跟原来的redux完全一样的输出效果了。</p>
<h2 id="完善Redux"><a href="#完善Redux" class="headerlink" title="完善Redux"></a>完善Redux</h2><p>接下来我们继续补充知识点</p>
<ol>
<li>createStore实际有三个参数，即<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">createStore(reducer, [preloadedState], enhancer)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>第二个参数 <code>[preloadedState] (any)</code>是可选的: initial state</p>
<p>第三个参数<code>enhancer(function)</code>也是可选的：用于添加中间件的</p>
<p>通常情况下，通过 preloadedState 指定的 state 优先级要高于通过 reducer 指定的 state。这种机制的存在允许我们在 reducer 可以通过指明默认参数来指定初始数据，而且还为通过服务端或者其它机制注入数据到 store 中提供了可能。</p>
<p>第三个参数我们下篇会说，先继续完善一下代码，我们需要对第二个和第三个可选参数进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当第二个参数没有传preloadedState，而直接传function的话，就会直接把这个function当成enhancer</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        enhancer = preloadedState</span><br><span class="line">        preloadedState = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当第三个参数传了但不是function也会报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reducer必须为函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the reducer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentState = preloadedState <span class="comment">// 第二个参数没传默认就是undefined赋给currentState</span></span><br><span class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于第三个参数判断为什么返回<br><code>return enhancer(createStore)(reducer, preloadedState)</code>我们下篇会说，这篇先忽略。<br>2. 我们实现了store.subscribe()方法，但还是不完整的，subscribe方法可以添加监听函数listener,它还有返回值，返回一个移除listener的函数；另外我们依然要对类型进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        currentListeners.push(listener)</span><br><span class="line">        <span class="comment">// 通过filter过滤，执行的时候将之前本身已经添加进数组的事件名移除数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            currentListeners = currentListeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过找数组下标的方式移除listener</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    currentListeners.push(listener)</span><br><span class="line">    <span class="comment">// 通过filter过滤，执行的时候将之前本身已经添加进数组的事件名移除数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = currentListeners.indexOf(listener)</span><br><span class="line">        currentListeners.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移除listener实际就是取消订阅，使用方式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unsubscribe = store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">unsubscribe(); <span class="comment">// 取消监听</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>diaptch方法执行完返回为action，然后我们同样需要为它作判断<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> isDispatching = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 用于判断action是否为一个普通对象</span></span><br><span class="line">        <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Actions must be plain objects. '</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止多次dispatch请求同时改状态，一定是前面的dispatch结束之后，才dispatch下一个</span></span><br><span class="line">        <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isDispatching = <span class="literal">true</span></span><br><span class="line">            currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            isDispatching = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于判断一个值是否为一个普通的对象(普通对象即直接以字面量形式或调用 new Object() 所创建的对象)</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> proto = obj</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">Object</span>.getPrototypeOf(proto) !== <span class="literal">null</span>) &#123;</span><br><span class="line">        proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(obj) === proto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
isPlainObject函数中通过 while 不断地判断 Object.getPrototypeOf(proto) !== null 并执行, 最终 proto 会指向 Object.prototype. 这时再判断 Object.getPrototypeOf(obj) === proto, 如果为 true 的话就代表 obj 是通过字面量或调用 new Object() 所创建的对象了。</li>
</ol>
<p>保持action对象是简单对象的作用是方便reducer进行处理，不用处理其他的情况（比如function/class实例等）</p>
<p>至此，我们实现了最基本能用的Redux代码，下篇再继续完善Redux代码，最后放出基础版Redux所有代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当第二个参数没有传preloadedState，而直接传function的话，就会直接把这个function当成enhancer</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> preloadedState === <span class="string">'function'</span> &amp;&amp; <span class="keyword">typeof</span> enhancer === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        enhancer = preloadedState </span><br><span class="line">        preloadedState = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当第三个参数传了但不是function也会报错</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> enhancer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the enhancer to be a function.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reducer必须为函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> reducer !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected the reducer to be a function.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> currentState = preloadedState <span class="comment">// 第二个参数没传默认就是undefined赋给currentState</span></span><br><span class="line">    <span class="keyword">let</span> currentListeners = [] <span class="comment">// 监听器，可监听多个事件</span></span><br><span class="line">    <span class="keyword">let</span> isDispatching = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> getState = <span class="function"><span class="params">()</span> =&gt;</span> currentState</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subscribe = <span class="function">(<span class="params">listener</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> listener !== <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected listener to be a function.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        currentListeners.push(listener)</span><br><span class="line">        <span class="comment">// 通过filter过滤，执行的时候将之前本身已经添加进数组的事件名移除数组</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            currentListeners = currentListeners.filter(<span class="function"><span class="params">l</span> =&gt;</span> l !== listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> dispatch = <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 用于判断action是否为一个普通对象</span></span><br><span class="line">        <span class="keyword">if</span> (!isPlainObject(action)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Actions must be plain objects. '</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止多次dispatch请求同时改状态，一定是前面的dispatch结束之后，才dispatch下一个</span></span><br><span class="line">        <span class="keyword">if</span> (isDispatching) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Reducers may not dispatch actions.'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isDispatching = <span class="literal">true</span></span><br><span class="line">            currentState = reducer(currentState, action) <span class="comment">// 覆盖原来的state</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            isDispatching = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentListeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener())</span><br><span class="line">        <span class="keyword">return</span> action</span><br><span class="line">    &#125;</span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'@@mini-redux/~GSDG4%FDG#*&amp;'</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123; </span><br><span class="line">        getState, </span><br><span class="line">        subscribe, </span><br><span class="line">        dispatch </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于判断一个值是否为一个普通的对象(普通对象即直接以字面量形式或调用 new Object() 所创建的对象)</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPlainObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> proto = obj</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">Object</span>.getPrototypeOf(proto) !== <span class="literal">null</span>) &#123;</span><br><span class="line">        proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(obj) === proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">Redux 入门教程（一）：基本用法</a></p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文Github仓库</a>，觉得不错的话欢迎star，给我一点鼓励吧~</li>
</ul>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title>React函数this绑定的原因及四种绑定方式对比</title>
    <url>/2020/04/16/React%E5%87%BD%E6%95%B0this%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E5%9B%9B%E7%A7%8D%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<p>react组件在绑定函数时，通常有三种方法，此文将对三种方法性能和写法展开写…</p>
<a id="more"></a>

<h2 id="为什么要绑定this"><a href="#为什么要绑定this" class="headerlink" title="为什么要绑定this"></a>为什么要绑定this</h2><p>首先，第一个很重要的问题就是，绑定this是什么原因？</p>
<p>js里面的this绑定是代码执行的时候进行绑定的，而不是编写的时候，所以this的指向取决于函数调用时的各种条件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'jacky'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Click&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> BindEvent;</span><br></pre></td></tr></table></figure>
<p>来看上面这个例子，运行点击按钮，发现程序报错，即this指向不是所在类。由于类的方法默认不会绑定this，因此在调用的时候如果没有绑定，this的值将会是undefined。故我们需要手动绑定this</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Uncaught TypeError: Cannot read property &#39;state&#39; of undefined</span><br></pre></td></tr></table></figure>
<p>需要我们自己绑定this，其实这不是react的锅，本质原因是 JavaScript 的 this 机制问题</p>
<h2 id="this机制"><a href="#this机制" class="headerlink" title="this机制"></a>this机制</h2><p>来看下面一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>, <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getName(); <span class="comment">// &#123;name: "obj", getName: ƒ&#125; "obj"</span></span><br></pre></td></tr></table></figure>
<p>结果理所应当，使用<code>.</code>操作符调用函数obj.getName()，this指向的是obj对象，即obj对象是函数getName的调用者，但如果改成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> middleObj = obj.getName;</span><br><span class="line">middleObj(); <span class="comment">// Window &#123;...&#125; ""</span></span><br></pre></td></tr></table></figure>
<p>将getName函数引用赋值给middleObj变量，并使用这个新的函数引用去调用该函数时，打印出this为Window对象，关于this的指向，可简单粗暴理解为<strong>this 永远指向最后调用它的那个对象</strong>。</p>
<p>如果没有显式调用一个函数，JS 的解释器就会把全局对象当作调用者，在浏览器则是Window对象为调用者。</p>
<p>如果使用严格模式，那么没有显式的使用调用者的情况下，this指向undefined 。</p>
<p>理解完上面，我们用类来作为参照：</p>
<p>下面定义了一个类，类里的display访问this.name属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    display() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// 运行打印： Foo &#123;name: "jacky"&#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> Foo(<span class="string">'jacky'</span>);</span><br><span class="line">foo.display(); <span class="comment">// jacky</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> display = foo.display; </span><br><span class="line">display();  </span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot read property 'name' of undefined</span></span><br></pre></td></tr></table></figure>
<p>当我们将一个函数引用赋值给某个其他变量，并使用这个新的函数引用去调用该函数时，在 display() 方法this为<code>undefined</code>，故找不到name值报错。</p>
<p>在这里又有一个问题了，display这样直接调用，在非严格模式下调用者不是应该为Window对象吗？在这里，要知道一个知识点：</p>
<p><strong>ES6 的 class 语法，所有在 class 中声明的方法都会自动地使用严格模式</strong></p>
<h2 id="React的JSX"><a href="#React的JSX" class="headerlink" title="React的JSX"></a>React的JSX</h2><p>说了这么多，这跟React那个有什么联系呢，想搞清楚为什么绑定this这个问题前，就想先弄明白JSX到底是一个什么东西。</p>
<blockquote>
<p>本质上来讲，JSX 只是为 React.createElement(component, props, …children) 方法提供的语法糖。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;button className=<span class="string">"btn"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">    Click Me</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>经babel编译为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">    <span class="string">"button"</span>, </span><br><span class="line">    &#123; <span class="attr">className</span>: <span class="string">"btn"</span>, <span class="attr">onClick</span>: <span class="keyword">this</span>.handleClick &#125;, </span><br><span class="line">    <span class="string">"Click Me"</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们把render方法里的JSX手动写成编译后这种形式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    handleClick(e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> React.createElement(</span><br><span class="line">            <span class="string">"button"</span>, </span><br><span class="line">            &#123; <span class="attr">className</span>: <span class="string">"btn"</span>, <span class="attr">onClick</span>: <span class="keyword">this</span>.handleClick &#125;, </span><br><span class="line">            <span class="string">"Click Me"</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>React.createElement的第二个参数，传入的是一个对象，而这个对象里面有属性的值是取this 对象里面的属性 ，当这个对象放入React.createElement执行后，去取这个this.handleClick属性的时候，this已经不是我们在书写的时候认为的绑定在Example组件上了。this.handleClick这里的this会默认绑定，但是又是在ES6的class中，所以this绑定了undefined。</p>
<p> 在JSX语法中: <code>onClick={ this.handleClick }</code>中onClick这个属性就是相当于上面的”中间变量”。</p>
<p> 即是将<code>this.handleClick</code>函数赋值给onClick这个中间变量，后面不仅要进行JSX语法转化,将JSX组件转换成<strong>JS对象</strong>,还要再将Javascript对象转换成真实DOM。把onClick作为中间变量,指向一个函数的时候,后面的一系列处理中，使用onClick这个中间变量所指向的函数，里面的this自然就丢失掉了，不是再指向组件实例了。</p>
<p> 所以，当在组件定义方法想访问this，才需要手动绑定。</p>
<h2 id="绑定this的方法"><a href="#绑定this的方法" class="headerlink" title="绑定this的方法"></a>绑定this的方法</h2><h3 id="render方法中绑定this"><a href="#render方法中绑定this" class="headerlink" title="render方法中绑定this"></a>render方法中绑定this</h3> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'jacky'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法即是在事件函数后使用<code>.bind(this)</code>将this绑定到当前组件中。因为 bind 函数会返回一个新的函数，所以每次父组件刷新时，都会重新生成一个函数，即使父组件传递给子组件其他的 props 值不变，子组件每次都会刷新，这将会影响性能，故不推荐使用。</p>
<h3 id="render方法中使用箭头函数"><a href="#render方法中使用箭头函数" class="headerlink" title="render方法中使用箭头函数"></a>render方法中使用箭头函数</h3> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'jacky'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.handleClick()&#125;&gt;点击&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首选要明确一点，<strong>箭头函数中，this 永远绑定了定义箭头函数所在的那个对象</strong></p>
<p>这种方法写法比较简洁， 最大好处就是传参很灵活，父组件刷新的时候，即使两个箭头函数的函数体是一样的，都会生成一个新的箭头函数。这种方式重新创建函数性能的损耗小于第1种。</p>
<h3 id="构造函数绑定this"><a href="#构造函数绑定this" class="headerlink" title="构造函数绑定this"></a>构造函数绑定this</h3> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'jacky'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;点击&lt;<span class="regexp">/button&gt; </span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 为了避免在render中绑定this引发可能的性能问题，可以在constructor中预先进行绑定。好处是仅需要绑定一次，避免每次渲染时都要重新绑定，也是常推荐的写法，就是写起来繁琐一点，要单独绑定。</p>
<h3 id="在定义阶段使用箭头函数绑定"><a href="#在定义阶段使用箭头函数绑定" class="headerlink" title="在定义阶段使用箭头函数绑定"></a>在定义阶段使用箭头函数绑定</h3>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">BindEvent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            name: <span class="string">'jacky'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.name)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;点击&lt;<span class="regexp">/button&gt; </span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法是ES7的写法，ES6并不支持，不过我们可以配置你的开发环境支持ES7。</p>
<p>这种方法避免了第1种和第2种的可能潜在的性能问题，也比第3种方法简洁，也是常推荐的写法。</p>
<p>至于哪一种是最好的写法，目前还真的无法定论，有待以后开发中得出最佳实践…</p>
<br>

<ul>
<li>ps： <a href="https://github.com/Jacky-Summer/personal-blog" target="_blank" rel="noopener">个人技术博文Github仓库</a>，欢迎star</li>
</ul>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>原生JavaScript DOM操作常见汇总</title>
    <url>/2020/04/09/%E5%8E%9F%E7%94%9FJavaScript-DOM%E6%93%8D%E4%BD%9C%E5%B8%B8%E8%A7%81%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>最近在看JS性能优化方面，说到了createDocumentFragment()方法，对该方法有印象，但为了进一步了解，我还是重新查阅一遍，顺便把DOM操作也给总结一下。</p>
<a id="more"></a>

<h2 id="创建新节点"><a href="#创建新节点" class="headerlink" title="创建新节点"></a>创建新节点</h2><ul>
<li><strong>createDocumentFragment()方法</strong></li>
</ul>
<p>该方法是用来创建一个虚拟的节点对象，或者说，是用来创建文档碎片节点。它可以包含各种类型的节点，在创建之初是空的。</p>
<p>DocumentFragment 不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。</p>
<p>当把一个DocumentFragment节点插入文档树时，插入的不是DocumentFragment自身，而是它的所有子孙节点，即插入的是括号里的节点。这个特性使得DocumentFragment成了占位符，暂时存放那些一次插入文档的节点。</p>
<ul>
<li><strong>createElement()方法</strong></li>
</ul>
<p>在 HTML 文档中，document.createElement() 方法用于创建一个由标签名称 tagName 指定的 HTML 元素</p>
<p>来看一个例子, 对于页面已存在的<code>&lt;ul id=&quot;ul&quot;&gt;&lt;/ul&gt;</code>元素，我们想往里面添加li标签</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"ul"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.innerHTML = <span class="string">"index: "</span> + i;</span><br><span class="line">    ul.appendChild(li);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面操作看起来很正常，但实际要很多的插入操作和改动；而每一次的插入都会引起重新渲染，该操作会引发多次渲染，在性能优化方面，有一点是减少DOM操作，因为DOM操作导致了页面的重绘或重排。</p>
<ul>
<li>createDocumentFragment()方法和createElement()方法区别</li>
</ul>
<p>如果是用createDocumentFragment()方法操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">"ul"</span>);</span><br><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.innerHTML = <span class="string">"index: "</span> + i;</span><br><span class="line">    fragment.appendChild(li);</span><br><span class="line">&#125;</span><br><span class="line">ul.appendChild(fragment);</span><br></pre></td></tr></table></figure>

<p>相比createElement()方法，这次是先将这些元素添加到fragment中，再统一将fragment添加到页面，会减少页面渲染dom的次数，效率会明显提升。因为fragment文档片段存在于内存中，并不在DOM中，所以将子元素插入到文档片段中时不会引起页面回流（新创建的fragment片段在文档内是没有对应的标签的，这里添加的是片段的所有子节点）</p>
<ul>
<li>createTextNode()方法</li>
</ul>
<p>该方法会创建一个文本节点。</p>
<p>HTML元素通常是由元素节点和文本节点组成。创建一个标题 (h1), 你必须创建 “h1” 元素和文本节点:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> h = <span class="built_in">document</span>.createElement(<span class="string">"h1"</span>)</span><br><span class="line"><span class="keyword">var</span> t = <span class="built_in">document</span>.createTextNode(<span class="string">"Hello World"</span>);</span><br><span class="line">h.appendChild(t);</span><br></pre></td></tr></table></figure>

<h2 id="DOM更改：添加、移除、替换、插入"><a href="#DOM更改：添加、移除、替换、插入" class="headerlink" title="DOM更改：添加、移除、替换、插入"></a>DOM更改：添加、移除、替换、插入</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加、删除子元素</span></span><br><span class="line">ele.appendChild(el);</span><br><span class="line">ele.removeChild(el);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换子元素</span></span><br><span class="line">ele.replaceChild(el1, el2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入子元素</span></span><br><span class="line">parentElement.insertBefore(newElement, referenceElement);</span><br></pre></td></tr></table></figure>
<p>前面三个用法就一目了然，对于insertBefore()方法来举个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newEle = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="string">'insertNode'</span>);</span><br><span class="line">newEle.appendChild(textNode);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>);</span><br><span class="line">ul.insertBefore(newEle, ul.firstChild);</span><br></pre></td></tr></table></figure>
<p>页面输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insertNode</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="DOM查询"><a href="#DOM查询" class="headerlink" title="DOM查询"></a>DOM查询</h2><p>元素查询的API返回的的结果是DOM节点或者DOM节点的列表</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getElementById()  </span><br><span class="line">getElementsByName()  </span><br><span class="line">getElementsByTagName()</span><br><span class="line">getElementsByClassName()</span><br><span class="line">querySelector()</span><br><span class="line">querySelectorAll()</span><br></pre></td></tr></table></figure>

<p>querySelector() 方法返回匹配指定 CSS 选择器元素的第一个子元素， 该方法只返回匹配指定选择器的第一个元素。如果要返回所有匹配元素，需要使用 querySelectorAll() 方法替代．</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.querySelector(&quot;#test&quot;); &#x2F;&#x2F; 获取到id名为test的首个元素</span><br></pre></td></tr></table></figure>
<ul>
<li>querySelector系列方法与getElementBy系列方法对比</li>
</ul>
<ol>
<li>得到的元素不是需要很麻烦的多次getElementBy..的话，尽量使用getElementBy系列方法,因为getElementBy系列执行速度更快。</li>
<li>得到的元素需要很麻烦的多次getElementBy…组合才能得到的话使用querySelector，方便。</li>
<li>querySelector()选择的标签是静态的，也就是说在选中之后，能够一直保存，也就是脱离了被选择的成为副本。而getelementsBy系列方法是动态的，相互映射，在调用时，变化可以及时的反映在页面上。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 querySelector 操作元素</span></span><br><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line"><span class="keyword">var</span> list = ul.querySelectorAll(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// 创建3个新的li标签，添加到ul列表中</span></span><br><span class="line">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'li'</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(list.length); <span class="comment">// 3  </span></span><br><span class="line"><span class="comment">// 输出的是添加前li的数量3，而非此时li的总数量6</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'ul'</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> list = ul.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123; <span class="comment">// 创建3个新的li标签，添加到ul列表中</span></span><br><span class="line">    ul.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'li'</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(list.length); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>还有元素的DOM导航方法：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取父元素、父节点</span></span><br><span class="line"><span class="keyword">var</span> parent = ele.parentElement;</span><br><span class="line"><span class="keyword">var</span> parent = ele.parentNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子节点，子节点可以是任何一种节点，可以通过nodeType来判断</span></span><br><span class="line"><span class="keyword">var</span> nodes = ele.children;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询子元素</span></span><br><span class="line"><span class="keyword">var</span> els = ele.getElementsByTagName(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">var</span> els = ele.getElementsByClassName(<span class="string">'test'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前元素的第一个/最后一个子元素节点</span></span><br><span class="line"><span class="keyword">var</span> el = ele.firstElementChild;</span><br><span class="line"><span class="keyword">var</span> el = ele.lastElementChild;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一个/上一个兄弟元素节点</span></span><br><span class="line"><span class="keyword">var</span> el = ele.nextElementSibling;</span><br><span class="line"><span class="keyword">var</span> el = ele.previousElementSibling;</span><br></pre></td></tr></table></figure>
<h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">getAttribute(key)</span><br><span class="line">setAttribute(key,value)</span><br><span class="line">hasAttribute(key)</span><br><span class="line">removeAttribute(key)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>用React+Antd封装Axios实现全局Loading效果</title>
    <url>/2020/03/29/%E7%94%A8React-Antd%E5%B0%81%E8%A3%85Axios%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80Loading%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>今天在做react后台管理的时候要实现一个全局Loading效果，通常使用axios库与后端进行数据交互。为了更好的用户体验，在每次请求前添加一个加载效果，让用户知道在等待加载。</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要实现这个功能，我们可以在每个组件请求手动添加加载效果返回后再将其隐藏，但如果每个请求都这么做，就要做多次重复设置显得很麻烦，但好处是可以设置定制多种请求效果。但考虑到该项目场景为后台管理系统，给管理员使用，花样可以不用搞太多，统一优雅即可，故采取全局设置loading效果。</p>
<h2 id="开发版本"><a href="#开发版本" class="headerlink" title="开发版本"></a>开发版本</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"react"</span>: <span class="string">"^16.13.1"</span>,</span><br><span class="line"><span class="string">"antd"</span>: <span class="string">"^4.0.4"</span>,</span><br><span class="line"><span class="string">"axios"</span>: <span class="string">"^0.19.2"</span></span><br></pre></td></tr></table></figure>

<h2 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h2><ol>
<li>通过 axios 提供的请求拦截和响应拦截的接口，控制 loading 的显示或者隐藏。在此我还设置了没有网络和网络超时的提示信息</li>
<li>采用antd的Spin组件来实现loading效果，message组件来进行消息提示（antd.css这里没有引入，是因为我设置了按需加载）</li>
<li>定义变量requestCount作为计数器，确保同一时刻如果有多个请求的话，不会同时添加多个 loading，而是只有1个，并在所有请求结束后才会隐藏 loading。</li>
<li>默认所有请求都会自动有 loading 效果。如果某个请求不需要 loading 效果，可以在请求 headers 中设置 isLoading 为false。</li>
</ol>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>在src目录下新建一个文件axios.js<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; message, Spin &#125; <span class="keyword">from</span> <span class="string">'antd'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Axios = axios.create(&#123;</span><br><span class="line">    <span class="comment">// baseURL: process.env.BASE_URL, // 设置请求的base url</span></span><br><span class="line">    timeout: <span class="number">20000</span>, <span class="comment">// 设置超时时长</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置post请求头</span></span><br><span class="line">Axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded;charset=UTF-8'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前正在请求的数量</span></span><br><span class="line"><span class="keyword">let</span> requestCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示loading</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showLoading</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (requestCount === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> dom = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">        dom.setAttribute(<span class="string">'id'</span>, <span class="string">'loading'</span>)</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(dom)</span><br><span class="line">        ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Spin</span> <span class="attr">tip</span>=<span class="string">"加载中..."</span> <span class="attr">size</span>=<span class="string">"large"</span>/&gt;</span></span>, dom)</span><br><span class="line">    &#125;</span><br><span class="line">    requestCount++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏loading</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hideLoading</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    requestCount--</span><br><span class="line">    <span class="keyword">if</span> (requestCount === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">document</span>.body.removeChild(<span class="built_in">document</span>.getElementById(<span class="string">'loading'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求前拦截</span></span><br><span class="line">Axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// requestCount为0，才创建loading, 避免重复创建</span></span><br><span class="line">    <span class="keyword">if</span> (config.headers.isLoading !== <span class="literal">false</span>) &#123;</span><br><span class="line">        showLoading()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// 判断当前请求是否设置了不显示Loading</span></span><br><span class="line">    <span class="keyword">if</span> (err.config.headers.isLoading !== <span class="literal">false</span>) &#123;</span><br><span class="line">        hideLoading()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回后拦截</span></span><br><span class="line">Axios.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 判断当前请求是否设置了不显示Loading</span></span><br><span class="line">    <span class="keyword">if</span> (res.config.headers.isLoading !== <span class="literal">false</span>) &#123;</span><br><span class="line">        hideLoading()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;, err =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.config.headers.isLoading !== <span class="literal">false</span>) &#123;</span><br><span class="line">        hideLoading()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err.message === <span class="string">'Network Error'</span>) &#123;</span><br><span class="line">        message.warning(<span class="string">'网络连接异常！'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (err.code === <span class="string">'ECONNABORTED'</span>) &#123;</span><br><span class="line">        message.warning(<span class="string">'请求超时，请重试'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把组件引入，并定义成原型属性方便使用</span></span><br><span class="line">Component.prototype.$axios = Axios</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Axios</span><br></pre></td></tr></table></figure></li>
<li>添加loading样式在共用的css文件里<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#loading</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.75</span>);</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">9999</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>axios请求<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 引入自定义axios文件路径</span></span><br><span class="line"><span class="comment">// 2. 引入共用css文件（loading样式）</span></span><br><span class="line"><span class="comment">// 3. 在react组件中正常写法请求url即可</span></span><br><span class="line">componentDidMount () &#123;</span><br><span class="line">    axios(&#123;</span><br><span class="line">      url: <span class="string">'/manage/statistic/base_count.do'</span></span><br><span class="line">    &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(res.data)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
不加loading效果，这样写<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">'/manage/statistic/base_count.do'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'isLoading'</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.setState(res.data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2></li>
</ol>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/3/29/17126d31a0fc0571?w=1854&h=954&f=gif&s=427836" alt=""></p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解之JavaScript之call, apply, bind方法</title>
    <url>/2020/03/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E4%B9%8BJavaScript%E4%B9%8Bcall-apply-bind%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在JavaScript中，call、apply和bind是Function对象自带的三个方法，这三个方法的主要作用是改变函数执行时的上下文，再具体一点就是<strong>改变函数运行时的this指向</strong>。</p>
<a id="more"></a>
<ul>
<li><h2 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h2></li>
</ul>
<p>call() 方法调用一个函数, 其具有一个指定的 this 值和多个参数(参数的列表)。</p>
<blockquote>
<p>fun.call(thisArg, arg1, arg2, …)</p>
</blockquote>
<p>thisArg的取值有以下4种情况：</p>
<ol>
<li>不传，或者传null, undefined， 函数中的this指向window对象（非严格模式下）</li>
<li>传递另一个函数的函数名，函数中的this指向这个函数的引用</li>
<li>传递字符串、数值或布尔类型等基础类型，函数中的this指向其对应的包装对象，如 String、Number、Boolean</li>
<li>传递一个对象，函数中的this指向这个对象.</li>
</ol>
<p>我们可以用如下代码验证一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"></span>) </span>&#123;   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);   </span><br><span class="line">&#125;       </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func2</span>(<span class="params"></span>) </span>&#123;&#125;       </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"jacky"</span> &#125;;  </span><br><span class="line"></span><br><span class="line">func1.call();   <span class="comment">// Window</span></span><br><span class="line">func1.call(<span class="literal">null</span>);   <span class="comment">// Window</span></span><br><span class="line">func1.call(<span class="literal">undefined</span>);   <span class="comment">// Window</span></span><br><span class="line">func1.call(<span class="number">1</span>);   <span class="comment">// Number &#123;1&#125;</span></span><br><span class="line">func1.call(<span class="string">''</span>);   <span class="comment">// String &#123;""&#125;</span></span><br><span class="line">func1.call(<span class="literal">true</span>);   <span class="comment">// Boolean &#123;true&#125;</span></span><br><span class="line">func1.call(func2);   <span class="comment">// ƒ func2() &#123;&#125;</span></span><br><span class="line">func1.call(obj);   <span class="comment">// &#123;name: "jacky"&#125;</span></span><br></pre></td></tr></table></figure>

<p>我们再来看个例子，理解怎么改变this的指向：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'animal'</span>;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'cat'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">animal.sayName.call(cat); <span class="comment">// cat</span></span><br><span class="line"><span class="comment">// this 永远指向最后调用它的那个对象</span></span><br><span class="line"><span class="comment">// 该例子中sayName方法的this指向Cat</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h2></li>
</ul>
<p>call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现，apply则是把除了改变上下文对象的参数放在一个<strong>数组</strong>里面作为它的第二个参数，他们俩之间的差别在于<strong>参数</strong>的区别。</p>
<p>如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> 和其他参数 <span class="subst">$&#123;args&#125;</span>`</span>); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = &#123;</span><br><span class="line">    name: <span class="string">'xiaomao'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用 call</span></span><br><span class="line">Animal.call(cat, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// xiaomao 和其他参数 1,2,3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 apply</span></span><br><span class="line">Animal.apply(cat, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// xiaomao 和其他参数 1,2,3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="call、apply使用"><a href="#call、apply使用" class="headerlink" title="call、apply使用"></a>call、apply使用</h2></li>
</ul>
<p>由于两个方法实际效果是一样的，对于两者平时用该如何选择呢？</p>
<ol>
<li>参数数量/顺序确定就用call，参数数量/顺序不确定的话就用apply。</li>
<li>考虑可读性：参数数量不多就用call，参数数量比较多的话，把参数整合成数组，使用apply。</li>
<li>参数集合已经是一个数组的情况，用apply。</li>
</ol>
<ul>
<li><h2 id="call-apply-的应用"><a href="#call-apply-的应用" class="headerlink" title="call, apply 的应用"></a>call, apply 的应用</h2></li>
</ul>
<h3 id="数组拼接"><a href="#数组拼接" class="headerlink" title="数组拼接"></a>数组拼接</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 apply方法</span></span><br><span class="line">[].push.apply(arr1, arr2);  <span class="comment">// 给arr1添加arr2</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>

<h3 id="获取数组中的最大值或最小值"><a href="#获取数组中的最大值或最小值" class="headerlink" title="获取数组中的最大值或最小值"></a>获取数组中的最大值或最小值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">98</span>]; </span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, numbers) );   <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.max.call(<span class="built_in">Math</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">100</span>, <span class="number">98</span>) ); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log( <span class="built_in">Math</span>.min.call(<span class="built_in">Math</span>, ...numbers) ); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'string'</span>,</span><br><span class="line">    obj = &#123; <span class="attr">name</span>: <span class="string">'jacky'</span> &#125;</span><br><span class="line"><span class="comment">// 判断传入参数是否为数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isArray(arr)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(isArray(str)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(arr)); <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(str)); <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(obj)); <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>)); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>

<h3 id="调用父类构造函数实现继承"><a href="#调用父类构造函数实现继承" class="headerlink" title="调用父类构造函数实现继承"></a>调用父类构造函数实现继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>)</span>&#123;      </span><br><span class="line">    <span class="keyword">this</span>.name = name;      </span><br><span class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;      </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);      </span><br><span class="line">    &#125;      </span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>)</span>&#123;    </span><br><span class="line">    Animal.call(<span class="keyword">this</span>, name);    </span><br><span class="line">&#125;      </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">"xiaomao"</span>);     </span><br><span class="line">cat.showName();   <span class="comment">// xiaomao</span></span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ol>
<li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li>
<li>每次子类实例化都要执行父类函数，重新声明父类this里所定义的方法，因此父类方法无法复用。</li>
</ol>
<h3 id="类数组对象转数组"><a href="#类数组对象转数组" class="headerlink" title="类数组对象转数组"></a>类数组对象转数组</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>还有像调用 getElementsByTagName , document.childNodes 之类的，它们返回NodeList对象都属于伪数组。</p>
<h3 id="代理console-log方法"><a href="#代理console-log方法" class="headerlink" title="代理console.log方法"></a>代理console.log方法</h3><p>注意这里传入多少个参数是不确定的，所以使用apply是最好的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log.apply(<span class="built_in">console</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br><span class="line">log(<span class="number">1</span>);    <span class="comment">// 1</span></span><br><span class="line">log(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h2></li>
</ul>
<p>MDN的解释是：</p>
<blockquote>
<p>bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
</blockquote>
<p>说直白一点，bind方法是创建一个函数，然后可以在需要调用的时候再执行函数，并非是立即执行函数；而call，apply是在改变了上下文中的this指向后并立即执行函数。</p>
<p>bind 接收的参数类型与 call 是一样的，给它传递的是一组用逗号分隔的参数列表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;   </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = &#123; </span><br><span class="line">    x: <span class="number">2</span>   </span><br><span class="line">&#125;   </span><br><span class="line">bar(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = bar.bind(foo);   </span><br><span class="line">func(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li><h2 id="bind的应用"><a href="#bind的应用" class="headerlink" title="bind的应用"></a>bind的应用</h2></li>
</ul>
<h3 id="bind绑定回调函数的this指向"><a href="#bind绑定回调函数的this指向" class="headerlink" title="bind绑定回调函数的this指向"></a>bind绑定回调函数的this指向</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(callBack) &#123;</span><br><span class="line">        <span class="keyword">this</span>.className = <span class="string">'PageA'</span></span><br><span class="line">        <span class="keyword">this</span>.MessageCallBack = callBack </span><br><span class="line">        <span class="keyword">this</span>.MessageCallBack(<span class="string">'执行了'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PageB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>.className = <span class="string">'PageB'</span></span><br><span class="line">        <span class="keyword">this</span>.pageClass = <span class="keyword">new</span> PageA(<span class="keyword">this</span>.handleMessage)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回调函数</span></span><br><span class="line">    handleMessage(msg) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'处理'</span> + <span class="keyword">this</span>.className + <span class="string">'的回调 '</span> + msg) <span class="comment">// 处理PageA的回调 执行了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> PageB();</span><br></pre></td></tr></table></figure>
<p>运行上面的代码，我们发现回调函数this丢失了？问题出在这行代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.pageClass = <span class="keyword">new</span> PageA(<span class="keyword">this</span>.handleMessage)</span><br></pre></td></tr></table></figure>
<p>传递过去的this.handleMessage是一个函数内存地址，没有上下文对象，也就是说该函数没有绑定它的this指向。</p>
<p>解决方案：用bind绑定this的指向</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.pageClass = <span class="keyword">new</span> PageA(<span class="keyword">this</span>.handleMessage.bind(<span class="keyword">this</span>))</span><br></pre></td></tr></table></figure>
<p>这也是为什么react的render函数在绑定回调函数的时候，也要使用bind绑定一下this的指向，也是因为同样的问题以及原理。</p>
<ul>
<li><p>多个bind的情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    x: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    x: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">    x: <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func1 = bar.bind(obj1).bind(obj2);</span><br><span class="line"><span class="keyword">var</span> func2 = bar.bind(obj1).bind(obj2).bind(obj3);</span><br><span class="line">func1(); <span class="comment">// 2</span></span><br><span class="line">func2(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>输出结果都为第一个绑定的obj对象的x值。原因是，在Javascript中，bind()方法返回的外来的绑定函数对象仅在创建的时候记忆上下文（如果提供了参数），多次 bind() 是无效的。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。</p>
</li>
<li><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li>
</ul>
<p>call和apply的第一个参数都是要改变上下文的对象，而call从第二个参数开始以参数列表的形式展现; apply则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数，他们俩之间的差别在于参数的区别。</p>
<p>call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数,其内的this指向为创建它时传入bind的第一个参数，而传入bind的第二个及以后的参数作为原函数的参数来调用原函数。bind的参数可以在函数执行的时候再次添加。</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之作用域链与闭包</title>
    <url>/2020/03/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E4%B8%8E%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>作用域和闭包是Js很重要的概念，对此进行深入了解</p>
<a id="more"></a>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域是指程序源代码中定义变量的区域。</p>
<p>实际上描述的就是查找变量的范围，作用域必须有的两个功能就是<strong>存储变量</strong>以及<strong>查找变量</strong>，作用域就是发挥这两个作用以及更多作用的规则。</p>
<p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p>
<h3 id="词法作用域和动态作用域"><a href="#词法作用域和动态作用域" class="headerlink" title="词法作用域和动态作用域"></a>词法作用域和动态作用域</h3><ul>
<li>词法作用域：（静态作用域）函数的作用域在函数定义的时候就决定了。</li>
<li>动态作用域：函数的作用域是在函数调用的时候才决定的。</li>
</ul>
<p>JavaScript采用的是词法作用域</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域</p>
<p>全局变量：</p>
<blockquote>
<ol>
<li>生命周期将存在于整个程序之内。</li>
<li>能被程序中任何函数或者方法访问。</li>
<li>在 JavaScript 内默认是可以被修改的。</li>
</ol>
</blockquote>
<p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p>
<h4 id="显式声明"><a href="#显式声明" class="headerlink" title="显式声明"></a>显式声明</h4><p>带有关键字 var 的声明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> winValue = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.winValue); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h4 id="隐式声明"><a href="#隐式声明" class="headerlink" title="隐式声明"></a>隐式声明</h4><p>不带有声明关键字的变量，JS 会默认帮你声明一个全局变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    result = value + <span class="number">1</span>;	 <span class="comment">// 没有用 var 声明</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line">foo(<span class="number">1</span>);	</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.result);	<span class="comment">// 2 &lt;=  挂在了 window全局对象上</span></span><br></pre></td></tr></table></figure>

<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p>函数作用域内，对外是封闭的，从外层的作用域无法直接访问函数内部的作用域。</p>
<p>在函数内部的变量权限称为函数作用域，有以下特点：</p>
<ol>
<li>每个函数都有自己的作用域，而且调用一次就会生成新的作用域</li>
<li>只能在函数内部才能访问，外部是没有权限访问的</li>
<li>进入函数内部时开启，函数执行完毕后销毁</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="string">'test'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>

<h3 id="块级作用域（ES6新增）"><a href="#块级作用域（ES6新增）" class="headerlink" title="块级作用域（ES6新增）"></a>块级作用域（ES6新增）</h3><p>凡是由{}符号包裹起来的都是块作用域</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>
<p>在 for 循环执行完毕之后 i 变量就被释放了</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>作用域链：当访问一个变量时，解释器会首先在当前作用域查找，如果没有找到，就去父作用域找，直到找到该变量或者不在父作用域中，这就是作用域链。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>
<p>从上面代码的执行结果可以看出，foo 函数取到了它外部的变量 a, 而最外层的 console.log(b) 操作并没能取得 foo 函数里面的变量 b。</p>
<ul>
<li>作用域链和原型继承查找时的区别：</li>
</ul>
<p>如果去查找一个普通对象的属性，但是在当前对象和其原型中都找不到时，会返回undefined；但查找的属性在作用域链中不存在的话就会抛出ReferenceError。</p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>闭包是指<strong>有权访问另外一个函数作用域中的变量的函数</strong></p>
<p>在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成”定义在一个函数内部的函数”。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p>
<ul>
<li>闭包由两部分构成：</li>
</ul>
<ol>
<li>函数</li>
<li>能访问另外一个函数作用域中的变量</li>
</ol>
<h3 id="为什么有闭包"><a href="#为什么有闭包" class="headerlink" title="为什么有闭包?"></a>为什么有闭包?</h3><blockquote>
<p>之所以出现闭包是因为JS的垃圾回收机制，JS本身为了避免解释器过量消耗内存，造成系统崩溃，自带有一套垃圾回收机制，垃圾回收机制能够检测到一个对象是不是无用的。检测到之后，就会把它占用的内存释放掉。但是实际工作中，我们也会需要一些变量不那么及时的被清理，所以就出现了闭包，用来达成这个效果。</p>
</blockquote>
<h3 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h3><ul>
<li>闭包可以访问当前函数以外的变量</li>
<li>即使外部函数已经返回，闭包仍能访问外部函数定义的变量</li>
<li>参数和变量不会被垃圾回收机制收回。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOuter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'jacky'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(str + name);  <span class="comment">// 可以访问getName函数外部的name</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getName(<span class="string">'名字是：'</span>); </span><br><span class="line">&#125;</span><br><span class="line">getOuter(); <span class="comment">// 名字是：jacky</span></span><br></pre></td></tr></table></figure>
<p>再来看下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = bar(); <span class="comment">// 这一句执行完，变量x并没有被回收，因为要内部函数还需要引用</span></span><br><span class="line"><span class="built_in">console</span>.log(foo()) <span class="comment">// 3  执行内部函数，引用外部变量x</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，在全局执行上下文中定义了一个函数bar和变量foo，函数bar内部返回一个匿名函数，所以此刻匿名函数的作用域链初始化为包含了全局变量对象和bar中的变量对象。</p>
<p>当执行var foo = bar()时，把函数bar的执行上下文压入栈，当bar执行完后，其执行上下文应该弹出栈，但是因为bar内部的匿名函数作用域链还引用这bar函数内的变量x，所以bar的执行上下文得不到释放，这样就形成了闭包。</p>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><ol>
<li>设计私有的方法和变量（封装，定义模块）。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> privateCounter = <span class="number">0</span>; <span class="comment">//私有变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">        privateCounter += val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        increment:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">            change(<span class="number">1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        decrement:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            change(<span class="number">-1</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        value:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> privateCounter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>匿名函数最大的用途是创建闭包。减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> objEvent = objEvent || &#123;&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> addEvent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// some code</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// some code</span></span><br><span class="line">    &#125;</span><br><span class="line">    objEvent.addEvent = addEvent</span><br><span class="line">    objEvent.removeEvent = removeEvent</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>addEvent 和 removeEvent 都是局部变量，但我们可以通过全局变量 objEvent 使用它</p>
<h3 id="如何销毁闭包"><a href="#如何销毁闭包" class="headerlink" title="如何销毁闭包"></a>如何销毁闭包</h3><p>javascript中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。</p>
<p>即释放对闭包的引用，使引用变量为null。</p>
<h3 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h3><p>优点：</p>
<ol>
<li>闭包里的变量不会污染全局，因为变量被封在闭包里；</li>
<li>所有变量都在闭包里保证了隐私性和私有性；</li>
<li>可以让这些局部变量保存在内存中，实现变量数据共享。</li>
</ol>
<p>缺点：</p>
<p>形成闭包即要把一个函数当成值传递，而且该函数还引用这另一个函数的作用域链使得被引用的函数不能被回收，使用不当容易造成内存泄漏；</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之 new 原理及模拟实现</title>
    <url>/2020/02/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B-new-%E5%8E%9F%E7%90%86%E5%8F%8A%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>探讨new原理……</p>
<a id="more"></a>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例</p>
<p>先看看 new 实现了哪些功能, 先来看一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"年龄为:"</span> + <span class="keyword">this</span>.age );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="number">18</span>);</span><br><span class="line">person.age; <span class="comment">// 访问构造函数里的属性</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">person.getAge(); <span class="comment">// 访问原型里的属性</span></span><br><span class="line"><span class="comment">// 年龄为:18</span></span><br></pre></td></tr></table></figure>

<p>从上面代码可以知道，实例 person 可以：</p>
<ol>
<li>访问到 Person 构造函数里的属性</li>
<li>访问到 Person.prototype 中的属性</li>
</ol>
<p>这个是最基本的了，也是刚学会new一个对象就知道这是new的特点</p>
<h2 id="探讨new还做了什么？"><a href="#探讨new还做了什么？" class="headerlink" title="探讨new还做了什么？"></a>探讨new还做了什么？</h2><p>探讨完上面，接下来看看new还做了什么？来看几个例子</p>
<h3 id="没有return语句"><a href="#没有return语句" class="headerlink" title="没有return语句"></a>没有return语句</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// Person &#123;age: 18&#125;</span></span><br></pre></td></tr></table></figure>
<p>从构造函数直观看，最后是没有 return语句的，但我们从返回结果也可以看出构造函数时默认情况会返回一个新对象</p>
<h3 id="return-对象数据类型"><a href="#return-对象数据类型" class="headerlink" title="return 对象数据类型"></a>return 对象数据类型</h3><p>我们尝试在构造函数最后返回一个对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">'手动返回一个对象'</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;name: "手动返回一个对象"&#125;</span></span><br></pre></td></tr></table></figure>
<p>打印出来的结果可以看出：return 之前的代码片段都被覆盖了，最后返回 return 后面的对象。</p>
<h3 id="return-基本数据类型"><a href="#return-基本数据类型" class="headerlink" title="return 基本数据类型"></a>return 基本数据类型</h3><p>如果构造函数最后return的不是对象呢，试下基本数据类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// Person &#123;age: 18&#125;</span></span><br></pre></td></tr></table></figure>
<p>从打印出来的结果可知，和没有return效果一样。</p>
<h2 id="new原理"><a href="#new原理" class="headerlink" title="new原理"></a>new原理</h2><p>mdn上把内部操作大概分为4步：</p>
<blockquote>
<ol>
<li>创建一个空的简单JavaScript对象（即{ } ）；</li>
<li>链接该对象（即设置该对象的构造函数）到另一个对象 ；(因此this就指向了这个新对象)</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>如果该函数没有返回对象，则返回this。</li>
</ol>
</blockquote>
<h2 id="模拟实现new"><a href="#模拟实现new" class="headerlink" title="模拟实现new"></a>模拟实现new</h2><p>new 是关键词，不可以直接覆盖。这里使用 create 来模拟实现 new 的效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(),</span><br><span class="line">    <span class="comment">// 获得构造函数，arguments中去除第一个参数</span></span><br><span class="line">    Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 链接到原型，obj 可以访问到构造函数原型中的属性</span></span><br><span class="line">    obj.__proto__ = Con.prototype;</span><br><span class="line">    <span class="comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">    <span class="keyword">var</span> ret = Con.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 优先返回构造函数返回的对象</span></span><br><span class="line">    <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>来看看上面是怎么一步步模拟实现的：</p>
<ol>
<li>用new Object() 的方式新建了一个空对象 obj</li>
<li>取出第一个参数，即是传入的构造函数。shift 会修改原数组，数组原来的第一个元素的值。</li>
<li>将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性</li>
<li>使用 apply，改变构造函数 this 的指向。将this指向obj对象 就可以访问到构造函数中的属性</li>
<li>处理返回值。</li>
</ol>
<ul>
<li>构造函数返回值有三种情况：</li>
</ul>
<ol>
<li>没有return，默认返回之前创建的对象</li>
<li>返回一个对象   </li>
<li>返回的不是对象，默认返回之前创建的空对象</li>
</ol>
<p>在上面我们用instanceof方法来判断是否为对象</p>
<blockquote>
<p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</p>
</blockquote>
<p>测试：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"年龄为:"</span> + <span class="keyword">this</span>.age );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = create(Person, <span class="number">18</span>)</span><br><span class="line">person.age; <span class="comment">// 访问构造函数里的属性</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line">person.getAge(); <span class="comment">// 访问原型里的属性</span></span><br><span class="line"><span class="comment">// 年龄为:18</span></span><br></pre></td></tr></table></figure>
<p>模拟实现成功！</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之原型与原型链</title>
    <url>/2020/02/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<p>对于JavaScript，原型是很重要的一个基础知识点，涉及的内容很多，在此总结一下</p>
<a id="more"></a>
<h2 id="原型prototype"><a href="#原型prototype" class="headerlink" title="原型prototype"></a>原型prototype</h2><p>原型是一个对象，把prototype称为原型对象，prototype可以让所有的对象实例共享它包含的属性和方法。</p>
<p>JavaScript规定，每一个函数都有一个prototype对象属性，指向另一个对象。prototype对象属性的所有属性和方法都会被构造函数的实例继承。</p>
<h2 id="只有函数有prototype属性"><a href="#只有函数有prototype属性" class="headerlink" title="只有函数有prototype属性"></a>只有函数有prototype属性</h2><p>js分为函数对象和普通对象，每个对象都有<strong>proto</strong>属性，但是只有函数对象才有prototype属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.prototype) <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(func.prototype) <span class="comment">// &#123; constructor: function()&#123;...&#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>JS通过new关键字，即靠构造函数生成对象，每次生成的对象都不一样。因为常常需要在两个对象之间共享属性，由于JS在设计之初没有类的概念，所以JS使用函数的prototype属性来处理这部分需要被共享的属性。</p>
<h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.name = <span class="string">'kiki'</span>;</span><br><span class="line"><span class="keyword">var</span> animal1 = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="keyword">var</span> animal2 = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(animal1.name, animal2.name) <span class="comment">// kiki kiki</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的animal1和animal2的原型</p>
<p>每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。</p>
<p>构造函数和实例原型关系如下图：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/15/17049498b6d308cb?w=885&h=207&f=png&s=21292" alt=""></p>
<h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h2><p>那么如何表示实例与实例原型之间的关系呢，这里需要讲到另一个属性<strong>proto</strong></p>
<p>每一个JavaScript对象(除了 null)都具有的一个属性，叫<strong>proto</strong>，这个属性会指向该对象的原型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(dog.__proto__ === Animal.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>于是更新实例与实例原型之间的关系如下图：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/15/17049522bfa417ec?w=866&h=336&f=png&s=32709" alt=""></p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>每个原型都有一个constructor属性指向关联的构造函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Animal === Animal.prototype.constructor); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/15/170496796080e487?w=849&h=347&f=png&s=35480" alt=""></p>
<p>则可以得出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(dog.__proto__ === Animal.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Object.getPrototypeOf() 方法返回指定对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(dog) === Animal.prototype) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Animal.prototype.constructor == Animal) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>再提一点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(dog.constructor === Animal); <span class="comment">// true</span></span><br><span class="line"><span class="comment">/* 当获取 dog.constructor 时，其实 dog 中并没有 constructor 属性,</span></span><br><span class="line"><span class="comment">当不能读取到constructor 属性时，</span></span><br><span class="line"><span class="comment">会从 dog 的原型也就是 Animal.prototype 中读取，正好原型中有该属性, 所以下列代码为true */</span></span><br><span class="line">dog.constructor === Animal.prototype.constructor</span><br></pre></td></tr></table></figure>

<h2 id="实例和原型"><a href="#实例和原型" class="headerlink" title="实例和原型"></a>实例和原型</h2><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal.prototype.name = <span class="string">'kiki'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Animal();</span><br><span class="line"></span><br><span class="line">dog.name = <span class="string">'xiaobai'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dog.name) <span class="comment">// xiaobai</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> dog.name;</span><br><span class="line"><span class="built_in">console</span>.log(dog.name) <span class="comment">// kiki</span></span><br></pre></td></tr></table></figure>

<p>上述代码。首先构造函数原型设置了 name值，接着dog实例添加了name属性，覆盖原型的name值，打印dog.name时结果自然是xiaobai。</p>
<p>当删除了dog的name属性时，读取dog.name时，从对象中无法找到name属性，就会从dog的原型，也就是dog.<strong>proto</strong>，即Animal.prototype中查找，找到结果为kiki。</p>
<p>如果原型没有设置name值，找不到呢？原型的原型又是谁？</p>
<h2 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h2><p>原型本身也是一个对象，既然是对象，我们就可以用最原始的方式创建它：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">'kiki'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// kiki</span></span><br></pre></td></tr></table></figure>
<p>其实原型对象就是通过 Object 构造函数生成的，所有函数的 默认原型 都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype。</p>
<p>由此，更新关系图：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/16/1704bf72a35f1a74?w=861&h=505&f=png&s=54960" alt=""></p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ol>
<li>每个对象都拥有一个原型对象: dog的原型是Animal.prototype。</li>
<li>对象的原型可能也是继承其他原型对象的: Animal.prototype也有它的原型Object.prototype。</li>
<li>一层一层的，以此类推，这种关系就是原型链。</li>
</ol>
<p>那么<code>Object.prototype</code>的原型是什么呢？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">const</span> proto = <span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>所以 Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。null 表示此处不应该有值，也就是原型链的终点了，所以查找属性的时候查到 Object.prototype 就可以停止查找了。</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/2/16/1704bffc23da9aaf?w=800&h=592&f=png&s=54550" alt=""></p>
<p>上图中的红色线组成的链就可以称之为原型链。</p>
<p>由上述关系图我们可以重新描述一下原型链：</p>
<blockquote>
<p>从一个实例对象开始往上找，这个实例对象的<strong>proto</strong>属性所指向的则是这个实例对象的原型对象，如果用dog表示这个实例，则原型对象表示为<code>dog.__proto__</code>。同时，这个原型也是一个对象，而且它也有上一级的原型对象，相对于上一级原型对象而言，它也是一个实例对象，那么它也拥有<strong>proto</strong>属性，它的<strong>proto</strong>属性也指向它的原型对象，后面也以此类推，一直到Object.prototype这个原型为止，这就是整个原型链。</p>
</blockquote>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之Generator生成器全解析</title>
    <url>/2020/01/13/ES6%E7%B3%BB%E5%88%97%E4%B9%8BGenerator%E7%94%9F%E6%88%90%E5%99%A8%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>上一篇我们写完了Iterator迭代器，这次我们来讲下Generator生成器，如果不了解Iterator的话建议先看我上一篇博客，因为这篇会涉及迭代器的内容。</p>
<a id="more"></a>
<h2 id="为什么需要Generator"><a href="#为什么需要Generator" class="headerlink" title="为什么需要Generator"></a>为什么需要Generator</h2><p>在JavaScript中，异步编程场景使用非常多，经常会出现需要逐步完成多个异步操作的情况。之前用回调函数实现异步编程如果碰到了这种问题就需要嵌套使用回调函数，异步操作越多，嵌套得就越深，导致代码的可维护性较差，代码阅读起来也很困难。</p>
<p>Generator函数是ES6提出的一种异步编程解决方案，它可以避免回调的嵌套，语法行为与传统函数完全不同。除此之外，Generator的特性在某些场景使用也十分方便。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>语法上，首先可以把它理解成，Generator 函数是一个状态机，还是一个Iterator对象生成函数。它返回的遍历器对象可以依次遍历Generator函数内部的每一个状态。Generator函数是生成一个对象，但是调用的时候前面不能加new命令。</p>
<p>通俗来说，Generator函数它可以随时暂停函数运行，并可以在任意时候恢复函数运行。</p>
<h2 id="与-Iterator-接口的关系"><a href="#与-Iterator-接口的关系" class="headerlink" title="与 Iterator 接口的关系"></a>与 Iterator 接口的关系</h2><p>任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p>
<p>由于 Generator 函数就是Iterator迭代器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...myIterable] ); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Generator 函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了 Iterator 接口，可以被…运算符遍历了。</p>
<p>Generator 函数执行后，返回一个迭代器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(g[<span class="built_in">Symbol</span>.iterator]() === g); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，gen是一个 Generator 函数，调用它会生成一个迭代器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li><p>function关键字与函数名之间有一个<code>*</code>号，而且这个<code>*</code>前后允许有空白字符，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> * <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;    </span><br><span class="line"><span class="function"><span class="keyword">function</span>*<span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>以上四种写法都可以，根据个人不同习惯，一般第三和第四种用得比较多</p>
</li>
<li><p>函数体内部使用yield表达式，定义不同的内部状态</p>
</li>
<li><p>普通函数的执行模式是: <strong>执行-结束</strong>, 生成器的执行模式是: <strong>执行-暂停-结束</strong>。生成器可以在执行当中暂停自身，可以立即恢复执行也可以过一段时间之后恢复执行。最大的区别就是它不像普通函数那样保证运行到完毕。</p>
</li>
</ol>
<h2 id="yield关键字"><a href="#yield关键字" class="headerlink" title="yield关键字"></a>yield关键字</h2><p>生成器函数中，有一个特殊的新关键字：<code>yield</code>。由于Generator函数返回的是一个Iterator对象，只有调用next方法才会遍历下一个内部状态,而<code>yield</code>关键字就是<strong>暂停标志</strong>。因为有它，所以才能实现执行-暂停-结束的执行模式。</p>
<p><code>yield</code> 后面可以是任意合法的JavaScript表达式，<code>yield</code>语句可以出现的位置可以等价于一般的赋值表达式（比如a=2）能够出现的位置。如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">b = <span class="number">2</span> + a = <span class="number">2</span> <span class="comment">// 不合法</span></span><br><span class="line">b = <span class="number">2</span> + <span class="keyword">yield</span> <span class="number">2</span> <span class="comment">// 不合法</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">2</span> + (a = <span class="number">2</span>) <span class="comment">// 合法</span></span><br><span class="line">b = <span class="number">2</span> + (<span class="keyword">yield</span> <span class="number">2</span>) <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>
<p><code>yield</code>关键字的优先级比较低，几乎<code>yield</code>之后的任何表达式都会先进行计算，然后再通过<code>yield</code>向外界产生值。而且<code>yield</code>是右结合运算符，也就是说</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yield yield 2 等价于 (yield (yield 2))</span><br></pre></td></tr></table></figure>
<p><strong>总结</strong>：</p>
<ol>
<li>它可以指定调用next方法时的返回值以及调用顺序。</li>
<li>每当执行完yield语句，函数就会停止执行，直到再次调用next方法才会继续执行</li>
<li>yield关键字只能在生成器内部使用，其他地方会导致语法错误</li>
</ol>
<h2 id="运行生成器函数"><a href="#运行生成器函数" class="headerlink" title="运行生成器函数"></a>运行生成器函数</h2><p>说了这么多，我们来举个简单的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述为一个生成器函数，如何运行它呢？我们知道，生成器还是一个遍历器/迭代器生成函数，也就是说，返回的Iterator对象，可以依次遍历生成器函数内部的每一个状态，所以我们可以使用next()方法让它运行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = gen(); <span class="comment">// 生成器返回的是一个指向内部状态的generator对象</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>首先要知道的是，Generator函数，不管内部有没有<code>yield</code>语句，调用函数时都不会执行任何语句，也不返回函数执行结果，而是返回一个指向内部状态的generator对象，也可以看作是一个Iterator对象。只有当调用next(),内部语句才会执行。</p>
<p>在该函数内部有3个<code>yield</code>表达式，即该函数有三个状态：1、2、3。而Generator函数在此分段执行，调用next方法函数内部逻辑开始执行，遇到<code>yield</code>表达式停止，返回Iterator对象，再次调用next方法，会从上一次停止时的<code>yield</code>处开始，直到最后。所以我们也不难理解<code>yield</code>语句只是函数暂停执行的一个标记。</p>
<p>再来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen();</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>上述生成器函数gen有三个状态：hello，world 和 return 语句。</p>
<p>第一次调用next方法，生成器函数开始执行，遇到第一个yield表达式，返回一个对象，它的value属性就是当前yield表达式的值hello，done属性的值false，表示遍历还没有结束。</p>
<p>同理第二次调用也是按上述逻辑推</p>
<p>第三次调用next方法，遇到了return语句（如果没有return语句，就执行到函数结束）。此时next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值，在这里return后的值即是”ending”（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。</p>
<p>第四次调用，此时 生成器函数已经运行完毕，故next方法返回对象的value属性为undefined，done属性为true。以后无论调用多少次next方法，返回的都是这个值。</p>
<h2 id="next传递参数"><a href="#next传递参数" class="headerlink" title="next传递参数"></a>next传递参数</h2><p>由上述我们知道总结next方法的运行逻辑：</p>
<ol>
<li>遇到 <code>yield</code> 语句暂停执行后面的操作，并将在 <code>yield</code> 后面那个表达式的值，作为返回对象的 value 属性值</li>
<li>下次调用 next 方法时，再继续往下执行，直到遇到下一个 <code>yield</code> 语句</li>
<li>如果没有遇到新的 <code>yield</code> 语句，就一直运行函数结束 到 return 语句为止，将 return 的值作为返回的对象 value 的属性值</li>
<li>如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined </li>
</ol>
<p>那next方法可以带参数吗？答案当然是可以的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> (a + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> b * <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator1 = gen(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(generator1.next()); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator1.next()); <span class="comment">// &#123;value: NaN, done: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> generator2 = gen(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(generator2.next(<span class="number">2</span>)); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator2.next(<span class="number">4</span>)); <span class="comment">// &#123;value: 16, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面两个例子中，生成器函数gen都接收了一个参数a,都传入了 1。</p>
<p>第一个例子中：第一次调用next方法，let b = yield 1 + 1 = yield 2,即返回<code>yield</code>的value值为2；到了第二次调用时，语句 return b * 2，返回的对象value值居然为NaN。由此可推断此时的b并不是上次计算的结果2，而是undefined，所以undefined * 4 = NaN</p>
<p>看到这里，不懂生成器的小伙伴可能有点懵逼，表面上变量b已经用yield语句赋值了，但并没有赋值成功。</p>
<p>再第二个例子：第一次调用next方法，let b = yield (1 + 1),此时的next方法传入了参数，值为1，这个参数有什么用呢？答：确实没什么用，这里只是为了示范它对结果无影响。</p>
<blockquote>
<p>第一个next方法只是用来启动生成器函数内部的遍历器，传参也没有多大意义。即使传了值，它只是将这个传入的值抛弃而已。ES6表明，generator函数在这种情况只是忽略了这些没有被用到的值。</p>
</blockquote>
<p>所以let b = yield (1 + 1) = yield 2, 返回value值仍然为2；第二次调用next方法时传入了参数4，此时4覆盖上次yield语句的返回值2，即let b = 4;故执行return b * 4语句时，即return 4 * 4，即返回了16。</p>
<ul>
<li>上述结果可以说明：<ul>
<li><strong>yield语句没有返回值，或者总是返回undefined；</strong></li>
<li><strong>next方法如果带上一个参数，这个参数就是作为上一个yield语句的返回值。<br>注意：因为next方法表示上一个yield语句的返回值，所以必须有上一个yield语句的存在，那么第一次调用next方法时就不能传参数。第一个next只是用来启动Generator函数内部的遍历器，传参也没有多大意义。</strong></li>
</ul>
</li>
</ul>
<p>对于上述两点，我们需要代码再次加深理解：</p>
<p>yield 后可以不带任何表达式的时候，返回的value为undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> gen = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(gen.next()); <span class="comment">// &#123; value: undefined, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<p>再举一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span>(x + <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span>(y / <span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123;value: 4, done: false&#125; 返回yield（2+2）= 4</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next(<span class="number">7</span>)); <span class="comment">// &#123;value: 3.5, done: false&#125; 设置yield(x+2) = 7,那么y= 2*7=14,那么yield(y/4) = 3.5</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next(<span class="number">3</span>)); <span class="comment">// &#123;value: 19, done: false&#125; 设置z = yield(y/4) = 3 那么 x+y+z = 2+14+3 = 19</span></span><br></pre></td></tr></table></figure>

<ol>
<li>第一次调用next方法，返回yield（2+2）= 4，返回value值为4</li>
<li>第二次调用next方法，next参数值为7，覆盖上一次的yield值，故let y = 2 * 7 = 14，则let z = yield(14 / 4) = 3.5</li>
<li>第三次调用next方法，next参数值为3，覆盖上一次的yield值，故z = 3，x + y + z = 2 + 14 + 3 = 19</li>
</ol>
<p>这里初次看可能有点绕，建议多看多试几次就容易理解了。</p>
<h2 id="return-与-yield区别"><a href="#return-与-yield区别" class="headerlink" title="return 与 yield区别"></a>return 与 yield区别</h2><p>从以上的例子也可以看出，函数不仅是碰到yield语句才会停止执行，碰到return语句也会停止执行。普通函数遇到return 也会停止执行，Generator函数也是一个函数，所以很好理解。那么，两者的区别是什么呢？先来看个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen();</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123;value: "hello", done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上面例子可以看出，当碰到return语句时，返回对象的value值为紧跟return后面的值，done属性值就为true，代表遍历结束，不管后面是否还有yield或者return语句。这种区别本质上是因为yield语句具备位置记忆功能而return语句则没有该功能。</p>
<h2 id="return-与-next-参数区别"><a href="#return-与-next-参数区别" class="headerlink" title="return 与 next 参数区别"></a>return 与 next 参数区别</h2><p>可以总结为三点：</p>
<ol>
<li>return终结遍历，之后的yield语句都失效；next返回本次yield语句的返回值。</li>
<li>return没有参数的时候，返回{ value: undefined, done: true }；next没有参数的时候返回本次yield语句的返回值。</li>
<li>return有参数的时候，覆盖本次yield语句的返回值，也就是说，返回{ value: 参数, done: true }；next有参数的时候，覆盖上次yield语句的返回值，返回值可能跟参数有关（参数参与计算的话），也可能跟参数无关（参数不参与计算）。</li>
</ol>
<h2 id="return-value-方法"><a href="#return-value-方法" class="headerlink" title="return(value)方法"></a>return(value)方法</h2><p>在生成器里使用return(value)方法，随时终止生成器，如下面代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = gen();</span><br><span class="line"><span class="built_in">console</span>.log(generator.next());     <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.return(<span class="number">10</span>)); <span class="comment">// &#123;value: 10, done: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next());     <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上述代码我们看出，使用return()方法我们提前终止了生成器，返回return里的值，再次调用next()方法时，done属性的值为true,遍历结束，由此可见return提前终止了生成器。</p>
<h2 id="throw-exception-方法"><a href="#throw-exception-方法" class="headerlink" title="throw(exception)方法"></a>throw(exception)方法</h2><p>除了用return(value)方法可以终止生成生成器，我们还可以调用 throw(exception) 进行提前终止生成器，示例代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generator = gen();</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); </span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    generator.throw(<span class="string">"throw error msg"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"必执行的finally语句块"</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(generator.next());</span><br></pre></td></tr></table></figure>
<p>输出结果;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line"><span class="keyword">throw</span> error msg</span><br><span class="line">必执行的<span class="keyword">finally</span>语句块</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>由此可以看出，在生成器外部调用try…catch…finally,throw()异常被try…catch捕捉并返回，并执行了finally代码块中的代码。当再次调用next方法，done属性返回true,说明生成器已被终止。</p>
<p>我们不仅可以在next执行过程中插入throw()语句，我们还可以在生成器内部插入try…catch进行错误处理。</p>
<blockquote>
<p>throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。</p>
</blockquote>
<p>代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"first Exception"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"second Exception"</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = gen();</span><br><span class="line"><span class="built_in">console</span>.log(generator.next());</span><br><span class="line"><span class="built_in">console</span>.log(generator.throw(<span class="string">"exception string"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(generator.throw(<span class="string">"exception string"</span>));</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">value</span>: <span class="number">1</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">first Exception</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">done</span>: <span class="literal">false</span>&#125;</span><br><span class="line">second Exception</span><br><span class="line">&#123;<span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<p>从代码输出可以输出，当我们在generator.throw()方法时，被生成器内部上个暂停点的异常处理代码所捕获，会附带执行下一条<code>yield</code>表达式。也就是说，会附带执行一次next方法。由此可见在生成器内部使用try…catch可以捕获异常，并不会影响到遍历器的状态。</p>
<h2 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h2><p>如果想要在 Generator 函数内部，调用另一个 Generator函数。需要在前者的函数体内部，自己手动完成遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="comment">// for...of遍历 gen1()</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> gen1()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> gen2())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">b</span><br></pre></td></tr></table></figure>

<p>如果有多个 Generator 函数嵌套，写起来就非常麻烦。<br>ES6 提供了<code>yield*</code>表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p>
<p>把上面的gen2函数改写如下,如下也能得到相同的输出结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* gen1();</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>yield*</code>可以将可迭代的对象iterable放在一个生成器里，生成器函数运行到<code>yield*</code> 位置时，将控制权委托给这个迭代器，直到执行完成为止。举个例子，数组也是可迭代对象，因此<code>yield*</code>也可委托给数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen1</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">gen2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">yield</span>* gen1(); </span><br><span class="line">    <span class="keyword">yield</span>* [<span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generator = gen2();</span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123;value: 4, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123;value: 5, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generator.next()); <span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Generator的应用场景"><a href="#Generator的应用场景" class="headerlink" title="Generator的应用场景"></a>Generator的应用场景</h2><h3 id="异步操作的同步化表达"><a href="#异步操作的同步化表达" class="headerlink" title="异步操作的同步化表达"></a>异步操作的同步化表达</h3><p>Generator函数的暂停执行的效果，意味着可以把异步操作写在yield表达式里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield表达式下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数，避免回调嵌套。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loadUI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  showLoadingScreen();</span><br><span class="line">  <span class="keyword">yield</span> loadUIDataAsynchronously();</span><br><span class="line">  hideLoadingScreen();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> loader = loadUI();</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.next();</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一次调用next方法时，则会显示Loading界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p>
<h3 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">'https://api.github.com/users/github'</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。不过也可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<h3 id="部署-Iterator-接口"><a href="#部署-Iterator-接口" class="headerlink" title="部署 Iterator 接口"></a>部署 Iterator 接口</h3><p>利用 Generator 函数，可以在任意对象上部署 Iterator 接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i];</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; <span class="attr">foo</span>: <span class="number">3</span>, <span class="attr">bar</span>: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了 Iterator 接口。也就是说，可以在任意对象上部署next方法。</p>
<h3 id="抽奖程序"><a href="#抽奖程序" class="headerlink" title="抽奖程序"></a>抽奖程序</h3><p>比如当前用户还可以抽奖5次，用户点了5次抽奖后就不能继续抽奖了，如做一个剩余抽奖次数的限制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"start"</span>&gt;</span>抽奖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> draw = <span class="function"><span class="keyword">function</span>(<span class="params">count</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 具体抽奖逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`剩余<span class="subst">$&#123;count&#125;</span>次`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> residue = <span class="function"><span class="keyword">function</span>* (<span class="params">count</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">while</span>(count &gt; <span class="number">0</span>) &#123; <span class="comment">// 抽奖次数的限制</span></span><br><span class="line">        count--;</span><br><span class="line">        <span class="keyword">yield</span> draw(count); <span class="comment">//执行抽奖的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start = residue(<span class="number">5</span>); </span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'start'</span>).addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    start.next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后我们通过点击5次抽奖按钮,依次输出剩余几次。当剩余0次时，再点击按钮不会有任何输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">剩余4次</span><br><span class="line">剩余3次</span><br><span class="line">剩余2次</span><br><span class="line">剩余1次</span><br><span class="line">剩余0次</span><br></pre></td></tr></table></figure>
<p>上述通过generator来控制抽奖的次数限制的好处是：抽奖次数无需保存在全局变量中，而且把抽奖具体逻辑给分离开。</p>
<h2 id="Generator函数的语法糖—async函数"><a href="#Generator函数的语法糖—async函数" class="headerlink" title="Generator函数的语法糖—async函数"></a>Generator函数的语法糖—async函数</h2><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便，而async 函数是就是 Generator 函数的语法糖。</p>
<ol>
<li><code>async</code> 对应的是 <code>*</code></li>
<li><code>await</code> 对应的是 <code>yield</code></li>
</ol>
<p><code>async</code>和<code>await</code>，比起<code>*</code>号和<code>yield</code>，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p>
<p>比如我们假装模拟一个请求ajax方法返回用户数据并输出显示的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'用户数据...'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">yield</span> ajax();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`输出的user数据:<span class="subst">$&#123;user&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当然真实项目不可能这么写，在此只是方便拿数据</span></span><br><span class="line"><span class="keyword">const</span> generator = fetchUser();</span><br><span class="line"><span class="keyword">let</span> obj = generator.next();</span><br><span class="line">generator.next(obj.value);</span><br></pre></td></tr></table></figure>
<p>如果用async函数代替,代码就会优雅很多</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fetchUser</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> user = <span class="keyword">await</span> ajax();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`输出的user数据:<span class="subst">$&#123;user&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">fetchUser();</span><br></pre></td></tr></table></figure>
<p>这里可以看出并不需要调用next()方法，因为async函数自带执行器。也就是说，<br>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Generator 是一个可以暂停和继续执行的函数，他可以完全实现 Iterator 的功能，并且由于可以保存上下文，他非常适合实现简单的状态机。另外通过一些流程控制代码的配合，可以比较容易进行异步操作。</p>
<p>Async/Await 就是generator进行异步操作的语法糖，该语法糖相比下有更好的应用和语义化，它们搭配promise，可以通过编写形似同步的代码来处理异步流程，提高代码的简洁性和可读性。</p>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之一文彻底弄懂Iterator</title>
    <url>/2020/01/11/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E6%96%87%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82Iterator/</url>
    <content><![CDATA[<p>本文主要来深入剖析ES6的Iterator（迭代器/遍历器），在了解它之前，我们首先要知道为什么需要Iterator? 它出现的原因是什么?</p>
<a id="more"></a>
<h2 id="从循环说起"><a href="#从循环说起" class="headerlink" title="从循环说起"></a>从循环说起</h2><p>平时开发中，我们经常会用到循环，拿最基本的来说，比如循环一个数组:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]); <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用forEach循环</span></span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用for in循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]); <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是循环输出字符串的每一个字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// for循环</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'abcde'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str[i]); <span class="comment">// a b c d e</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// for in循环</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> str)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str[k]); <span class="comment">// a b c d e</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach不能遍历字符串，如果硬要用则只能先把字符串转为数组再用数组方式循环</span></span><br></pre></td></tr></table></figure>


<p>如果是循环输出一个map对象呢, 妥妥的就一个foreach循环，普通的for循环和for…in都不行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'第一'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'第二'</span>);</span><br><span class="line">map.set(<span class="string">'third'</span>, <span class="string">'第三'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// forEach循环</span></span><br><span class="line">map.forEach(<span class="function">(<span class="params">val,key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(val, key);</span><br><span class="line">    <span class="comment">// 第一 first</span></span><br><span class="line">    <span class="comment">// 第二 second</span></span><br><span class="line">    <span class="comment">// 第三 third</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>对于上述各集合数据，我们发现没有一个循环方法是可以一次性解决的。</p>
<p>虽然forEach循环不能循环字符串，但字符串可以转为数组再使用forEach即可输出，但这操作并不舒服每次使用都要转换。而且forEach循环存在缺点：<code>不能使用break，continue语句跳出循环，或者使用return从函数体返回</code>。</p>
<p>而for循环在有些情况写代码会增加复杂度，而且不能循环对象。</p>
<p>相比下，for…in的缺点是不仅遍历数字键名，还会遍历手动添加的自定义键，甚至包括原型链上的键。for…in主要还是为遍历对象而设计的，并不太适用于遍历数组。</p>
<p>如下代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.protoValue = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr.test = <span class="string">'test'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]); <span class="comment">// 1 2 3 4 test hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>话说回来，有没有一种更好的循环能一统上述循环问题？ ES6就有了，用for…of循环</p>
<h2 id="for…of循环出现"><a href="#for…of循环出现" class="headerlink" title="for…of循环出现"></a>for…of循环出现</h2><p>它的出现解决了什么问题呢？首先是当然是能解决了上述我们的问题</p>
<p>对上述数据进行循环输出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// 1 2 3 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v); <span class="comment">// a b c d e</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">    <span class="comment">// (2) ["first", "第一"]</span></span><br><span class="line">    <span class="comment">// (2) ["second", "第二"]</span></span><br><span class="line">    <span class="comment">// (2) ["third", "第三"]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看看它的优点：</p>
<ol>
<li>简洁直接的遍历数组语法</li>
<li>它避开了 for-in 循环的所有缺点</li>
<li>与forEach循环不同的是，它可以使用break、continue 和 return 语句</li>
</ol>
<p>阮一峰老师的《ECMAScript 6 入门》提到：</p>
<blockquote>
<p>ES6中引入了for…of循环，作为遍历所有数据结构的统一的方法。</p>
</blockquote>
<blockquote>
<p>Iterator是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
</blockquote>
<p>一个数据结构只要具有 iterator 接口，就可以用for…of循环遍历它的成员。</p>
<p>也就是说，并不是所有的对象都能使用for…of循环，只有实现了Iterator接口的对象，才能够for…of来进行遍历取值。</p>
<p>那么，Iterator是什么呢？我们接着说</p>
<h2 id="Iterator迭代器"><a href="#Iterator迭代器" class="headerlink" title="Iterator迭代器"></a>Iterator迭代器</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p>
</blockquote>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>为各种数据结构，提供一个统一的、简便的访问接口；</li>
<li>使得数据结构的成员能够按某种次序排列；</li>
<li>创造一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。</li>
</ol>
<p>现在明白了，Iterator的产生主要是为了使用for…of方法。但具体Iterator概念还是有些抽象，如果要直接具体的描述的话：</p>
<p>Iterator其实就是一个具有 next()方法的对象，并且每次调用next()方法都会返回一个结果对象，这个结果对象有两个属性, 如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    value: 表示当前的值,</span><br><span class="line">    done: 表示遍历是否结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里多了一些概念，我们来梳理一下：</p>
<p>Iterator是一个特殊的对象：</p>
<ol>
<li>它具有next()方法，调用该方法就会返回一个结果对象</li>
<li>结果对象有两个属性值：<code>value</code>和<code>done</code>。</li>
<li><code>value</code>表示具体的返回值；done是布尔类型，表示集合是否完成遍历，没有则返回true，否则返回false</li>
<li>内部有一个指针，指向数据结构的起始位置。每调用一次next()方法，指针都会向后移动一个位置，直到指向最后一个位置。</li>
</ol>
<h3 id="模拟Iterator"><a href="#模拟Iterator" class="headerlink" title="模拟Iterator"></a>模拟Iterator</h3><p>根据上述描述，我们来模拟一个迭代器，代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createIterator</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> done = (i &gt;= item.length);</span><br><span class="line">            <span class="keyword">var</span> value = !done ? items[i++] : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: done,</span><br><span class="line">                value: value</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterator 就是一个迭代器对象</span></span><br><span class="line"><span class="keyword">var</span> iterator = createIterator([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: false, value: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: false, value: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: false, value: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>

<p>过程:</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li>
<li>第一次调用指针对象的next方法，next 方法内部通过闭包来保存指针<code>i</code> 的值，每次调用<code>i</code>都会<code>+1</code>，指向下一个。故第一次指针指向数据结构的第一个成员，输出1。</li>
<li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员，输出2。</li>
<li>第三次调用指针对象的next方法，数组长度为3，此时数据结构的结束位置，输出3。</li>
<li>第四次调用指针对象的next方法，此时已遍历完成了，输出done为true表示完成，value为undefined，此后第n次调用都是该结果。</li>
</ol>
<p>看到这里大家大概知道<code>Iterator</code>了，但Iterator接口主要供for…of消费。我们试着用for…of循环上面创建Iterator对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var iterator &#x3D; makeIterator([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">for (let value of iterator) &#123;</span><br><span class="line">    console.log(value); &#x2F;&#x2F; Uncaught TypeError: iterator is not iterable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果报错，说明我们生成的 iterator 对象并不是可遍历的，这样的结构还不能够被for…of循环</p>
<p>那什么样的结构才是可遍历的呢？</p>
<h2 id="可迭代对象Iterable"><a href="#可迭代对象Iterable" class="headerlink" title="可迭代对象Iterable"></a>可迭代对象Iterable</h2><h3 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h3><p>ES6还引入了一个新的Symbol对象，symbol值是唯一的。</p>
<p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口；调用这个接口，就会返回一个遍历器对象。这样的数据结构才能被称为可迭代对象(Iterator)，该对象可被for…of遍历。</p>
<p>照着上面的规定来创建一个可迭代对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> done = (i &gt;= _this.length);</span><br><span class="line">            <span class="keyword">var</span> value = !done ? _this[i++] : <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: done,</span><br><span class="line">                value: value</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时可以for...of遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item); <span class="comment">// 1 2 3 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由此，我们也可以知道 for…of 遍历的其实是对象的 Symbol.iterator 属性。</p>
<h3 id="原生具备Iterator接口的数据结构"><a href="#原生具备Iterator接口的数据结构" class="headerlink" title="原生具备Iterator接口的数据结构"></a>原生具备Iterator接口的数据结构</h3><p>在ES6中，所有的集合对象，包括数组，类数组对象（arguments对象、DOM NodeList 对象），Map和Set，还有字符串都是可迭代的，都可以被for…of遍历，因为他们都有默认的迭代器。</p>
<p>下面就挑其中几个类型来举例子：</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> iteratorObj = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next());</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next());</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next());</span><br><span class="line"><span class="built_in">console</span>.log(iteratorObj.next());</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/8/16f8433c4b0b041a?w=294&h=282&f=png&s=23046" alt=""><br>由上述对迭代器的概念认识，输出结果也完全符合我们预期。</p>
<h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>我们知道普通对象是默认没有部署这个接口的，所以arguments这个属性没有在原型上，而是在对象自身的属性上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj = <span class="built_in">arguments</span>[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">   <span class="built_in">console</span>.log(obj.next());</span><br><span class="line">   <span class="built_in">console</span>.log(obj.next());</span><br><span class="line">   <span class="built_in">console</span>.log(obj.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/8/16f8446fec7e2102?w=508&h=197&f=png&s=20591" alt=""></p>
<h4 id="NodeList"><a href="#NodeList" class="headerlink" title="NodeList"></a>NodeList</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nodeList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'test'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> node <span class="keyword">of</span> nodeList) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/8/16f84531078f206d?w=236&h=61&f=png&s=3489" alt=""></p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>这次直接从原型上找来证明</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Map</span>.prototype.hasOwnProperty(<span class="built_in">Symbol</span>.iterator)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>至于其他类型的可迭代对象大家可举一反三。</p>
<h2 id="调用-Iterator-接口的场合"><a href="#调用-Iterator-接口的场合" class="headerlink" title="调用 Iterator 接口的场合"></a>调用 Iterator 接口的场合</h2><p>有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法）</p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = new Set().add('a').add('b').add('c');</span><br><span class="line"></span><br><span class="line">let [x, y] = <span class="keyword">set</span>;</span><br><span class="line">console.log(x, y); // a b</span><br></pre></td></tr></table></figure>

<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>扩展运算符（…）也会调用默认的 Iterator 接口，可以将当前迭代对象转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log([...str]); <span class="comment">// ["h", "e", "l", "l", "o"]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">console</span>.log([<span class="string">'a'</span>, ...arr, <span class="string">'d'</span>]); <span class="comment">// ["a", "b", "c", "d"]</span></span><br></pre></td></tr></table></figure>

<h3 id="yield"><a href="#yield" class="headerlink" title="yield*"></a>yield*</h3><p>yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = generator();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>关于yield之后会再写一篇专题</p>
<h3 id="其他场合"><a href="#其他场合" class="headerlink" title="其他场合"></a>其他场合</h3><p>例如：for…of、Set()、Map()、Array.from()等。我们主要是为了证明调用上面这些函数时着实是用到了Iterator接口。</p>
<p>我们贴出上面的实现可迭代对象的代码，进行改动。想一想，尽管我们没有手动添加 Symbol.iterator属性，但因为 ES6 默认部署了 Symbol.iterator，数组还是可以遍历成功，那当然我们也可以手动修改这个属性，重新部署也可以。</p>
<p>如果我们手动修改生效，影响了输出，证明某方法调用需要用到Iterator接口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> done = (i &gt;= _this.length);</span><br><span class="line">            <span class="keyword">var</span> value = !done ? _this[i++] : <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                done: done,</span><br><span class="line">                value: value + <span class="string">' 手动添加的属性'</span> <span class="comment">// 添加自定义值</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果显示手动修改生效，证明for...of调用了Iterator接口</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> item <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">    <span class="comment">// 1 手动添加的属性</span></span><br><span class="line">    <span class="comment">// 2 手动添加的属性</span></span><br><span class="line">    <span class="comment">// 3 手动添加的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = new Set(arr);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(3) &#123;<span class="number">1</span> 手动添加的属性<span class="string">", 2 手动添加的属性"</span>, <span class="number">3</span> 手动添加的属性<span class="string">"&#125;</span></span><br></pre></td></tr></table></figure>
<p>上述其他方法证明也是如此，就不一一列出了。</p>
<h2 id="计算生成的数据结构"><a href="#计算生成的数据结构" class="headerlink" title="计算生成的数据结构"></a>计算生成的数据结构</h2><p>有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6 的数组、Set、Map 都部署了以下三个方法，调用后都返回遍历器对象。</p>
<ol>
<li>entries() 返回一个遍历器对象，用来遍历[键名,键值]组成的数组。对于数组，键名就是索引值。</li>
<li>keys() 返回一个遍历器对象，用来遍历所有的键名。</li>
<li>values() 返回一个遍历器对象，用来遍历所有的键值。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"third"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> arr.keys()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> color <span class="keyword">of</span> arr.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first</span></span><br><span class="line"><span class="comment">// second</span></span><br><span class="line"><span class="comment">// third</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr.entries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [ 0, "first" ]</span></span><br><span class="line"><span class="comment">// [ 1, "second" ]</span></span><br><span class="line"><span class="comment">// [ 2, "third" ]</span></span><br></pre></td></tr></table></figure>


<h2 id="判断对象是否可迭代"><a href="#判断对象是否可迭代" class="headerlink" title="判断对象是否可迭代"></a>判断对象是否可迭代</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isIterable = <span class="function"><span class="params">obj</span> =&gt;</span> obj != <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> obj[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>())); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>())); <span class="comment">// true  </span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])); <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">"hello world"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


<h3 id="for…of循环不支持遍历普通对象"><a href="#for…of循环不支持遍历普通对象" class="headerlink" title="for…of循环不支持遍历普通对象"></a>for…of循环不支持遍历普通对象</h3><p>梳理了半天，回到最初，Iterator的产生主要是为了使用for…of方法。而对象不像数组的值是有序的，遍历的时候根本不知道如何确定他们的先后顺序，所以要注意的是for…of循环不支持遍历对象。</p>
<p>如果非要遍历对象，同理对象也必须包含[Symbol.iterator]的属性并实现迭代器方法，可以通过手动利用Object.defineProperty方法添加该属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">2</span>, <span class="attr">b</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// Uncaught TypeError: obj is not iterable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于Iterator就写到这里了，下一篇写ES6的Generator生成器。</p>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之箭头函数全解析</title>
    <url>/2020/01/07/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%85%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>ES6中允许使用箭头来定义箭头函数，是ES6中较受欢迎也较常使用的新增特性。本文将从箭头函数的基本语法，与普通函数对比，箭头函数不适用场景三个方面进行梳理。</p>
<a id="more"></a>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上面可以看出，定义箭头函数语法上要比普通函数简洁得多。箭头函数省去了<code>function</code>关键字，采用箭头<code>=&gt;</code>来定义函数。函数的参数放在<code>=&gt;</code>前面的括号中，函数体跟在<code>=&gt;</code>后的花括号中，箭头函数在参数和箭头之间不能换行。</p>
<h3 id="箭头函数的参数"><a href="#箭头函数的参数" class="headerlink" title="箭头函数的参数"></a>箭头函数的参数</h3><ol>
<li>如果箭头函数没有参数，直接写一个空括号即可。</li>
<li>如果箭头函数的参数只有一个，可以省略包裹参数的括号。</li>
<li>如果箭头函数有多个参数，将参数依次用逗号分隔，参数必须被包裹在括号中。</li>
</ol>
<h3 id="箭头函数的函数体"><a href="#箭头函数的函数体" class="headerlink" title="箭头函数的函数体"></a>箭头函数的函数体</h3><p>如果箭头函数的函数体只有一句代码，即返回某个变量或者返回一个简单的JS表达式，可以省去函数体的大括号{ }。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">val</span> =&gt;</span> val;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123; <span class="keyword">return</span> val &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mulFunction = <span class="function">(<span class="params">num1, num2 ,num3</span>) =&gt;</span> num1 * num2 * num3;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> mulFunction = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2 ,num3</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 * num2 * num3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="箭头函数返回一个对象"><a href="#箭头函数返回一个对象" class="headerlink" title="箭头函数返回一个对象"></a>箭头函数返回一个对象</h3><p>如果箭头函数的函数体只有一句代码且返回一个对象（对象字面量）时，直接写一个表达式是不行的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;; </span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">// 执行后返回undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是这样还会直接报错</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="attr">foo</span>: <span class="number">1</span>, <span class="attr">bar</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>原因是花括号被解释为函数体的大括号，解决办法：<strong>用圆括号把对象字面量包起来</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">foo</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">// &#123;foo: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不过上面那样解决的缺点是可读性变差了，所以更推荐直接当成多条语句的形式来写，可读性高  </span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        foo: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简化回调函数"><a href="#简化回调函数" class="headerlink" title="简化回调函数"></a>简化回调函数</h3><p>这是箭头函数比较常见的用法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>].sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = [<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>
<h2 id="跟普通函数的区别"><a href="#跟普通函数的区别" class="headerlink" title="跟普通函数的区别"></a>跟普通函数的区别</h2><h3 id="没有this绑定"><a href="#没有this绑定" class="headerlink" title="没有this绑定"></a>没有this绑定</h3><p>箭头函数没有自己的this，它会捕获自己在<em>定义时</em>）所处的外层执行环境的this，并继承这个this值。所以，箭头函数中this的指向在它被定义的时候就已经确定了，之后永远不会改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	a: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>) &#125;    </span><br><span class="line">&#125;</span><br><span class="line">obj.a();  <span class="comment">// 打印结果：obj对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">	a:<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">obj.a();  <span class="comment">// 打印结果： Window对象</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，箭头函数与外层的this保持一致，最外层的this就是Window对象。</p>
<h3 id="没有arguments"><a href="#没有arguments" class="headerlink" title="没有arguments"></a>没有arguments</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> func2 = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line">func1(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line">func2(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// Uncaught ReferenceError: arguments is not defined</span></span><br></pre></td></tr></table></figure>
<p>如果非要打印函数参数，可以在箭头函数中使用rest参数代替arguments对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func2 = <span class="function">(<span class="params">...rest</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(rest); <span class="comment">// (2) [1, 2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="不能通过-new-关键字调用"><a href="#不能通过-new-关键字调用" class="headerlink" title="不能通过 new 关键字调用"></a>不能通过 new 关键字调用</h3><p>在构造函数中，this指向新创建的对象实例</p>
<p>而箭头函数没有 [[Construct]]方法，箭头函数不可以当作构造函数，如果这样做会抛出异常</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught TypeError: Person is not a constructor</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'jacky'</span>);</span><br></pre></td></tr></table></figure>
<p>箭头函数在创建时this对象就绑定了，故不会指向对象实例。</p>
<h3 id="没有-new-target"><a href="#没有-new-target" class="headerlink" title="没有 new.target"></a>没有 new.target</h3><p>new.target是ES6新引入的属性，普通函数如果通过new调用，new.target会返回该函数的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(); <span class="comment">// ƒ Cat() &#123; console.log(new.target); &#125;</span></span><br></pre></td></tr></table></figure>
<p>此属性主要：用于确定构造函数是否为new调用的。 </p>
<p>箭头函数的this指向全局对象，在箭头函数中使用箭头函数会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target);</span><br><span class="line">&#125;</span><br><span class="line">a(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target); <span class="comment">// 报错：Uncaught SyntaxError: new.target expression is not allowed here</span></span><br><span class="line">&#125;;</span><br><span class="line">b();</span><br></pre></td></tr></table></figure>

<h3 id="没有原型"><a href="#没有原型" class="headerlink" title="没有原型"></a>没有原型</h3><p>由于不能通过 new 关键字调用，不能作为构造函数，所以箭头函数不存在 prototype 这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(func.prototype) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="没有-super"><a href="#没有-super" class="headerlink" title="没有 super"></a>没有 super</h3><p>箭头函数没有原型，故也不能通过 super 来访问原型的属性，所以箭头函数也是没有 super 的。同this、arguments、new.target 一样，这些值由外围最近一层非箭头函数决定。</p>
<h3 id="call-apply-bind方法无法改变箭头函数中this的指向"><a href="#call-apply-bind方法无法改变箭头函数中this的指向" class="headerlink" title="call/apply/bind方法无法改变箭头函数中this的指向"></a>call/apply/bind方法无法改变箭头函数中this的指向</h3><p>call()、apply()、bind()方法的共同特点是可以改变this的指向，用来动态修改函数执行时this的指向。但由于箭头函数的this定义时就已经确定了且不会改变。所以这三个方法永远也改变不了箭头函数this的指向。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'global name'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'jacky'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数定义在全局作用域</span></span><br><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">func();     <span class="comment">// global name</span></span><br><span class="line"><span class="comment">// this的指向不会改变，永远指向Window对象,放到到window下的全局变量</span></span><br><span class="line">func.call(obj);     <span class="comment">// global name</span></span><br><span class="line">func.apply(obj);    <span class="comment">// global name</span></span><br><span class="line">func.bind(obj)();   <span class="comment">// global name</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数的解析顺序相对靠前"><a href="#箭头函数的解析顺序相对靠前" class="headerlink" title="箭头函数的解析顺序相对靠前"></a>箭头函数的解析顺序相对靠前</h3><p>虽然箭头函数中的箭头不是运算符，但箭头函数具有与常规函数不同的特殊运算符优先级解析规则。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> callback;</span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;;      </span><br><span class="line"><span class="comment">// SyntaxError:非法箭头函数属性</span></span><br><span class="line"></span><br><span class="line">callback = callback || <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;&#125;);    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<h3 id="箭头函数不支持重名参数"><a href="#箭头函数不支持重名参数" class="headerlink" title="箭头函数不支持重名参数"></a>箭头函数不支持重名参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, a</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, <span class="built_in">arguments</span>); <span class="comment">// 2 Arguments(2) [1, 2, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boo = <span class="function">(<span class="params">a, a</span>) =&gt;</span> &#123; <span class="comment">// 直接报错：Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;;</span><br><span class="line">foo(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">boo(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h3 id="1使用-yield-关键字"><a href="#1使用-yield-关键字" class="headerlink" title="1使用 yield 关键字"></a>1使用 yield 关键字</h3><p>yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器（ Generator ）。</p>
<h2 id="箭头函数不适用的场景"><a href="#箭头函数不适用的场景" class="headerlink" title="箭头函数不适用的场景"></a>箭头函数不适用的场景</h2><p><strong>1.不应被用在定义对象的方法上</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: <span class="number">10</span>,</span><br><span class="line">  b: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span>.x, <span class="keyword">this</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  c: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.x, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">obj.b(); <span class="comment">// 10  &#123;x: 10, b: ƒ, c: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line">obj.c(); <span class="comment">// undefined Window</span></span><br></pre></td></tr></table></figure>
<p>因为它内部this的指向原因，当使用obj.c()的时候，我们希望c方法里面的this指向obj，但是它却指向了obj所在上下文中的this（即window），违背了我们的需求，所以箭头函数不适合作为对象的方法。</p>
<p><strong>2.具有动态上下文的回调函数，也不应使用箭头函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;);</span><br><span class="line">为btn的监听函数是一个箭头函数，导致里面的<span class="keyword">this</span>就是全局对象,而不符合我们想操作按钮本身的需求。如果改成普通函数，<span class="keyword">this</span>就会动态指向被点击的按钮对象</span><br></pre></td></tr></table></figure>

<p>除了前面两点，剩下的跟上面讲的与普通函数的区别重复了，故只作总结不贴代码了:</p>
<ol>
<li>不应被用在定义对象的方法上</li>
<li>具有动态上下文的回调函数，也不应使用箭头函数</li>
<li>不能应用在构造函数中</li>
<li>避免在 prototype 上使用</li>
<li>避免在需要 arguments 上使用</li>
</ol>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之模板字符串</title>
    <url>/2020/01/05/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>模板字符串是ES6中非常重要的一个新特性，这个特性使得处理相关业务变得更加容易。</p>
<a id="more"></a>
<h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">`hello world`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>
<p>注意这里不是双引号，而是反撇号`</p>
<p>在模板字符串中，还可以拼接html元素，同时空格、缩进、换行都会被保留，并且如果模板字符串中的变量没有声明，将报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;ul&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;11&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;22&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/5/16f75f81fdc039fd?w=283&h=118&f=png&s=3077" alt=""></p>
<p>上面代码中，<code>&lt;div&gt;</code>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">        &lt;ul&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;11&lt;/li&gt;</span></span><br><span class="line"><span class="string">            &lt;li&gt;22&lt;/li&gt;</span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span>.trim();</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2020/1/5/16f75fa6f941fbc2?w=285&h=115&f=png&s=3098" alt=""></p>
<p>在模版字符串内使用反引号`时，需要在它前面加转义符\</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">`hello \\n`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<h2 id="嵌入变量"><a href="#嵌入变量" class="headerlink" title="嵌入变量"></a>嵌入变量</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'jacky'</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'我叫'</span> + name + <span class="string">'，大家好'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 我叫jacky，大家好</span></span><br></pre></td></tr></table></figure>
<p>当有变量参与拼接时，ES5下必须用+号这样的形式进行拼接，这样很麻烦而且很容易出错。<br>ES6新增了字符串模版，可以很好的解决这个问题。这时再引用str变量就需要用${name}这种形式了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'jacky'</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'我叫$&#123;name&#125;，大家好'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 我叫jacky，大家好</span></span><br></pre></td></tr></table></figure>
<p>如果大括号内部是一个字符串，将会原样输出：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> world = <span class="string">'666'</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">`hello <span class="subst">$&#123;<span class="string">'world'</span>&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<h2 id="对运算的支持"><a href="#对运算的支持" class="headerlink" title="对运算的支持"></a>对运算的支持</h2><p>在${}里面，可以写任意的JS表达式，比如我们用它进行运算</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="string">`<span class="subst">$&#123;a+b&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h2 id="模板字符串调用函数"><a href="#模板字符串调用函数" class="headerlink" title="模板字符串调用函数"></a>模板字符串调用函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span>); <span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之变量的解构赋值</title>
    <url>/2020/01/04/ES6%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
    <content><![CDATA[<p>解构赋值在开发中很常用，在此总结它的用法…</p>
<a id="more"></a>
<h2 id="什么是解构？"><a href="#什么是解构？" class="headerlink" title="什么是解构？"></a>什么是解构？</h2><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。它在语法上比ES5所提供的更加简洁、紧凑、清晰。它不仅能减少你的代码量，还能从根本上改变你的编码方式。</p>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>以前，为变量赋值，我们只能直接指定值，比如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>; </span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>现在可以用数组解构的方式来进行赋值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1, 2, 3</span></span><br></pre></td></tr></table></figure>
<p>这是数组解构最基本类型的用法，还可以解构对象数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象数组解构</span></span><br><span class="line"><span class="keyword">let</span> [a, b, c] = [&#123;<span class="attr">name</span>: <span class="string">'jacky'</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'monkey'</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">'houge'</span>&#125;];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// &#123;name: 'jacky'&#125;, &#123;name: 'monkey'&#125;, &#123;name: 'houge'&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="数组模式和赋值模式统一"><a href="#数组模式和赋值模式统一" class="headerlink" title="数组模式和赋值模式统一"></a>数组模式和赋值模式统一</h2><p>这条可以理解为等号左边和等号右边的形式要统一，如果不统一解构将失败。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [b, c], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d); <span class="comment">// 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 提取除第二、三个外的所有数值</span></span><br><span class="line"><span class="keyword">let</span> [a, , , d] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, d); <span class="comment">// 1 4</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 1 [2, 3, 4]</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> [a, , , ...d] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, d); <span class="comment">// 1 [4, 5]</span></span><br></pre></td></tr></table></figure>
<p>如果解构不成功，变量的值就等于<code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 2 3 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [c] = [];</span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上述是完全解构的情况，还有一种是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组，解构依然可以成功。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; </span><br><span class="line"><span class="built_in">console</span>.log(x, y); <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, d); <span class="comment">// 1 2 4</span></span><br></pre></td></tr></table></figure>

<h2 id="解构的默认值"><a href="#解构的默认值" class="headerlink" title="解构的默认值"></a>解构的默认值</h2><p>解构赋值允许指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b=<span class="number">2</span>] = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 1 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [a=<span class="number">1</span>, b=<span class="number">2</span>, c, d=<span class="number">13</span>] = [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c, d); <span class="comment">// 10 11 12 13</span></span><br></pre></td></tr></table></figure>

<h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 对象解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而非前者。</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">"aaa"</span>, <span class="attr">b</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">a</span>: x, <span class="attr">b</span>: y &#125; = obj; </span><br><span class="line"><span class="built_in">console</span>.log(x, y); <span class="comment">// aaa bbb</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; a, b &#125; = &#123; <span class="attr">a</span>: <span class="string">'aaa'</span>, <span class="attr">b</span>: <span class="string">'bbb'</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// aaa bbb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不按照顺序</span></span><br><span class="line"><span class="keyword">let</span> &#123; b, a &#125; = &#123; <span class="attr">a</span>: <span class="string">'test1'</span>, <span class="attr">b</span>: <span class="string">'test2'</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(a, b) <span class="comment">// test1 test2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套解构</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">obj</span>: &#123; name &#125;&#125; = &#123; <span class="attr">obj</span>: &#123; <span class="attr">name</span>: <span class="string">'jacky'</span>, <span class="attr">age</span>: <span class="string">'22'</span> &#125; &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// jacky</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 稍微复杂的嵌套</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    p: [</span><br><span class="line">        <span class="string">'Hello'</span>,</span><br><span class="line">        &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line"><span class="built_in">console</span>.log(x, y); <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: rename &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>,<span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(rename); <span class="comment">// aaa</span></span><br><span class="line"><span class="built_in">console</span>.log(foo); <span class="comment">// Uncaught ReferenceError: foo is not defined</span></span><br></pre></td></tr></table></figure>
<p>如果在解构之前就定义了变量，这时候再解构会出现问题。下面是错误的代码，编译会报错（因为js引擎会将{a}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免js将其解释成代码块，才能解决这个问题）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">"aaa"</span> &#125;;</span><br><span class="line">&#123;a&#125; = obj; <span class="comment">// Uncaught SyntaxError: Unexpected token '='</span></span><br></pre></td></tr></table></figure>
<p>要解决报错，使程序正常，这时候只要在解构的语句外边加一个圆括号就可以了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="string">"aaa"</span> &#125;;</span><br><span class="line">( &#123;a&#125; = obj );</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// aaa</span></span><br></pre></td></tr></table></figure>
<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>函数的参数也可以使用解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>函数参数的解构也可以使用默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x, y = <span class="number">7</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">3</span>)); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串解构"><a href="#字符串解构" class="headerlink" title="字符串解构"></a>字符串解构</h2><p>字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e, f] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//h</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">//e</span></span><br><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">//l</span></span><br><span class="line"><span class="built_in">console</span>.log(d); <span class="comment">//l</span></span><br><span class="line"><span class="built_in">console</span>.log(e); <span class="comment">//o</span></span><br><span class="line"><span class="built_in">console</span>.log(f); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s === <span class="built_in">Number</span>.prototype.toString); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s === <span class="built_in">Boolean</span>.prototype.toString); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>

<h2 id="解构赋值的应用"><a href="#解构赋值的应用" class="headerlink" title="解构赋值的应用"></a>解构赋值的应用</h2><h3 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h3><p>通常交换两个变量的方法需要一个额外的临时变量,如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> temp;</span><br><span class="line"></span><br><span class="line">temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure>
<p>用ES6解构赋值的话，会变得很简洁</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">[a, b] = [b ,a];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b); <span class="comment">// 2 1</span></span><br></pre></td></tr></table></figure>

<h3 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h3><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>

<h3 id="访问数组中元素"><a href="#访问数组中元素" class="headerlink" title="访问数组中元素"></a>访问数组中元素</h3><p>有种场景，比如有一个数组（可能为空）。并且希望访问数组的第一个、第二个或第n个项，但如果该项不存在，则使用指定默认值。<br>通常会使用数组的<code>length</code>属性来判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstItem = <span class="string">'hello'</span>;</span><br><span class="line"><span class="keyword">if</span> (list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    firstItem = list[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstItem); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>如果用ES6解构赋值来实现上述逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [];</span><br><span class="line"><span class="keyword">const</span> [firstItem = <span class="string">'hello'</span>] = list;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(firstItem); <span class="comment">// 'hello'</span></span><br></pre></td></tr></table></figure>

<h3 id="提取-JSON-数据"><a href="#提取-JSON-数据" class="headerlink" title="提取 JSON 数据"></a>提取 JSON 数据</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  status: <span class="string">"OK"</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(id, status, number);</span><br><span class="line"><span class="comment">// 42, "OK", [867, 5309]</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历-Map-结构"><a href="#遍历-Map-结构" class="headerlink" title="遍历 Map 结构"></a>遍历 Map 结构</h3><p>任何部署了 Iterator 接口的对象，都可以用<code>for...of</code>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>文章部分内容参考：阮一峰老师的《ECMAScript 6 入门》一书</li>
</ul>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6系列之let和const与var的区别</title>
    <url>/2019/12/28/ES6%E7%B3%BB%E5%88%97%E4%B9%8Blet%E5%92%8Cconst%E4%B8%8Evar%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>ES6规范新增了let、const两种变量声明方式，项目中也经常要用到，今天借着温习ES6语法，来总结let 、const、var的区别。</p>
<a id="more"></a>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>来看下面三段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(c); <span class="comment">// Uncaught ReferenceError: c is not defined</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>用var声明的变量，会在其作用域中发生变量提升，js默认给变量一个undefined值。</p>
<p>但是，在ES6中使用let/const声明的变量，不存在变量提升过程。也就是说，在使用let/const声明的变量，声明前访问它，都会报错。</p>
<h2 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h2><blockquote>
<p>代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">'global'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    a = <span class="string">'block'</span>;    <span class="comment">// Uncaught ReferenceError: a is not defined</span></span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，if代码块里，在let声明变量a之前，都是a的”暂时性死区”,在该范围内访问a都会报错。<br>由此可见，块级作用域内存在let声明的话，它所声明的变量就绑定在这个块级作用域，不再受外部影响。</p>
<h2 id="重复声明"><a href="#重复声明" class="headerlink" title="重复声明"></a>重复声明</h2><p>let 和 const 命令声明的变量不允许重复声明；而使用var声明变量，可以多次重复声明一个同名变量，但最终变量的值为最后一次声明赋值的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'last value'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// last value</span></span><br></pre></td></tr></table></figure>

<p>let与const在相同作用域声明重复的变量会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br></pre></td></tr></table></figure>
<p>var和let同时声明同一个变量，也是报同样的错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'b' has already been declared</span></span><br></pre></td></tr></table></figure>
<p>或先var，再let</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> c = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">20</span>; <span class="comment">// Uncaught SyntaxError: Identifier 'c' has already been declared</span></span><br></pre></td></tr></table></figure>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>这里就涉及到一个最经典的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 5 5 5 5 5 </span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个问题的解决可以使用闭包等，ES6的let为这个问题提供了新的解决方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123; </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(i); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用let声明的变量仅在块级作用域内有效。 i在循环体内的局部作用域，不受外界影响。</p>
<p>在ES6之前，都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以花括号{}限定不了var声明变量的访问范围。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">9</span>;     <span class="comment">// es6的let: b变量只在花括号内有效</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br></pre></td></tr></table></figure>

<h2 id="let、const声明的全局变量不会作为window对象的一个属性"><a href="#let、const声明的全局变量不会作为window对象的一个属性" class="headerlink" title="let、const声明的全局变量不会作为window对象的一个属性"></a>let、const声明的全局变量不会作为window对象的一个属性</h2><p>使用var声明的全局变量，会被JS自动添加在全局对象window上，但let和const不会</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="number">30</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.c); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>



<h2 id="const声明常量"><a href="#const声明常量" class="headerlink" title="const声明常量"></a>const声明常量</h2><p>由于const用来声明常量，一旦声明，就必须立即初始化，而且声明之后值不能改变。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">20</span>; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<p>常量的值不变，实际上是指常量指向的那个内存地址中所保存的数据不可更改。</p>
<p>对于基本数据类型（数值，字符串、布尔值），他们本身具体的值就保存在常量所指向对应的栈内存地址中，所以修改值就等于修改栈内存地址，这显然不允许会报错。</p>
<p>但是，如果一个常量的值是一个引用类型值，那么常量所指向的内存地址（堆内存）中实际保存的是指向该引用类型值的一个指针（也就是引用类型值在内存中的地址）。所以const只能保证该引用类型地址不变，但该地址中的具体数据是可以变化的。</p>
<p>如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;a: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当obj指向了另一个对象，即obj中保存的地址发生了变化，即会报错</span></span><br><span class="line">obj = &#123;&#125;;  <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>

<h2 id="如何正确使用"><a href="#如何正确使用" class="headerlink" title="如何正确使用"></a>如何正确使用</h2><p>在开发的时候，声明变量我们应该少使用var，避免产生不必要的全局变量。当需要改变变量的值时声明用let，对于需要写保护的变量或定义常量使用const。</p>
]]></content>
      <categories>
        <category>ES6系列</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>swiper父级元素处于隐藏状态滚动效果失效问题</title>
    <url>/2019/12/25/swiper%E7%88%B6%E7%BA%A7%E5%85%83%E7%B4%A0%E5%A4%84%E4%BA%8E%E9%9A%90%E8%97%8F%E7%8A%B6%E6%80%81%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在使用vue-awesome-swiper的时候，实现这样一个功能, 点击页面的banner图（Banner.vue），进入一个图片画廊（Gallary.vue），可以查看更多相关的照片，但发现轮播图滚动效果失效,本文将解决这个问题。</p>
<a id="more"></a>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/25/16f3aa7f03be6109?w=432&h=764&f=gif&s=1825248" alt=""></p>
<p>原因是：一开始Gallay.vue的所有用swiper控制的图片处于隐藏状态，直到点击才进入图片画廊显示图片。swiper其父级元素处于隐藏状态(display:none), 会导致swiper初始化失败, 页面中的滚动效果就会有问题。</p>
<p>Gallary.vue的结构</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>  @<span class="attr">click</span>=<span class="string">"handleGallaryClick"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">:options</span>=<span class="string">"swiperOption"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">swiper-slide</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of imgs"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"swiper-img"</span> <span class="attr">:src</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span> <span class="attr">slot</span>=<span class="string">"pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一开始Gallary组件都是通过父组件Banner的v-show值设置处于隐藏状态</p>
<p>解决办法：<br>通过swiper的配置项：</p>
<blockquote>
<p>observer<br>启动动态检查器(OB/观众/观看者)，当改变swiper的样式（例如隐藏/显示）或者修改swiper的子元素时</p>
</blockquote>
<blockquote>
<p>observeParents<br>将observe应用于Swiper的父元素。当Swiper的父元素变化时，例如window.resize，Swiper更新。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        swiperOption: &#123;</span><br><span class="line">            pagination : &#123;</span><br><span class="line">                el: &#39;.swiper-pagination&#39;,</span><br><span class="line">                type: &#39;fraction&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            observeParents: true, &#x2F;&#x2F;修改swiper的父元素时，自动初始化swiper</span><br><span class="line">            observer: true   &#x2F;&#x2F;修改swiper自己或子元素时，自动初始化swiper</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/12/25/16f3ab29259088a7?w=431&h=759&f=gif&s=974520" alt=""></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义checkbox样式</title>
    <url>/2019/12/14/%E8%87%AA%E5%AE%9A%E4%B9%89checkbox%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>由于原生的checkbox样式比较难看，所以我们经常需要改写它的样式，美化复选框，所以今天总结下自定义checkbox样式的方法</p>
<a id="more"></a>
<p>html文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox-inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">class</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"hobby"</span>&gt;</span>羽毛球<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"checkmark"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">"checkbox-inline"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">class</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"hobby"</span>&gt;</span>跑步<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"checkmark"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.checkbox-inline</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkbox</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkmark</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">2px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hobby</span>&#123;</span><br><span class="line">    <span class="attribute">padding-left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkbox-inline</span> <span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> ~ <span class="selector-class">.checkmark</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#492c94</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkbox-inline</span> <span class="selector-tag">input</span><span class="selector-pseudo">:checked</span> ~ <span class="selector-class">.checkmark</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.checkbox-inline</span> <span class="selector-class">.checkmark</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">4px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border</span>: solid white;</span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">    <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果图（未选中与选中对比）：</p>
<p><img src="/images/custom-checkbox.png" alt="image.png"></p>
<p>采取的做法是</p>
<ol>
<li>先将原生的checkbox样式隐藏，设置宽高为0，使其隐藏不占位。</li>
<li>在label标签里面添加额外的span标签，用来做自定义样式</li>
<li>添加伪元素，利用css3的transform属性做矩形旋转，做出打勾的样式，并将其隐藏。</li>
<li>当checkbox被选中时，利用css3的选择器:checked，匹配每个已被选中的 checkbox 元素；再使用兄弟选择符~，匹配到同层级checkmark类，就可以显示和触发自定义checkbox选中状态的样式了</li>
</ol>
<p>这里还涉及到一个知识点，伪元素属于主元素的一部分，因此点击伪元素触发的是主元素的click事件。</p>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-awesome-swiper修改轮播图pagination的颜色</title>
    <url>/2019/12/12/vue-awesome-swiper%E4%BF%AE%E6%94%B9%E8%BD%AE%E6%92%AD%E5%9B%BEpagination%E7%9A%84%E9%A2%9C%E8%89%B2/</url>
    <content><![CDATA[<p>在使用vue-awsome-swiper轮播图的时候，pagination处于当前选中状态默认是蓝色，但通过修改这个类并无法改变其背景颜色…</p>
<a id="more"></a>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">:options</span>=<span class="string">"swiperOption"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">swiper-slide</span> <span class="attr">v-for</span>=<span class="string">"(item, index) of swiperList"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">"swiper-img"</span> <span class="attr">:src</span>=<span class="string">"item.imgUrl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">swiper-slide</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span> <span class="attr">slot</span>=<span class="string">"pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/22/16f2bbbf5fbc739b?w=433&h=140&f=png&s=141401" alt=""></p>
<p>原因是为style设置了scoped以后，swiper分页样式就失效了。分页是在mounted里创建的，此时创建的DOM，vue不会帮swiper的pagination加上scoped自定义属性。</p>
<p>解决办法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &gt;&gt;&gt; <span class="selector-class">.swiper-pagination-bullet-active</span></span><br><span class="line">    <span class="selector-tag">background</span>: <span class="selector-id">#ff0</span></span><br></pre></td></tr></table></figure>
<pre><code>.wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active
表示的是在wrapper下所有出现.swiper-pagination-bullet-active</code></pre><p>效果如下：<br><img src="https://user-gold-cdn.xitu.io/2019/12/22/16f2bc67d4dbfa0f?w=426&h=136&f=png&s=151132" alt=""></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue实现星级评价效果</title>
    <url>/2019/12/09/Vue%E5%AE%9E%E7%8E%B0%E6%98%9F%E7%BA%A7%E8%AF%84%E4%BB%B7%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<p>在做店家评价的时候，常常会有星级评价的效果，今天来试试看怎么实现它…</p>
<a id="more"></a>
<p>我们把星级评价单独做成一个Star组件，抽离出来，其中父组件中引入(传入的是评分的值)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"score"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Star</span> <span class="attr">:score</span>=<span class="string">"poiInfo.wm_poi_score"</span>&gt;</span><span class="tag">&lt;/<span class="name">Star</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>初始Star.vue</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;star&quot;&gt;</span><br><span class="line">          &lt;span class&#x3D;&quot;star-item&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123; score &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    name: &#39;Star&#39;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        score: Number</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<p>首先我们把要做星级图片用类名为star-item的span标签循环出来，星级图片有三张，全星，半星，空星<br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/29/16f51be56d1a5ea8?w=20&h=19&f=png&s=1215" alt=""><br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/29/16f51bdf50383e0f?w=20&h=19&f=png&s=1349" alt=""><br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/29/16f51be27b49b42d?w=20&h=19&f=png&s=1220" alt=""></p>
<p>下面只罗列关键的css部分, 通过增加类区分图片</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.star-item</span><span class="selector-class">.on</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(./img/star24_on@<span class="number">2</span>x.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-item</span><span class="selector-class">.half</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(./img/star24_half@<span class="number">2</span>x.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star-item</span><span class="selector-class">.off</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(./img/star24_off@<span class="number">2</span>x.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来修改Star.vue的代码</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"star"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"star-item"</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"(itemClass, index) in itemClasses"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:class</span>=<span class="string">"itemClass"</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>itemClasses值是通过计算属性获取的，思路：</p>
<ol>
<li>通过computed返回一个长度为5的数组（显示5颗星）</li>
<li>数组的值是上述css取的不同星对应的类名，再通过绑定每一个循环添加的class，从而遍历星级。</li>
</ol>
<p>比如举例评分：</p>
<ul>
<li>4.7分对应的数组为[‘on’, ‘on’, ‘on’, ‘on’, ‘half’]</li>
<li>3.4分对应的数组为[‘on’, ‘on’, ‘on’, ‘half’, ‘half’]</li>
</ul>
<p>JS部分的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 星星长度 </span></span><br><span class="line"><span class="keyword">const</span> LENGTH = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 星星的状态</span></span><br><span class="line"><span class="keyword">const</span> CLS_ON = <span class="string">'on'</span></span><br><span class="line"><span class="keyword">const</span> CLS_HALF = <span class="string">'half'</span></span><br><span class="line"><span class="keyword">const</span> CLS_OFF = <span class="string">'off'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name: <span class="string">'Star'</span>,</span><br><span class="line">    props: &#123;</span><br><span class="line">        score: <span class="built_in">Number</span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        itemClasses () &#123;</span><br><span class="line">            <span class="keyword">let</span> result = []</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> score = <span class="built_in">Math</span>.floor(<span class="keyword">this</span>.score * <span class="number">2</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 半星 (通过跟1取余判断是否为小数)</span></span><br><span class="line">            <span class="keyword">let</span> hasDecimal = score % <span class="number">1</span> !== <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 全星 （向下取整，获取全星部分）</span></span><br><span class="line">            <span class="keyword">let</span> integer = <span class="built_in">Math</span>.floor(score)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历全星</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; integer; i++)&#123;</span><br><span class="line">                result.push(CLS_ON)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理半星</span></span><br><span class="line">            <span class="keyword">if</span>(hasDecimal)&#123;</span><br><span class="line">                result.push(CLS_HALF)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 补齐</span></span><br><span class="line">            <span class="keyword">while</span>(result.length &lt; LENGTH)&#123; <span class="comment">// 到这里还不够五颗星，则凑空星</span></span><br><span class="line">                result.push(CLS_OFF)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>itemClasses最终是返回了一个长度为5的数组，需要注意的是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let score &#x3D; Math.floor(this.score * 2) &#x2F; 2</span><br></pre></td></tr></table></figure>
<p>半星的划分：只有当小数第一位大于或等于5才可以算为半星，否则是空星。该计算是为了小数部分&gt;=0.5的计算结果带有小数，从而再后面跟1取余判断是否为半星。一开始有点蒙，多试几个数想想就懂了。</p>
<blockquote>
<p>比如4.3分没有半星，4.5有半星出现</p>
</blockquote>
<p>结果：<br>比如传入的值为4.7，则显示</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/29/16f51d7db002aa38?w=161&h=28&f=png&s=5690" alt=""></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>页面内容是否超出可视高度，footer始终保持底部显示</title>
    <url>/2019/12/07/CSS%E7%B3%BB%E5%88%97%E4%B9%8B%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E8%B6%85%E5%87%BA%E5%8F%AF%E8%A7%86%E9%AB%98%E5%BA%A6%EF%BC%8Cfooter%E5%A7%8B%E7%BB%88%E4%BF%9D%E6%8C%81%E5%BA%95%E9%83%A8%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>记录一个项目中经常会用到的技巧，footer区（比如版权信息）要始终居于页面底部。如果用fixed定位显然不可取，因为要保证页面高度大于屏幕高度时，footer区要跟随着页面滚动保持在底部</p>
<a id="more"></a>
<p>如下图：</p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/7/16ee0e36c5c55fea?w=1737&h=899&f=png&s=23364" alt=""></p>
<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/12/7/16ee0e3a25e302bd?w=1577&h=903&f=png&s=27932" alt=""></p>
<ul>
<li>tip：以下两个方法仅适用于footer区高度固定的情况</li>
</ul>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>页面结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main-container&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;box&quot;&gt;这是主要内容&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;footer&gt;这是底部&lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>关键的css<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.wrapper</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.main-container</span>&#123;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">footer</span>&#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如上代码，主要内容区和footer区必须为并列关系。设置main-container为border-box，即元素的内边距和边框都在已设定的高度内绘制，我们设置了min-height为100%，即最小高度是铺满整屏幕。padding-bottom在border-box盒子中，留出高度40px的空白块。footer的margin-top为-40px（如果footer有设置高度，padding-bottom的值应以footer高度为准），即向上拉到空白块内，main-container最小高度为整个屏幕，故页面内容不足也可以显示在底部。</p>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>页面结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;main-container&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;box&quot;&gt;这是主要内容&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;footer&gt;这是底部&lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>关键的css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html,body&#123;</span><br><span class="line">    height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.wrapper&#123;</span><br><span class="line">    min-height: 100%;</span><br><span class="line">    position: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.main-container&#123;</span><br><span class="line">    padding-bottom: 40px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">footer&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    height: 40px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码时用绝对定位，相对于wrapper居于底部，跟第一个方法有异曲同工之妙。</p>
]]></content>
      <categories>
        <category>CSS系列</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之执行上下文和变量对象</title>
    <url>/2019/11/28/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>继续接着上篇文章，今天再细说执行上下文中的变量对象…</p>
<a id="more"></a>
<p>上篇我们说到函数上下文的结构可表示为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ExecutionContextObj = &#123;</span><br><span class="line">    VO: <span class="built_in">window</span>,     <span class="comment">// 变量对象</span></span><br><span class="line">    ScopeChain: &#123;&#125;, <span class="comment">// 作用域链</span></span><br><span class="line">    <span class="keyword">this</span>: <span class="built_in">window</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>即每个函数上下文，都要有这三个重要属性：</p>
<ul>
<li>变量对象(Variable object, VO)</li>
<li>作用域链(Scope chain)</li>
<li>this</li>
</ul>
<h2 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h2><h3 id="什么是变量对象"><a href="#什么是变量对象" class="headerlink" title="什么是变量对象"></a>什么是变量对象</h3><p>变量对象是与执行上下文的相关的数据作用域，存储了在上下文中定义的变量和函数声明。因为不同执行上下文的变量对象略有不同，所以变量对象一般分为全局上下文下的变量对象和函数上下文下的变量对象。</p>
<h3 id="变量对象-VO-的创建过程"><a href="#变量对象-VO-的创建过程" class="headerlink" title="变量对象(VO)的创建过程"></a>变量对象(VO)的创建过程</h3><p>变量对象的创建，属于执行上下文中的创建阶段，依次经过以下三个过程：</p>
<p>创建执行上下文有两个阶段：一个是创建阶段，一个是执行阶段。变量对象的创建，属于执行上下文中的创建阶段，会依次经过三个过程：</p>
<h4 id="1-为函数的形参赋值（函数上下文）"><a href="#1-为函数的形参赋值（函数上下文）" class="headerlink" title="1.为函数的形参赋值（函数上下文）"></a>1.为函数的形参赋值（函数上下文）</h4><p>在进入函数执行上下文时，会首先检查实参个数，接着对实参对象和形参进行赋值。如果没有实参，属性值设为undefined；当传入的实参数量小于形参数量，则会将没有被赋值的形参赋值为 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1 2 undefined</span></span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>此时变量对象的结构为:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">VO = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-函数声明"><a href="#2-函数声明" class="headerlink" title="2.函数声明"></a>2.函数声明</h4><p>遇到同名的函数时，后面函数会覆盖前面的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'先声明的'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'后声明的'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn); <span class="comment">//ƒ fn() &#123; console.log('后声明的'); &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="3-变量声明"><a href="#3-变量声明" class="headerlink" title="3.变量声明"></a>3.变量声明</h4><p>检查当前环境中通过变量声明(var)并赋值为undefined（变量提升产生的原因）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn); <span class="comment">// ƒ fn() &#123; console.log('后声明的');&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'先声明的'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'后声明的'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>由上面我们看出，当变量名称与函数名称同名时，会忽略此变量声明，即同名时，函数声明优先</p>
<p>js虽然单线程的语言，执行顺序为顺序执行，但JS引擎并不是一行一行地分析和执行程序，而是一段一段地分析执行。</p>
<p>让我们从JS引擎的角度理一理上述三个过程：<strong>函数提升和变量提升，是全局执行上下文做的准备工作；当执行函数时，又会创建一个执行上下文，做的是这个函数内部的准备工作；这就是JS引擎分析代码的”预编译阶段”，做完该工作才进入执行阶段。</strong></p>
<h3 id="全局上下文的变量对象"><a href="#全局上下文的变量对象" class="headerlink" title="全局上下文的变量对象"></a>全局上下文的变量对象</h3><p>在客户端 JavaScript 中，全局对象就是 Window 对象;</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>; <span class="comment">// 在全局上下文使用var定义变量a，作为全局变量的宿主</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window对象</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>对于全局上下文中来说，变量对象就是全局对象，</p>
<h3 id="变量对象变为活动对象"><a href="#变量对象变为活动对象" class="headerlink" title="变量对象变为活动对象"></a>变量对象变为活动对象</h3><p>执行上下文的第二个阶段为执行阶段，此时会进行变量赋值，执行其他代码等工作，此时，变量对象变为活动对象(Active object, AO)。</p>
<blockquote>
<p>活动对象和变量对象其实是同个东西，只是规范概念上的差异。只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫活动对象。而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。</p>
</blockquote>
<p>所以明确，活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fn); <span class="comment">// ƒ fn() &#123; console.log('后声明的');&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// undefined</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'先声明的'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'后声明的'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">20</span>;        </span><br><span class="line"><span class="built_in">console</span>.log(fn);<span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>上述代码，真正开始执行是从第一行console.log(fn)。在此之前，变量对象VO是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建过程</span></span><br><span class="line">EC= &#123;</span><br><span class="line">  VO：&#123;&#125;, <span class="comment">// 创建变量对象</span></span><br><span class="line">  scopeChain: [&#123;VO&#125;], <span class="comment">// 作用域链</span></span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span> <span class="comment">// this绑定</span></span><br><span class="line">&#125;</span><br><span class="line">VO = &#123;</span><br><span class="line">  <span class="comment">// argument: &#123;&#125;, // 当前为全局上下文，不存在arguments</span></span><br><span class="line">  fn: reference to <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="comment">// 函数fn的引用地址</span></span><br><span class="line">  b: undefiend  <span class="comment">// 变量提升</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据变量对象创建的三个过程，</p>
<ol>
<li>首先是arguments对象的创建（全局上下文没有则忽略）</li>
<li>其次，是检查函数的声明。此时，函数fn声明了两次，则后一次的声明会覆盖上一次的声明。</li>
<li>最后，是检查变量的声明，先声明了变量b，将它赋值为 undefined；接着遇到fn的变量声明，由于fn已经被声明为一个函数，故忽略该变量声明。 </li>
</ol>
<p>到此，变量对象的创建阶段完成，接下来进行执行阶段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.执行console.log(fn);此时fn为声明的第二个函数，故输出结果：&quot;后声明的&quot;。</span><br><span class="line">2.执行console.log(b)，此时b已被赋值为undefined，故输出结果：&quot;undefined&quot;。</span><br><span class="line">3.执行赋值操作： b &#x3D; 10;</span><br><span class="line">4.执行console.log(b) ，故输出b为10。</span><br><span class="line">5.执行赋值操作： fn &#x3D; 20;</span><br><span class="line">6.执行console.log(fn) ，故输出fn为20。</span><br></pre></td></tr></table></figure>

<p>执行到最后一步时，执行上下文如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行阶段</span></span><br><span class="line">EC = &#123;</span><br><span class="line">  VO = &#123;&#125;;</span><br><span class="line">  scopeChain: &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// VO ---- AO</span></span><br><span class="line">AO = &#123;</span><br><span class="line">  argument: &#123;&#125;;</span><br><span class="line">  fn: <span class="number">20</span>;</span><br><span class="line">  b: <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上，就是变量对象在代码执行前及执行后的变化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>全局上下文的变量对象初始化是全局对象</p>
</li>
<li><p>函数上下文的变量对象初始化只包括 arguments 对象</p>
</li>
<li><p>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</p>
</li>
<li><p>在代码执行阶段，会再次修改变量对象的属性值</p>
</li>
</ol>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之执行上下文和执行栈</title>
    <url>/2019/11/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E6%89%A7%E8%A1%8C%E6%A0%88/</url>
    <content><![CDATA[<p>都说想成为出色的JavaScript 开发者，就要深入学习 JavaScript 程序内部的执行机制，最近学了一遍JS的执行上下文和执行栈，以此作总结。</p>
<a id="more"></a>
<p>首先先来了解几个专业概念</p>
<ul>
<li><p>EC：函数执行环境（或执行上下文），Execution Context</p>
</li>
<li><p>ECS：执行环境栈，Execution Context Stack</p>
</li>
<li><p>VO：变量对象，Variable Object</p>
</li>
<li><p>AO：活动对象，Active Object</p>
</li>
<li><p>scope chain：作用域链</p>
</li>
</ul>
<h2 id="什么是执行上下文"><a href="#什么是执行上下文" class="headerlink" title="什么是执行上下文"></a>什么是执行上下文</h2><p>每次当控制器转到ECMAScript可执行代码的时候，它都是在执行上下文中运行，即是指当前执行环境中的变量、函数声明，参数，作用域链，this等信息。</p>
<h3 id="组成代码示例"><a href="#组成代码示例" class="headerlink" title="组成代码示例"></a>组成代码示例</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ExecutionContextObj = &#123;</span><br><span class="line">    VO: <span class="built_in">window</span>,     <span class="comment">// 变量对象</span></span><br><span class="line">    ScopeChain: &#123;&#125;, <span class="comment">// 作用域链</span></span><br><span class="line">    <span class="keyword">this</span>: <span class="built_in">window</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="执行上下文的类型"><a href="#执行上下文的类型" class="headerlink" title="执行上下文的类型"></a>执行上下文的类型</h2><p>JavaScript 中有三种执行上下文类型。</p>
<ol>
<li><p><strong>全局执行上下文</strong>——  这是默认上下文，浏览器中的全局对象就是window对象，任何不在函数内部的代码都在全局上下文中，this指向这个全局对象。</p>
</li>
<li><p><strong>函数执行上下文</strong> —— 当<strong>函数被调用时创建</strong>,会为该函数创建一个新的执行上下文，可以有任意个。 </p>
</li>
<li><p><strong>Eval 函数执行上下文</strong> ——<br>执行 eval函数内部的代码也有属于它的上下文，由于开发中是尽量避免或不用eval函数，故此不作讨论。</p>
</li>
</ol>
<h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈，也叫调用栈，被用来存储代码运行时创建的所有执行上下文。</p>
<blockquote>
<p>栈：一种数据结构，遵循后进先出的原则</p>
</blockquote>
<p>当 JavaScript 引擎第一次遇到脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。</p>
<p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn1被调用了 -- 创建了fn1的函数执行上下文，压入栈'</span>);</span><br><span class="line">  fn2(); </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn2执行完成，fn2的执行上下文会从栈中弹出'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'fn2被调用了 -- 创建了fn2的函数执行上下文，压入栈'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'fn1执行完成，fn2的执行上下文会从栈中弹出'</span>);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fn1被调用了 -- 创建了fn1的函数执行上下文，压入栈</span><br><span class="line">fn2被调用了 -- 创建了fn2的函数执行上下文，压入栈</span><br><span class="line">fn2执行完成，fn2的执行上下文会从栈中弹出</span><br><span class="line">fn1执行完成，fn2的执行上下文会从栈中弹出</span><br></pre></td></tr></table></figure>
<p>上述代码的执行上下文栈：<br><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/11/27/16ead7c041a4b415?w=1276&h=316&f=png&s=30716" alt=""></p>
<p>当上述代码在浏览器加载时，JavaScript引擎创建了一个全局执行上下文并把它压入栈中，当函数fn1()被调用时，JavaScript为该函数创建了一个函数执行上下文，并把它压入当前执行栈的顶部。</p>
<p>当fn1()函数内部调用fn2()函数时，JavaScript引擎同样创建了fn2()的函数执行上下文并压入栈的顶部。然后执行了fn2()函数后，fn2()函数会从当前栈（后进先出结构）弹出，并且按程序执行顺序继续执行fn1()函数，即此刻处于fn1的函数执行上下文。</p>
<p>当 fn1()函数执行完毕，它的执行上下文从栈弹出，控制流程到达全局执行上下文。一旦所有代码执行完毕，JavaScript 引擎从当前栈中移除全局执行上下文。</p>
<h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>已经知道JavaScript 怎样管理执行上下文了，现在来了解JavaScript引擎是怎么创建执行上下文的。</p>
<p>创建执行上下文有两个阶段：</p>
<ol>
<li>创建阶段</li>
<li>执行阶段。</li>
</ol>
<p>在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事：</p>
<ol>
<li>this绑定</li>
<li>创建(LexicalEnvironment)词法环境组件</li>
<li>创建(VariableEnvironment)变量环境组件</li>
</ol>
<p>执行上下文在概念可表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ExecutionContext &#x3D; &#123;</span><br><span class="line">  ThisBinding &#x3D; &lt;this value&gt;,</span><br><span class="line">  LexicalEnvironment &#x3D; &#123; ... &#125;,</span><br><span class="line">  VariableEnvironment &#x3D; &#123; ... &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-创建阶段"><a href="#1-创建阶段" class="headerlink" title="1. 创建阶段"></a>1. 创建阶段</h3><h4 id="this-绑定"><a href="#this-绑定" class="headerlink" title="this 绑定"></a>this 绑定</h4><p>在全局执行上下文中，this 的值指向全局对象。(在浏览器中，this引用window对象)</p>
<p>在函数执行上下文中，this的指向取决于函数是如何被调用的,在本篇暂不对this指向做详细讨论。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    fn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> win = obj.fn;</span><br><span class="line"></span><br><span class="line">obj.fn(); <span class="comment">//this指向obj</span></span><br><span class="line">win(); <span class="comment">// this指向window</span></span><br></pre></td></tr></table></figure>

<h4 id="词法环境（Lexical-Environment）"><a href="#词法环境（Lexical-Environment）" class="headerlink" title="词法环境（Lexical Environment）"></a>词法环境（Lexical Environment）</h4><p>ES6官方文档把词法环境定义为：</p>
<blockquote>
<p>词法环境是用来定义 基于词法嵌套结构的ECMAScript代码内的标识符与变量值和函数值之间的关联关系 的一种规范类型。一个词法环境由环境记录（Environment Record）和一个可能为null的对外部词法环境的引用（outer）组成。一般来说，词法环境都与特定的ECMAScript代码语法结构相关联，例如函数、代码块、TryCatch中的Catch从句，并且每次执行这类代码时都会创建新的词法环境。</p>
</blockquote>
<p>可以理解为词法环境是一种包含标识符(变量/函数的名称)和变量(函数/原始值/数组对象等)映射的数据结构</p>
<h5 id="词法环境有两个组成部分"><a href="#词法环境有两个组成部分" class="headerlink" title="词法环境有两个组成部分"></a>词法环境有两个组成部分</h5><ol>
<li><p>声明式环境记录器：存储变量和函数声明的实际位置</p>
</li>
<li><p>对象环境记录器：可以访问其外部词法环境(作用域)</p>
</li>
</ol>
<h5 id="词法环境有两种类型"><a href="#词法环境有两种类型" class="headerlink" title="词法环境有两种类型"></a>词法环境有两种类型</h5><ol>
<li><p>全局环境：是一个没有外部环境的词法环境，其外部环境引用为 null。拥有一个全局对象（window 对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this 的值指向这个全局对象。</p>
</li>
<li><p>函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments 对象。对外部环境的引用可以是全局环境，也可以是包含内部函数的外部函数环境。</p>
</li>
</ol>
<h4 id="变量环境-VariableEnvironment"><a href="#变量环境-VariableEnvironment" class="headerlink" title="变量环境 (VariableEnvironment)"></a>变量环境 (VariableEnvironment)</h4><p>变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性。</p>
<p>在ES6中，词法环境组件和变量环境组件之间的一个区别是前者用于存储函数声明和变量let和const绑定，而后者仅用于存储变量var绑定。</p>
<h3 id="2-执行阶段"><a href="#2-执行阶段" class="headerlink" title="2.执行阶段"></a>2.执行阶段</h3><p>在此阶段，完成对所有这些变量的分配，最后执行代码。（在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined）</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之实现继承的7种方式</title>
    <url>/2019/11/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%847%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>有必要搞清楚JS实现继承的方式…</p>
<a id="more"></a>
<h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>核心：<strong>将父类的实例作为子类的原型</strong></p>
<p>首先，要知道构造函数、原型和实例之间的关系：构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个原型对象的指针。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'父类的名字'</span>;</span><br><span class="line">&#125;   </span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'子类的名字'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果此时有Son的原型对象有方法或属性，下面Son.prototype = new Father()，由于原型重定向，原型上的方法和属性会丢失</span></span><br><span class="line">Son.prototype.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类的年龄'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father(); <span class="comment">// 核心:创建父类的实例，并将该实例赋值给子类的prototype</span></span><br><span class="line"></span><br><span class="line">Son.prototype.getSonName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类的方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line">son.getFatherName(); <span class="comment">// 父类的方法</span></span><br><span class="line">Son.prototype.__proto__.getFatherName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 缺点：如果有多个实例对其父类原型，则会互相影响</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类改变父类的方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line">son.getFatherName(); <span class="comment">// 子类改变父类的方法</span></span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ol>
<li><p>父类使用this声明的属性(私有属性和公有属性)被所有实例共享,在多个实例之间对引用类型数据操作会互相影响。</p>
</li>
<li><p>创建子类实例时，无法向父类构造函数传参。</p>
</li>
</ol>
<h2 id="借用构造函数继承-call"><a href="#借用构造函数继承-call" class="headerlink" title="借用构造函数继承(call)"></a>借用构造函数继承(call)</h2><p>核心：<strong>使用父类的构造函数来增强子类实例</strong>，即复制父类的实例属性给子类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;  </span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>,name, age); <span class="comment">// 继承自Father</span></span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>, <span class="number">22</span>, <span class="string">'前端开发'</span>);</span><br><span class="line"><span class="comment">//son.getFatherName(); // Uncaught TypeError: son.getFatherName is not a function</span></span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ol>
<li>可以向父类传递参数,而且解决了原型链继承中：父类属性使用this声明的属性会在所有实例共享的问题。</li>
</ol>
<p>缺点：</p>
<ol>
<li>只能继承父类通过this声明的属性/方法，不能继承父类prototype上的属性/方法。</li>
<li>每次子类实例化都要执行父类函数，重新声明父类this里所定义的方法，因此父类方法无法复用。</li>
</ol>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>核心：<strong>组合上述两种方法，用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.sex = <span class="string">'man'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>,name,age); <span class="comment">// 第二次调用:创建子类型实例的时候</span></span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line">Son.prototype = <span class="keyword">new</span> Father(); <span class="comment">// 第一次调用:设置子类型实例的原型的时候</span></span><br><span class="line">Son.prototype.constructor = Son; <span class="comment">// prototype构造器指回自己 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>, <span class="number">22</span>, <span class="string">'前端开发'</span>);</span><br><span class="line">son.getFatherName();</span><br><span class="line"><span class="built_in">console</span>.log(son)</span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/11/20/16e89812367319c7?w=517&h=227&f=png&s=19707" alt=""></p>
<p>优点：</p>
<ol>
<li>可以继承父类原型上的属性，可以传参，可复用。</li>
<li>每个新子类对象实例引入的构造函数属性是私有的。</li>
</ol>
<p>缺点：</p>
<ol>
<li>两次调用父类函数(new fatherFn()和fatherFn.call(this))，造成一定的性能损耗。</li>
<li>在使用子类创建实例对象时，其原型中会存在两份相同属性/方法的问题。</li>
</ol>
<p>拓展：</p>
<h3 id="constructor的作用"><a href="#constructor的作用" class="headerlink" title="constructor的作用"></a>constructor的作用</h3><p><strong>返回创建实例对象的Object构造函数的引用</strong>。</p>
<blockquote>
<p>当我们只有实例对象没有构造函数的引用时：<br>某些场景下，我们对实例对象经过多轮导入导出，我们不知道实例是从哪个函数中构造出来或者追踪实例的构造函数，较为艰难。(它主要防止一种情况下出错，就是你显式地去使用构造函数。比如，我并不知道instance是由哪个函数实例化出来的，但是我想clone一个，这时就可以这样——&gt;instance.constructor)<br>这个时候就可以通过实例对象的constructor属性来得到构造函数的引用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> sonFn() <span class="comment">// 实例化子类</span></span><br><span class="line"><span class="keyword">export</span> instance;</span><br><span class="line"><span class="comment">// 多轮导入+导出，导致sonFn追踪非常麻烦，或者不想在文件中再引入sonFn</span></span><br><span class="line"><span class="keyword">let</span>  fn = instance.constructor</span><br></pre></td></tr></table></figure>

<p>因此每次<strong>重写</strong>函数的prototype都应该修正一下constructor的指向，以保持读取constructor指向的一致性</p>
<h2 id="原型式继承（Object-create-）"><a href="#原型式继承（Object-create-）" class="headerlink" title="原型式继承（Object.create()）"></a>原型式继承（Object.create()）</h2><p>核心：利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Object.create() 的实现原理 */</span></span><br><span class="line"><span class="comment">// cloneObject()对传入其中的对象执行了一次浅拷贝，将构造函数F的原型直接指向传入的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = obj; <span class="comment">// 将传进来obj对象作为空函数的prototype</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F(); <span class="comment">// 此对象的原型为被继承的对象, 通过原型链查找可以拿到被继承对象的属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> father = &#123;</span><br><span class="line">    name: <span class="string">'jacky'</span>,</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">    courses: [<span class="string">'前端'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var son1 = Object.create(father); // 效果一样</span></span><br><span class="line"><span class="keyword">var</span> son1 = cloneObject(father);</span><br><span class="line">son1.courses.push(<span class="string">'后端'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son2 = cloneObject(father);</span><br><span class="line">son2.courses.push(<span class="string">'全栈'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(father.courses); <span class="comment">//  ["前端", "后端", "全栈"]</span></span><br></pre></td></tr></table></figure>
<p>优点：</p>
<p>从已有对象衍生新对象，不需要创建自定义类型</p>
<p>缺点：</p>
<p>与原型链继承一样。多个实例共享被继承对象的属性，存在篡改的可能；也无法传参。</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>核心：<strong>在原型式继承的基础上，创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象(增加了一些新的方法和属性)，最后返回对象。</strong></p>
<p>使用场景：专门为对象来做某种固定方式的增强。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(obj);</span><br><span class="line">    clone.skill = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 以某种方式来增强这个对象</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'run'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> animal = &#123;</span><br><span class="line">    eat: <span class="string">'food'</span>,</span><br><span class="line">    drink: <span class="string">'water'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = createAnother(animal);</span><br><span class="line">dog.skill();</span><br></pre></td></tr></table></figure>

<p>优点：没有创建自定义类型，因为只是套了个壳子增加特定属性/方法返回对象，以达到增强对象的目的</p>
<p>缺点：</p>
<p>同原型式继承：原型链继承多个实例的引用类型属性指向相同，存在篡改的可能，也无法传递参数</p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>核心：结合借用构造函数传递参数和寄生模式实现继承</p>
<ol>
<li>通过借用构造函数(call)来继承父类this声明的属性/方法</li>
<li>通过原型链来继承方法</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Father.prototype.getFatherName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'父类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    Father.call(<span class="keyword">this</span>,name,age); <span class="comment">// 借用构造继承: 继承父类通过this声明属性和方法至子类实例的属性上</span></span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄生式继承：封装了son.prototype对象原型式继承father.prototype的过程，并且增强了传入的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">son,father</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(father.prototype); <span class="comment">// 原型式继承：浅拷贝father.prototype对象</span></span><br><span class="line">    clone.constructor = son;  <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性</span></span><br><span class="line">    son.prototype = clone; <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Son,Father); <span class="comment">// 将父类原型指向子类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性</span></span><br><span class="line">Son.prototype.getSonName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'子类的方法'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>,<span class="number">22</span>,<span class="string">'前端开发'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(son);</span><br></pre></td></tr></table></figure>

<p><img src="https://images.weserv.nl/?url=https://user-gold-cdn.xitu.io/2019/11/23/16e97782ff645ca0?w=361&h=182&f=png&s=24333" alt=""></p>
<ul>
<li>寄生组合式继承相对于组合继承有如下优点：</li>
</ul>
<ol>
<li>只调用一次父类Father构造函数。不必为了指定子类的原型而调用构造函数，而是间接的让 Son.prototype 访问到 Father.prototype。</li>
<li>避免在子类prototype上创建不必要多余的属性。<br>使用原型式继承父类的prototype，保持了原型链上下文不变, instanceof 和isPrototypeOf()也能正常使用。</li>
<li>寄生组合式继承是最成熟的继承方法, 也是现在最常用的继承方法，众多JS库采用的继承方案也是它。</li>
</ol>
<p>缺点：</p>
<p>硬要说的话，就是给子类原型添加属性和方法的时候，一定要放在inheritPrototype()方法之后</p>
<h2 id="ES6-extends继承（最优方式）"><a href="#ES6-extends继承（最优方式）" class="headerlink" title="ES6 extends继承（最优方式）"></a>ES6 extends继承（最优方式）</h2><p>核心： 类之间通过extends关键字实现继承，清晰方便。 class 仅仅是一个语法糖，它的核心思想仍然是寄生组合式继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">	<span class="keyword">this</span>.name = name;</span><br><span class="line">	<span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  skill() &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'父类的技能'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, job)&#123;</span><br><span class="line">	<span class="keyword">super</span>(name, age); <span class="comment">// 调用父类的constructor,只有调用super之后，才可以使用this关键字</span></span><br><span class="line">	<span class="keyword">this</span>.job = job;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="keyword">this</span>.age, <span class="keyword">this</span>.job);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="string">'jacky'</span>,<span class="number">22</span>,<span class="string">'前端开发'</span>);</span><br><span class="line">son.skill(); <span class="comment">// 父类的技能</span></span><br><span class="line">son.getInfo(); <span class="comment">// jacky 22 前端开发</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</li>
</ul>
<blockquote>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。</p>
</blockquote>
<h2 id="ES5继承与ES6继承的区别"><a href="#ES5继承与ES6继承的区别" class="headerlink" title="ES5继承与ES6继承的区别"></a>ES5继承与ES6继承的区别</h2><ol>
<li>ES5的继承实质上是先创建子类的实例对象，再将父类的方法添加到this上( Father.call(this) )。</li>
<li>ES6的继承是先创建父类的实例对象this，再用子类的构造函数修改this。</li>
<li>因为子类没有自己的this对象，所以必须先调用父类的super()方法。</li>
</ol>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>实现swiper自定义分页器</title>
    <url>/2019/11/16/%E5%AE%9E%E7%8E%B0swiper%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E9%A1%B5%E5%99%A8/</url>
    <content><![CDATA[<p><strong>问题:不想使用swiper(用的是4.5.1版本)的自带的圆钮式的分页器，需要自定义样式同时分页器需要摆在图片外面</strong></p>
<a id="more"></a>

<p>解决办法:利用swiper提供的renderCustom()方法</p>
<p>html文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-wrapper"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/IMG_20191109_141728.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-slide"</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./img/IMG_20191109_154050.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--分页器要放图片外显示的话，需要移出来--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;div class="swiper-pagination"&gt;&lt;/div&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"swiper-pagination"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySwiper = <span class="keyword">new</span> Swiper (<span class="string">'.swiper-container'</span>, &#123;</span><br><span class="line">        autoplay: &#123;</span><br><span class="line">            delay: <span class="number">3000</span>,</span><br><span class="line">            disableOnInteraction: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        pagination: &#123;</span><br><span class="line">            el: <span class="string">'.swiper-pagination'</span>,</span><br><span class="line">            type: <span class="string">'custom'</span>,</span><br><span class="line">            renderCustom: <span class="function"><span class="keyword">function</span> (<span class="params">swiper, current, total</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> customPaginationHtml = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">                    <span class="comment">// 判断哪个分页器此刻应该被激活</span></span><br><span class="line">                    <span class="keyword">if</span>(i == (current - <span class="number">1</span>)) &#123;</span><br><span class="line">                        customPaginationHtml += <span class="string">'&lt;span class="swiper-pagination-customs swiper-pagination-customs-active"&gt;&lt;/span&gt;'</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        customPaginationHtml += <span class="string">'&lt;span class="swiper-pagination-customs"&gt;&lt;/span&gt;'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> customPaginationHtml;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>css文件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.swiper-box</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-container</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">74vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">34vw</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">4vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-container</span> <span class="selector-class">.swiper-slide</span> <span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-pagination</span>&#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">74vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-pagination-bullet</span>&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">4vw</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 包裹自定义分页器的div的位置的样式 */</span></span><br><span class="line"><span class="selector-class">.swiper-pagination-custom</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: -<span class="number">5vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.swiper-pagination-customs</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../img/point-grey.png); <span class="comment">/* 未轮播到的图片分页样式 */</span></span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: contain;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1.4vw</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">1.4vw</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">2vw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*自定义分页器激活时的样式表现*/</span></span><br><span class="line"><span class="selector-class">.swiper-pagination-customs-active</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(../img/point-green.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：<img src="/images/swiper-pagination.png" alt=" "></p>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端原生JS之开启和禁止页面滚动</title>
    <url>/2019/11/10/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%8E%9F%E7%94%9FJS%E4%B9%8B%E5%BC%80%E5%90%AF%E5%92%8C%E7%A6%81%E6%AD%A2%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/</url>
    <content><![CDATA[<p>在做移动端页面通常有操作需要禁止页面的滚动，来看看原生js怎么操作</p>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 禁止页面滚动</span></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'touchmove'</span>, handler, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>passive：false。 设置该属性的目的主要是为了在阻止事件默认行为导致的卡顿。等待监听器的执行是耗时的，有些甚至耗时很明显，这样就会导致页面卡顿。即便监听器是个空函数，也会产生一定的卡顿，毕竟空函数的执行也会耗时。加上{ passive: false }能防止页面卡顿。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启页面滚动</span></span><br><span class="line"><span class="built_in">document</span>.body.removeEventListener(<span class="string">'touchmove'</span>, handler, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure></li>
<li>注意点，不能这样写<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启页面滚动</span></span><br><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">&#125;, &#123; <span class="attr">passive</span>: <span class="literal">false</span> &#125;);</span><br></pre></td></tr></table></figure></li>
<li>添加和移除的函数对象应该是同一个,否则移除不起作用,即listener不能直接用匿名函数</li>
</ul>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>sessionStorage、localStorage用法总结</title>
    <url>/2019/11/03/sessionStorage%E3%80%81localStorage%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>在工作中使用sessionStorage存储数据时，发现sessionStorage无法直接存储数组和对象，如存入对象则显示为”[object Object]”，对此作下记录，重新温习sessionStorage和localStorage</p>
<a id="more"></a>

<p>html5 中的 web Storage 包括了两种存储方式：sessionStorage 和 localStorage</p>
<h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><p>存储大小为5MB，都保存在客户端，不与服务器进行交互通信，有相同的Web API</p>
<h2 id="sessionStorage、localStorage区别"><a href="#sessionStorage、localStorage区别" class="headerlink" title="sessionStorage、localStorage区别"></a>sessionStorage、localStorage区别</h2><p>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</p>
<p>sessionStorage 数据在当前浏览器窗口关闭后自动删除。</p>
<p>因此<strong>sessionStorage 和 localStorage 的主要区别在于他们存储数据的生命周期</strong>，sessionStorage 存储的数据的生命周期是一个会话，而 localStorage存储的数据的生命周期是永久，除非主动删除数据，否则永远不会过期</p>
<h2 id="Web-Storage-API"><a href="#Web-Storage-API" class="headerlink" title="Web Storage API"></a>Web Storage API</h2><p>localStorage 和 sessionStorage 有着统一的API接口，下面以sessionStorage为例介绍一下 API 接口使用方法</p>
<h3 id="添加键值对"><a href="#添加键值对" class="headerlink" title="添加键值对"></a>添加键值对</h3><p><strong>setItem(key,value)：为指定key值设置一个对应的value值</strong></p>
<p>除了使用setItem方法，还可以使用sessionStorage.key = value或者sessionStorage[‘key’] = value这两种形式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把name值存储到name的键上</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'name'</span>, <span class="string">'jacky'</span>); <span class="comment">// 法1 </span></span><br><span class="line"><span class="comment">// sessionStorage.name = 'jacky'; // 法2 </span></span><br><span class="line"><span class="comment">// sessionStorage['name'] = 'jacky'; // 法3</span></span><br></pre></td></tr></table></figure>
<p><strong>添加数组和对象</strong></p>
<p>需要注意的是key和value值必须是<strong>字符串形式</strong>的，如果不是字符串，会调用它们相应的toString()方法来转换成字符串再存储。</p>
<p>所以要存储数组或对象时，应先转换成字符串格式（如JSON格式）再进行存储，使用<strong>JSON.stringify(obj)方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'jacky'</span>, </span><br><span class="line">    age: <span class="number">22</span></span><br><span class="line">&#125;;</span><br><span class="line">sessionStorage[<span class="string">'person'</span>] = <span class="built_in">JSON</span>.stringify(obj);</span><br><span class="line"><span class="comment">//sessionStorage['person'] = obj; 不能这样存储，这样存进去结果是"[object Object]"</span></span><br></pre></td></tr></table></figure>

<p>存进去之后则为字符串格式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"&#123;"</span>name<span class="string">":"</span>jacky<span class="string">","</span>age<span class="string">":22&#125;"</span></span><br></pre></td></tr></table></figure>

<p>需要拿出来使用的时候则使用<strong>JSON.parse()方法</strong>将JSON字符串转换为对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="built_in">JSON</span>.parse(sessionStorage[<span class="string">'person'</span>])</span><br></pre></td></tr></table></figure>
<p>同理，数组也是这个用这个方法进行存储。</p>
<h3 id="getItem（key）：根据指定的key值获取对应的value值"><a href="#getItem（key）：根据指定的key值获取对应的value值" class="headerlink" title="getItem（key）：根据指定的key值获取对应的value值"></a>getItem（key）：根据指定的key值获取对应的value值</h3><p>和setItem一样，getItem也有两种等效形式,value = sessionStorage.key和value = sessionStorage[‘key’]。获取到的 value 值是字符串类型，如果需要其他类型，需要自己做类型转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取存储到 name 的键上的值</span></span><br><span class="line"><span class="keyword">var</span> name = sessionStorage.getItem(<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">// var name = sessionStorage.name;</span></span><br><span class="line"><span class="comment">// var name = sessionStorage['name'];</span></span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### removeItem（key）：删除指定的key值对应的value值</span></span><br><span class="line"><span class="string">注意localStorage 没有数据过期的概念，所有数据如果失效了，需要开发者手动删除。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line">    <span class="keyword">var</span> name = sessionStorage.getItem(<span class="string">'name'</span>); <span class="comment">// "jacky"</span></span><br><span class="line">    sessionStorage.removeItem(<span class="string">'name'</span>);</span><br><span class="line">    name = sessionStorage.getItem(<span class="string">'name'</span>); <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h3 id="clear-：删除所有存储的内容"><a href="#clear-：删除所有存储的内容" class="headerlink" title="clear()：删除所有存储的内容"></a>clear()：删除所有存储的内容</h3><p>它和removeItem不同的地方是removeItem删除的是某一项，而clear是删除所有。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 清除 localStorage</span></span><br><span class="line">sessionStorage.clear();</span><br><span class="line"><span class="keyword">var</span> len = sessionStorage.length; <span class="comment">// 0</span></span><br><span class="line"><span class="comment">//length属性用于获取 sessionStorage 中键值对的数量。</span></span><br></pre></td></tr></table></figure>

<h3 id="key-index-：在指定的数字位置获取该位置的名字"><a href="#key-index-：在指定的数字位置获取该位置的名字" class="headerlink" title="key(index)：在指定的数字位置获取该位置的名字"></a>key(index)：在指定的数字位置获取该位置的名字</h3><p>需要注意的是赋值早的键值对应的索引值大，赋值完的键值对应的索引小,key方法可用于遍历 sessionStorage 存储的键值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">'name'</span>,<span class="string">'jacky'</span>);</span><br><span class="line"><span class="keyword">var</span> key = sessionStorage.key(<span class="number">0</span>); <span class="comment">// 'name'</span></span><br><span class="line">sessionStorage.setItem(<span class="string">'age'</span>, <span class="number">10</span>);</span><br><span class="line">key = sessionStorage.key(<span class="number">0</span>); <span class="comment">// 'age'</span></span><br><span class="line">key = sessionStorage.key(<span class="number">1</span>); <span class="comment">// 'name'</span></span><br></pre></td></tr></table></figure>

<h2 id="两者应用场景"><a href="#两者应用场景" class="headerlink" title="两者应用场景"></a>两者应用场景</h2><h3 id="sessionStorage应用场景"><a href="#sessionStorage应用场景" class="headerlink" title="sessionStorage应用场景"></a>sessionStorage应用场景</h3><p>进行页面传值</p>
<h3 id="localStorage应用场景"><a href="#localStorage应用场景" class="headerlink" title="localStorage应用场景"></a>localStorage应用场景</h3><ol>
<li>适合长期保存在本地的数据</li>
<li>可以用于存储该浏览器对该页面的访问次数</li>
</ol>
]]></content>
      <categories>
        <category>日常总结</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之获取数组中的最大值方法（this,apply）</title>
    <url>/2019/10/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E8%8E%B7%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%E6%96%B9%E6%B3%95%EF%BC%88this-apply%EF%BC%89/</url>
    <content><![CDATA[<p>1.排序法 2.假设法 3.基于Math.max与apply 4.ES6展开运算符</p>
<a id="more"></a>
<h2 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h2><p>思路：给数组先排序(由大到小排序),第一项就是最大值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> max1 = arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b-a;</span><br><span class="line">&#125;)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(max1);</span><br></pre></td></tr></table></figure>
<h2 id="假设法"><a href="#假设法" class="headerlink" title="假设法"></a>假设法</h2><p>思路：假设第一个值是最大值,依次遍历数组中后面的每一项,和假设的值进行比较,如果比假设的值要大,把当前项赋值给MAX…</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> max2 = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= arr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> item = arr[i];</span><br><span class="line">    item &gt; max2 ? max2 = item : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(max2);</span><br></pre></td></tr></table></figure>
<h2 id="基于Math-max与apply"><a href="#基于Math-max与apply" class="headerlink" title="基于Math.max与apply"></a>基于Math.max与apply</h2><p>思路：基于基于Math.max完成和apply特性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">5</span> ,<span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">40</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, arr));</span><br></pre></td></tr></table></figure>
<p>这个是要重点理解的一个方案，call,apply,bind常常会被放一起比较<br>首先，call，apply，bind这三个方法其实都是继承自Function.prototype中的，属于实例方法。<br>三个方法的作用，都是<strong>改变this的指向</strong>，只是用法稍微有些区别</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>什么是this</p>
<p><strong>this 既不指向函数自身，也不指函数的词法作用域</strong>。它在函数定义的时候是确定不了的,在函数被调用时才发生的绑定，也就是说<code>this具体指向什么，取决于你是怎么调用的函数</code>。</p>
<p>怎么判断this</p>
<blockquote>
<p>1.给当前元素的某个事件绑定方法, 当事件触发方法执行的时候，方法中的THIS是当前操作的元素对象<br>2.普通函数执行，函数中的THIS取决于执行的主体，谁执行的，THIS就是谁（执行主体：方法执行，看方法名前面是否有“点”，有的话，点前面是谁this就是谁，没有this是window）<br>下面看个例子：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</span><br><span class="line">&#125;    </span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    myFunction()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">myFunction(); <span class="comment">// true</span></span><br><span class="line">obj.myFunction(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>对this有了大致了解后，再来看call方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'windowName'</span>;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'objName'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name:<span class="string">'obj1Name'</span></span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">//windowName</span></span><br><span class="line">fn.call(obj); <span class="comment">// objName：虽然是fn调用，但call改变了this指向，this的指向是obj,故obj.name的值为objName</span></span><br><span class="line">fn.call(obj1); <span class="comment">// obj1Name</span></span><br></pre></td></tr></table></figure>
<p>call方法执行的时候，内部处理了一些事情。首先把要操作函数中的this关键字变为call方法第一个传递的实参值,把call方法第二个及第二个以后的实参获取到，把要操作的函数执行，并且把第二个以后的传递进来的实参传给函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line">fn.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>CALL中的细节</p>
<blockquote>
<p>1.非严格模式下，如果参数不传，或者第一个传递的是null/undefined，this都指向window<br>2.在严格模式下，第一个参数是谁，this就指向谁（包括null/undefined），不传this是undefined<br>在上述代码中，如果用apply，则是</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a + b);</span><br><span class="line">&#125;</span><br><span class="line">fn.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>apply：和call基本上一模一样，唯一区别在于<strong>传参方式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">fn.apply(obj,[<span class="number">10</span>,<span class="number">20</span>]) <span class="comment">//APPLY把需要传递给FN的参数放到一个数组（或者类数组）中传递进去，虽然写的是一个数组，但是也相当于给FN一个个的传递</span></span><br></pre></td></tr></table></figure>
<p>bind：语法和call一模一样，唯一的区别在于立即执行还是等待执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn.call(obj,<span class="number">10</span>,<span class="number">20</span>) 改变FN中的THIS,并且把FN立即执行</span><br><span class="line">fn.bind(obj,<span class="number">10</span>,<span class="number">20</span>) 改变FN中的THIS,此时的FN并没有执行（不兼容IE6~<span class="number">8</span>）</span><br></pre></td></tr></table></figure>
<p>bind调用之后是返回原函数，需要再调用一次才行</p>
<hr>
<p>回到原题，求数组最大值<br>Math.max(arr)这样肯定是报错的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(ary)); <span class="comment">// =&gt; NaN </span></span><br><span class="line"><span class="comment">// =&gt; Math.max是获取一堆数中的最大值,需要我们把比较的数,一个个的传递给这个方法 //=&gt;Math.max(12,13,14...) =&gt;Math.max([12,13,14...])这样只是传递一个值</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,arr);</span><br><span class="line"><span class="comment">// =&gt; 利用了apply的一个特征：虽然放的是一个数组，但是执行方法的时候，也是把数组中的每一项一个个的传递给函数</span></span><br></pre></td></tr></table></figure>

<h2 id="ES6展开运算符"><a href="#ES6展开运算符" class="headerlink" title="ES6展开运算符"></a>ES6展开运算符</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...arr));</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之由一道题来思考闭包</title>
    <url>/2019/10/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E7%94%B1%E4%B8%80%E9%81%93%E9%A2%98%E6%9D%A5%E6%80%9D%E8%80%83%E9%97%AD%E5%8C%85/</url>
    <content><![CDATA[<p>从一道很经典的闭包问题说起…</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>闭包就是指有权访问另一个函数作用域中的变量的函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">&lt;title&gt;点击li标签弹出对应数字&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">0</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;1&lt;/</span>li&gt;</span><br><span class="line">    &lt;li&gt;<span class="number">2</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    &lt;li&gt;3&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var list = document.getElementsByTagName('li');</span></span><br><span class="line"><span class="regexp">    for(var i = 0;i &lt; list.length;i++)&#123;</span></span><br><span class="line"><span class="regexp">     list[i].onclick = function()&#123;</span></span><br><span class="line"><span class="regexp">         alert(i);</span></span><br><span class="line"><span class="regexp">     &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>如上题，最为常见的一个例子，这里解释由这道题引出的js知识点，如上我们知道在浏览器运行无论点击哪个li标签都是弹出3,首先来理解为什么会弹出3。</p>
<p>程序通过for循环给每个li标签绑定了事件，然后通过点击li标签触发方法，即执行alert(i)。js中有个作用域链查找机制，首先会在onclick返回的函数作用域查找i变量的值，找不到则往上一层找i，上一层即是window全局作用域，即找到全局变量i，即for循环定义的i。</p>
<p>注意for循环的i并不是私有变量，而是全局变量。</p>
<blockquote>
<p>js中所有的事件绑定都是异步编程（当前这件事件没有彻底完成，不再等待，继续执行下面的任务）</p>
</blockquote>
<p>当绑定onclick事件后，不需要等待执行，继续执行下一个循环任务，所以当我们点击执行方法的时候，循环早已结束,即是最后i=3。故程序执行后全局变量i被循环执行后赋值为最终的3，所以当点击的时候，外层循环已经结束，页面加载完成预示着js代码都已经执行完成，即执行alert(i)时，由于i不是私有变量，便会找到上一级window作用域全局的i，所以无论点击哪个li标签都是弹出3</p>
<h2 id="为什么要用闭包"><a href="#为什么要用闭包" class="headerlink" title="为什么要用闭包"></a>为什么要用闭包</h2><p>那么，解决这个问题的缘由，在于i每次在页面加载完就赋值为3，alert(i)的时候总是找到全局变量i。在ES5传统语法中，能形成作用域的只有全局和函数，现在每次i找的都是全局，那么要保住i的值只能在全局和onclick返回函数的作用域中间再加一个小的私有作用域，即是大的作用域外再加一个小的作用域，这样i往上一层作用域查找时，就会获取小作用域的i的值，而不会去获取全局变量的i值。</p>
<p>这个思路解决问题就需要引入闭包，在这个理解上闭包是指函数变量可以保存在函数作用域内，因此看起来是函数将变量“包裹”了起来。于是，代码改成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; list.length;i++)&#123;</span><br><span class="line">    list[i].onclick = (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;<span class="comment">//形参n</span></span><br><span class="line">        <span class="comment">//=&gt;让自执行函数执行,把执行的返回值(return)赋值给onclick</span></span><br><span class="line">        <span class="comment">//（此处onclick绑定的是返回的小函数，点击的时候执行的是小函数）,</span></span><br><span class="line">        <span class="comment">// 自执行函数在给事件赋值的时候就已经执行了</span></span><br><span class="line">        <span class="comment">// 自执行函数形成一个私有作用域</span></span><br><span class="line">        <span class="keyword">var</span> i = n;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)(i);<span class="comment">//传入实参i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环三次，形成三个不销毁的私有作用域（自执行函数执行），而每一个不销毁的栈内存中都存储了一个私有变量i，而这个值分别是每一次执行传递进来的全局i的值（也就是：第一个不销毁的作用域存储的是0，第二个是1，第三个是2，第四个是3）；当点击的时候，执行返回的小函数，遇到变量i，向它自己的上级作用域查找。这样就达到了我们需要的效果，这种闭包实现，也可以有另一种写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*原理同法二都是形成三个不销毁的私有作用域,分别存储需要的索引值*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; list.length;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">        list[n].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(n);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于初始的代码，如果说为什么不能实现，那原因就可归纳为：</p>
<blockquote>
</blockquote>
<ol>
<li>执行方法,形成一个私有的栈内存,遇到变量i,i不是私有变量,向上一级作用域查找（上级作用域window）</li>
<li>所有的事件绑定都是异步编程,绑定事件后,不需要等待执行,继续执行下一个循环任务,所以当我们点击执行方法的时候,循环早已结束（让全局的i等于循环最后的结果3）</li>
</ol>
<h2 id="ES6语法的解决方式"><a href="#ES6语法的解决方式" class="headerlink" title="ES6语法的解决方式"></a>ES6语法的解决方式</h2><p>在ES6中，解决这种问题只需要一个let变量，ES6中才有块级作用域（类似于私有作用域）的概念</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; list.length;i++)&#123;</span><br><span class="line">    list[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="闭包对内存的影响"><a href="#闭包对内存的影响" class="headerlink" title="闭包对内存的影响"></a>闭包对内存的影响</h2><p>从上面可知，每次for都会形成一个私有作用域，每个都里面保存的变量i的值，程序运行后这些作用域并不会被销毁，所以由于闭包会携带包含它的函数的作用域，所以会比其他函数占用更多内容，过度使用闭包会导致内存占用过多。</p>
<p>在真实项目中为了保证JS的性能（堆栈内存的性能优化），应该尽可能的减少闭包的使用（不销毁的堆栈内存是耗性能的）</p>
<h2 id="堆内存和栈内存的释放"><a href="#堆内存和栈内存的释放" class="headerlink" title="堆内存和栈内存的释放"></a>堆内存和栈内存的释放</h2><p>这里又要提到一个知识点，js中存储方式的分类：</p>
<blockquote>
<p>JS中的内存分为堆内存和栈内存<br>堆内存：存储引用数据类型值（对象：键值对  函数：代码字符串）<br>栈内存：提供JS代码执行的环境和存储基本类型值</p>
</blockquote>
<p>粗暴理解var定义的变量存在栈内存中，如for循环中的i是存在栈内存中的；而函数，它是存在堆内存中</p>
<p><strong>一般情况下，当函数执行完成，所形成的私有作用域（栈内存）都会自动释放掉（在栈内存中存储的值也都会释放掉）</strong>，那为什么闭包的栈内存不会被自动释放掉，在js中也有特殊不被销毁的情况：</p>
<blockquote>
<p>1.函数执行完成，当前形成的栈内存中，某些内容被栈内存以外的变量占用了，此时栈内存不能释放（一旦释放外面找不到原有的内容了）<br>2.全局栈内存只有在页面关闭的时候才会被释放掉</p>
</blockquote>
<p>闭包则是属于第一种情况，onclick函数形成的栈内存，被小函数【alert(i)，i找到onclick作用域获取i值】占用了onclick函数的栈内存（变量i是存在栈内存中），故栈内存不能被释放，所以才会说闭包过度使用容易导致内存被占用过多，因为不会自动释放内存。</p>
<p><strong>堆内存的释放</strong></p>
<blockquote>
<p>堆内存让所有引用堆内存空间地址的变量赋值为null即可（没有变量占用这个堆内存了，浏览器会在空闲的时候把它释放掉）</p>
</blockquote>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript之变量提升</title>
    <url>/2019/10/23/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B9%8B%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    <content><![CDATA[<p>原理：JS引擎的工作方式是先解析代码，获取所有被声明的变量；然后在运行。JS代码自上而下执行之前，浏览器首先会把所有带”VAR”/“FUNCTION”关键词的进行提前”声明”或者”定义”，这种预先处理机制称之为 “变量提升”。</p>
<a id="more"></a>

<h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">//undefined undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">12</span>,</span><br><span class="line">    b = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b);<span class="comment">//=&gt;undefined 12</span></span><br><span class="line">    <span class="keyword">var</span> a = b = <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b);<span class="comment">//=&gt;13 13</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(a, b);<span class="comment">//=&gt;12 13</span></span><br></pre></td></tr></table></figure>

<ul>
<li>undefined undefined：首先输出这个结果是因为变量提升，即前三行变成<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//undefined undefined</span></span><br><span class="line">a = <span class="number">12</span>;</span><br><span class="line">b = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li>
<li>undefined 12：接下来执行函数fn（fn一开始也被执行了变量提升,只不过函数中存储的都是字符串而已），对fn内部进行分析，即内部代码变成：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//undefined 12</span></span><br><span class="line">a = <span class="number">13</span>;</span><br><span class="line">b = <span class="number">13</span>; <span class="comment">//不加var的本质是WIN的属性，即相当于window.b = 13; </span></span><br><span class="line"><span class="built_in">console</span>.log(a,b);<span class="comment">//13 13</span></span><br></pre></td></tr></table></figure>
<p>一开始b在fn内部找不到，便会开始往上一层找，找到了全局的b，于是b输出12。</p>
<p>当经过var a = b = 13; 后，b被赋值为13，于是输出先从函数内部找b，找到了b=13，第二次输出b为13。（！同时，最先定义的全局变量b = 12也被赋值为13，故最后的b也等于13）</p>
<blockquote>
<p>私有作用域中带var和不带var的区别：</p>
<ol>
<li>带var的在私有作用于变量提升阶段，都声明为私有变量，和外界没有任何的关系</li>
<li>不带var不是私有变量，会向它的上级作用于查找，一直找到window为止（这种查找机制叫做：“作用域链”），也就是在私有作用域中操作的这个非私有变量，是一直操作别人的</li>
</ol>
</blockquote>
<h2 id="只对等号左边进行变量提升"><a href="#只对等号左边进行变量提升" class="headerlink" title="只对等号左边进行变量提升"></a>只对等号左边进行变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sum();</span><br><span class="line">fn();<span class="comment">// Uncaught TypeError: fn is not a function </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;匿名函数之函数表达式</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fn'</span>);</span><br><span class="line">&#125;<span class="comment">//=&gt;代码执行到此处会把函数值赋值给fn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//=&gt;普通的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sum'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="条件判断下的变量提升"><a href="#条件判断下的变量提升" class="headerlink" title="条件判断下的变量提升"></a>条件判断下的变量提升</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在当前作用域下，不管条件是否成立都要进行变量提升</span></span><br><span class="line"><span class="comment"> *   =&gt;带VAR的还是只声明</span></span><br><span class="line"><span class="comment"> *   =&gt;带FUNCTION的在老版本浏览器渲染机制下，声明和定义都处理，但是为了迎合ES6中的块级作用 </span></span><br><span class="line"><span class="comment"> *     域，新版浏览器对于函数（在条件判断中的函数），</span></span><br><span class="line"><span class="comment"> *     不管条件是否成立，都只是先声明，没有定义，类似于var</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> === <span class="number">2</span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="重名问题的处理"><a href="#重名问题的处理" class="headerlink" title="重名问题的处理"></a>重名问题的处理</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fn();<span class="comment">//=&gt;4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">1</span>);&#125;</span><br><span class="line">fn();<span class="comment">//=&gt;4</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>);&#125;</span><br><span class="line">fn();<span class="comment">//=&gt;4</span></span><br><span class="line"><span class="keyword">var</span> fn=<span class="number">100</span>;<span class="comment">//=&gt;带VAR的在提升阶段只把声明处理了,赋值操作没有处理,所以在代码执行的时候需要完成赋值 FN=100</span></span><br><span class="line">fn();<span class="comment">//=&gt;100() Uncaught TypeError: fn is not a function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">3</span>);&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="number">4</span>);&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p>带VAR和FUNCTION关键字声明相同的名字，这种也算是重名了（其实是一个FN，只是存储值的类型不一样）<br>关于重名的处理：如果名字重复了，不会重新的声明，但是会重新的定义（重新赋值）[不管是变量提升还是代码执行阶段皆是如此]</p>
]]></content>
      <categories>
        <category>深入理解JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>jquery设计的巧妙</title>
    <url>/2019/09/07/jquery%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B7%A7%E5%A6%99/</url>
    <content><![CDATA[<p>最近开始阅读jquery的源码，首先先提炼出jquery的核心结构。</p>
<a id="more"></a>
<h2 id="自执行函数"><a href="#自执行函数" class="headerlink" title="自执行函数"></a>自执行函数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window,undefined</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<h3 id="为什么传入window"><a href="#为什么传入window" class="headerlink" title="为什么传入window?"></a>为什么传入window?</h3><p><strong>1.代码压缩</strong></p>
<p>首先从代码压缩混淆的角度考虑，用线上工具来压缩混淆下面这段示例代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name=<span class="string">"hello"</span>;</span><br><span class="line">  <span class="built_in">window</span>.description=<span class="string">"hi "</span>+name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>压完混完后瘦了一点：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> a=<span class="string">"hello"</span>;<span class="built_in">window</span>.description=<span class="string">"hi "</span>+a&#125;</span><br></pre></td></tr></table></figure>
<p>用a代替了name，但是window既不是声明的局部变量也不是参数，是不会被压缩混淆的。<br>所以将window作为参数传入可解决这个问题。将window作为参数传入，可以在压缩代码时进行优化，即参数名可以压缩变短。也可以在函数内另起个简短的变量名代替。  </p>
<p><strong>2.作用域</strong></p>
<p>访问当前作用域下的变量比访问全局变量要快<br>如果不传入，每个语句都要去找一次window。如果将window作为参数传递过去，不要每个语句都去找window，提高了效率。</p>
<h3 id="为什么要传入undefined？"><a href="#为什么要传入undefined？" class="headerlink" title="为什么要传入undefined？"></a>为什么要传入undefined？</h3><p>undefined并不是作为JavaScript的保留关键字；undefined在IE8及以下中是可以对其重新赋值的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var undefined&#x3D;&quot;new value&quot;;</span><br><span class="line">alert(undefined);&#x2F;&#x2F;alert “new value&quot;</span><br></pre></td></tr></table></figure>
<p>执行匿名函数的时候，只传递一个参数window，而不传递undefined，那么函数体中的undefined局部变量的值，刚好就是undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">8</span>;  </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window </span>) </span>&#123;   </span><br><span class="line">    alert(<span class="built_in">window</span>.undefined); <span class="comment">// 8  </span></span><br><span class="line">    alert(<span class="literal">undefined</span>); <span class="comment">// 8  </span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>加了undefined后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="number">8</span>;  </span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"> window, undefined </span>) </span>&#123;   </span><br><span class="line">    alert(<span class="built_in">window</span>.undefined);  <span class="comment">// 8  </span></span><br><span class="line">    alert(<span class="literal">undefined</span>); <span class="comment">// 此处undefined参数为局部的名称为undefined变量，值为undefined  </span></span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure>
<p>在 自调用匿名函数 的作用域内，确保undefined是真的未定义。因为undefined能够被重写，赋予新的值.</p>
<h2 id="new-jQuery-fn-init-selector-context"><a href="#new-jQuery-fn-init-selector-context" class="headerlink" title="new jQuery.fn.init( selector, context );"></a>new jQuery.fn.init( selector, context );</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context );</span><br><span class="line">    <span class="comment">//=&gt;创建了init这个类的实例，也相当于创建了jQuery这个类的实例（因为在后面的时候，让init.prototype=jQuery.prototype）&#125;;</span></span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要理解这段代码，首先要理解jquery的两种调用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'body'</span>).css(<span class="string">'background'</span>,<span class="string">'red'</span>);</span><br><span class="line">$.parseJSON(<span class="string">'&#123;&#125;'</span>);</span><br></pre></td></tr></table></figure>
<p>$(‘body’)应该是一个实例对象，css是每个实例共享的方法，是原型上的方法。<br>而$则是一个类，parseJSON则是类的静态方法。  </p>
<h3 id="如何不用new关键字得到jQuery对象？"><a href="#如何不用new关键字得到jQuery对象？" class="headerlink" title="如何不用new关键字得到jQuery对象？"></a>如何不用new关键字得到jQuery对象？</h3><p>一般获取实例对象调取实例方法的例子，如果没有使用new则会报错</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo=<span class="keyword">new</span> Demo(<span class="string">"jacky"</span>);</span><br><span class="line">demo.change();</span><br></pre></td></tr></table></figure>
<p>但是获取jQuery对象（以下简称JQ对象）用new和不用new都可以，返回的是一样的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log($(<span class="string">'*'</span>).length);<span class="comment">//14</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> $(<span class="string">'*'</span>).length);<span class="comment">//14</span></span><br></pre></td></tr></table></figure>
<p>为了做到这点，我们很容易想到需要<strong>在构造函数内部返回对象</strong>。</p>
<p>构造函数有return值怎么办？<br><strong>构造函数里没有显式调用return时，默认是返回this对象，也就是新创建的实例对象。</strong></p>
<p>当构造函数里调用return时，分两种情况：</p>
<blockquote>
<p>1.return的是五种简单数据类型：String，Number，Boolean，Null，Undefined。 这种情况下，忽视return值，依然返回this对象。<br>2.return的是Object 这种情况下，不再返回this对象，而是返回return语句的返回值。</p>
</blockquote>
<p>所以我们应该在jQuery构造函数内部去返回一个对象，这样就可以不用new的方式去创建JQ对象了，其实这时候，构造函数就相当于一个工厂函数了。</p>
<p>该返回什么样的对象？对于这个对象有何要求？<br>这个对象必须可以调用jQuery.prototype上的方法</p>
<p>我们使用或自己写jQuery插件的时候会经常遇到$.fn这个对象，很多插件都是通过扩展这个对象来实现的。<br>$.fn其实对应着jQuery.prototype，$和fn分别是jQuery和prototype的简写方式，只要我们把方法扩展到这个原型对象身上，通过$()获取的JQ对象都是可以访问到方法的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.fn.greeting=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'hi'</span>)&#125;;</span><br><span class="line">$(<span class="string">'body'</span>).greeting();<span class="comment">// alert 'hi'</span></span><br></pre></td></tr></table></figure>
<p>jquery源码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context, rootjQuery );</span><br><span class="line">&#125;,</span><br><span class="line">jQuery.fn = jQuery.prototype = &#123; <span class="comment">// fn即对应prototype</span></span><br><span class="line">    <span class="keyword">constructor</span>: jQuery,</span><br><span class="line">    init: function( selector, context, rootjQuery ) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jQuery.fn.init.prototype = jQuery.fn;<br>看到上面这段源码，原因就很明显了，”jQuery.fn.init.prototype = jQuery.fn”这句很重要，它将init的原型指向jQuery的原型，所以JQ对象才可以访问‘css’、’show’、’hide’这些写在jQuery.fn上的方法。其实我们所说的JQ对象根本就是init函数的实例对象，而init则是jQuery原型上的一个对象，它本身是没有什么方法的，全靠从jQuery原型上拿。</p>
<p>为何要从init这绕这么一大圈来访问jQuery的原型，而不是直接返回一个jQuery实例直接通过这个实例来访问自身原型？比如说代码可以写成这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> jQuery();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>问题很明显，死在循环里。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jQuery.fn.init();<span class="comment">// 不同点在于去掉了new关键字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做点动作来证明加上new是有用的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> jQuery.fn.init();</span><br><span class="line">&#125;,</span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name=<span class="string">'sheila'</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    anotherName:<span class="string">'sunwukong'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> jq=jQuery();</span><br><span class="line"><span class="built_in">console</span>.log(jq.anotherName);<span class="comment">// "sunwukong"</span></span><br><span class="line"><span class="built_in">console</span>.log(jq.name);<span class="comment">// "sheila"</span></span><br></pre></td></tr></table></figure>
<p>上面这段代码是为了说明this的作用域问题，其不仅能访问init函数内部，还能向上一层到fn对象，作用域不独立.如果是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init();</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(jq.anotherName);<span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(jq.name);<span class="comment">//  "sheila"</span></span><br></pre></td></tr></table></figure>
<p>加不加new还牵涉到一个更重要的问题：返回的对象究竟是谁。</p>
<p>不加new的情况下，’jQuery.fn.init()’相当于调用方法，this指向的以及最后返回的都是同一个jQuery.fn对象，$(‘body’)和$(‘p’)就没有区分了。</p>
<p>显然，这是不合理的。而加了new，就是每次用构造函数实例化了一个新对象，彼此都是不同的</p>
]]></content>
      <categories>
        <category>开发杂记</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>this.props.history.push()报错解决</title>
    <url>/2019/04/05/this-props-history-push%E6%96%B9%E6%B3%95%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>在使用 React 的路由跳转时，出现了这个错误”cannot read property ‘push’ of undefined”，找来找去，发现是子组件这样调用时才会报错,它不是路由组件。以下是解决方案：</p>
<a id="more"></a>

<p>在我的每个页面中，Header 组件都会引入，使其成为子组件</p>
<h3 id="通过父组件传值给子组件"><a href="#通过父组件传值给子组件" class="headerlink" title="通过父组件传值给子组件"></a>通过父组件传值给子组件</h3><p>在父组件中，传递一个 history 给子组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;Header history=&#123;<span class="keyword">this</span>.props.history&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>子组件方法还是一样写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.history.push(<span class="string">'/login'</span>)</span><br></pre></td></tr></table></figure>

<p>但如果 Header 组件被嵌套封装更深的话是不行的，这时只能选择第二种方法。</p>
<h3 id="使用-withRouter"><a href="#使用-withRouter" class="headerlink" title="使用 withRouter"></a>使用 withRouter</h3><blockquote>
<p>默认情况下必须经过路由匹配渲染的组件才存在 this.props,才拥有路由参数，执行 this.props.history.push(‘/login’)跳转到对应路由的页面，然而不是所有组件都直接与路由相连（通过路由跳转到此组件）的，当这些组件需要路由参数时，使用 withRouter 就可以给此组件传入路由参数，将 react-router 的 history、location、match 三个对象传入 props 对象上，此时就可以使用 this.props。</p>
</blockquote>
<p>可见当一个非路由组件也想访问到当前路由的 match,location,history 对象，那么 withRouter 将是一个非常好的选择，可以理解为将一个组件包裹成路由组件。</p>
<p>用法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Header) <span class="comment">// export时要使用withRouter</span></span><br></pre></td></tr></table></figure>

<p>在 Header 组件引入并使用，就可以使用 this.props.history.push 方法进行正常跳转了~~</p>
]]></content>
      <categories>
        <category>React笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB性能之逐条插入与批量插入</title>
    <url>/2018/05/12/MongoDB%E6%80%A7%E8%83%BD%E4%B9%8B%E9%80%90%E6%9D%A1%E6%8F%92%E5%85%A5%E4%B8%8E%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5/</url>
    <content><![CDATA[<p>在 mongoDB 中，当我们要插入很多数据时，可以选择用循环依次逐条插入，或者可以先把所有数据装在一个数组再整个数组插入集合，但是，最好使用第二种方式…</p>
<a id="more"></a>

<p>如下代码所示（已新建数据库 log 和集合 test），在 js 写入如下代码</p>
<h2 id="逐条插入"><a href="#逐条插入" class="headerlink" title="逐条插入"></a>逐条插入</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() <span class="comment">//获得开始时间</span></span><br><span class="line"><span class="keyword">var</span> db = connect(<span class="string">'log'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  db.test.insert(&#123; <span class="attr">num</span>: <span class="number">1</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> runTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - startTime <span class="comment">//获得运行时间</span></span><br><span class="line">print(<span class="string">'runTime is '</span> + runTime + <span class="string">'ms'</span>) <span class="comment">//runTime is 745ms</span></span><br></pre></td></tr></table></figure>

<h2 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() <span class="comment">//获得开始时间</span></span><br><span class="line"><span class="keyword">var</span> db = connect(<span class="string">'log'</span>)</span><br><span class="line"><span class="keyword">var</span> tempArr = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">  tempArr.push(&#123; <span class="attr">num</span>: <span class="number">1</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">db.test.insert(tempArr)</span><br><span class="line"><span class="keyword">var</span> runTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - startTime</span><br><span class="line">print(<span class="string">'runTime is '</span> + runTime + <span class="string">'ms'</span>) <span class="comment">// runTime is 48ms</span></span><br></pre></td></tr></table></figure>

<p>由运行时间来看，批量插入比逐条插入所用的时间少了很多，在小型项目中可能感受不到的差距，在大项目就是性能的问题了，故应使用第二种方式来批量插入数据。</p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
</search>
